# Gitbook Documentation Compilation
Generated on Tue Mar 25 15:39:59 UTC 2025



## File: ./.gitbook/assets/README (1).md

BitBadges / [Exports](modules.md)


## File: ./.gitbook/assets/README.md

BitBadges / [Exports](modules.md)


## File: ./.gitbook/assets/modules (1).md

[BitBadges](README.md) / Exports

# BitBadges

## Table of contents

### Enumerations

- [DistributionMethod](enums/DistributionMethod.md)
- [MetadataAddMethod](enums/MetadataAddMethod.md)
- [SupportedChain](enums/SupportedChain.md)
- [TransactionStatus](enums/TransactionStatus.md)

### Interfaces

- [AccountDocs](interfaces/AccountDocs.md)
- [AccountDocument](interfaces/AccountDocument.md)
- [AccountMap](interfaces/AccountMap.md)
- [AccountResponse](interfaces/AccountResponse.md)
- [ActivityItem](interfaces/ActivityItem.md)
- [Addresses](interfaces/Addresses.md)
- [AnnouncementActivityItem](interfaces/AnnouncementActivityItem.md)
- [Approval](interfaces/Approval.md)
- [BadgeMetadata](interfaces/BadgeMetadata.md)
- [BadgeMetadataMap](interfaces/BadgeMetadataMap.md)
- [BadgeSupplyAndAmount](interfaces/BadgeSupplyAndAmount.md)
- [BadgeUri](interfaces/BadgeUri.md)
- [Balance](interfaces/Balance.md)
- [BalanceObject](interfaces/BalanceObject.md)
- [BalancesMap](interfaces/BalancesMap.md)
- [BitBadgeCollection](interfaces/BitBadgeCollection.md)
- [BitBadgeMintObject](interfaces/BitBadgeMintObject.md)
- [BitBadgesUserInfo](interfaces/BitBadgesUserInfo.md)
- [ClaimItem](interfaces/ClaimItem.md)
- [ClaimItemWithTrees](interfaces/ClaimItemWithTrees.md)
- [Claims](interfaces/Claims.md)
- [CollectionDocs](interfaces/CollectionDocs.md)
- [CollectionMap](interfaces/CollectionMap.md)
- [CosmosAccountInformation](interfaces/CosmosAccountInformation.md)
- [DbStatus](interfaces/DbStatus.md)
- [Docs](interfaces/Docs.md)
- [GetAccountResponse](interfaces/GetAccountResponse.md)
- [GetBadgeBalanceResponse](interfaces/GetBadgeBalanceResponse.md)
- [GetBalanceResponse](interfaces/GetBalanceResponse.md)
- [GetCollectionResponse](interfaces/GetCollectionResponse.md)
- [GetOwnersResponse](interfaces/GetOwnersResponse.md)
- [GetPortfolioResponse](interfaces/GetPortfolioResponse.md)
- [IdRange](interfaces/IdRange.md)
- [IndexerStatus](interfaces/IndexerStatus.md)
- [LatestBlockStatus](interfaces/LatestBlockStatus.md)
- [MetadataDocs](interfaces/MetadataDocs.md)
- [MetadataDocument](interfaces/MetadataDocument.md)
- [PaginationInfo](interfaces/PaginationInfo.md)
- [PasswordDocument](interfaces/PasswordDocument.md)
- [PendingTransfer](interfaces/PendingTransfer.md)
- [Proof](interfaces/Proof.md)
- [SearchResponse](interfaces/SearchResponse.md)
- [StoredBadgeCollection](interfaces/StoredBadgeCollection.md)
- [SubassetSupply](interfaces/SubassetSupply.md)
- [TransferActivityItem](interfaces/TransferActivityItem.md)
- [TransferList](interfaces/TransferList.md)
- [TransferListWithUnregisteredUsers](interfaces/TransferListWithUnregisteredUsers.md)
- [Transfers](interfaces/Transfers.md)
- [TransfersExtended](interfaces/TransfersExtended.md)
- [UserBalance](interfaces/UserBalance.md)

### Type Aliases

- [Permissions](modules.md#permissions)

### Variables

- [AllAddressesTransferList](modules.md#alladdressestransferlist)
- [CHAIN\_DETAILS](modules.md#chain_details)
- [CanCreateMoreBadgesDigit](modules.md#cancreatemorebadgesdigit)
- [CanDeleteDigit](modules.md#candeletedigit)
- [CanManagerBeTransferredDigit](modules.md#canmanagerbetransferreddigit)
- [CanUpdateBytesDigit](modules.md#canupdatebytesdigit)
- [CanUpdateDisallowedDigit](modules.md#canupdatedisalloweddigit)
- [CanUpdateUrisDigit](modules.md#canupdateurisdigit)
- [DefaultPlaceholderMetadata](modules.md#defaultplaceholdermetadata)
- [ErrorMetadata](modules.md#errormetadata)
- [GO\_MAX\_UINT\_64](modules.md#go_max_uint_64)
- [MAX\_DATE\_TIMESTAMP](modules.md#max_date_timestamp)
- [METADATA\_PAGE\_LIMIT](modules.md#metadata_page_limit)
- [MINT\_ACCOUNT](modules.md#mint_account)
- [NUM\_PERMISSIONS](modules.md#num_permissions)

### Functions

- [AddBalancesForIdRanges](modules.md#addbalancesforidranges)
- [DeleteBalanceForIdRanges](modules.md#deletebalanceforidranges)
- [GetAccountByNumberRoute](modules.md#getaccountbynumberroute)
- [GetAccountRoute](modules.md#getaccountroute)
- [GetAccountsRoute](modules.md#getaccountsroute)
- [GetBadgeBalanceRoute](modules.md#getbadgebalanceroute)
- [GetBalanceInfoToInsertToStorage](modules.md#getbalanceinfotoinserttostorage)
- [GetBalanceRoute](modules.md#getbalanceroute)
- [GetBalancesForIdRanges](modules.md#getbalancesforidranges)
- [GetCollectionRoute](modules.md#getcollectionroute)
- [GetCollectionsRoute](modules.md#getcollectionsroute)
- [GetIdRangeToInsert](modules.md#getidrangetoinsert)
- [GetIdRangesToInsertToStorage](modules.md#getidrangestoinserttostorage)
- [GetIdRangesWithOmitEmptyCaseHandled](modules.md#getidrangeswithomitemptycasehandled)
- [GetIdxSpanForRange](modules.md#getidxspanforrange)
- [GetIdxToInsertForNewId](modules.md#getidxtoinsertfornewid)
- [GetMetadataRoute](modules.md#getmetadataroute)
- [GetOwnersRoute](modules.md#getownersroute)
- [GetPermissionNumberValue](modules.md#getpermissionnumbervalue)
- [GetPermissions](modules.md#getpermissions)
- [GetPortfolioRoute](modules.md#getportfolioroute)
- [GetSearchRoute](modules.md#getsearchroute)
- [GetStatusRoute](modules.md#getstatusroute)
- [InsertRangeToIdRanges](modules.md#insertrangetoidranges)
- [MergePrevOrNextIfPossible](modules.md#mergeprevornextifpossible)
- [NormalizeIdRange](modules.md#normalizeidrange)
- [RemoveIdsFromIdRange](modules.md#removeidsfromidrange)
- [SafeAdd](modules.md#safeadd)
- [SafeSubtract](modules.md#safesubtract)
- [SearchBalances](modules.md#searchbalances)
- [SearchIdRangesForId](modules.md#searchidrangesforid)
- [SetBalanceForIdRanges](modules.md#setbalanceforidranges)
- [SortIdRangesAndMergeIfNecessary](modules.md#sortidrangesandmergeifnecessary)
- [SubtractBalancesForIdRanges](modules.md#subtractbalancesforidranges)
- [UpdateBalancesForIdRanges](modules.md#updatebalancesforidranges)
- [UpdatePermissions](modules.md#updatepermissions)
- [ValidatePermissions](modules.md#validatepermissions)
- [ValidatePermissionsUpdate](modules.md#validatepermissionsupdate)
- [checkIfApproved](modules.md#checkifapproved)
- [checkIfApprovedInTransferList](modules.md#checkifapprovedintransferlist)
- [checkIfIdRangesOverlap](modules.md#checkifidrangesoverlap)
- [convertToBitBadgesUserInfo](modules.md#converttobitbadgesuserinfo)
- [convertToBitBadgesAddress](modules.md#converttocosmosaddress)
- [createCollectionFromMsgNewCollection](modules.md#createcollectionfrommsgnewcollection)
- [doesChainMatchName](modules.md#doeschainmatchname)
- [filterBadgeActivityForBadgeId](modules.md#filterbadgeactivityforbadgeid)
- [getAbbreviatedAddress](modules.md#getabbreviatedaddress)
- [getBadgeIdsToDisplayForPageNumber](modules.md#getbadgeidstodisplayforpagenumber)
- [getBalanceAfterTransfer](modules.md#getbalanceaftertransfer)
- [getBalanceAfterTransfers](modules.md#getbalanceaftertransfers)
- [getBlankBalance](modules.md#getblankbalance)
- [getChainForAddress](modules.md#getchainforaddress)
- [getClaimsFromClaimItems](modules.md#getclaimsfromclaimitems)
- [getIdRangesForAllBadgeIdsInCollection](modules.md#getidrangesforallbadgeidsincollection)
- [getMatchingAddressesFromTransferList](modules.md#getmatchingaddressesfromtransferlist)
- [getMaxBatchId](modules.md#getmaxbatchid)
- [getMetadataForBadgeId](modules.md#getmetadataforbadgeid)
- [getMetadataMapObjForBadgeId](modules.md#getmetadatamapobjforbadgeid)
- [getNonTransferableDisallowedTransfers](modules.md#getnontransferabledisallowedtransfers)
- [getSupplyByBadgeId](modules.md#getsupplybybadgeid)
- [getTransferListForSelectOptions](modules.md#gettransferlistforselectoptions)
- [getTransfersFromClaimItems](modules.md#gettransfersfromclaimitems)
- [isAddressValid](modules.md#isaddressvalid)
- [isTransferListFull](modules.md#istransferlistfull)
- [populateFieldsOfOtherBadges](modules.md#populatefieldsofotherbadges)
- [updateMetadataForBadgeIdsFromIndexerIfAbsent](modules.md#updatemetadataforbadgeidsfromindexerifabsent)
- [updateMetadataMap](modules.md#updatemetadatamap)
- [updateTransferListAccountNums](modules.md#updatetransferlistaccountnums)

## Type Aliases

### Permissions

Ƭ **Permissions**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `CanCreateMoreBadges` | `boolean` |
| `CanDelete` | `boolean` |
| `CanManagerBeTransferred` | `boolean` |
| `CanUpdateBytes` | `boolean` |
| `CanUpdateDisallowed` | `boolean` |
| `CanUpdateUris` | `boolean` |

#### Defined in

[permissions.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L3)

## Variables

### AllAddressesTransferList

• `Const` **AllAddressesTransferList**: [`TransferList`](interfaces/TransferList.md)

#### Defined in

[badges.ts:109](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L109)

___

### CHAIN\_DETAILS

• `Const` **CHAIN\_DETAILS**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `chainId` | `number` |
| `cosmosChainId` | `string` |

#### Defined in

[constants.ts:9](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L9)

___

### CanCreateMoreBadgesDigit

• `Const` **CanCreateMoreBadgesDigit**: ``2``

#### Defined in

[permissions.ts:16](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L16)

___

### CanDeleteDigit

• `Const` **CanDeleteDigit**: ``6``

#### Defined in

[permissions.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L12)

___

### CanManagerBeTransferredDigit

• `Const` **CanManagerBeTransferredDigit**: ``4``

#### Defined in

[permissions.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L14)

___

### CanUpdateBytesDigit

• `Const` **CanUpdateBytesDigit**: ``5``

#### Defined in

[permissions.ts:13](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L13)

___

### CanUpdateDisallowedDigit

• `Const` **CanUpdateDisallowedDigit**: ``1``

#### Defined in

[permissions.ts:17](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L17)

___

### CanUpdateUrisDigit

• `Const` **CanUpdateUrisDigit**: ``3``

#### Defined in

[permissions.ts:15](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L15)

___

### DefaultPlaceholderMetadata

• `Const` **DefaultPlaceholderMetadata**: [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[constants.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L14)

___

### ErrorMetadata

• `Const` **ErrorMetadata**: [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[constants.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L20)

___

### GO\_MAX\_UINT\_64

• `Const` **GO\_MAX\_UINT\_64**: ``1000000000000000``

#### Defined in

[constants.ts:7](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L7)

___

### MAX\_DATE\_TIMESTAMP

• `Const` **MAX\_DATE\_TIMESTAMP**: `number`

#### Defined in

[constants.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L5)

___

### METADATA\_PAGE\_LIMIT

• `Const` **METADATA\_PAGE\_LIMIT**: ``100``

#### Defined in

[constants.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L3)

___

### MINT\_ACCOUNT

• `Const` **MINT\_ACCOUNT**: [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Defined in

[chains.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L5)

___

### NUM\_PERMISSIONS

• `Const` **NUM\_PERMISSIONS**: ``6``

#### Defined in

[permissions.ts:1](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L1)

## Functions

### AddBalancesForIdRanges

▸ **AddBalancesForIdRanges**(`userBalanceInfo`, `ranges`, `balanceToAdd`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `userBalanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `balanceToAdd` | `number` |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:116](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L116)

___

### DeleteBalanceForIdRanges

▸ **DeleteBalanceForIdRanges**(`ranges`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:142](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L142)

___

### GetAccountByNumberRoute

▸ **GetAccountByNumberRoute**(`id`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `id` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:8](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L8)

___

### GetAccountRoute

▸ **GetAccountRoute**(`bech32address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `bech32address` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:4](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L4)

___

### GetAccountsRoute

▸ **GetAccountsRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L12)

___

### GetBadgeBalanceRoute

▸ **GetBadgeBalanceRoute**(`collectionId`, `accountNumber`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |
| `accountNumber` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:28](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L28)

___

### GetBalanceInfoToInsertToStorage

▸ **GetBalanceInfoToInsertToStorage**(`balanceInfo`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `balanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:254](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L254)

___

### GetBalanceRoute

▸ **GetBalanceRoute**(`bech32address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `bech32address` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:16](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L16)

___

### GetBalancesForIdRanges

▸ **GetBalancesForIdRanges**(`badgeIds`, `currentUserBalances`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeIds` | [`IdRange`](interfaces/IdRange.md)[] |
| `currentUserBalances` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L36)

___

### GetCollectionRoute

▸ **GetCollectionRoute**(`collectionId`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L20)

___

### GetCollectionsRoute

▸ **GetCollectionsRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:24](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L24)

___

### GetIdRangeToInsert

▸ **GetIdRangeToInsert**(`start`, `end`): `Object`

#### Parameters

| Name | Type |
| :------ | :------ |
| `start` | `number` |
| `end` | `number` |

#### Returns

`Object`

| Name | Type |
| :------ | :------ |
| `end` | `number` |
| `start` | `number` |

#### Defined in

[idRanges.ts:152](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L152)

___

### GetIdRangesToInsertToStorage

▸ **GetIdRangesToInsertToStorage**(`idRanges`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:31](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L31)

___

### GetIdRangesWithOmitEmptyCaseHandled

▸ **GetIdRangesWithOmitEmptyCaseHandled**(`ids`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ids` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:144](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L144)

___

### GetIdxSpanForRange

▸ **GetIdxSpanForRange**(`targetRange`, `targetIdRanges`): [[`IdRange`](interfaces/IdRange.md), `boolean`]

#### Parameters

| Name | Type |
| :------ | :------ |
| `targetRange` | [`IdRange`](interfaces/IdRange.md) |
| `targetIdRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[[`IdRange`](interfaces/IdRange.md), `boolean`]

#### Defined in

[idRanges.ts:111](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L111)

___

### GetIdxToInsertForNewId

▸ **GetIdxToInsertForNewId**(`id`, `targetIds`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `id` | `number` |
| `targetIds` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

`number`

#### Defined in

[idRanges.ts:176](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L176)

___

### GetMetadataRoute

▸ **GetMetadataRoute**(`collectionId`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:40](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L40)

___

### GetOwnersRoute

▸ **GetOwnersRoute**(`collectionId`, `badgeId`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |
| `badgeId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:32](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L32)

___

### GetPermissionNumberValue

▸ **GetPermissionNumberValue**(`permissions`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `permissions` | [`Permissions`](modules.md#permissions) |

#### Returns

`number`

#### Defined in

[permissions.ts:19](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L19)

___

### GetPermissions

▸ **GetPermissions**(`permissions`): [`Permissions`](modules.md#permissions)

#### Parameters

| Name | Type |
| :------ | :------ |
| `permissions` | `number` |

#### Returns

[`Permissions`](modules.md#permissions)

#### Defined in

[permissions.ts:118](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L118)

___

### GetPortfolioRoute

▸ **GetPortfolioRoute**(`accountNumber`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `accountNumber` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L36)

___

### GetSearchRoute

▸ **GetSearchRoute**(`query`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `query` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:44](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L44)

___

### GetStatusRoute

▸ **GetStatusRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:48](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L48)

___

### InsertRangeToIdRanges

▸ **InsertRangeToIdRanges**(`rangeToAdd`, `targetIds`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `rangeToAdd` | [`IdRange`](interfaces/IdRange.md) |
| `targetIds` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:274](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L274)

___

### MergePrevOrNextIfPossible

▸ **MergePrevOrNextIfPossible**(`targetIds`, `insertedAtIdx`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `targetIds` | [`IdRange`](interfaces/IdRange.md)[] |
| `insertedAtIdx` | `number` |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:218](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L218)

___

### NormalizeIdRange

▸ **NormalizeIdRange**(`rangeToNormalize`): `Object`

#### Parameters

| Name | Type |
| :------ | :------ |
| `rangeToNormalize` | [`IdRange`](interfaces/IdRange.md) |

#### Returns

`Object`

| Name | Type |
| :------ | :------ |
| `end` | `number` |
| `start` | `number` |

#### Defined in

[idRanges.ts:164](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L164)

___

### RemoveIdsFromIdRange

▸ **RemoveIdsFromIdRange**(`rangeToRemove`, `rangeObject`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `rangeToRemove` | [`IdRange`](interfaces/IdRange.md) |
| `rangeObject` | [`IdRange`](interfaces/IdRange.md) |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:47](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L47)

___

### SafeAdd

▸ **SafeAdd**(`left`, `right`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `left` | `number` |
| `right` | `number` |

#### Returns

`number`

#### Defined in

[balances-gpt.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L5)

___

### SafeSubtract

▸ **SafeSubtract**(`left`, `right`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `left` | `number` |
| `right` | `number` |

#### Returns

`number`

#### Defined in

[balances-gpt.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L14)

___

### SearchBalances

▸ **SearchBalances**(`targetAmount`, `balanceObjects`): (`number` \| `boolean`)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `targetAmount` | `number` |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

(`number` \| `boolean`)[]

#### Defined in

[balances-gpt.ts:224](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L224)

___

### SearchIdRangesForId

▸ **SearchIdRangesForId**(`id`, `idRanges`): [`number`, `boolean`]

#### Parameters

| Name | Type |
| :------ | :------ |
| `id` | `number` |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`number`, `boolean`]

#### Defined in

[idRanges.ts:92](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L92)

___

### SetBalanceForIdRanges

▸ **SetBalanceForIdRanges**(`ranges`, `amount`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `amount` | `number` |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:183](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L183)

___

### SortIdRangesAndMergeIfNecessary

▸ **SortIdRangesAndMergeIfNecessary**(`idRanges`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L3)

___

### SubtractBalancesForIdRanges

▸ **SubtractBalancesForIdRanges**(`userBalanceInfo`, `ranges`, `balanceToRemove`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `userBalanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `balanceToRemove` | `number` |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:129](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L129)

___

### UpdateBalancesForIdRanges

▸ **UpdateBalancesForIdRanges**(`ranges`, `newAmount`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `newAmount` | `number` |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:22](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L22)

___

### UpdatePermissions

▸ **UpdatePermissions**(`currPermissions`, `permissionDigit`, `value`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `currPermissions` | `number` |
| `permissionDigit` | `number` |
| `value` | `boolean` |

#### Returns

`number`

#### Defined in

[permissions.ts:97](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L97)

___

### ValidatePermissions

▸ **ValidatePermissions**(`permissions`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `permissions` | `number` |

#### Returns

`void`

#### Defined in

[permissions.ts:53](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L53)

___

### ValidatePermissionsUpdate

▸ **ValidatePermissionsUpdate**(`oldPermissions`, `newPermissions`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `oldPermissions` | `number` |
| `newPermissions` | `number` |

#### Returns

`void`

#### Defined in

[permissions.ts:60](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L60)

___

### checkIfApproved

▸ **checkIfApproved**(`userBalance`, `accountNumber`, `balancesToCheck`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `userBalance` | [`UserBalance`](interfaces/UserBalance.md) |
| `accountNumber` | `number` |
| `balancesToCheck` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

`boolean`

#### Defined in

[badges.ts:311](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L311)

___

### checkIfApprovedInTransferList

▸ **checkIfApprovedInTransferList**(`addresses`, `connectedUser`, `managerAccountNumber`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `addresses` | [`Addresses`](interfaces/Addresses.md) |
| `connectedUser` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md) |
| `managerAccountNumber` | `number` |

#### Returns

`boolean`

#### Defined in

[badges.ts:130](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L130)

___

### checkIfIdRangesOverlap

▸ **checkIfIdRangesOverlap**(`idRanges`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

`boolean`

#### Defined in

[idRanges.ts:301](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L301)

___

### convertToBitBadgesUserInfo

▸ **convertToBitBadgesUserInfo**(`accountInfo`): [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `accountInfo` | [`AccountResponse`](interfaces/AccountResponse.md) |

#### Returns

[`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Defined in

[users.ts:4](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/users.ts#L4)

___

### convertToBitBadgesAddress

▸ **convertToBitBadgesAddress**(`address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |

#### Returns

`string`

#### Defined in

[chains.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L12)

___

### createCollectionFromMsgNewCollection

▸ **createCollectionFromMsgNewCollection**(`msgNewCollection`, `collectionMetadata`, `individualBadgeMetadata`, `connectedUser`, `claimItems`, `existingCollection?`): [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `msgNewCollection` | `MessageMsgNewCollection` |
| `collectionMetadata` | [`BadgeMetadata`](interfaces/BadgeMetadata.md) |
| `individualBadgeMetadata` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `connectedUser` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md) |
| `claimItems` | [`ClaimItemWithTrees`](interfaces/ClaimItemWithTrees.md)[] |
| `existingCollection?` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

[`BitBadgeCollection`](interfaces/BitBadgeCollection.md)

#### Defined in

[badges.ts:29](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L29)

___

### doesChainMatchName

▸ **doesChainMatchName**(`chain`, `name?`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `chain` | [`SupportedChain`](enums/SupportedChain.md) |
| `name?` | `string` |

#### Returns

`boolean`

#### Defined in

[chains.ts:87](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L87)

___

### filterBadgeActivityForBadgeId

▸ **filterBadgeActivityForBadgeId**(`badgeId`, `activity`): [`TransferActivityItem`](interfaces/TransferActivityItem.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `activity` | [`TransferActivityItem`](interfaces/TransferActivityItem.md)[] |

#### Returns

[`TransferActivityItem`](interfaces/TransferActivityItem.md)[]

#### Defined in

[badges.ts:10](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L10)

___

### getAbbreviatedAddress

▸ **getAbbreviatedAddress**(`address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |

#### Returns

`string`

#### Defined in

[chains.ts:46](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L46)

___

### getBadgeIdsToDisplayForPageNumber

▸ **getBadgeIdsToDisplayForPageNumber**(`collections?`, `startIdxNum`, `pageSize`): { `badgeIds`: `number`[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)  }[]

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `collections` | { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)  }[] | `[]` |
| `startIdxNum` | `number` | `undefined` |
| `pageSize` | `number` | `undefined` |

#### Returns

{ `badgeIds`: `number`[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)  }[]

#### Defined in

[badges.ts:197](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L197)

___

### getBalanceAfterTransfer

▸ **getBalanceAfterTransfer**(`balance`, `startSubbadgeId`, `endSubbadgeId`, `amountToTransfer`, `numRecipients`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `balance` | [`UserBalance`](interfaces/UserBalance.md) |
| `startSubbadgeId` | `number` |
| `endSubbadgeId` | `number` |
| `amountToTransfer` | `number` |
| `numRecipients` | `number` |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L14)

___

### getBalanceAfterTransfers

▸ **getBalanceAfterTransfers**(`balance`, `transfers`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `balance` | [`UserBalance`](interfaces/UserBalance.md) |
| `transfers` | [`TransfersExtended`](interfaces/TransfersExtended.md)[] |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:21](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L21)

___

### getBlankBalance

▸ **getBlankBalance**(): [`UserBalance`](interfaces/UserBalance.md)

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L5)

___

### getChainForAddress

▸ **getChainForAddress**(`address`): `SupportedChain`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |

#### Returns

`SupportedChain`

#### Defined in

[chains.ts:26](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L26)

___

### getClaimsFromClaimItems

▸ **getClaimsFromClaimItems**(`balance`, `claimItems`): `Object`

#### Parameters

| Name | Type |
| :------ | :------ |
| `balance` | [`UserBalance`](interfaces/UserBalance.md) |
| `claimItems` | [`ClaimItemWithTrees`](interfaces/ClaimItemWithTrees.md)[] |

#### Returns

`Object`

| Name | Type |
| :------ | :------ |
| `claims` | [`Claims`](interfaces/Claims.md)[] |
| `undistributedBalance` | `any` |

#### Defined in

[claims.ts:63](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/claims.ts#L63)

___

### getIdRangesForAllBadgeIdsInCollection

▸ **getIdRangesForAllBadgeIdsInCollection**(`collection`): `any`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`any`

#### Defined in

[badges.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L20)

___

### getMatchingAddressesFromTransferList

▸ **getMatchingAddressesFromTransferList**(`list`, `toAddresses`, `chain`, `managerAccountNumber`): `any`[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `list` | [`TransferList`](interfaces/TransferList.md)[] |
| `toAddresses` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)[] |
| `chain` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md) |
| `managerAccountNumber` | `number` |

#### Returns

`any`[]

#### Defined in

[badges.ts:153](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L153)

___

### getMaxBatchId

▸ **getMaxBatchId**(`collection`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`number`

#### Defined in

[badges.ts:245](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L245)

___

### getMetadataForBadgeId

▸ **getMetadataForBadgeId**(`badgeId`, `metadataMap`): `undefined` \| [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `metadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |

#### Returns

`undefined` \| [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[badges.ts:183](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L183)

___

### getMetadataMapObjForBadgeId

▸ **getMetadataMapObjForBadgeId**(`badgeId`, `metadataMap`): `undefined` \| { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `metadata`: [`BadgeMetadata`](interfaces/BadgeMetadata.md) ; `uri`: `string`  }

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `metadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |

#### Returns

`undefined` \| { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `metadata`: [`BadgeMetadata`](interfaces/BadgeMetadata.md) ; `uri`: `string`  }

#### Defined in

[badges.ts:170](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L170)

___

### getNonTransferableDisallowedTransfers

▸ **getNonTransferableDisallowedTransfers**(): `any`[]

#### Returns

`any`[]

#### Defined in

[badges.ts:105](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L105)

___

### getSupplyByBadgeId

▸ **getSupplyByBadgeId**(`badgeId`, `balances`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `balances` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

`number`

#### Defined in

[balances.ts:48](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L48)

___

### getTransferListForSelectOptions

▸ **getTransferListForSelectOptions**(`isFromList`, `unregistered`, `users`, `all`, `none`, `everyoneExcept`): `undefined` \| [`TransferListWithUnregisteredUsers`](interfaces/TransferListWithUnregisteredUsers.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `isFromList` | `boolean` |
| `unregistered` | `string`[] |
| `users` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)[] |
| `all` | `boolean` |
| `none` | `boolean` |
| `everyoneExcept` | `boolean` |

#### Returns

`undefined` \| [`TransferListWithUnregisteredUsers`](interfaces/TransferListWithUnregisteredUsers.md)

#### Defined in

[transferLists.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L36)

___

### getTransfersFromClaimItems

▸ **getTransfersFromClaimItems**(`claimItems`, `accounts`): [`TransfersExtended`](interfaces/TransfersExtended.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `claimItems` | [`ClaimItem`](interfaces/ClaimItem.md)[] |
| `accounts` | [`AccountMap`](interfaces/AccountMap.md) |

#### Returns

[`TransfersExtended`](interfaces/TransfersExtended.md)[]

#### Defined in

[claims.ts:6](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/claims.ts#L6)

___

### isAddressValid

▸ **isAddressValid**(`address`, `chain?`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |
| `chain?` | `string` |

#### Returns

`boolean`

#### Defined in

[chains.ts:55](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L55)

___

### isTransferListFull

▸ **isTransferListFull**(`transfersList`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `transfersList` | [`TransferList`](interfaces/TransferList.md)[] |

#### Returns

`boolean`

#### Defined in

[transferLists.ts:27](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L27)

___

### populateFieldsOfOtherBadges

▸ **populateFieldsOfOtherBadges**(`individualBadgeMetadata`, `badgeIds`, `key`, `value`, `metadataToSet?`): [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `individualBadgeMetadata` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `badgeIds` | [`IdRange`](interfaces/IdRange.md)[] |
| `key` | `string` |
| `value` | `any` |
| `metadataToSet?` | [`BadgeMetadata`](interfaces/BadgeMetadata.md) |

#### Returns

[`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Defined in

[metadata.ts:61](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/metadata.ts#L61)

___

### updateMetadataForBadgeIdsFromIndexerIfAbsent

▸ **updateMetadataForBadgeIdsFromIndexerIfAbsent**(`badgeIdsToDisplay`, `collection`): `number`[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeIdsToDisplay` | `number`[] |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`number`[]

#### Defined in

[badges.ts:264](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L264)

___

### updateMetadataMap

▸ **updateMetadataMap**(`currMetadataMap`, `metadata`, `badgeIds`, `uri`): [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `currMetadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `metadata` | [`BadgeMetadata`](interfaces/BadgeMetadata.md) |
| `badgeIds` | [`IdRange`](interfaces/IdRange.md) |
| `uri` | `string` |

#### Returns

[`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Defined in

[metadata.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/metadata.ts#L5)

___

### updateTransferListAccountNums

▸ **updateTransferListAccountNums**(`accountNumber`, `remove`, `transferListAddresses`): [`Addresses`](interfaces/Addresses.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `accountNumber` | `number` |
| `remove` | `boolean` |
| `transferListAddresses` | [`Addresses`](interfaces/Addresses.md) |

#### Returns

[`Addresses`](interfaces/Addresses.md)

#### Defined in

[transferLists.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L5)


## File: ./.gitbook/assets/modules.md

[BitBadges](README.md) / Exports

# BitBadges

## Table of contents

### Enumerations

- [DistributionMethod](enums/DistributionMethod.md)
- [MetadataAddMethod](enums/MetadataAddMethod.md)
- [SupportedChain](enums/SupportedChain.md)
- [TransactionStatus](enums/TransactionStatus.md)

### Interfaces

- [AccountDocs](interfaces/AccountDocs.md)
- [AccountDocument](interfaces/AccountDocument.md)
- [AccountMap](interfaces/AccountMap.md)
- [AccountResponse](interfaces/AccountResponse.md)
- [ActivityItem](interfaces/ActivityItem.md)
- [Addresses](interfaces/Addresses.md)
- [AnnouncementActivityItem](interfaces/AnnouncementActivityItem.md)
- [Approval](interfaces/Approval.md)
- [BadgeMetadata](interfaces/BadgeMetadata.md)
- [BadgeMetadataMap](interfaces/BadgeMetadataMap.md)
- [BadgeSupplyAndAmount](interfaces/BadgeSupplyAndAmount.md)
- [BadgeUri](interfaces/BadgeUri.md)
- [Balance](interfaces/Balance.md)
- [BalanceObject](interfaces/BalanceObject.md)
- [BalancesMap](interfaces/BalancesMap.md)
- [BitBadgeCollection](interfaces/BitBadgeCollection.md)
- [BitBadgeMintObject](interfaces/BitBadgeMintObject.md)
- [BitBadgesUserInfo](interfaces/BitBadgesUserInfo.md)
- [ClaimItem](interfaces/ClaimItem.md)
- [ClaimItemWithTrees](interfaces/ClaimItemWithTrees.md)
- [Claims](interfaces/Claims.md)
- [CollectionDocs](interfaces/CollectionDocs.md)
- [CollectionMap](interfaces/CollectionMap.md)
- [CosmosAccountInformation](interfaces/CosmosAccountInformation.md)
- [DbStatus](interfaces/DbStatus.md)
- [Docs](interfaces/Docs.md)
- [GetAccountResponse](interfaces/GetAccountResponse.md)
- [GetBadgeBalanceResponse](interfaces/GetBadgeBalanceResponse.md)
- [GetBalanceResponse](interfaces/GetBalanceResponse.md)
- [GetCollectionResponse](interfaces/GetCollectionResponse.md)
- [GetOwnersResponse](interfaces/GetOwnersResponse.md)
- [GetPortfolioResponse](interfaces/GetPortfolioResponse.md)
- [IdRange](interfaces/IdRange.md)
- [IndexerStatus](interfaces/IndexerStatus.md)
- [LatestBlockStatus](interfaces/LatestBlockStatus.md)
- [MetadataDocs](interfaces/MetadataDocs.md)
- [MetadataDocument](interfaces/MetadataDocument.md)
- [PaginationInfo](interfaces/PaginationInfo.md)
- [PasswordDocument](interfaces/PasswordDocument.md)
- [PendingTransfer](interfaces/PendingTransfer.md)
- [Proof](interfaces/Proof.md)
- [SearchResponse](interfaces/SearchResponse.md)
- [StoredBadgeCollection](interfaces/StoredBadgeCollection.md)
- [SubassetSupply](interfaces/SubassetSupply.md)
- [TransferActivityItem](interfaces/TransferActivityItem.md)
- [TransferList](interfaces/TransferList.md)
- [TransferListWithUnregisteredUsers](interfaces/TransferListWithUnregisteredUsers.md)
- [Transfers](interfaces/Transfers.md)
- [TransfersExtended](interfaces/TransfersExtended.md)
- [UserBalance](interfaces/UserBalance.md)

### Type Aliases

- [Permissions](modules.md#permissions)

### Variables

- [AllAddressesTransferList](modules.md#alladdressestransferlist)
- [CHAIN\_DETAILS](modules.md#chain_details)
- [CanCreateMoreBadgesDigit](modules.md#cancreatemorebadgesdigit)
- [CanDeleteDigit](modules.md#candeletedigit)
- [CanManagerBeTransferredDigit](modules.md#canmanagerbetransferreddigit)
- [CanUpdateBytesDigit](modules.md#canupdatebytesdigit)
- [CanUpdateDisallowedDigit](modules.md#canupdatedisalloweddigit)
- [CanUpdateUrisDigit](modules.md#canupdateurisdigit)
- [DefaultPlaceholderMetadata](modules.md#defaultplaceholdermetadata)
- [ErrorMetadata](modules.md#errormetadata)
- [GO\_MAX\_UINT\_64](modules.md#go_max_uint_64)
- [MAX\_DATE\_TIMESTAMP](modules.md#max_date_timestamp)
- [METADATA\_PAGE\_LIMIT](modules.md#metadata_page_limit)
- [MINT\_ACCOUNT](modules.md#mint_account)
- [NUM\_PERMISSIONS](modules.md#num_permissions)

### Functions

- [AddBalancesForIdRanges](modules.md#addbalancesforidranges)
- [DeleteBalanceForIdRanges](modules.md#deletebalanceforidranges)
- [GetAccountByNumberRoute](modules.md#getaccountbynumberroute)
- [GetAccountRoute](modules.md#getaccountroute)
- [GetAccountsRoute](modules.md#getaccountsroute)
- [GetBadgeBalanceRoute](modules.md#getbadgebalanceroute)
- [GetBalanceInfoToInsertToStorage](modules.md#getbalanceinfotoinserttostorage)
- [GetBalanceRoute](modules.md#getbalanceroute)
- [GetBalancesForIdRanges](modules.md#getbalancesforidranges)
- [GetCollectionRoute](modules.md#getcollectionroute)
- [GetCollectionsRoute](modules.md#getcollectionsroute)
- [GetIdRangeToInsert](modules.md#getidrangetoinsert)
- [GetIdRangesToInsertToStorage](modules.md#getidrangestoinserttostorage)
- [GetIdRangesWithOmitEmptyCaseHandled](modules.md#getidrangeswithomitemptycasehandled)
- [GetIdxSpanForRange](modules.md#getidxspanforrange)
- [GetIdxToInsertForNewId](modules.md#getidxtoinsertfornewid)
- [GetMetadataRoute](modules.md#getmetadataroute)
- [GetOwnersRoute](modules.md#getownersroute)
- [GetPermissionNumberValue](modules.md#getpermissionnumbervalue)
- [GetPermissions](modules.md#getpermissions)
- [GetPortfolioRoute](modules.md#getportfolioroute)
- [GetSearchRoute](modules.md#getsearchroute)
- [GetStatusRoute](modules.md#getstatusroute)
- [InsertRangeToIdRanges](modules.md#insertrangetoidranges)
- [MergePrevOrNextIfPossible](modules.md#mergeprevornextifpossible)
- [NormalizeIdRange](modules.md#normalizeidrange)
- [RemoveIdsFromIdRange](modules.md#removeidsfromidrange)
- [SafeAdd](modules.md#safeadd)
- [SafeSubtract](modules.md#safesubtract)
- [SearchBalances](modules.md#searchbalances)
- [SearchIdRangesForId](modules.md#searchidrangesforid)
- [SetBalanceForIdRanges](modules.md#setbalanceforidranges)
- [SortIdRangesAndMergeIfNecessary](modules.md#sortidrangesandmergeifnecessary)
- [SubtractBalancesForIdRanges](modules.md#subtractbalancesforidranges)
- [UpdateBalancesForIdRanges](modules.md#updatebalancesforidranges)
- [UpdatePermissions](modules.md#updatepermissions)
- [ValidatePermissions](modules.md#validatepermissions)
- [ValidatePermissionsUpdate](modules.md#validatepermissionsupdate)
- [checkIfApproved](modules.md#checkifapproved)
- [checkIfApprovedInTransferList](modules.md#checkifapprovedintransferlist)
- [checkIfIdRangesOverlap](modules.md#checkifidrangesoverlap)
- [convertToBitBadgesUserInfo](modules.md#converttobitbadgesuserinfo)
- [convertToBitBadgesAddress](modules.md#converttocosmosaddress)
- [createCollectionFromMsgNewCollection](modules.md#createcollectionfrommsgnewcollection)
- [doesChainMatchName](modules.md#doeschainmatchname)
- [filterBadgeActivityForBadgeId](modules.md#filterbadgeactivityforbadgeid)
- [getAbbreviatedAddress](modules.md#getabbreviatedaddress)
- [getBadgeIdsToDisplayForPageNumber](modules.md#getbadgeidstodisplayforpagenumber)
- [getBalanceAfterTransfer](modules.md#getbalanceaftertransfer)
- [getBalanceAfterTransfers](modules.md#getbalanceaftertransfers)
- [getBlankBalance](modules.md#getblankbalance)
- [getChainForAddress](modules.md#getchainforaddress)
- [getClaimsFromClaimItems](modules.md#getclaimsfromclaimitems)
- [getIdRangesForAllBadgeIdsInCollection](modules.md#getidrangesforallbadgeidsincollection)
- [getMatchingAddressesFromTransferList](modules.md#getmatchingaddressesfromtransferlist)
- [getMaxBatchId](modules.md#getmaxbatchid)
- [getMetadataForBadgeId](modules.md#getmetadataforbadgeid)
- [getMetadataMapObjForBadgeId](modules.md#getmetadatamapobjforbadgeid)
- [getNonTransferableDisallowedTransfers](modules.md#getnontransferabledisallowedtransfers)
- [getSupplyByBadgeId](modules.md#getsupplybybadgeid)
- [getTransferListForSelectOptions](modules.md#gettransferlistforselectoptions)
- [getTransfersFromClaimItems](modules.md#gettransfersfromclaimitems)
- [isAddressValid](modules.md#isaddressvalid)
- [isTransferListFull](modules.md#istransferlistfull)
- [populateFieldsOfOtherBadges](modules.md#populatefieldsofotherbadges)
- [updateMetadataForBadgeIdsFromIndexerIfAbsent](modules.md#updatemetadataforbadgeidsfromindexerifabsent)
- [updateMetadataMap](modules.md#updatemetadatamap)
- [updateTransferListAccountNums](modules.md#updatetransferlistaccountnums)

## Type Aliases

### Permissions

Ƭ **Permissions**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `CanCreateMoreBadges` | `boolean` |
| `CanDelete` | `boolean` |
| `CanManagerBeTransferred` | `boolean` |
| `CanUpdateBytes` | `boolean` |
| `CanUpdateDisallowed` | `boolean` |
| `CanUpdateUris` | `boolean` |

#### Defined in

[permissions.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L3)

## Variables

### AllAddressesTransferList

• `Const` **AllAddressesTransferList**: [`TransferList`](interfaces/TransferList.md)

#### Defined in

[badges.ts:109](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L109)

___

### CHAIN\_DETAILS

• `Const` **CHAIN\_DETAILS**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `chainId` | `number` |
| `cosmosChainId` | `string` |

#### Defined in

[constants.ts:9](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L9)

___

### CanCreateMoreBadgesDigit

• `Const` **CanCreateMoreBadgesDigit**: ``2``

#### Defined in

[permissions.ts:16](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L16)

___

### CanDeleteDigit

• `Const` **CanDeleteDigit**: ``6``

#### Defined in

[permissions.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L12)

___

### CanManagerBeTransferredDigit

• `Const` **CanManagerBeTransferredDigit**: ``4``

#### Defined in

[permissions.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L14)

___

### CanUpdateBytesDigit

• `Const` **CanUpdateBytesDigit**: ``5``

#### Defined in

[permissions.ts:13](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L13)

___

### CanUpdateDisallowedDigit

• `Const` **CanUpdateDisallowedDigit**: ``1``

#### Defined in

[permissions.ts:17](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L17)

___

### CanUpdateUrisDigit

• `Const` **CanUpdateUrisDigit**: ``3``

#### Defined in

[permissions.ts:15](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L15)

___

### DefaultPlaceholderMetadata

• `Const` **DefaultPlaceholderMetadata**: [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[constants.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L14)

___

### ErrorMetadata

• `Const` **ErrorMetadata**: [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[constants.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L20)

___

### GO\_MAX\_UINT\_64

• `Const` **GO\_MAX\_UINT\_64**: ``1000000000000000``

#### Defined in

[constants.ts:7](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L7)

___

### MAX\_DATE\_TIMESTAMP

• `Const` **MAX\_DATE\_TIMESTAMP**: `number`

#### Defined in

[constants.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L5)

___

### METADATA\_PAGE\_LIMIT

• `Const` **METADATA\_PAGE\_LIMIT**: ``100``

#### Defined in

[constants.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L3)

___

### MINT\_ACCOUNT

• `Const` **MINT\_ACCOUNT**: [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Defined in

[chains.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L5)

___

### NUM\_PERMISSIONS

• `Const` **NUM\_PERMISSIONS**: ``6``

#### Defined in

[permissions.ts:1](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L1)

## Functions

### AddBalancesForIdRanges

▸ **AddBalancesForIdRanges**(`userBalanceInfo`, `ranges`, `balanceToAdd`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `userBalanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `balanceToAdd` | `number` |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:116](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L116)

___

### DeleteBalanceForIdRanges

▸ **DeleteBalanceForIdRanges**(`ranges`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:142](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L142)

___

### GetAccountByNumberRoute

▸ **GetAccountByNumberRoute**(`id`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `id` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:8](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L8)

___

### GetAccountRoute

▸ **GetAccountRoute**(`bech32address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `bech32address` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:4](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L4)

___

### GetAccountsRoute

▸ **GetAccountsRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L12)

___

### GetBadgeBalanceRoute

▸ **GetBadgeBalanceRoute**(`collectionId`, `accountNumber`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |
| `accountNumber` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:28](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L28)

___

### GetBalanceInfoToInsertToStorage

▸ **GetBalanceInfoToInsertToStorage**(`balanceInfo`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `balanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:254](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L254)

___

### GetBalanceRoute

▸ **GetBalanceRoute**(`bech32address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `bech32address` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:16](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L16)

___

### GetBalancesForIdRanges

▸ **GetBalancesForIdRanges**(`badgeIds`, `currentUserBalances`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeIds` | [`IdRange`](interfaces/IdRange.md)[] |
| `currentUserBalances` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L36)

___

### GetCollectionRoute

▸ **GetCollectionRoute**(`collectionId`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L20)

___

### GetCollectionsRoute

▸ **GetCollectionsRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:24](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L24)

___

### GetIdRangeToInsert

▸ **GetIdRangeToInsert**(`start`, `end`): `Object`

#### Parameters

| Name | Type |
| :------ | :------ |
| `start` | `number` |
| `end` | `number` |

#### Returns

`Object`

| Name | Type |
| :------ | :------ |
| `end` | `number` |
| `start` | `number` |

#### Defined in

[idRanges.ts:152](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L152)

___

### GetIdRangesToInsertToStorage

▸ **GetIdRangesToInsertToStorage**(`idRanges`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:31](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L31)

___

### GetIdRangesWithOmitEmptyCaseHandled

▸ **GetIdRangesWithOmitEmptyCaseHandled**(`ids`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ids` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:144](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L144)

___

### GetIdxSpanForRange

▸ **GetIdxSpanForRange**(`targetRange`, `targetIdRanges`): [[`IdRange`](interfaces/IdRange.md), `boolean`]

#### Parameters

| Name | Type |
| :------ | :------ |
| `targetRange` | [`IdRange`](interfaces/IdRange.md) |
| `targetIdRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[[`IdRange`](interfaces/IdRange.md), `boolean`]

#### Defined in

[idRanges.ts:111](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L111)

___

### GetIdxToInsertForNewId

▸ **GetIdxToInsertForNewId**(`id`, `targetIds`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `id` | `number` |
| `targetIds` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

`number`

#### Defined in

[idRanges.ts:176](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L176)

___

### GetMetadataRoute

▸ **GetMetadataRoute**(`collectionId`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:40](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L40)

___

### GetOwnersRoute

▸ **GetOwnersRoute**(`collectionId`, `badgeId`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |
| `badgeId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:32](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L32)

___

### GetPermissionNumberValue

▸ **GetPermissionNumberValue**(`permissions`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `permissions` | [`Permissions`](modules.md#permissions) |

#### Returns

`number`

#### Defined in

[permissions.ts:19](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L19)

___

### GetPermissions

▸ **GetPermissions**(`permissions`): [`Permissions`](modules.md#permissions)

#### Parameters

| Name | Type |
| :------ | :------ |
| `permissions` | `number` |

#### Returns

[`Permissions`](modules.md#permissions)

#### Defined in

[permissions.ts:118](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L118)

___

### GetPortfolioRoute

▸ **GetPortfolioRoute**(`accountNumber`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `accountNumber` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L36)

___

### GetSearchRoute

▸ **GetSearchRoute**(`query`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `query` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:44](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L44)

___

### GetStatusRoute

▸ **GetStatusRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:48](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L48)

___

### InsertRangeToIdRanges

▸ **InsertRangeToIdRanges**(`rangeToAdd`, `targetIds`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `rangeToAdd` | [`IdRange`](interfaces/IdRange.md) |
| `targetIds` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:274](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L274)

___

### MergePrevOrNextIfPossible

▸ **MergePrevOrNextIfPossible**(`targetIds`, `insertedAtIdx`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `targetIds` | [`IdRange`](interfaces/IdRange.md)[] |
| `insertedAtIdx` | `number` |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:218](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L218)

___

### NormalizeIdRange

▸ **NormalizeIdRange**(`rangeToNormalize`): `Object`

#### Parameters

| Name | Type |
| :------ | :------ |
| `rangeToNormalize` | [`IdRange`](interfaces/IdRange.md) |

#### Returns

`Object`

| Name | Type |
| :------ | :------ |
| `end` | `number` |
| `start` | `number` |

#### Defined in

[idRanges.ts:164](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L164)

___

### RemoveIdsFromIdRange

▸ **RemoveIdsFromIdRange**(`rangeToRemove`, `rangeObject`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `rangeToRemove` | [`IdRange`](interfaces/IdRange.md) |
| `rangeObject` | [`IdRange`](interfaces/IdRange.md) |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:47](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L47)

___

### SafeAdd

▸ **SafeAdd**(`left`, `right`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `left` | `number` |
| `right` | `number` |

#### Returns

`number`

#### Defined in

[balances-gpt.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L5)

___

### SafeSubtract

▸ **SafeSubtract**(`left`, `right`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `left` | `number` |
| `right` | `number` |

#### Returns

`number`

#### Defined in

[balances-gpt.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L14)

___

### SearchBalances

▸ **SearchBalances**(`targetAmount`, `balanceObjects`): (`number` \| `boolean`)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `targetAmount` | `number` |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

(`number` \| `boolean`)[]

#### Defined in

[balances-gpt.ts:224](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L224)

___

### SearchIdRangesForId

▸ **SearchIdRangesForId**(`id`, `idRanges`): [`number`, `boolean`]

#### Parameters

| Name | Type |
| :------ | :------ |
| `id` | `number` |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`number`, `boolean`]

#### Defined in

[idRanges.ts:92](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L92)

___

### SetBalanceForIdRanges

▸ **SetBalanceForIdRanges**(`ranges`, `amount`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `amount` | `number` |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:183](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L183)

___

### SortIdRangesAndMergeIfNecessary

▸ **SortIdRangesAndMergeIfNecessary**(`idRanges`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L3)

___

### SubtractBalancesForIdRanges

▸ **SubtractBalancesForIdRanges**(`userBalanceInfo`, `ranges`, `balanceToRemove`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `userBalanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `balanceToRemove` | `number` |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:129](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L129)

___

### UpdateBalancesForIdRanges

▸ **UpdateBalancesForIdRanges**(`ranges`, `newAmount`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `newAmount` | `number` |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:22](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L22)

___

### UpdatePermissions

▸ **UpdatePermissions**(`currPermissions`, `permissionDigit`, `value`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `currPermissions` | `number` |
| `permissionDigit` | `number` |
| `value` | `boolean` |

#### Returns

`number`

#### Defined in

[permissions.ts:97](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L97)

___

### ValidatePermissions

▸ **ValidatePermissions**(`permissions`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `permissions` | `number` |

#### Returns

`void`

#### Defined in

[permissions.ts:53](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L53)

___

### ValidatePermissionsUpdate

▸ **ValidatePermissionsUpdate**(`oldPermissions`, `newPermissions`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `oldPermissions` | `number` |
| `newPermissions` | `number` |

#### Returns

`void`

#### Defined in

[permissions.ts:60](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L60)

___

### checkIfApproved

▸ **checkIfApproved**(`userBalance`, `accountNumber`, `balancesToCheck`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `userBalance` | [`UserBalance`](interfaces/UserBalance.md) |
| `accountNumber` | `number` |
| `balancesToCheck` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

`boolean`

#### Defined in

[badges.ts:311](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L311)

___

### checkIfApprovedInTransferList

▸ **checkIfApprovedInTransferList**(`addresses`, `connectedUser`, `managerAccountNumber`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `addresses` | [`Addresses`](interfaces/Addresses.md) |
| `connectedUser` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md) |
| `managerAccountNumber` | `number` |

#### Returns

`boolean`

#### Defined in

[badges.ts:130](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L130)

___

### checkIfIdRangesOverlap

▸ **checkIfIdRangesOverlap**(`idRanges`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

`boolean`

#### Defined in

[idRanges.ts:301](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L301)

___

### convertToBitBadgesUserInfo

▸ **convertToBitBadgesUserInfo**(`accountInfo`): [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `accountInfo` | [`AccountResponse`](interfaces/AccountResponse.md) |

#### Returns

[`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Defined in

[users.ts:4](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/users.ts#L4)

___

### convertToBitBadgesAddress

▸ **convertToBitBadgesAddress**(`address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |

#### Returns

`string`

#### Defined in

[chains.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L12)

___

### createCollectionFromMsgNewCollection

▸ **createCollectionFromMsgNewCollection**(`msgNewCollection`, `collectionMetadata`, `individualBadgeMetadata`, `connectedUser`, `claimItems`, `existingCollection?`): [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `msgNewCollection` | `MessageMsgNewCollection` |
| `collectionMetadata` | [`BadgeMetadata`](interfaces/BadgeMetadata.md) |
| `individualBadgeMetadata` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `connectedUser` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md) |
| `claimItems` | [`ClaimItemWithTrees`](interfaces/ClaimItemWithTrees.md)[] |
| `existingCollection?` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

[`BitBadgeCollection`](interfaces/BitBadgeCollection.md)

#### Defined in

[badges.ts:29](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L29)

___

### doesChainMatchName

▸ **doesChainMatchName**(`chain`, `name?`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `chain` | [`SupportedChain`](enums/SupportedChain.md) |
| `name?` | `string` |

#### Returns

`boolean`

#### Defined in

[chains.ts:87](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L87)

___

### filterBadgeActivityForBadgeId

▸ **filterBadgeActivityForBadgeId**(`badgeId`, `activity`): [`TransferActivityItem`](interfaces/TransferActivityItem.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `activity` | [`TransferActivityItem`](interfaces/TransferActivityItem.md)[] |

#### Returns

[`TransferActivityItem`](interfaces/TransferActivityItem.md)[]

#### Defined in

[badges.ts:10](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L10)

___

### getAbbreviatedAddress

▸ **getAbbreviatedAddress**(`address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |

#### Returns

`string`

#### Defined in

[chains.ts:46](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L46)

___

### getBadgeIdsToDisplayForPageNumber

▸ **getBadgeIdsToDisplayForPageNumber**(`collections?`, `startIdxNum`, `pageSize`): { `badgeIds`: `number`[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)  }[]

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `collections` | { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)  }[] | `[]` |
| `startIdxNum` | `number` | `undefined` |
| `pageSize` | `number` | `undefined` |

#### Returns

{ `badgeIds`: `number`[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)  }[]

#### Defined in

[badges.ts:197](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L197)

___

### getBalanceAfterTransfer

▸ **getBalanceAfterTransfer**(`balance`, `startSubbadgeId`, `endSubbadgeId`, `amountToTransfer`, `numRecipients`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `balance` | [`UserBalance`](interfaces/UserBalance.md) |
| `startSubbadgeId` | `number` |
| `endSubbadgeId` | `number` |
| `amountToTransfer` | `number` |
| `numRecipients` | `number` |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L14)

___

### getBalanceAfterTransfers

▸ **getBalanceAfterTransfers**(`balance`, `transfers`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `balance` | [`UserBalance`](interfaces/UserBalance.md) |
| `transfers` | [`TransfersExtended`](interfaces/TransfersExtended.md)[] |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:21](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L21)

___

### getBlankBalance

▸ **getBlankBalance**(): [`UserBalance`](interfaces/UserBalance.md)

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L5)

___

### getChainForAddress

▸ **getChainForAddress**(`address`): `SupportedChain`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |

#### Returns

`SupportedChain`

#### Defined in

[chains.ts:26](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L26)

___

### getClaimsFromClaimItems

▸ **getClaimsFromClaimItems**(`balance`, `claimItems`): `Object`

#### Parameters

| Name | Type |
| :------ | :------ |
| `balance` | [`UserBalance`](interfaces/UserBalance.md) |
| `claimItems` | [`ClaimItemWithTrees`](interfaces/ClaimItemWithTrees.md)[] |

#### Returns

`Object`

| Name | Type |
| :------ | :------ |
| `claims` | [`Claims`](interfaces/Claims.md)[] |
| `undistributedBalance` | `any` |

#### Defined in

[claims.ts:63](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/claims.ts#L63)

___

### getIdRangesForAllBadgeIdsInCollection

▸ **getIdRangesForAllBadgeIdsInCollection**(`collection`): `any`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`any`

#### Defined in

[badges.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L20)

___

### getMatchingAddressesFromTransferList

▸ **getMatchingAddressesFromTransferList**(`list`, `toAddresses`, `chain`, `managerAccountNumber`): `any`[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `list` | [`TransferList`](interfaces/TransferList.md)[] |
| `toAddresses` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)[] |
| `chain` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md) |
| `managerAccountNumber` | `number` |

#### Returns

`any`[]

#### Defined in

[badges.ts:153](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L153)

___

### getMaxBatchId

▸ **getMaxBatchId**(`collection`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`number`

#### Defined in

[badges.ts:245](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L245)

___

### getMetadataForBadgeId

▸ **getMetadataForBadgeId**(`badgeId`, `metadataMap`): `undefined` \| [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `metadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |

#### Returns

`undefined` \| [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[badges.ts:183](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L183)

___

### getMetadataMapObjForBadgeId

▸ **getMetadataMapObjForBadgeId**(`badgeId`, `metadataMap`): `undefined` \| { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `metadata`: [`BadgeMetadata`](interfaces/BadgeMetadata.md) ; `uri`: `string`  }

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `metadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |

#### Returns

`undefined` \| { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `metadata`: [`BadgeMetadata`](interfaces/BadgeMetadata.md) ; `uri`: `string`  }

#### Defined in

[badges.ts:170](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L170)

___

### getNonTransferableDisallowedTransfers

▸ **getNonTransferableDisallowedTransfers**(): `any`[]

#### Returns

`any`[]

#### Defined in

[badges.ts:105](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L105)

___

### getSupplyByBadgeId

▸ **getSupplyByBadgeId**(`badgeId`, `balances`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `balances` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

`number`

#### Defined in

[balances.ts:48](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L48)

___

### getTransferListForSelectOptions

▸ **getTransferListForSelectOptions**(`isFromList`, `unregistered`, `users`, `all`, `none`, `everyoneExcept`): `undefined` \| [`TransferListWithUnregisteredUsers`](interfaces/TransferListWithUnregisteredUsers.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `isFromList` | `boolean` |
| `unregistered` | `string`[] |
| `users` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)[] |
| `all` | `boolean` |
| `none` | `boolean` |
| `everyoneExcept` | `boolean` |

#### Returns

`undefined` \| [`TransferListWithUnregisteredUsers`](interfaces/TransferListWithUnregisteredUsers.md)

#### Defined in

[transferLists.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L36)

___

### getTransfersFromClaimItems

▸ **getTransfersFromClaimItems**(`claimItems`, `accounts`): [`TransfersExtended`](interfaces/TransfersExtended.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `claimItems` | [`ClaimItem`](interfaces/ClaimItem.md)[] |
| `accounts` | [`AccountMap`](interfaces/AccountMap.md) |

#### Returns

[`TransfersExtended`](interfaces/TransfersExtended.md)[]

#### Defined in

[claims.ts:6](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/claims.ts#L6)

___

### isAddressValid

▸ **isAddressValid**(`address`, `chain?`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |
| `chain?` | `string` |

#### Returns

`boolean`

#### Defined in

[chains.ts:55](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L55)

___

### isTransferListFull

▸ **isTransferListFull**(`transfersList`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `transfersList` | [`TransferList`](interfaces/TransferList.md)[] |

#### Returns

`boolean`

#### Defined in

[transferLists.ts:27](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L27)

___

### populateFieldsOfOtherBadges

▸ **populateFieldsOfOtherBadges**(`individualBadgeMetadata`, `badgeIds`, `key`, `value`, `metadataToSet?`): [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `individualBadgeMetadata` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `badgeIds` | [`IdRange`](interfaces/IdRange.md)[] |
| `key` | `string` |
| `value` | `any` |
| `metadataToSet?` | [`BadgeMetadata`](interfaces/BadgeMetadata.md) |

#### Returns

[`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Defined in

[metadata.ts:61](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/metadata.ts#L61)

___

### updateMetadataForBadgeIdsFromIndexerIfAbsent

▸ **updateMetadataForBadgeIdsFromIndexerIfAbsent**(`badgeIdsToDisplay`, `collection`): `number`[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeIdsToDisplay` | `number`[] |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`number`[]

#### Defined in

[badges.ts:264](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L264)

___

### updateMetadataMap

▸ **updateMetadataMap**(`currMetadataMap`, `metadata`, `badgeIds`, `uri`): [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `currMetadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `metadata` | [`BadgeMetadata`](interfaces/BadgeMetadata.md) |
| `badgeIds` | [`IdRange`](interfaces/IdRange.md) |
| `uri` | `string` |

#### Returns

[`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Defined in

[metadata.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/metadata.ts#L5)

___

### updateTransferListAccountNums

▸ **updateTransferListAccountNums**(`accountNumber`, `remove`, `transferListAddresses`): [`Addresses`](interfaces/Addresses.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `accountNumber` | `number` |
| `remove` | `boolean` |
| `transferListAddresses` | [`Addresses`](interfaces/Addresses.md) |

#### Returns

[`Addresses`](interfaces/Addresses.md)

#### Defined in

[transferLists.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L5)


## File: ./README.md

---
description: >-
  Here, you will find documentation about BitBadges, how it works, how to
  interact, and how to contribute!
---

# 👋 BitBadges Overview



<figure><img src=".gitbook/assets/bitbadgeslogo.png" alt="" width="188"><figcaption></figcaption></figure>

## Overview

BitBadges offers gating-as-a-service. We offer a multi-chain, state-of-the-art, community-driven token standard and suite of tools (Sign In with BitBadges, attestations, claim checking) for you to gate any app or service from websites to in-person events to Discord servers to repositories. Anything you want!

BitBadges can be simply thought of in two parts.&#x20;

1. Criteria Checking: Let us do the heavy lifting of checking the criteria through multi-chain authentication, criteria checks from 7000+ apps, multi-chain badges, points, address lists, and much more!
2. Utility - Seamlessly offer gated services like websites, URLs, tiered perks, subscriptions, anything to users who meet the criteria!

By checking any criteria and delivering any reward, you can gate anything!

<figure><img src=".gitbook/assets/image (4) (1) (1).png" alt=""><figcaption></figcaption></figure>

The BitBadges ecosystem aims to offer the full-stack of tools and services you may need from the required storage (blockchain, data indexing, off-chain data storage) to a universal multi-chain authentication standard to distribution to offline-first verification tools (in-person verification, website gated sign-ins) to communicating with your badge holders and more!

### **Motive for building BitBadges?**

The answer is simple. We believe in the potential of blockchains and a multi-chain world, but this potential cannot be realized with the current infrastructure and technology in place today. Current infrastructure is not scalable, lacks consistency, limited in features, and is limited to a single blockchain ecosystem at a time. BitBadges wants to help by building the critical infrastructure the right way!

This applies to not only our token standard but everything we do. We have built everything from the ground up to support multiple blockchain ecosystems all with the SAME interface. All while maintaining our core values of decentralization.

No longer do you need to support multiple interfaces for each blockchain ecosystem you want to support. For example, you can authenticate users from Cosmos, Solana, Bitcoin, and Ethereum all with the same interface. All users can own the SAME badges, use the SAME protocols, and so on. Before BitBadges, building multi-chain applications was a nightmare due to having to support all the various interfaces, protocols, and more for each blockchain ecosystem. Now, it is all in one place.

<div data-full-width="false"><figure><img src=".gitbook/assets/image (8) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure></div>

## Our Services

### Badges

With our innovative 100x token standard, create multi-chain tokens (badges) that can be owned, transferred, and traded by BitBadges accounts. By multi-chain, users from ANY chain can own and transfer the SAME token (badge)! Something completely novel in the Web3 ecosystem today.

Tokens (badges) are simply something that you can own digitally and prove ownership of it. You probably already use and own many digital tokens: verification checkmarks, a movie streaming subscription, concert tickets, etc. These tokens can be used for many [use cases](./#use-cases), each potentially offering you different utility and value. Some may have real-world use cases (e.g. entry to a concert), while some may be purely digital (e.g. verification checkmark). Some may signify something about your reputation (certifications), while some may just be collected for fun.

When combined with blockchain technology, badges become even more secure and more powerful, due to the unique properties of the blockchain (verifiable, decentralized, tamper-proof, and so on). However, the existing infrastructure and technology is not nearly good enough to realize the vast potential of digital blockchain tokens (not scalable, lacks consistency, and is limited to a single blockchain ecosystem at a time).

### Alternatives - Lists, Protocols, Attestations, Points, Tiers, Quests

We also offer alternatives to badges to enhance your digital identity and portfolio:

1. **Address Lists:** Manage users from any supported blockchain with simple address lists. This streamlined alternative to traditional badges allows for efficient user management across multiple chains.
2. **Protocols / Maps:** Leverage reusable protocols to manage information such as preferences, reputation, and more across applications and chains. These protocols create a standardized way to store and access data, enhancing interoperability between different platforms and ecosystems.
3. **Attestations:** Use attestations to prove information, such as credentials, privately with zero-knowledge selective disclosure. This feature allows you to verify specific details without revealing unnecessary personal information, enhancing privacy and security in digital interactions.
4. **Points / Tiers / Quests** - Gamify user experiences with a points based leaderboard, quests, or gamified tiers they can earn.

These additional tools complement our badge system, providing a comprehensive suite for managing digital identities and interactions in the blockchain space.

### Universal Authentication - Sign In with BitBadges

Putting it all together, think of your BitBadges portfolio as a digital data backpack / identity. You own it. You control it. You take it with you everywhere you go and can use it to prove anything.

![](image-1.png)

Thus, BitBadges becomes the all-in-one authentication provider, revolutionizing how users prove their identity and credentials across various platforms. With BitBadges, you can:

* Authenticate using your address from any supported blockchain
* Prove ownership of specific badges
* Verify particular attestations
* Demonstrate membership in address lists
* Validate adherence to protocols
* Connect with claims to check any criteria
* Create custom experiences for your users based on protocols, ownership and more!

All in one place! All outsourced to BitBadges!

This comprehensive approach to authentication works both digitally and in-person:

1. **Digital Authentication:** Use "Sign In with BitBadges" for seamless access to websites and applications. This method allows you to prove your identity and credentials without creating new accounts or sharing unnecessary personal information.
2. **In-Person Authentication:** Utilize QR codes to verify your identity, badge ownership, or attestations in real-world scenarios, such as event entry or age verification. Export the QR codes to formats like Apple Wallet or any prefererd format.

<figure><img src=".gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### BitBadges Claims

Claims are a core aspect of BitBadges allowing you to check criteria from over 7000+ apps and integrations. Tons of plugins are supported directly no-code and in-site, but we also have flexible implementation options to allow you to add your own logic (webhooks, API, building / publishing your own plugin).

The most powerful feature of claims is that they are compatible with every other aspect of BitBadges (ex: gating badge distribution with claims, Sign In with BitBadges and check claims all in one flow).

Combine criteria checks to gate anything from content to websites to badge distribution to anything you want! Let BitBadges do the heavy lifting, enabling you to focus on offering your core utility.

<figure><img src=".gitbook/assets/image (153).png" alt=""><figcaption></figcaption></figure>

### Zapier

BitBadges has a Zapier integration that allows you to connect BitBadges to any app supported by Zapier ([https://zapier.com/apps](https://zapier.com/apps)). Automatically trigger BitBadges claims or trigger actions upon successful claims.

![](image.png)

## Use Cases

{% content-ref url="overview/use-cases.md" %}
[use-cases.md](overview/use-cases.md)
{% endcontent-ref %}

## 100x Token Standard

The BitBadges token (badge) standard is state-of-the-art compared to existing token standards (ERC20, ERC721, etc) and does not require smart contracts. The standard is ever-evolving and natively supports never-before-seen features like time-dependent ownership, fine-grained transferability requirements, and hybrid off-chain balances. We like to think of BitBadges as a 100x improvement over existing token standards.

In addition to the standard features of existing token standards (mint, transfer, approve, etc), we expand and offer the following functionality:

* [**Time-Based Balances**](broken-reference)**:** Badge balances are all time-dependent which allow you to, for example, transfer only a specific period of time (e.g. subscription token for a month), clearly define token unlock schedules, or approve a transfer only for a specific period of time.
* [**Off-Chain Balances:**](broken-reference) New ways to store and track balances, in addition to the standard on-chain storage of balances. Storing balances off-chain can offer over 1000x better scalability and much better user experience because users never need to transact with the blockchain. Badges are auto assigned to their wallets. This also allows seamless connection to any Web2 app since you are not limited to only blockchain data anymore.
* [**Fine-Grained Transferability and Approvals Customization**](broken-reference)**:** Simply abstracting transferability to "transferable" or "non-transferable" is too simple for many use cases. We recognize that transferability is a complex protocol of who can transfer to who? at what times? what badges? how many? revokable? freezable? etc.
  * Example: Only those who own the verified checkmark badge can transfer the badge IDs 1-5 to each other from Monday to Tuesday 12PM, but badges will be revokable by the manager after that.
  * [**Must Own Badges:** ](broken-reference)Restrict sending and receiving badges to only those who own specific badges of other collections (e.g. a KYC badge, a verified badge).
  * [**Fine-Grained Approvals:** ](broken-reference)In addition to simply specifying approval of X amount, you can customize approvals further with details like predetermined balances (x1 of ID 1, then x1 of ID 2), max number of transfers allowed, and more!
  * [**Incoming Approvals:** ](broken-reference)In addition to having control over your outgoing transfers, have control over your incoming transfers via incoming approvals.
    * Ex: Block certain users from transferring to you. Block all transfers unless you opt-in to receiving them.
  * And more!
* [**Customizable Permissions**](broken-reference)**:** Each collection has fine-grained customizable permissions that can be optionally set and executed by a special party called the manager, such as archiving the collection, deleting it, updating its metadata, updating transferability, etc.
* [**Time-Based Details**](for-developers/badges-advanced/timelines.md)**:** Important collection details such as metadata are time-based, allowing you to automatically commit to updating it at a future time without needing to transact at that time. Ex: Set the metadata to be one value from January 1 to January 10 and then auto-change to another value!
* [**Batch Transfers**](broken-reference)**:** Batch transfer badges instead of only being able to transfer one by one.
  * Instead of needing 1000 transactions to send 1000 unique non-fungible badges in a collection (e.g. x1 of Badge ID 1, x1 of ID 2, ...), you can batch all into one transaction efficiently (e.g. send x1 of Badge IDs 1-1000).

And much more!


## File: ./SUMMARY.md

# Table of contents

## Overview

* [👋 BitBadges Overview](README.md)
* [👨‍💻 Learn the Basics](overview/learn/README.md)
  * [BitBadges Claims](overview/learn/distribution.md)
  * [Multi-Chain Accounts](overview/learn/accounts.md)
  * [Sign In with BitBadges](overview/learn/verification-tools.md)
  * [Badges](overview/learn/badges.md)
  * [Address Lists](overview/learn/address-lists.md)
  * [Attestations](overview/learn/attestations.md)
  * [Applications (Points)](overview/learn/applications-points.md)
  * [Additional Badge Concepts](overview/learn/badge-concepts/README.md)
    * [Manager](overview/learn/badge-concepts/manager.md)
    * [Total Supplys](overview/learn/badge-concepts/total-supplys.md)
    * [Time-Dependent Ownership](overview/learn/badge-concepts/time-dependent-ownership.md)
    * [Transferability](overview/learn/badge-concepts/transferability.md)
    * [Balances Types](overview/learn/badge-concepts/balances-types.md)
  * [Wallets and Sign Ins](overview/learn/wallets-and-sign-ins/README.md)
    * [Supported Wallets](overview/learn/wallets-and-sign-ins/supported-wallets.md)
    * [Alternate Sign Ins / Mobile](overview/learn/wallets-and-sign-ins/mobile-support.md)
    * [Approved Transactors](overview/learn/wallets-and-sign-ins/approved-transactors.md)
* [🔨 Getting Started](overview/getting-started.md)
* [💻 How Do I Check...?](overview/how-do-i-check-xyz.md)
* [🔐 How Do I Gate...?](overview/how-do-i-gate-xyz.md)
* [🎨 Use Cases](overview/use-cases.md)
* [🔗 Official Links and Resources](overview/official-links.md)
* [⚖️ BitBadges L1 vs Others](overview/comparing-bitbadges-to-other-protocols.md)
* [🪙 Launch Phases](overview/launch-phases.md)
* [🌴 Ecosystem](overview/ecosystem/README.md)
  * [WordPress Plugin](overview/ecosystem/wordpress-plugin.md)
  * [MetaMask Snap](overview/ecosystem/metamask-snap.md)
  * [Browser Extensions](overview/ecosystem/chrome-extension.md)
  * [LinkedIn Certifications](overview/ecosystem/linkedin-certifications.md)
  * [Blockin](overview/ecosystem/blockin.md)
* [🤝 Brand Guidelines](overview/link-sharing.md)
* [❓ FAQ](overview/faq.md)

## ⌨️ For Developers

* [🚴‍♂️ Getting Started](for-developers/getting-started.md)
* [👤 Handling Addresses](for-developers/accounts.md)
* [🧪 Testnet Mode](overview/testnet-mode.md)
* [📚 BitBadges API](for-developers/bitbadges-api/README.md)
  * [Getting Started](for-developers/bitbadges-api/api.md)
  * [Full Reference](https://bitbadges.stoplight.io/docs/bitbadges)
  * [Typed SDK Types](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html)
  * [Upgrading an API Key Tier](for-developers/bitbadges-api/upgrading-an-api-key-tier.md)
  * [Concepts](for-developers/bitbadges-api/concepts/README.md)
    * [Native Chain Algorithm](for-developers/bitbadges-api/concepts/native-chain-algorithm.md)
    * [Refresh / Claim Completion Queue](for-developers/bitbadges-api/concepts/refresh-queue.md)
    * [Designing for Compatibility](for-developers/bitbadges-api/concepts/designing-for-compatibility.md)
    * [Limits / Restrictions](for-developers/bitbadges-api/concepts/limits-restrictions.md)
    * [Managing Views](for-developers/bitbadges-api/concepts/managing-views.md)
    * [Use via Pipedream](for-developers/bitbadges-api/concepts/use-via-pipedream.md)
* [🖱️ Sign In with BitBadges](for-developers/authenticating-with-bitbadges/README.md)
  * [Overview](for-developers/sign-in-with-bitbadges/overview.md)
  * [Already Have Web3 Auth?](for-developers/authenticating-with-bitbadges/already-have-web3-auth.md)
  * [Alternative - P2P Verification](for-developers/authenticating-with-bitbadges/alternative-p2p-verification.md)
  * [Templates and Frameworks](for-developers/authenticating-with-bitbadges/framework-templates/README.md)
    * [WordPress](for-developers/authenticating-with-bitbadges/framework-templates/wordpress.md)
    * [Auth0](for-developers/authenticating-with-bitbadges/framework-templates/auth0.md)
    * [ExpressJS](for-developers/authenticating-with-bitbadges/framework-templates/passportjs.md)
    * [Discourse](for-developers/authenticating-with-bitbadges/framework-templates/discourse.md)
    * [Supabase](for-developers/authenticating-with-bitbadges/framework-templates/supabase.md)
    * [Others](for-developers/authenticating-with-bitbadges/framework-templates/others.md)
  * [Setting Up an App](for-developers/sign-in-with-bitbadges/setting-up-an-app.md)
  * [Connecting a Claim](for-developers/authenticating-with-bitbadges/connecting-a-claim.md)
  * [Authorization URL](for-developers/authenticating-with-bitbadges/authentication-url-+-parameters/README.md)
    * [Configuration](for-developers/authenticating-with-bitbadges/authentication-url-+-parameters/overview.md)
    * [Generating the URL](for-developers/authenticating-with-bitbadges/authentication-url-+-parameters/generating-the-url.md)
  * [Approaches](for-developers/authenticating-with-bitbadges/approaches/README.md)
    * [QR Codes](for-developers/authenticating-with-bitbadges/approaches/manual.md)
    * [Redirect Callback](for-developers/sign-in-with-bitbadges/approaches/redirected-callback.md)
  * [Verification](for-developers/authenticating-with-bitbadges/verification/README.md)
    * [Verification Flow](for-developers/authenticating-with-bitbadges/verification/verification-flow.md)
    * [Access Tokens](for-developers/authenticating-with-bitbadges/verification/api-access-tokens.md)
    * [Offline Verification](for-developers/authenticating-with-bitbadges/verification/offline-verification.md)
    * [Security Considerations](for-developers/authenticating-with-bitbadges/verification/other-security-considerations.md)
  * [Blockin Docs](https://blockin.gitbook.io/blockin)
* [🏗️ BitBadges Claims](overview/claim-builder/README.md)
  * [Overview](for-developers/claim-builder/overview.md)
  * [Concepts](for-developers/claim-builder/concepts/README.md)
    * [Standard vs On-Demand](for-developers/claim-builder/concepts/standard-vs-on-demand.md)
    * [Completion Methods](for-developers/claim-builder/completion-methods.md)
    * [Gating Badge Distribution](for-developers/claim-builder/concepts/gating-badge-distribution.md)
    * [Claim Numbers](for-developers/claim-builder/concepts/claim-numbers.md)
    * [Success Logic](for-developers/claim-builder/success-logic.md)
    * [Claim Links (URLs)](for-developers/claim-builder/claim-links.md)
    * [Signed In vs Select Address](for-developers/claim-builder/concepts/signed-in-vs-select-address.md)
    * [Universal Approach - Claim Codes](for-developers/claim-builder/concepts/universal-approach-claim-codes.md)
    * [Identify By Socials / Emails?](for-developers/claim-builder/concepts/identify-by-socials-emails.md)
    * [Payment Checking](for-developers/claim-builder/concepts/monetizing-apps-badges.md)
    * [Receiving Attestations](for-developers/claim-builder/concepts/receiving-attestations.md)
  * [Checking Custom Criteria](for-developers/claim-builder/checking-custom-criteria.md)
  * [Implementing Custom Utility](for-developers/claim-builder/implementing-custom-utility.md)
  * [BitBadges API & Claims](for-developers/claim-builder/bitbadges-api-claims/README.md)
    * [Verifying Claim Attempts w/ the API](for-developers/claim-builder/bitbadges-api-claims/verifying-claim-attempts-w-the-api.md)
    * [Fetching Claims](for-developers/claim-builder/bitbadges-api-claims/fetching-claims.md)
    * [Auto-Complete Claims w/ BitBadges API](for-developers/claim-builder/bitbadges-api-claims/auto-complete-claims-w-bitbadges-api.md)
  * [Dynamic Stores](for-developers/claim-builder/dynamic-stores/README.md)
    * [Overview](for-developers/claim-builder/dynamic-stores/overview.md)
    * [Adding Data](for-developers/claim-builder/dynamic-stores/adding-data.md)
  * [Custom Plugins / Webhooks](for-developers/claim-builder/plugins/README.md)
    * [Overview](for-developers/claim-builder/plugins/overview.md)
    * [Pre-Built Webhook Plugins](for-developers/claim-builder/plugins/creating-a-custom-plugin/alternatives.md)
    * [Creating a Custom Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/README.md)
      * [Implement Your Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/README.md)
        * [Getting Started](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/getting-started.md)
        * [Hook Types and Simulations](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/hook-types-and-simulations.md)
        * [Design Considerations](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/design-considerations.md)
        * [Parameters](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/parameters.md)
        * [Custom Inputs](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/user-inputs.md)
        * [API Handler](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/api-handler.md)
      * [Managing Your Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/managing-your-plugin.md)
      * [Testing Your Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/testing-your-plugin.md)
    * [Created Plugins](for-developers/claim-builder/plugins/bitbadges-created-plugins/README.md)
      * [Plugins Directory](https://bitbadges.io/plugin-directory)
      * [Number of Uses](for-developers/claim-builder/plugins/bitbadges-created-plugins/number-of-uses.md)
      * [Signed in to BitBadges](for-developers/claim-builder/plugins/bitbadges-created-plugins/signed-in-to-bitbadges.md)
      * [Socials / Email Plugins](for-developers/claim-builder/plugins/bitbadges-created-plugins/authentication-based-plugins.md)
      * [Codes](for-developers/claim-builder/plugins/bitbadges-created-plugins/codes.md)
      * [Password](for-developers/claim-builder/plugins/bitbadges-created-plugins/password.md)
      * [Transfer Times](for-developers/claim-builder/plugins/bitbadges-created-plugins/transfer-times.md)
      * [Whitelist](for-developers/claim-builder/plugins/bitbadges-created-plugins/whitelist.md)
      * [Halt](for-developers/claim-builder/plugins/bitbadges-created-plugins/halt.md)
      * [IP Restrictions](for-developers/claim-builder/plugins/bitbadges-created-plugins/ip-restrictions.md)
      * [Geolocation](for-developers/claim-builder/plugins/bitbadges-created-plugins/geolocation.md)
      * [Discord Server](for-developers/claim-builder/plugins/bitbadges-created-plugins/discord-server.md)
      * [Twitch Follow / Subscription](for-developers/claim-builder/plugins/bitbadges-created-plugins/twitch-follow-subscription.md)
      * [GitHub Contributions](for-developers/claim-builder/plugins/bitbadges-created-plugins/github-contributions.md)
      * [Min $BADGE](for-developers/claim-builder/plugins/bitbadges-created-plugins/min-usdbadge.md)
      * [Ownership Requirements](for-developers/claim-builder/plugins/bitbadges-created-plugins/ownership-requirements.md)
    * [Configuration Tools](for-developers/claim-builder/plugins/configuration-tools.md)
  * [Integrate with Zapier](for-developers/claim-builder/auto-completing-claims/automate-w-zapier/README.md)
    * [Overview](for-developers/claim-builder/auto-completing-claims/automate-w-zapier/overview.md)
    * [Dynamic Store Zaps](for-developers/claim-builder/automate-w-zapier/dynamic-store-zaps.md)
    * [Automatic Claim Tutorial](for-developers/claim-builder/auto-completing-claims/automate-w-zapier/automatic-claim-tutorial.md)
    * [Post-Success Zaps](for-developers/claim-builder/automate-w-zapier/post-success-zaps.md)
    * [Automate Any Part of the Process](for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/README.md)
      * [Google Forms](for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/google-forms.md)
  * [Integrate with Pipedream](for-developers/claim-builder/integrate-with-pipedream/README.md)
    * [Overview](for-developers/claim-builder/integrate-with-pipedream/overview.md)
    * [Build Custom Plugins](for-developers/claim-builder/integrate-with-pipedream/build-custom-plugins.md)
    * [Workflow Actions](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/README.md)
      * [Complete Claim](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/complete-claim.md)
      * [Get Claim Attempt Status](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-attempt-status.md)
      * [Get Claim Code by Idx](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-code-by-idx.md)
      * [Add User to Dynamic Store](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/add-user-to-dynamic-store.md)
    * [Workflow Triggers](for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/README.md)
      * [Poll Claim Attempts](for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/poll-claim-attempts.md)
    * [End to End Example](for-developers/claim-builder/integrate-with-pipedream/end-to-end-example.md)
  * [Tutorials](for-developers/claim-builder/other-tutorials/README.md)
    * [In-Site Guides](for-developers/claim-builder/other-tutorials/in-site-guides.md)
    * [Get Integration User IDs](for-developers/claim-builder/other-tutorials/get-integration-user-ids/README.md)
      * [Get Discord User ID](for-developers/claim-builder/other-tutorials/get-integration-user-ids/get-discord-user-id.md)
      * [Get Discord Server ID](for-developers/claim-builder/other-tutorials/get-integration-user-ids/discord.md)
      * [X / Twitch / GitHub IDs](for-developers/claim-builder/other-tutorials/get-integration-user-ids/x-twitch-github-ids.md)
    * [Add Telegram Bot to Channel](for-developers/claim-builder/other-tutorials/add-telegram-bot-to-channel.md)
* [⚒️ BitBadges JS / SDK](for-developers/bitbadges-sdk/README.md)
  * [Overview](for-developers/bitbadges-sdk/overview.md)
  * [SDK Types](for-developers/bitbadges-sdk/sdk-types.md)
  * [Common Snippets](for-developers/bitbadges-sdk/common-snippets/README.md)
    * [Address Conversions](for-developers/bitbadges-sdk/common-snippets/address-conversions.md)
    * [NumberType Conversions](for-developers/bitbadges-sdk/common-snippets/numbertype-conversions.md)
    * [Uint Ranges](for-developers/bitbadges-sdk/common-snippets/uint-ranges.md)
    * [Balances](for-developers/bitbadges-sdk/common-snippets/balances.md)
    * [Transfers](for-developers/bitbadges-sdk/common-snippets/transfers-w-increments.md)
    * [Address Lists](for-developers/bitbadges-sdk/common-snippets/address-lists.md)
    * [Badge Metadata](for-developers/bitbadges-sdk/common-snippets/badge-metadata.md)
    * [Approvals / Transferability](for-developers/bitbadges-sdk/common-snippets/get-unhandled-approvals.md)
    * [Off-Chain Balances](for-developers/bitbadges-sdk/common-snippets/off-chain-balances.md)
    * [Timelines](for-developers/bitbadges-sdk/common-snippets/timelines.md)
    * [Aliases](for-developers/bitbadges-sdk/common-snippets/aliases.md)
* [🌟 Badges - Advanced](for-developers/badges-advanced/README.md)
  * [Overview](for-developers/badges-advanced/overview.md)
  * [Balances / Transfers](for-developers/badges-advanced/balances-transfers/README.md)
    * [📊 Balances](for-developers/badges-advanced/balances-transfers/balances.md)
    * [➕ Valid Badge IDs](for-developers/badges-advanced/balances-transfers/creating-badges.md)
    * [🪙 Balance Types](for-developers/badges-advanced/balances-transfers/balance-types.md)
    * [🤝 Transferability / Approvals](for-developers/badges-advanced/balances-transfers/transferability-approvals.md)
    * [✅ Approval Criteria](for-developers/badges-advanced/balances-transfers/approval-criteria/README.md)
      * [Overview](for-developers/badges-advanced/balances-transfers/approval-criteria/overview.md)
      * [$BADGE Transfers](for-developers/badges-advanced/balances-transfers/approval-criteria/usdbadge-transfers.md)
      * [Override User Level Approvals](for-developers/badges-advanced/balances-transfers/approval-criteria/overrides.md)
      * [Ownership Requirements](for-developers/badges-advanced/balances-transfers/approval-criteria/must-own-badges.md)
      * [Approval Trackers](for-developers/badges-advanced/balances-transfers/approval-criteria/approval-trackers.md)
      * [Tallied Approval Amounts](for-developers/badges-advanced/balances-transfers/approval-criteria/tallied-approval-amounts.md)
      * [Max Number of Transfers](for-developers/badges-advanced/balances-transfers/approval-criteria/max-number-of-transfers.md)
      * [Predetermined Balances](for-developers/badges-advanced/balances-transfers/approval-criteria/predetermined-balances.md)
      * [Requires](for-developers/badges-advanced/balances-transfers/approval-criteria/requires.md)
      * [Merkle Challenges](for-developers/badges-advanced/balances-transfers/approval-criteria/merkle-challenges.md)
      * [ZK Proofs](for-developers/badges-advanced/balances-transfers/approval-criteria/zk-proofs.md)
      * [Extending the Approval (Advanced)](for-developers/badges-advanced/balances-transfers/approval-criteria/linking-trackers-advanced.md)
  * [Self-Hosted Balances](for-developers/badges-advanced/self-hosted-balances/README.md)
    * [Overview](for-developers/badges-advanced/self-hosted-balances/overview.md)
    * [Examples / Tutorials](for-developers/badges-advanced/self-hosted-balances/examples-tutorials/README.md)
      * [Indexed](for-developers/badges-advanced/self-hosted-balances/examples-tutorials/indexed.md)
      * [Non-Indexed](for-developers/badges-advanced/self-hosted-balances/examples-tutorials/non-indexed.md)
  * [Permissions](for-developers/badges-advanced/permissions/README.md)
    * [Overview](for-developers/badges-advanced/permissions/overview.md)
    * [Action Permission](for-developers/badges-advanced/permissions/action-permission.md)
    * [Timed Update Permission](for-developers/badges-advanced/permissions/timed-update-permission.md)
    * [Timed Update With Badge Ids Permission](for-developers/badges-advanced/permissions/timed-update-with-badge-ids-permission.md)
    * [Badge IDs Action Permission](for-developers/badges-advanced/permissions/balances-action-permission.md)
    * [Update Approval Permission](for-developers/badges-advanced/permissions/update-approval-permission.md)
  * [Standards](for-developers/badges-advanced/standards.md)
  * [Archived Collections](for-developers/badges-advanced/archived-collections.md)
  * [Metadata](for-developers/badges-advanced/metadata.md)
  * [Timelines](for-developers/badges-advanced/timelines.md)
  * [Different Time Fields](for-developers/badges-advanced/different-time-fields.md)
  * [List IDs](for-developers/badges-advanced/list-ids.md)
  * [Uint Ranges](for-developers/badges-advanced/uint-ranges.md)
* [⛓️ BitBadges Blockchain](for-developers/bitbadges-blockchain/README.md)
  * [Overview](for-developers/bitbadges-blockchain/overview.md)
  * [Chain Details](for-developers/bitbadges-blockchain/chain-details.md)
  * [REST API Docs - Node](for-developers/bitbadges-blockchain/rest-api-docs-node.md)
  * [Staking / Validators](overview/staking-usdbadge.md)
  * [Run a Node](for-developers/bitbadges-blockchain/run-a-node/README.md)
    * [Overview](for-developers/bitbadges-blockchain/run-a-node/overview.md)
    * [Run a Mainnet Node](for-developers/bitbadges-blockchain/run-a-node/run-a-mainnet-node.md)
    * [Run a Local Dev Node](for-developers/bitbadges-blockchain/run-a-node/run-a-local-dev-node.md)
    * [Cosmovisor](for-developers/bitbadges-blockchain/run-a-node/cosmovisor.md)
  * [Create a Smart Contract](for-developers/bitbadges-blockchain/create-a-wasm-contract.md)
  * [🔃 Create, Generate, and Sign Txs](for-developers/bitbadges-blockchain/create-and-broadcast-txs/README.md)
    * [Transaction Context](for-developers/bitbadges-blockchain/create-and-broadcast-txs/transaction-context.md)
    * [Generate Msg Contents](for-developers/bitbadges-blockchain/create-and-broadcast-txs/generate-msg-contents.md)
    * [Signing - Cosmos](for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-cosmos.md)
    * [Signing - Ethereum](for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-ethereum.md)
    * [Signing - Solana](for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-solana.md)
    * [Signing - Bitcoin](for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-bitcoin.md)
    * [Broadcast to a Node](for-developers/bitbadges-blockchain/create-and-broadcast-txs/broadcast-to-a-node.md)
    * [Sign + Broadcast - bitbadges.io](for-developers/bitbadges-blockchain/create-and-broadcast-txs/sign-+-broadcast-bitbadges.io.md)
  * [📩 Cosmos SDK Msgs](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/README.md)
    * [x/anchor](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-anchor/README.md)
      * [MsgAddCustomData](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-anchor/msgaddcustomdata.md)
    * [x/badges](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/README.md)
      * [MsgCreateCollection](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgcreatecollection.md)
      * [MsgUpdateCollection](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgupdatecollection.md)
      * [MsgDeleteCollection](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgdeletecollection.md)
      * [MsgCreateAddressLists](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgcreateaddresslists.md)
      * [MsgTransferBadges](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgtransferbadges.md)
      * [MsgUpdateUserApprovals](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgupdateuserapprovals.md)
      * [MsgUniversalUpdateCollection](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msguniversalupdatecollection.md)
    * [x/wasmx](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/README.md)
      * [MsgStoreCodeCompat](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msgstorecodecompat.md)
      * [MsgInstantiateContractCompat](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msginstantiatecontractcompat.md)
      * [MsgExecuteContractCompat](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msgexecutecontractcompat.md)
    * [x/maps](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/README.md)
      * [MsgCreateMap](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgcreateprotocol.md)
      * [MsgUpdateMap](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgupdateprotocol.md)
      * [MsgDeleteMap](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgdeleteprotocol.md)
      * [MsgSetValue](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgsetcollectionforprotocol.md)
    * [MsgSend](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/msgsend.md)
    * [Cosmos Native Msgs](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/cosmos-native-msgs.md)
* [🧠 Other Concepts](for-developers/core-concepts/README.md)
  * [Uint Ranges](for-developers/core-concepts/uint-ranges.md)
  * [Accounts (Low-Level)](for-developers/core-concepts/accounts-technical.md)
  * [Address Lists](for-developers/core-concepts/address-lists-lists.md)
  * [Maps / Protocols](for-developers/core-concepts/maps.md)
  * [Attestations - Advanced](for-developers/core-concepts/verifiable-attestations/README.md)
    * [Overview](for-developers/core-concepts/verifiable-attestations/overview.md)
    * [Creating an Attestation](for-developers/core-concepts/verifiable-attestations/creating-a-attestation.md)
    * [Custom Creation Links](for-developers/core-concepts/verifiable-attestations/custom-creation-links.md)
    * [Proofs vs Attestations](for-developers/core-concepts/verifiable-attestations/proofs-vs-attestations.md)
    * [Deriving a Proof](for-developers/core-concepts/verifiable-attestations/deriving-a-proof.md)
    * [Design Considerations](for-developers/core-concepts/verifiable-attestations/design-considerations.md)
    * [Verification / Presentations](for-developers/core-concepts/verifiable-attestations/creating-and-verifying-a-proof.md)
    * [Custom Schemes](for-developers/core-concepts/verifiable-attestations/custom-schemes/README.md)
      * [WITNESS Proofs](for-developers/core-concepts/verifiable-attestations/custom-schemes/witness-proofs.md)


## File: ./for-developers/accounts.md

# 👤 Handling Addresses

This page will give you an overview of BitBadges accounts. It should be enough information for most, but for more low-level interaction, [this page](core-concepts/accounts-technical.md) will give you more in-depth explanations.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Mapping to a Common Address (bitbadgesAddress)**

To enable interoperability between different blockchains, each individual L1 blockchain will have its native addresses mapped to an equivalent Cosmos (aka BitBadges) bech32 address. We use the mapped **bitbadgesAddress** as the universal base address whenever needed.

We try to be as accommodating of native addresses as possible, but there are many places where universal standardization is needed. You will often come across places in development where you need to specify a **bitbadgesAddress.** This is expected to be the mapped address and not the native address (thus, you will need to map first). The typical naming convention we use is **bitbadgesAddress** vs **address.**&#x20;

The mappings should ONLY happen behind the scenes. On the user facing side, you should always display the user's native address.

Ethereum Example:

* Mapped BitBadges Address (Bech32): bb14au322k9munkmx5wrchz9q30juf5wjgz2cfqku
* Address (Native - [EIP55](https://eips.ethereum.org/EIPS/eip-55) Ethereum Hex): 0xAF79152AC5dF276D9A8e1E2E22822f9713474902

Solana Example:

* Address (Native - Base58): 6H2af68Yyg6j7N4XeQKmkZFocYQgv6yYoU3Xk491efa5
* Mapped BitBadges Address (Bech32): bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl

Bitcoin Example

* Address (Native - P2WPKH): bc1q9s7rynm5pwhluhecsmlku8rn5yej5wdgj0gv3e
* Mapped BitBadges Address (Bech32): bb19s7rynm5pwhluhecsmlku8rn5yej5wdg8g75f9

#### Why can I convert Solana address to a BitBadges / ETH / BTC address but not the other way around?

You may notice that you cannot go from a BitBadges / ETH / BTC address directly to a Solana address but you can the other way around. This is because conversion from a Solana address requires a hash, so if you just have the postimage of the hash (an ETH / BitBadges address), you cannot deduce the preimage without prior knowledge of it.

#### **How to convert?**

The mapped addresses can be converted behind the scenes using the converter functions from [BitBadges SDK](bitbadges-sdk/) (address-converter). This can be done with any validly formatted address.

<pre class="language-typescript"><code class="lang-typescript"><strong>import { convertToEthAddress, convertToBitBadgesAddress, mustConvertToBtcAddress } from 'bitbadgesjs-sdk';
</strong>
<strong>const bitbadgesAddress = convertToBitBadgesAddress(btcAddress);
</strong>const ethAddress = convertToEthAddress(bitbadgesAddress);
const bitbadgesAddressFromSolana = convertToBitBadgesAddress(solAddress);
const btcAddress = mustConvertToBtcAddress(address);

// Note there is no convertToSolanaAddress due to how the addresses work. See above
</code></pre>

**What is signature compatibility?**

To enable interoperability between different blockchains, BitBadges is signature compatible with all of the supported chains (Bitcoin, Ethereum, Solana, and Cosmos).

Signature compatibility means that we can verify transaction signatures from any wallet of any supported ecosystem. BitBadges is its own blockchain and does not pull any data from any other blockchain. Everything is confined to the BitBadges blockchain.

#### **How do I query details for an address?**

1. You can use the [BitBadges API](bitbadges-api/api.md) to get information about an address (recommended option). This is the recommended options because we have indexed all the data already for you.
2. You an also query a BitBadges blockchain node directly, either through the CLI or [REST API](https://docs.cosmos.network/v0.46/run-node/interact-node.html)


## File: ./for-developers/authenticating-with-bitbadges/README.md

# 🖱️ Sign In with BitBadges



## File: ./for-developers/authenticating-with-bitbadges/already-have-web3-auth.md

# Already Have Web3 Auth?

If you already have Web3 authentication, then there is no need for the full Sign In with BitBadges step. Simply attach a claim to your authentication process!

```typescript
// Pre-req: Create claim in BitBadges site
// 1. Authenticate your user (using your existing setup)
// 2. Verify claim success
const res = await BitBadgesApi.checkClaimSuccess(claimId, address);
```

Now, your service is gated by any criteria imaginable!


## File: ./for-developers/authenticating-with-bitbadges/alternative-p2p-verification.md

# Alternative - P2P Verification

Before diving in, we want to showcase a zero-setup alternative (P2P Verification) that is natively in the site already. See the Create tab to test it out. Peer Verification lets a prover device (which is signed in to a BitBadges account) prove their signed in address to a verifier device (no login required) and potentially ownership of badges / attestations all directly via the site. Once you have the address, you (the verifier) can also add custom checks on your end too.

Pros: No setup required. Accessible on the go. All directly in-site.

Cons: No backend server which means no session handling, custom functionality, automatic handling, etc. Requires two way connection. Both devices must be online and prover must be signed in.&#x20;



<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/authenticating-with-bitbadges/approaches/README.md

# Approaches



## File: ./for-developers/authenticating-with-bitbadges/approaches/manual.md

# QR Codes

If you do not specify a redirect URL, we will generate a QR code from the authorization code and prompt the user to store it in their BitBadges account under the "Authentication Codes" tab or export it to a more portable format like email, Apple Wallet, etc. The QR code flow is used for delayed authentication scenarios, most often in-person events. This can be exported to any portable format you wish so that users do not have to have wallets handy at authentication time. The text value of the code is the 32-byte code that you will exchange in the verification process.

**Generating URL**

The most important part of this step is to not include a **redirectUri** in the parameters. This lets us know that you want to store the details in the users' account as a QR, rather than being transmitted to the redirect URI. See the [Generating the URL](../authentication-url-+-parameters/generating-the-url.md) section for more details.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) ( (9).png" alt="" width="539"><figcaption></figcaption></figure>


## File: ./for-developers/authenticating-with-bitbadges/authentication-url-+-parameters/README.md

# Authorization URL



## File: ./for-developers/authenticating-with-bitbadges/authentication-url-+-parameters/generating-the-url.md

# Generating the URL

The base URL is [https://bitbadges.io/siwbb/authorize](https://bitbadges.io/siwbb/authorize), with parameters appended to it.

For instance:

```vbnet
https://bitbadges.io/siwbb/authorize?client_id=...
```

This URL structure adheres to the following interface:

* **Base URL**: [https://bitbadges.io/siwbb/authorize](https://bitbadges.io/siwbb/authorize)
* **Parameters**: Custom parameters specific to your implementation.

You can use [https://bitbadges.io/auth/linkgen](https://bitbadges.io/auth/linkgen) or the code below to generate the URL or click Create SIWBB URL directly from your app in the developer portal (recommended).

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

**Snippets**

<pre class="language-typescript"><code class="lang-typescript"><strong>import { generateBitBadgesAuthUrl, CodeGenQueryParams } from 'bitbadgesjs-sdk';
</strong>
const popupParams: CodeGenQueryParams {
    ...
} // See Authentication URL page

<strong>const authUrl = generateBitBadgesAuthUrl(popupParams);
</strong></code></pre>

```ts
export const generateBitBadgesAuthUrl = (params: CodeGenQueryParams) => {
    let url = `https://bitbadges.io/siwbb/authorize?`;
    for (const [key, value] of Object.entries(params)) {
        if (value) {
            if (typeof value === 'object') {
                const valueString = JSON.stringify(value);
                const encodedValue = encodeURIComponent(valueString);
                url = url.concat(`${key}=${encodedValue}&`);
            } else {
                url = url.concat(`${key}=${value}&`);
            }
        }
    }
    return url;
};
```


## File: ./for-developers/authenticating-with-bitbadges/authentication-url-+-parameters/overview.md

# Configuration

BitBadges authentication uses an OAuth URL with custom parameters: `https://bitbadges.io/siwbb/authorize?client_id=...`.

Users will visit this URL to authenticate and receive an authorization code. This code will be passed behind the scenes for digital flows via the redirect or it will be the actual QR code for in-person / delayed flows.

By default, Sign In with BitBadges will handle multi-chain authentication for the user (in other words, checking address ownership). You can additionally:

-  Specify the `scope` to request additional BitBadges API permissions for the user (e.g. 'completeClaims,readAddressLists')
-  Specify a `claimId` to display a specific claim to the user (for display purposes, you will need to verify the claim successes on your end). Claims open up any criteria like badge ownership checks, payments, anything
-  You can also `expectAttestations` to have the user provide you with attestations from their account that you want to receive (to be verified on your end)

## Parameter Interface

```typescript
interface CodeGenQueryParams {
    client_id: string; // Required: Your app's client ID
    redirect_uri?: string; // Required for instant auth. Not needed for QR code auth.
    state?: string; // Optional: Additional data passed to redirect
    scope?: string; // Optional: Comma-separated BitBadges API permission scopes (e.g. 'completeClaims,readAddressLists')

    // Claim UI Options (optional)
    claimId?: string; // ID of required claim
    hideIfAlreadyClaimed?: boolean; // Hide if already claimed
    expectVerifySuccess?: boolean;

    // Expect attestation presentations
    expectAttestations?: boolean;
}
```

## Key Features

### 1. App Configuration

-   Create OAuth apps at [bitbadges.io/developer](https://bitbadges.io/developer)
-   `client_id` is mandatory (obtained from app registration)
-   `redirect_uri` required for instant auth, optional for delayed auth
-   If `redirect_uri` is blank, QR code is generated and stored in user's account
-   See OAuth tutorials for more details

### 2. Scopes

-   This is only needed for authorized BitBadges API access. By default, you will verify address ownership with no scopes.
-   Format: `scope: 'completeClaims,readAddressLists'`
-   View all available scopes at [bitbadges.io/auth/linkgen](https://bitbadges.io/auth/linkgen)

### 3. Claims

-   Specify required claim to be satisfied with `claimId`
-   Create the claim in the developer portal. See claim docs for more details.
-   Claims are not a part of the core authentication process. You need to verify them separately server-side to ensure the user has met the criteria.

### 4. Attestations

-   Receive attestations from the user directly via the sign-in process. This is a more direct alternative rather than needing to set up a custom plugin in a claim.
-   Note, like claims, these are not a part of the core authentication process. You need to verify them separately server-side to ensure the user has met the criteria.&#x20;
-   While we do our best to maintain well-formedness, treat BitBadges as the middleman. Verify all on your end.


## File: ./for-developers/authenticating-with-bitbadges/connecting-a-claim.md

# Connecting a Claim

Sign In with BitBadges becomes super powerful when you connect a BitBadges claim because you can natively check any criteria and authenticate in one flow:

* Check badge ownership
* Check social sign-ins from any supported social
* Receive privately held attestations securely
* Connect to 7000+ app integration plugins
* And much more all within the same flow.

Treat claims as not a part of the core SIWBB process. Do it all in one flow but verify it separately. 1) Authenticate the user 2) Verify the authenticated address meets claim criteria.

The claim verification is typically during the exchange flow handling.

1. Exchange and verify SIWBB request
2. Post-authentication, verify claim

{% content-ref url="../../overview/claim-builder/" %}
[claim-builder](../../overview/claim-builder/)
{% endcontent-ref %}

{% content-ref url="../claim-builder/bitbadges-api-claims/verifying-claim-attempts-w-the-api.md" %}
[verifying-claim-attempts-w-the-api.md](../claim-builder/bitbadges-api-claims/verifying-claim-attempts-w-the-api.md)
{% endcontent-ref %}


## File: ./for-developers/authenticating-with-bitbadges/framework-templates/README.md

# Integrations



## File: ./for-developers/authenticating-with-bitbadges/framework-templates/auth0.md

# Auth0

### **Social Connection Integration**

When adding a Social Connection, you will see BitBadges as a preconfigured option. This has everything setup for you. You will simply need to specify your client ID and client secret. You will also have to configure your redirect URI to match your Auth0 application's domain. This typically ends with /callback (for example, [https://dev-pgv803tz4ztg35oi.us.auth0.com/login/callback](https://dev-pgv803tz4ztg35oi.us.auth0.com/login/callback)).

### [https://marketplace.auth0.com/integrations/bitbadges](https://marketplace.auth0.com/integrations/bitbadges)

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (126).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Custom

You can also customize the connection further by creating a custom connection. This allows you to add parameters beyond the standard flow. You callback will be the same as above.

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Authorization URL:** https://bitbadges.io/siwbb/authorize

**Token URL:** https://api.bitbadges.io/api/v0/siwbb/token

**Scopes:** None (All you typically need is the user crypto address) - Although, you can add as needed

**Fields:** Get your API key, client ID, and client secret at https://bitbadgesio/developer.

**Fetch Profile Script**:

```javascript
function fetchUserProfile(accessToken, ctx, cb) {
    request.post(
        {
            url: 'https://api.bitbadges.io/api/v0/auth/status',
            headers: {
                'Content-Type': 'application/json',
                // TODO: Replace
                'x-api-key': 'ENTER_API_KEY_HERE',
                Authorization: 'Bearer ' + accessToken,
            },
        },
        (err, resp, body) => {
            if (err) {
                return cb(err);
            }
            if (resp.statusCode !== 200) {
                return cb(new Error(body));
            }
            let bodyParsed;
            try {
                bodyParsed = JSON.parse(body);
            } catch (jsonError) {
                return cb(
                    new Error('Failed JSON parsing for user profile response.')
                );
            }

            const account = bodyParsed;

            const profile = {
                address: account.address,
                chain: account.chain,
                id: account.bitbadgesAddress,
                name: account.address,
            };
            return cb(null, profile);
        }
    );
}
```

**Custom Headers:**&#x20;

Make sure you enter your API key in the custom headers an d replace it in the fetch script.

```
{
    "x-api-key": "YOUR_API_KEY"
}
```


## File: ./for-developers/authenticating-with-bitbadges/framework-templates/discourse.md

# Discourse

For Discourse, we do not have a dedicated plugin, but SIWBB is OAuth2 compatible and integrated with other providers. So, you can reuse existing plugins as needed.

**Auth0 Plugin**

Set up SIWBB with Auth0 here:

{% content-ref url="auth0.md" %}
[auth0.md](auth0.md)
{% endcontent-ref %}

Then, integrate with Discourse here:

{% embed url="https://meta.discourse.org/t/configure-sign-up-and-log-in-with-auth0-using-the-oauth2-basic-plugin/64633" %}

**OAuth2 Plugin**

{% embed url="https://meta.discourse.org/t/discourse-oauth2-basic/33879" %}


## File: ./for-developers/authenticating-with-bitbadges/framework-templates/others.md

# Others

Many of your favorite frameworks already support Auth0, and you can simply use Sign In with BitBadges through that.

* Auth.js (Next Auth) - [https://authjs.dev/getting-started/providers/auth0](https://authjs.dev/getting-started/providers/auth0)
* Amazon Cognito - [https://auth0.com/docs/customize/integrations/aws/amazon-cognito#configure-amazon-web-services](https://auth0.com/docs/customize/integrations/aws/amazon-cognito#configure-amazon-web-services)
* Supabase - [https://supabase.com/partners/integrations/auth0](https://supabase.com/partners/integrations/auth0)

If you have any suggestions for unsupported integrations as well, let us know!


## File: ./for-developers/authenticating-with-bitbadges/framework-templates/passportjs.md

# PassportJS

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadges-passportjs-example/blob/main/index.ts" %}


## File: ./for-developers/authenticating-with-bitbadges/framework-templates/supabase.md

# Supabase

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadges-supabase-demo" %}

This repository is a basic example for getting started with Supabase and Sign in with BitBadges. It is meant to be a starting point and is not production ready.

This example:

* Uses the Next.js x Supabase template
* Uses traditional Supabase authentication and once signed in, you can additionally Sign In with BitBadges. This effectively creates a username <-> address mapping that you can use.

<figure><img src="../../../.gitbook/assets/image (226).png" alt=""><figcaption></figcaption></figure>

Anything else is left as an exercise for you.

* Gating the entire site rather than using traditional authentication
* Gating specific pages / implementing your utility
* Linking claims

Note: Supabase is flexible. You may choose to implement it via Express, Auth0, or another way as well. This is just a reference to help you get started.

**Setup**

1. Setup Supabase as explained via their documentation
2. Add your BitBadges API key, client ID, and client secret to your .env
3. Execute the SQL in supabase/migrations folder to setup the tables. This can be done via the SQL Editor in the dashboard.





## File: ./for-developers/authenticating-with-bitbadges/framework-templates/wordpress.md

# WordPress

Gate your WordPress site with BitBadges! Authenticate with SIgn In with BitBadges and check any claim criteria, allowing you to create multi-chain websites gated for anything.

Directory Link (Under Review): [https://wordpress.org/plugins/search/sign-in-with-bitbadges/](https://wordpress.org/plugins/search/sign-in-with-bitbadges/)

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadges-wp-plugin" %}

<figure><img src="../../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

This plugin allows users to gate their WordPress site with BitBadges – claims, payments, NFT badges, and more!

\== Description ==

This plugin allows users to gate their site with BitBadges - claims, payments, NFT badges, and more!

**Important Note:** This plugin ONLY handles authentication with BitBadges - it does not restrict access to your site by itself. For restricting access, we recommend using this plugin in conjunction with:

* [Force Login](https://wordpress.org/plugins/wp-force-login/) - Forces users to log in to view your site
* [Restrict Content](https://wordpress.org/plugins/restrict-content/) - Restrict content to logged-in users
* [Members](https://wordpress.org/plugins/members/) - Advanced user roles and permissions
* Or other plugins that restrict access to your site

\== Installation ==

1. Download the plugin files and upload them to your `/wp-content/plugins/` directory
2. Activate the plugin through the 'Plugins' menu in WordPress
3. Go to Settings > BitBadges SIWBB to configure the plugin

\== Configuration ==

1. Create a new application (OAuth App) in the [BitBadges Developer Portal](https://bitbadges.io/developer)
2. Set your redirect URI to: `https://your-wordpress-site.com/wp-login.php?action=bitbadges-callback`
3. Copy your Client ID and Client Secret
4. Go to your WordPress admin panel > Settings > BitBadges SIWBB
5. Enter your Client ID and Client Secret
6. (Optional) Configure a claim ID to gate access and other additional settings
7. Save the settings

\== Features ==

* Adds a "Sign in with BitBadges" button to the WordPress login form
* Creates WordPress users automatically when they first sign in with BitBadges
* Secure OAuth 2.0 implementation with state verification
* Simple admin interface for configuration
* Optional exclusive BitBadges authentication mode (disable normal WordPress login)
* Claim-gated access support
* Emergency admin access URL for exclusive mode
* Customizable claim visibility on authorization page

\== Security ==

* CSRF protection using state parameter
* Secure storage of client credentials
* WordPress nonce verification
* Input sanitization
* Proper error handling
* Secure admin access fallback
* Claim verification

\== User Experience ==

* Clean, centered login button design
* Shortened wallet addresses for better readability
* Clear separation between traditional and BitBadges login
* Visible claim requirements before authentication
* Seamless first-time user setup

\== Requirements ==

* WordPress 5.0 or higher
* PHP 7.0 or higher
* HTTPS enabled on your site (required for secure OAuth)

\== Support ==

For support or feature requests, please visit the [BitBadges website](https://bitbadges.io) or create an issue in the GitHub repository.

\== License ==

This plugin is licensed under the GPL v2 or later.\
License URI: https://www.gnu.org/licenses/gpl-2.0.html

\== Changelog ==

\= 1.0.0 =

* Initial release with basic OAuth functionality
* Added exclusive authentication mode
* Added claim-gating support
* Added emergency admin access
* Improved user display names
* Enhanced UI/UX for login button
* Added claim visibility options


## File: ./for-developers/authenticating-with-bitbadges/verification/README.md

# Verification



## File: ./for-developers/authenticating-with-bitbadges/verification/api-access-tokens.md

# Access Tokens

With access tokens, you can start sending requests to authenticated endpoints with your access token specified in the Authorization header as "Bearer YOUR\_ACCESS\_TOKEN".

If you did not request any specific scopes, you will still have access to the health check endpoint to ensure the user has not revoked authorization.

<figure><img src="../../../.gitbook/assets/image (96).png" alt=""><figcaption></figcaption></figure>

If you are using the SDK, you can instead do this which handles the header setting:

```typescript
BitBadgesApi.setAccessToken(token);
BitBadgesApi.unsetAccessToken();
```

Access tokens by default expire in 1 day, and refresh tokens expire in 60 days. Note that they may also become invalid as the user revokes access to them as well.

**Health Checks**

To check that you are signed in, use the following route. This will return signedIn: false if not authenticated, access token is expired, or authorization has been revoked.

Note: This can even be used when no scopes are requested.

```typescript
// POST /api/v0/auth/status {}
const res = await BitBadgesApi.checkIfSignedIn({})
// 200 { signedIn: boolean, scopes: [...], ... }
console.log(res.signedIn)
```

**Refreshing**

```typescript
const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({
    refresh_token
    grant_type: 'refresh_token',
    client_secret: '...',
    client_id: '...',
    redirect_uri: '...' //only needed if redirected
});

const { access_token, access_token_expires_at, refresh_token, refresh_token_expires_at } = res;
```

Using the refresh token obtained previously, you can exchange for a new access token and refresh token (with expiration reset) on a rolling basis. This step can be repeated indefinitely.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Revoking Access**

Once you are done with the access token, you should revoke your access to it via the following. This can also be done by the user via the Connections -> Authorizations tab in-site. This can be done by either the user or the app.

```typescript
// POST https://api.bitbadges.io/api/v0/siwbb/token/revoke
await BitBadgesApi.revokeOauthAuthorization({ token });
```


## File: ./for-developers/authenticating-with-bitbadges/verification/offline-verification.md

# Offline Verification

If you need to pre-fetch all (code, request) pairs before verification time (e.g. you are verifying in an offline setting), you can fetch all codes created via BitBadges for your client ID with the API.&#x20; This just returns the authorization codes, and you still need to exchange them (which is a one-time only process).

```typescript
const res = await BitBadgesApi.getSIWBBRequestsForDeveloperApp({
    clientId,
    bookmark: '',
});
console.log(res);
```

```typescript
await BitBadgesApi.verifySIWBBRequest({ ... });
await BitBadgesApi.exchangeSIWBBAuthorizationCode({ code: blockinChallenge._docId, options: { ... }});
```


## File: ./for-developers/authenticating-with-bitbadges/verification/other-security-considerations.md

# Security Considerations

This flow is OAuth 2.0 compatible, so we refer you to the official spec and other OAuth 2.0 resources for security considerations with the protocol itself (replay attacks, man in the middle, etc). 

You may also be prone to flash criteria checks, such as flash ownership checks. For example, Bob signs in, transfers a badge to Alice, and Alice signs in with the same badge. Both are authenticated with the same badge which may not be desired. This can apply to any criteria not just badges. Ensure your claim criteria, attestations, etc protect against such cases.

## File: ./for-developers/authenticating-with-bitbadges/verification/verification-flow.md

# Verification Flow

From the prior pages, you should now have the authorization **code** (32 byte hex) for the user. This is either the QR code value for in-person or the redirect code you receive in your handler for the standard digital flow.

```typescript
// 32 byte hex string
async function myHandler(req: NextApiRequest, res: NextApiResponse) {
    const code = req.query.code as string;
}
```

You can now exchange the code and valid app configuration details. Be sure to keep the client secret secret. The response will contain all authentication details, including a **verificationResponse**.

**Exchanging the Code**

The next step is to exchange the code for authentication details. This is done via the exchange endpoint. This follows typical OAuth2 flow. You can also specify options to check the issued at time of code generation. Typically for in-person, you may need to disable the issued at time check of 10 minutes.

[API Reference](https://bitbadges.stoplight.io/docs/bitbadges) -> Exchange SIWBB Code

```typescript
// 32 byte hex string
async function myHandler(req: NextApiRequest, res: NextApiResponse) {
    const code = req.query.code as string;

    const options = {
        issuedAtTimeWindowMs: 1000 * 60 * 10, // 10 minutes (set to 0 to disable)
    };

    // POST https://api.bitbadges.io/api/v0/siwbb/token
    const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({
        code,
        options,
        grant_type: 'authorization_code',
        client_secret: '...',
        client_id: '...',
        redirect_uri: '...', //only needed for digital immediate flow
    });

    const { address, chain, verificationResponse } = res;
    if (!verificationResponse.success) {
        console.log(verificationResponse.errorMessage);
        throw new Error('Not authenticated');
    }
    
    //Verify claims or anything else you need to do here
}
```

**Access Tokens / Session Management**

We return access tokens and refresh tokens for you to perform session management. The expiration times can help you implement sessions for your users, and you can health check the user hasn't revoked through the API. Code exchanges can only be performed once per unique code which is checked on our end.

```typescript
// 32 byte hex string
async function myHandler(req: NextApiRequest, res: NextApiResponse) {
    const code = req.query.code as string;

    // POST https://api.bitbadges.io/api/v0/siwbb/token
    const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({ ... });

    const { access_token, access_token_expires_at, refresh_token, refresh_token_expires_at } = res;
    // TODO: You can use these tokens for session management and authorized API access
}
```

Note this is not the only way of implementing sessions. You may implement custom approaches on your own like checking IDs, stamping hands, using claim numbers, etc.

{% content-ref url="api-access-tokens.md" %}
[api-access-tokens.md](api-access-tokens.md)
{% endcontent-ref %}

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Verifying Other "Attached" Criteria**

For any other criteria like claim verification or attestations, you must check this additionally server-side. Do not trust that if you added `claimId` in the URL params that it is automatically verified.

{% content-ref url="../../claim-builder/bitbadges-api-claims/verifying-claim-attempts-w-the-api.md" %}
[verifying-claim-attempts-w-the-api.md](../../claim-builder/bitbadges-api-claims/verifying-claim-attempts-w-the-api.md)
{% endcontent-ref %}

As for attestations, we refer you to the following documentation. Treat BitBadges as the middleman, and verify everything server-side on your end. You will receive an attestationPresentations array directly from the response if the query URL requested attestations.

```typescript
const { ..., attestationPresentations } = res;
```

{% content-ref url="../../claim-builder/concepts/receiving-attestations.md" %}
[receiving-attestations.md](../../claim-builder/concepts/receiving-attestations.md)
{% endcontent-ref %}

```typescript
async function myHandler(req: NextApiRequest, res: NextApiResponse) {
    const code = req.query.code as string;

    // Exchange code from above

    const { address, chain, verificationResponse } = res;

    // ...

    // After verifying the address, you can now check other criteria with knowledge that the user is the owner of the address
    // const claimAttemptsByAddress = await BitBadgesApi.getClaimAttempts(claimId, { address });
    // const ownershipRequirementsRes = await BitBadgesApi.verifyOwnershipRequirements(...);
    // const addressListsRes = await BitBadgesApi.getAddressLists(...);
}
```

**Putting It Together**

```typescript
import { BitBadgesApi } from 'bitbadgesjs-sdk';

// 32 byte hex string
async function myHandler(req: NextApiRequest, res: NextApiResponse) {
    const code = req.query.code as string;

    const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({
        code,
        options,
        grant_type: 'authorization_code',
        client_secret: '...',
        client_id: '...',
        redirect_uri: '...', //only needed if immediate
    });

    const { address, chain, verificationResponse } = res;
    if (!verificationResponse.success) {
        console.log(verificationResponse.errorMessage);
        throw new Error('Not authenticated');
    }

    const {
        access_token,
        access_token_expires_at,
        refresh_token,
        refresh_token_expires_at,
    } = res;
    // TODO: You can use these tokens for session management and authorized API access

    // After verifying the address, you can now check other criteria with knowledge that the user is the owner of the address
    // const claimsRes = await BitBadgesApi.getClaims({ ... });

    //TODO: Handle other checks and logic here
    // - Prevent replay attacks by checking timestamps or nonces
    // - Need to cache anything for later use?
    // - If verifying with assets, is the asset transferable and prone to flash ownership attacks (e.g. one use per asset, etc)?
    // - Other criteria needed for signing in? (e.g. whitelist / blacklist of addresses signing in)
    // - Verify claim criteria

    //TODO: If receiving attestations, are the contents valid?
    //For example:
    // - Verify the contents of the attestation messages are correct
    // - Verify the creator is who you expect
    // - Verify the metadata is correct
    // - Verify the on-chain anchors / update history are correct
    // - Verify the update history is correct
}
```

## **IMPORTANT: What is verified natively vs not?**

Does check :white\_check\_mark:

* Proof of address ownership via their authenticated BitBadges account
* Anything specified in the verify challenge options
* Issued at time of code generation is not too long ago if **options.isssuedAtTimeWindowMs** is specified. Defaults to 10 minutes.
* One exchange per authorization code -> access / refresh token

Does not check natively :x:

* Additional app-specific criteria needed for signing in (claims, ownership requirements, attestations)
* Does not natively prevent against flash ownership attacks, replay attacks, or man-in-the-middle attacks other than what OAuth2 protects against


## File: ./for-developers/badges-advanced/README.md

# 🌟 Badges - Advanced



## File: ./for-developers/badges-advanced/archived-collections.md

# Archived Collections

Collections can be archived using the **isArchivedTimeline**. Before any transaction, we check if the collection is archived at the current time. If it is, all transactions will fail. The next successful transaction that can be processed must be one that unarchives the collection. The updatability of the **isArchivedTimeline** is controlled by the **canArchiveCollection** permission.

Use Cases: This can potentially be used for a few reasons

* Security: Pause all transactions if you believe the collection's security is at risk
* Sunsetting: Sunset the collection to be idle but still verifiable and public on-chain.

Note this doesn't delete the collection, just makes it read-only.


## File: ./for-developers/badges-advanced/balances-transfers/README.md

# Balances / Transfers



## File: ./for-developers/badges-advanced/balances-transfers/approval-criteria/README.md

# ✅ Approval Criteria



## File: ./for-developers/badges-advanced/balances-transfers/approval-criteria/approval-trackers.md

# Approval Trackers

```typescript
export interface iApprovalAmounts<T extends NumberType> {
  ...
  
  /** The ID of the approval tracker. This is the key used to track tallies. */
  amountTrackerId: string;
}
```

```typescript
export interface iMaxNumTransfers<T extends NumberType> {
  ...
  
  /** The ID of the approval tracker. This is the key used to track tallies. */
  amountTrackerId: string;
}
```

## Approval Trackers

Approval or amount trackers track how many badges have been transferred and how many transfers have occurred. This is done via an incrementing tally system with a threshold.&#x20;

Take the following approval tracker

1. You are approved for x10 of badge IDs 1-10. For simplicity, lets say the tracker ID is "xyz".
2. You transfer x5 of badge IDs 1-10 -> "xyz" tally goes from x0/10 -> x5/10
3. You transfer another x5 -> "xyz" tally goes to x10/10
4. You transfer another x1 -> exceed threshold so transfer fails and will also fail for all subsequent approvals that match to "xyz".
5. However, if subsequent transfers match to tracker "abc", the tally starts from zero again because it is a different tracker w/o any history.

### **How are approval trackers identified?**

Above, we used "xyz" for simplicity, but the identifier of each approval tracker actually consists of **amountTrackerId** along with other identifying details.

Note that if multiple approvals specify the same **amountTrackerId,** the SAME tracker will be incremented when DIFFERENT approvals are used. This is because the tracker identifier will be the same and thus increment the same tracker. However, all tracker IDs specify the **approvalId** which must be unique. Thus, all trackers are only ever scoped to a single aproval.

```
ID: collectionId-approvalLevel-approverAddress-approvalId-amountTrackerId-trackerType-approvedAddress
```

```typescript
export interface ApprovalTrackerIdDetails<T extends NumberType> {
  collectionId: T
  approvalLevel: "collection" | "incoming" | "outgoing" | ""
  approvalId: string
  approverAddress: string
  amountTrackerId: string
  trackerType: "overall" | "to" | "from" | "initiatedBy" | ""
  approvedAddress: string
}
```

The **trackerType** corresponds to what type of tracker it is. For example, should we increment every time this approval is used? per unique recipient? sender? initiator?

If "overall", this is applicable to any transfer and will increment everytime the approval is used. This creates a single universal tally. **approvedAddress** will be empty.&#x20;

If "to", "from", or "initiatedBy", the **approvedAddress** is the sender, recipient, or initiator of the transfer, respectively. Note since **approvedAddress** and **trackerType** are part of the approval tracker's identifier, this creates unique individual tallies (trackers) per address.

For example, these correspond to different trackers because the **approvedAddress** is different. Thus, Alice's transfers will be tracked separately from Bob's.

`1-collection- -approvalId-uniqueID-initiatedBy-alice`

`1-collection- -approvalId-uniqueID-initiatedBy-bob`

**Handling Multiple Trackers**

Trackers are ID-based, and thus, multiple trackers can be created. Take note of what makes up the ID. The collection ID, approval level, approver address, and more are all considered. If one changes or is different, the whole ID is different and will correspond to a new tracker.

**Increment Only**

Trackers are increment only and immutable in storage. To start an approval tally from scratch, you will need to map the approval to a new unused ID. This can be done simply by editing **amountTrackerId** (because this changes the whole ID) or restructuring to change one of the other fields that make up the overall ID.

IMPORTANT: Because of the immutable nature, be careful to not revert to a previously used ID unintentionally because the starting point will be the previous tally (not starting from scratch).

### **What is tracked?**

```typescript
export interface ApprovalTrackerInfoBase<T extends NumberType> extends ApprovalTrackerIdDetails<T> {
  numTransfers: T;
  amounts: Balance<T>[];
}
```

Each transfer that maps to the tracker increments **numTransfers** by 1, and each badge transferred increments the **amounts** in the interface (if tracked).

Example:

`ID: 1-collection- -uniqueID-initiatedBy-alice`

```json
{
    "numTransfers": 10,
    "amounts": [{ 
        "amount": 10n, 
        "badgeIds": [{ start: 1n, end: 1n }], 
        "ownershipTimes":  [{ start: 1n, end: 100000000000n }], 
    }]
}
```

**As-Needed Basis**

We increment on an as-needed basis. Meaning, if there is no need to increment the tally (unlimited limit and/or not restrictions), we **do not increment** for efficiency purposes. For example, if we only have requirements for **numTransfers** but do not need the **amounts**, we do not increment the amounts.

**Different Tracker IDs - Amounts vs Transfers**

It is possible to have different tracker IDs for the number of transfers and amounts (as seen at the top of the page). However, typically, these will be the same for simplicity.


## File: ./for-developers/badges-advanced/balances-transfers/approval-criteria/linking-trackers-advanced.md

# Extending the Approval (Advanced)

We try to offer as much as we can in the native interface; however, in edge cases, you may run into scenarios where you need more advanced functionality, for example, cross-approval functionality or access to other blockchain data / modules.

Before trying to extend the approval, please consider workarounds and design considerations. Many approvals that you think may need extension can be altered to fit into the native interfaces by thinking out of the box.

If you truly do need a more custom implementation, you will have to build your own smart contract with CosmWASM or an alternative self-implementation and call into the x/badges module. We refer you to the Tutorials section for how to do so.&#x20;

Please also let us know if whatever you are missing can be added natively. Our end goal is to have no one ever write a smart contract.



## File: ./for-developers/badges-advanced/balances-transfers/approval-criteria/max-number-of-transfers.md

# Max Number of Transfers

Pre-Readings (IMPORTANT): [Approval Trackers](approval-trackers.md)

```typescript
export interface ApprovalCriteria<T extends NumberType> {
  ...
  maxNumTransfers?: MaxNumTransfers<T>;
  ...
}
```

Similar to approval amounts, you can also specify the maximum number of transfers that can occur on an overall or per sender/recipient/initiatedBy basis. If tracked, the corresponding approval tracker will be incremented by 1 each transfer.&#x20;

"0" means unlimited allowed and not tracked. "N" means max N transfers allowed.

**Example**

Let's say we have the ID `1-collection- -approvalId-uniqueID-initiatedBy-alice` and the defined values below:

<pre class="language-json"><code class="lang-json">"maxNumTransfers": {
<strong>    "overallMaxNumTransfers": "0",
</strong>    "perFromAddressMaxNumTransfers": "0",
    "perToAddressMaxNumTransfers": "0",
    "perInitiatedByAddressMaxNumTransfers": "1",
    "amountTrackerId": "uniqueID",
}
</code></pre>

The first transfer initiated by Alice would increment the approval tracker ID`1-collection- -approvalId-uniqueID-initiatedBy-alice` to 1/1 transfers used. Alice can no longer initiate another transfer.

However, Bob can still transfer because his ID is `1-collection- -approvalId-uniqueID-initiatedBy-bob` which is a different tracker.

**As-Needed Basis**

We track on an as-needed basis, meaning if we do not have requirements that use the number of transfers, we will not increment / track.

Edge Case: In [Predetermined Balances](max-number-of-transfers.md#predetermined-balances), you may need the number of transfers for determining the balances to assign to each transfer (e.g. transfer #10 -> badge ID 10). In this case, we do need to track the number of transfers. This is all facilitated via the same tracker, so even if you have "0" or unlimited set for the corresponding value in **maxNumTransfers**, the tracker may be incremented behind the scenes. Consider this when editing / creating approvals. You do not want to use a tracker that has prior history when you expect it to start from scratch.


## File: ./for-developers/badges-advanced/balances-transfers/approval-criteria/merkle-challenges.md

# Merkle Challenges

```typescript
export interface MerkleChallenge<T extends NumberType> {
  root: string
  expectedProofLength: T;
  useCreatorAddressAsLeaf: boolean
  maxUsesPerLeaf: T
  uri: string
  customData: string
  challengeTrackerId: string
}
```

<pre class="language-json"><code class="lang-json"><strong>"merkleChallenge": {
</strong>   "root": "758691e922381c4327646a86e44dddf8a2e060f9f5559022638cc7fa94c55b77",
   "expectedProofLength": "1",
   "useCreatorAddressAsLeaf": true,
   "maxOneUsePerLeaf": true,
   "uri": "ipfs://Qmbbe75FaJyTHn7W5q8EaePEZ9M3J5Rj3KGNfApSfJtYyD",
   "customData": "",
   "challengeTrackerId": "uniqueId"
}
</code></pre>

Merkle challenges allow you to define a SHA256 Merkle tree, and to be approved for each transfer, the initiator of the transfer must provide a valid Merkle path for the tree when they transfer (via **merkleProofs** in [MsgTransferBadges](../../../bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgtransferbadges.md)).

For example, you can create a Merkle tree of claim codes. Then to be able to claim badges, each claimee must provide a valid unused Merkle path from the claim code to the **root**. You distribute the secret leaves / paths in any method you prefer.

Or, you can create an whitelist tree where the user's addresses are the leaves, and they must specify the valid Merkle path from their address to claim. This can be used to distribute gas costs among N users rather than the collection creator defining an address list with N users on-chain and paying all gas fees.

#### Expected Proof Length

The **expectedProofLength** defines the expected length for the Merkle proofs to be provided. This avoids preimage and second preimage attacks. **All proofs must be of the same length, which means you must design your trees accordingly. THIS IS CRITICAL.**

**Whitelist Trees**

Whitelist trees can be used to distribute gas costs among N users rather than the collection creator defining an expensive address list with N users on-chain and paying all gas fees. For small N, we recommend not using whitelist trees for user experience.

If defining a whitelist tree, note that the initiator must also be within the **initiatedByList** of the approval for it to make sense. Typically, **initiatedByList** will be set to "All" and then the whitelist tree restricts who can initiate.

To create a whitelist tree, you need to set **useCreatorAddressAsLeaf** to true. If **useCreatorAddressAsLeaf** is set to true, we will override the provided leaf of each Merkle proof with the BitBadges address of the initiator of the transfer transaction.

**Max Uses per Leaf**

For whitelist trees (**useCreatorAddressAsLeaf** is true), **maxUsesPerLeaf** can be set to any number. "0" or null means unlimited uses. "1" means max one use per leaf and so on. When **useCreatorAddressAsLeaf** is false, this must be set to "1" to avoid replay attacks. For example, ensure that a code / proof can only be used once because once used once, the blockchain is public and anyone then knows the secret code.

We track this in a challenge tracker, similar to the approvals trackers previously explained. We simply track if a leaf index (leftmost leaf of expected proof length layer (aka leaf layer) = index 0, ...) has been used and only allow it to be used **maxUsesPerLeaf** many times, if constrained.

The identifier for each challenge tracker consists of **challengeTrackerId** along with other identifying details seen below. The full ID contains the **approvalId,** so you know state will always be scoped to an approval and the tracker cannot be used by any other approval.

Like approval trackers, this is increment only and non-deletable. Thus, it is critical to not use a tracker with prior history if you intend for it to start tracking from scratch. This can be achieved by using an unused **challengeTrackerId**. If updating an approval with a challenge, please consider how the challenge tracker is working behind the scenes.

```typescript
{
  collectionId: T;
  approvalId: string;
  approvalLevel: "collection" | "incoming" | "outgoing";
  approverAddress?: string;
  challengeTrackerId: string;
  leafIndex: T;
}
```

**approvalLevel** corresponds to whether it is a collection-level approval, user incoming approval, or user outgoing approval. If it is user level, the **approverAddress** is the user setting the approval. **approverAddress** is blank for collection level.

Example:

`1-collection- -approvalId-uniqueID-0` -> USED 1 TIME

`1-collection- -approvalId-uniqueID-1` -> UNUSED

**Reserving Specific Leafs**

See Predetermined Balances below for reserving specific leaf indices for specific badges / ownership times.

#### **Creating a Merkle Tree**

We provide the **treeOptions** field in the SDK to let you define your own build options for the tree (see [Compatibility](../../../bitbadges-api/concepts/designing-for-compatibility.md) with the BitBadges API / Indexer). You may experiment with this, but please test all Merkle paths and claims work as intended first. The only tested build options so far are what you see below with the fillDefaultHash.

The important part is making sure all leaves are on the same layer and have the same proof length, or else, they will fail on-chain.

```typescript
import { SHA256 } from 'crypto-js';
import MerkleTree from 'merkletreejs';

const codes = [...]
const hashedCodes = codes.map(x => SHA256(x).toString());
const treeOptions = { fillDefaultHash: '0000000000000000000000000000000000000000000000000000000000000000' }
const codesTree = new MerkleTree(hashedCodes, SHA256, treeOptions);
const codesRoot = codesTree.getRoot().toString('hex');
const expectedMerkleProofLength = codesTree.getLayerCount() - 1;
```

For whitelists, replace with this code.

```typescript
addresses.push(...toAddresses.map(x => convertToBitBadgesAddress(x)));

const addressesTree = new MerkleTree(addresses.map(x => SHA256(x)), SHA256, treeOptions)
const addressesRoot = addressesTree.getRoot().toString('hex');
```

A valid proof can then be created via where codeToSubmit is the code submitted by the user.

```typescript
const passwordCodeToSubmit = '....'
const leaf = isWhitelist ? SHA256(chain.bitbadgesAddress).toString() : SHA256(passwordCodeToSubmit).toString();
const proofObj = tree?.getProof(leaf, whitelistIndex !== undefined && whitelistIndex >= 0 ? whitelistIndex : undefined);
const isValidProof = proofObj && tree && proofObj.length === tree.getLayerCount() - 1;


const codeProof = {
  aunts: proofObj ? proofObj.map((proof) => {
    return {
      aunt: proof.data.toString('hex'),
      onRight: proof.position === 'right'
    }
  }) : [],
  leaf: isWhitelist ? '' : passwordCodeToSubmit,
}

const txCosmosMsg: MsgTransferBadges<bigint> = {
  creator: chain.bitbadgesAddress,
  collectionId: collectionId,
  transfers: [{
    ...
    merkleProofs: requiresProof ? [codeProof] : [],
    ...
  }],
};
```


## File: ./for-developers/badges-advanced/balances-transfers/approval-criteria/must-own-badges.md

# Ownership Requirements

Must own badges are another unique feature that is very powerful. This allows you to specify certain badges and amounts of badges of a collection (typically a different collection) that must be owned in order to be approved. This is checked on-chain.

For example, you may implement a badge collection where only holders of a verified badge are approved to send and receive badges. Or, you may implement what you must NOT own (own x0) a scammer badge in order to interact.

Note that alternatively, you may choose to check / enforce this off-chain as well via BitBadges claims.

```typescript
export interface MustOwnBadges<T extends NumberType> {
  collectionId: T;

  amountRange: UintRange<T>; //min/max amount expected to be owned
  ownershipTimes: UintRange<T>[];
  badgeIds: UintRange<T>[];
  
  //override ownershipTimes with the exact block millisecond at execution
  //Ex: [{start: 12345, end: 12345}]
  overrideWithCurrentTime: boolean;
  
  //if true, must meet ownership requirements for ALL badges
  //if false, must meet ownership requirements for ONE badge
  mustSatisfyForAllAssets: boolean; 
}
```


## File: ./for-developers/badges-advanced/balances-transfers/approval-criteria/overrides.md

# Override User Level Approvals

As mentioned in the transferability page, the collection-wide approvals can override the user-level approvals. This is done via **overridesFromOutgoingApprovals** or **overridesToIncomingApprovals**.

If set to true, we will not check the user's incoming / outgoing approvals for the approved balances respectively. Essentially, it is **forcefully** transferred without needing user approvals. This can be leveraged to implement forcefully revoking a badge, freezing a badge, etc.

IMPORTANT: The Mint address has its own approvals store, but since it is not a real address, they are always empty. **Thus, it is important that when you define approvals from the Mint address, you always override the outgoing approvals of the Mint address.** Or else, the approval will not work.

* <pre class="language-json"><code class="lang-json"><strong>"fromListId": "Mint", //represents the list with the "Mint" addres
  </strong>...
  "approvalCriteria": {
    "overridesFromOutgoingApprovals": true
    ...
  }
  </code></pre>

<figure><img src="../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1)  (13).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/badges-advanced/balances-transfers/approval-criteria/overview.md

# Overview

In the transferability page, we mainly talked about how we match and check an approval. Here, we will talk about the **approvalCriteria.**

These are the additional options or restrictions you can set which decide whether a transfer is approved or not (e.g. how much can be transferred? how many times? etc). To be approved, it must satisfy all the options / restrictions set (everything talked about in the last page AND the **approvalCriteria**).

```typescript
export interface iApprovalCriteria<T extends NumberType> {
  /** The list of must own badges to be approved. */
  mustOwnBadges?: iMustOwnBadges<T>[];
  /** The list of ZK proofs that need to be satisfied. One use per proof solution. */
  zkProofs?: iZkProof[];
  /** The $BADGE transfers to be executed upon every approval. */
  coinTransfers?: iCoinTransfer<T>[];
  /** The list of merkle challenges that need valid proofs to be approved. */
  merkleChallenges?: iMerkleChallenge<T>[];
  /** The predetermined balances for each transfer. */
  predeterminedBalances?: iPredeterminedBalances<T>;
  /** The maximum approved amounts for this approval. */
  approvalAmounts?: iApprovalAmounts<T>;
  /** The max num transfers for this approval. */
  maxNumTransfers?: iMaxNumTransfers<T>;
  /** Whether the to address must equal the initiatedBy address. */
  requireToEqualsInitiatedBy?: boolean;
  /** Whether the from address must equal the initiatedBy address. */
  requireFromEqualsInitiatedBy?: boolean;
  /** Whether the to address must not equal the initiatedBy address. */
  requireToDoesNotEqualInitiatedBy?: boolean;
  /** Whether the from address must not equal the initiatedBy address. */
  requireFromDoesNotEqualInitiatedBy?: boolean;
  /** Whether this approval overrides the from address's approved outgoing transfers. */
  overridesFromOutgoingApprovals?: boolean;
  /** Whether this approval overrides the to address's approved incoming transfers. */
  overridesToIncomingApprovals?: boolean;
}
```

**Extending Functionality**

These are just the native options provided in the interface for convenience and consistency, but you can always implement your own approvals via custom logic with a CosmWASM smart contract.

Or, you can leverage the native features for custom implementations:

* Use Merkle challenges as a commit-reveal claim code mechanism. This is what we do for BitBadges claims. Then, you can assign claim codes how you wish.&#x20;
* Create custom, general-purpose zero-knowledge circuits that need to be satisfied. Implement your custom logic within in the circuit (if it lends itself to this approach).

#### Tracker IDs

The approval interface utilizes trackers behind the scenes for certain fields which are identified by IDs (**amountTrackerId, challengeTrackerId)**. Trackers are increment only and immutable in storage and referenced by an ID consisting of **approvalId-trackerId** plus other identifying details. Because the **approvalId** is in there, this enforces that all trackers are scoped to a specific approvalId. However, since they are ID based and increment only, it is important to be careful to not use previous IDs that have state. See best practices below.

**Best Practices - Creating / Updating / Deleting**

A really important part in creating / editing / deleting approvals is to keep track of the trackers' state. You do not want to use a tracker with prior history when creating an approval which should start from scratch. This messes up the expected behavior of the approval. You can't just simply delete the tracker because it is increment only and immutable.

To combat this, we recommend the following best practices:

* When creating an approval for the first time (which is expected to start completely from scratch), always use unique, unused IDs for **approvalId**, **amountTrackerId** and **challengeTrackerId**. If these are unique, the tracker IDs will also be unique which means they will have no prior history.
* When you want entirely new state (whole approval), change the **approvalId** to something unique. This makes all tracker IDs different. This is the recommended option (if applicable) because you know for certain that all trackers have been reset.
* When you want just an individual tracker's state to be reset, you need to change the individual tracker ID to a aunique unused vaue.

#### Scoped vs Cross-Approval Logic

All approvals' state is expected to be scoped, but sometimes, you may want to implement cross-approval logic (e.g. do not allow double dipping between two approvals). This, unfortunately, is out of scope for the native interface at the moment.  Consider workarounds and careful design decisions.&#x20;

However, if you do need more advanced functionality, you may have to go up a level and use CosmWASM or alternative solutions. If you run into this problem, let us know, and we can recommend what to do.&#x20;


## File: ./for-developers/badges-advanced/balances-transfers/approval-criteria/predetermined-balances.md

# Predetermined Balances

Predetermined balances are a new way of having fine-grained control over the amounts that are approved with each transfer. In a typical tally-based system where you approve X amount to be transferred, you have no control over the combination of amounts that will add up to X. For example, if you approve x100, you can't control whether the transfers are \[x1, x1, x98] or \[x100] or another combination.

Predetermined balances let you explicitly define the amounts that must be transferred and the order of the transfers. For example, you can enforce x1 of badge ID 1 has to be transferred before x1 of badge ID 2, and so on.&#x20;

Although this can be used in tandem with approval amounts, either one or the other is usually used because they both specify amount restrictions.

**TLDR; The transfer will fail if the balances are not EXACTLY as defined in the predetermined balances.**

```typescript
export interface PredeterminedBalances<T extends NumberType> {
  manualBalances: ManualBalances<T>[];
  incrementedBalances: IncrementedBalances<T>;
  orderCalculationMethod: PredeterminedOrderCalculationMethod;
}
```

## **Defining Balances**

There are two ways to define the balances. Both can not be used together.

* **Manual Balances:** Simply define an array of balances manually. Each element corresponds to a different set of balances for a unique transfer.
* ```json
  "manualBalances": [
    {
      "amount": "1",
      "badgeIds": [
        {
          "start": "1",
          "end": "1"
        }
      ],
      "ownershipTimes": [
        {
          "start": "1691978400000",
          "end": "1723514400000"
        }
      ]
    },
    {...},
    {...},
  ]
  ```
* **Incremented Balances:** Define starting balances and then define how much to increment the IDs and times by after each transfer. This is how to implement the above example: you can enforce x1 of badge ID 1 has to be transferred before x1 of badge ID 2, and so on. This is typically used for minting badges.
* ```json
  "incrementedBalances": {
    "startBalances": [
      {
        "amount": "1",
        "badgeIds": [
          {
            "start": "1",
            "end": "1"
          }
        ],
        "ownershipTimes": [
          {
            "start": "1691978400000",
            "end": "1723514400000"
          }
        ]
      }
    ],
    "incrementBadgeIdsBy": "1",
    "incrementOwnershipTimesBy": "0"
  }
  ```

## **Precalculating Balances**

Predetermined balances can quickly change, such as in between the time a transaction is broadcasted and confirmed. For example, other users' mints get processed, and thus, the badge IDs one should receive changes. This creates a problem because you can't manually specify balances because that results in race conditions and failed transfers / claims.

To combat this, when initiating a transfer, we allow you to specify **precalculateBalancesFromApproval** (in [MsgTransferBadges](../../../bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgtransferbadges.md)). Here, you define which **approvalId** you want to precalculate from, and at execution time, we calculate what the predetermined balances are and override the requested balances to transfer with them. Note this is the unique **approvalId** of the approval, not the tracker ID.

<pre class="language-typescript"><code class="lang-typescript"><strong>precalculateBalancesFromApproval: {
</strong>    approvalId: string;
    approvalLevel: string; //"collection" | "incoming" | "outgoing"
    approverAddress: string; //"" if collection-level
}
</code></pre>

## **Defining Order of Transfers**

Which balances to assign for a transfer is calculated by a specified order calculation method.

For manual balances, we want to determine which element index of the array is transferred (e.g. order number = 0 means the balances of manualBalances\[0] will be transferred). For incremented balances, this corresponds to how many times we should increment (e.g. order number = 5 means apply the increments to the starting balances five times).

There are five calculation methods to determine the order method.&#x20;

### Defining Order by Number of Transfers

We either use a running tally of the number of transfers to calculate the order number (no previous transfers = order number 0, one previous transfer = order number 1, and so on). This can be done on an overall or per to/from/initiatedBy address basis and is incremented using an approval tracker as explained in [Max Number of Transfers](predetermined-balances.md#max-number-of-transfers).&#x20;

IMPORTANT: Note the number of transfers is tracked using the same tracker as used within **maxNumTransfers**. Trackers are increment only, immutable, and incremented on an as-needed basis. Be mindful of this. If the tracker has prior history (potentially because **maxNumTransfers** was set), the order numbers will be calculated according to the prior history of this tracker. The opposite is also true. If you are tracking transfers here for predetermined balances, the **maxNumTransfers** restrictions will be calculated according to the tracker's history. Consider this when editing / creating approvals. You do not want to use a tracker that has prior history when you expect it to start from scratch.

### Reserved Order

We also support using the leaf index for the defined Merkle challenge proof (see [Merkle Challenges](predetermined-balances.md#merkle-challenges)) to calculate the order number (e.g. leftmost leaf on expected leaf layer will correspond to order number 0, next leaf will be order number 1, and so on). The leftmost leaf means the leftmost leaf of the **expectedProofLength** layer. The challenge we will use is the one with the corresponding **challengeTrackerId**.

This is used to reserve specific badges for specific users / claim codes. For example, reserve the badges corresponding to order number 10 (leaf number 10) for address xyz.eth.

```typescript
export interface PredeterminedOrderCalculationMethod {
  useOverallNumTransfers: boolean;
  usePerToAddressNumTransfers: boolean;
  usePerFromAddressNumTransfers: boolean;
  usePerInitiatedByAddressNumTransfers: boolean;
  useMerkleChallengeLeafIndex: boolean;
  challengeTrackerId: string;
}
```

&#x20;

**Overlap / Out of Bounds**

In the base approval interface, we specify the bounds for the approval ("Alice" can transfer the IDs 1-10 for Mon-Fri to "Bob" initiated by "Alice"). Typically, the precalculated balances should be completely within these bounds. However, the order number may eventually correspond to balances that have no overlap with these bounds or partially overlap. For example, if you approve x1 of ID 1, then x1 of ID 2 and so on up to x1 of ID 10000, eventually, the order number will be 10001 which corresponds to balances that are out of bounds.

If it is completely out of bounds (e.g. order number = 101 but approved badgeIds 1-100 with increments of 1), this is practically ignored. This is because if you try and transfer badge ID 101, it will never match to the current approval.

You should try and design your approvals for no partial overlaps. But, in rare cases, this may occur (some in bounds and some out of bounds). In this case, the overall transfer balances still must be **exactly** as defined (in bounds + out of bounds); however, we only approve the in bounds ones for the current approval. The out of bounds ones must be approved by a separate approval.


## File: ./for-developers/badges-advanced/balances-transfers/approval-criteria/requires.md

# Requires

You also have the following options to further restrict who can transfer to who.

**requireToEqualsInitiatedBy, requireToDoesNotEqualsInitiatedBy**

**requireFromEqualsInitiatedBy, requireFromDoesNotEqualsInitiatedBy**

These are pretty self-explanatory. You can enforce that we additionally check if the to or from address equals or does not equal the initiator of the transfer.&#x20;

Note that this is bounded to the addresses in the respective lists for to, from, and initiatedBy (i.e. **toList, fromList, initiatedByList**).


## File: ./for-developers/badges-advanced/balances-transfers/approval-criteria/tallied-approval-amounts.md

# Tallied Approval Amounts

Pre-Readings (IMPORTANT): [Approval Trackers](approval-trackers.md)

```typescript
export interface ApprovalCriteria<T extends NumberType> {
  ...
  approvalAmounts?: ApprovalAmounts<T>;
  ...
}
```

**Approval Amounts**

Approval amounts (**approvalAmounts**) allow you to specify the threshold amount that can be transferred for this approval. This is similar to other interfaces (such as approvals for ERC721), except we use an increment + threshold system as opposed to a decrement + greater than 0 system. This is facilitated via the concept of [Approval Trackers](approval-trackers.md).

The amounts approved are scoped to the **badgeIds** and **ownershipTimes** defined by the base approval (see transferability page). Also, note that the to addresses are bounded to the addresses in the **toList,** from addresses from the **fromList**, and initiated by addresses from the **initiatedByList**.

We define four levels (**trackerType** = "overall", "to", "from", "initiatedBy") that you can specify for approval amounts as seen below. You can define multiple if desired, and to be approved, the transfer must satisfy all.

* **Overall**: Overall will increment a universal, cumulative approval tracker for all transfers that match this approval, regardless of who sends, receives, or initiates them.
* **Per To Address**: If you specify an approval amount per to address, we will create unique cumulative trackers for every unique "to" address.
* **Per From Address**: Creates unique cumulative tallies for every unique "from" address.
* **Per Initiated By Address**: Creates unique cumulative tallies for every unique "initiatedBy" address.

If the amount set is nil value or "0", this means there is no limit (no amount restrictions).

**Example**

```json
"collectionApprovals": [
    {
      "fromListId": "Bob",
      "toListId": "AllWithMint",
      "initiatedByListId": "AllWithMint",
      "transferTimes": [
        {
          "start": "1691931600000",
          "end": "1723554000000"
        }
      ],
      "ownershipTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "badgeIds": [
        {
          "start": "1",
          "end": "100"
        }
      ],
      "approvalId": "uniqueID",
      
      "approvalCriteria": {
        "approvalAmounts": {
           "overallApprovalAmount": "1000", //overall limit of x1000
           "perFromAddressApprovalAmount": "0", //no limit
           "perToAddressApprovalAmount": "0",
           "perInitiatedByAddressApprovalAmount": "10", //limit of x10 per initiator
           "amountTrackerId": "uniqueID",
        },
        ...
      }
      ...
    }
  
```

Let's say we have the **approvalAmounts** defined above and Alice initiates a transfer of x10 from Bob. There are two separate trackers that get incremented here.

\#1) Tracker with the following ID `1-collection- -approvalId-uniqueID-overall-` gets incremented to x10 out of 1000. Any subsequent transfers (say from Charlie) will also increment this overall universal tracker as well.

\#2) Tracker with ID `1-collection- -approvalId-uniqueID-initiatedBy-alice`gets incremented to x10 out of 10 used. Alice has now fully used up her threshold for this tracker. This tracker is only incremented when Alice initiates the transfer. If Charlie initiates a transfer, his unique initiatedBy tracker will get incremented which is separate from Alice's.

Since there was an unlimited amount approved for the "to" and "from" trackers, we do not increment anything for those trackers (as-needed basis).

**Resets + ID Changes**

Let's say we update the **amountTrackerId** to "uniqueID2" from "uniqueID". This makes all tracker IDs different, and thus, all tallies will start from scratch.

`1-collection- -approvalId-uniqueID-initiatedBy-alice` ->

`1-collection- -approvalId-uniqueID2-initiatedBy-alice`

If in the future, you change back to "uniqueID", the starting point will be the previous tally. Using the examples above, x10/10 used for Alice's initiated by tracker.


## File: ./for-developers/badges-advanced/balances-transfers/approval-criteria/usdbadge-transfers.md

# $BADGE Transfers

**coinTransfers** are the $BADGE credits to be sent **every** use of the approval. There can be multiple transfers here to implement complex royalty systems, for example. Or, you can leave it blank for no $BADGE transfers.

Note: $BADGE refers to the native gas credits token of the blockchain, not a specific badge.

```typescript
export interface iCoinTransfer<T extends NumberType> {
    /**
     * The recipient of the coin transfer. This should be a Bech32 BitBadges address.
     */
    to: string;
    /**
     * The coins
     */
    coins: iCosmosCoin<T>[];
}
```

```typescript
export interface iCosmosCoin<T extends NumberType> {
    /** The amount of the coin. */
    amount: T;
    /** The denomination of the coin. */
    denom: string;
}
```


## File: ./for-developers/badges-advanced/balances-transfers/approval-criteria/zk-proofs.md

# ZK Proofs

Zero knowledge proofs are also supported in the approval interface. If you provide a valid proof, you are granted approval.

Pre-Readings: [https://docs.circom.io/background/background/](https://docs.circom.io/background/background/) and have a basic understanding of the concepts of zkSnarks and ZK Proofs from a high level. You do not need to fully know the math / cryptography behind the scenes to write ZK circuits, but you should be familiar with the main concepts.

**Replays**

Each valid proof solution can only be used once. This is tracked with the **zkpTrackerId**, in the same manner as merkle challenges (we refer you there for more info). The tracker is scoped to an approval, immutable, and increment only (full ID -> USED or UNUSED). Design your proofs with this in consideration.

**Storage**

On the blockchain, we store an array of proofs that need to be solved for each approval (if array is empty, there is no need). Users must solve all the proofs in the array for approval. This is stored in the approval's **approvalCriteria.zkProofs.** See the iZkProof interface below. All that we store on-chain (for scalability reasons) is the verification key. You may provide additional details (such as the circuit, proving key, etc) via the uri or customData.

```typescript
export interface iZkProof {
    /**
     * The verification key of the zkProof.
     */
    verificationKey: string;

    /**
     * The URI where to fetch the zkProof metadata from.
     */
    uri: string;

    /**
     * Arbitrary custom data that can be stored on-chain.
     */
    customData: string;

    /**
     * ZKP tracker ID.
     */
    zkpTrackerId: string;
}
```

**Proof Solutions**

Within MsgTransferBadges, users can specify **zkProofSolutions** array where they provide the valid solutions to the proofs. These follow the interface as seen below.

```
export interface iZkProofSolution {
  /**
   * The proof of the zkProof.
   */
  proof: string;

  /**
   * The public inputs of the zkProof.
   */
  publicInputs: string;
}
```

**Formatting**

We rely heavily on [Circom implementation](https://docs.circom.io/getting-started/installation/) for proofs and formatting. Circom is a library and full programming language to write ZK proofs. Pretty much, you will do all the proof writing, generation, and proving with Circom. Then, the outputted files are what we use on-chain.

Proving Method: zkSnark Groth16

```
pragma circom 2.0.0;

/*This circuit template checks that c is the multiplication of a and b.*/

template Multiplier2 () {

   // Declaration of signals.
   signal input a;
   signal input b;
   signal output c;

   // Constraints.
   c <== a * b;
}
```

With every compiled Circom circuit + valid proof, you will get the following files:

* verification\_key.json - The verification key for proving the circuit
* proof.json - A succint proof proving all criteria is satisfied
* public.json - The public inputs to the proof.

These JSON files should be stringified, and they are what is passed on-chain via storage and the solutions.

The verificationKey.json is what you will pass into verificationKey field of iZkProof.

The proof.json is what you will pass into proof of iZkProofSolution.

The public.json is what you will pass into publicInputs of iZkProofSolution.

Examples

<figure><img src="../../../../.gitbook/assets/image (63).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/image (64).png" alt=""><figcaption></figcaption></figure>

Create Collection Msg w/ Proof

```json
{
    "creator": "bb1kfr2xajdvs46h0ttqadu50nhu8x4v0tc2wajnh",
    "collectionId": "0",
    "balancesType": "Standard",
    "defaultBalances": {
        "balances": [],
        "incomingApprovals": [],
        "outgoingApprovals": [],
        "userPermissions": {
            "canUpdateOutgoingApprovals": [],
            "canUpdateIncomingApprovals": [],
            "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [],
            "canUpdateAutoApproveSelfInitiatedIncomingTransfers": []
        },
        "autoApproveSelfInitiatedOutgoingTransfers": true,
        "autoApproveSelfInitiatedIncomingTransfers": true
    },
    "badgeIdsToAdd": [
        {
            "start": "1",
            "end": "100"
        }
    ],
    "updateCollectionPermissions": true,
    "collectionPermissions": {
        "canDeleteCollection": [],
        "canArchiveCollection": [],
        "canUpdateOffChainBalancesMetadata": [],
        "canUpdateStandards": [],
        "canUpdateCustomData": [],
        "canUpdateManager": [],
        "canUpdateCollectionMetadata": [],
        "canUpdateValidBadgeIds": [],
        "canUpdateBadgeMetadata": [],
        "canUpdateCollectionApprovals": []
    },
    "updateManagerTimeline": true,
    "managerTimeline": [],
    "updateCollectionMetadataTimeline": true,
    "collectionMetadataTimeline": [
        {
            "collectionMetadata": {
                "uri": "ipfs://Qmf8xxN2fwXGgouue3qsJtN8ZRSsnoHxM9mGcynTPhh6Ub",
                "customData": ""
            },
            "timelineTimes": [
                {
                    "start": "1",
                    "end": "18446744073709551615"
                }
            ]
        }
    ],
    "updateBadgeMetadataTimeline": true,
    "badgeMetadataTimeline": [
        {
            "badgeMetadata": [
                {
                    "uri": "ipfs://Qmf8xxN2fwXGgouue3qsJtN8ZRSsnoHxM9mGcynTPhh6Ub",
                    "badgeIds": [
                        {
                            "start": "1",
                            "end": "10000000000000"
                        }
                    ],
                    "customData": ""
                }
            ],
            "timelineTimes": [
                {
                    "start": "1",
                    "end": "18446744073709551615"
                }
            ]
        }
    ],
    "updateOffChainBalancesMetadataTimeline": true,
    "offChainBalancesMetadataTimeline": [],
    "updateCustomDataTimeline": true,
    "customDataTimeline": [],
    "updateCollectionApprovals": true,
    "collectionApprovals": [
        {
            "toListId": "All",
            "fromListId": "Mint",
            "initiatedByListId": "All",
            "transferTimes": [
                {
                    "start": "1",
                    "end": "18446744073709551615"
                }
            ],
            "badgeIds": [
                {
                    "start": "1",
                    "end": "100"
                }
            ],
            "ownershipTimes": [
                {
                    "start": "1",
                    "end": "18446744073709551615"
                }
            ],
            "approvalId": "test",
            "amountTrackerId": "fdklasf",
            "challengeTrackerId": "fdhhjksafhdj",
            "uri": "ipfs://QmWtjFHDbKCKNAMoJH3ZAkt6eCY8RSohHpXFMF9yf8vAuN",
            "customData": "",
            "approvalCriteria": {
                "mustOwnBadges": [],
                "merkleChallenge": {
                    "root": "",
                    "expectedProofLength": "0",
                    "useCreatorAddressAsLeaf": false,
                    "maxUsesPerLeaf": "0",
                    "uri": "",
                    "customData": ""
                },
                "predeterminedBalances": {
                    "manualBalances": [],
                    "incrementedBalances": {
                        "startBalances": [],
                        "incrementBadgeIdsBy": "0",
                        "incrementOwnershipTimesBy": "0"
                    },
                    "orderCalculationMethod": {
                        "useOverallNumTransfers": false,
                        "usePerToAddressNumTransfers": false,
                        "usePerFromAddressNumTransfers": false,
                        "usePerInitiatedByAddressNumTransfers": false,
                        "useMerkleChallengeLeafIndex": false
                    }
                },
                "approvalAmounts": {
                    "overallApprovalAmount": "0",
                    "perToAddressApprovalAmount": "0",
                    "perFromAddressApprovalAmount": "0",
                    "perInitiatedByAddressApprovalAmount": "0"
                },
                "maxNumTransfers": {
                    "overallMaxNumTransfers": "0",
                    "perToAddressMaxNumTransfers": "0",
                    "perFromAddressMaxNumTransfers": "0",
                    "perInitiatedByAddressMaxNumTransfers": "1"
                },
                "requireToEqualsInitiatedBy": false,
                "requireFromEqualsInitiatedBy": false,
                "requireToDoesNotEqualInitiatedBy": false,
                "requireFromDoesNotEqualInitiatedBy": false,
                "overridesFromOutgoingApprovals": true,
                "overridesToIncomingApprovals": true,
                "zkProofs": [
                    {
                        "verificationKey": "{\n\t\t\t\t\"protocol\": \"groth16\",\n\t\t\t\t\"curve\": \"bn128\",\n\t\t\t\t\"nPublic\": 1,\n\t\t\t\t\"vk_alpha_1\": [\n\t\t\t\t \"13148620221535972250452852483621388707005895520407749254029942589019911968317\",\n\t\t\t\t \"2889632388761537408217987365790126432839324967233397666357486962226656274862\",\n\t\t\t\t \"1\"\n\t\t\t\t],\n\t\t\t\t\"vk_beta_2\": [\n\t\t\t\t [\n\t\t\t\t\t\"235184211515192335800888829014779038630276494620926581575684953647609832787\",\n\t\t\t\t\t\"19688718941701106378739125377381200373190897484213597668400002191692567452234\"\n\t\t\t\t ],\n\t\t\t\t [\n\t\t\t\t\t\"17139505730823840138430760175182215851804207584515613019250263963726263545682\",\n\t\t\t\t\t\"15827693620421453696738510788300059898248795618831839628175348577712566794715\"\n\t\t\t\t ],\n\t\t\t\t [\n\t\t\t\t\t\"1\",\n\t\t\t\t\t\"0\"\n\t\t\t\t ]\n\t\t\t\t],\n\t\t\t\t\"vk_gamma_2\": [\n\t\t\t\t [\n\t\t\t\t\t\"10857046999023057135944570762232829481370756359578518086990519993285655852781\",\n\t\t\t\t\t\"11559732032986387107991004021392285783925812861821192530917403151452391805634\"\n\t\t\t\t ],\n\t\t\t\t [\n\t\t\t\t\t\"8495653923123431417604973247489272438418190587263600148770280649306958101930\",\n\t\t\t\t\t\"4082367875863433681332203403145435568316851327593401208105741076214120093531\"\n\t\t\t\t ],\n\t\t\t\t [\n\t\t\t\t\t\"1\",\n\t\t\t\t\t\"0\"\n\t\t\t\t ]\n\t\t\t\t],\n\t\t\t\t\"vk_delta_2\": [\n\t\t\t\t [\n\t\t\t\t\t\"503765186455257630293828867624988330153366884012427107660916834216629962594\",\n\t\t\t\t\t\"5063908373717690658921653190209557568433126368699956121277602772003448036384\"\n\t\t\t\t ],\n\t\t\t\t [\n\t\t\t\t\t\"7089519436043338270412729805469570497303116366059156310430246336448604006110\",\n\t\t\t\t\t\"4176347866589911546633049464699627263382512831672401904553239775361215104922\"\n\t\t\t\t ],\n\t\t\t\t [\n\t\t\t\t\t\"1\",\n\t\t\t\t\t\"0\"\n\t\t\t\t ]\n\t\t\t\t],\n\t\t\t\t\"vk_alphabeta_12\": [\n\t\t\t\t [\n\t\t\t\t\t[\n\t\t\t\t\t \"18604433221051551034480587482664214870599340609016463817742300813893366628865\",\n\t\t\t\t\t \"18085175124799896104522525897296636509228330955796915514958149085721253919374\"\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t \"5818719788508620172684530200840038363514092465014332706277430885575255653155\",\n\t\t\t\t\t \"13271739325997130171594168052085563392477243703137959518318871241167867548541\"\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t \"15990090000399229437316874893245659161037348656905875554257382661511921214897\",\n\t\t\t\t\t \"21037562072546073120182607002350315755086517195889115785617784603842266232387\"\n\t\t\t\t\t]\n\t\t\t\t ],\n\t\t\t\t [\n\t\t\t\t\t[\n\t\t\t\t\t \"2203738935953083333113402844434965170714091346913547128007885238438368497527\",\n\t\t\t\t\t \"12254441210030526054660165902009315439490317537751453916247356602839811164652\"\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t \"18042350999254486153299086364647673457109976987505413008188358179267817106631\",\n\t\t\t\t\t \"20440311422039242859067644437230958996502643417500127952743189403997461532235\"\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t \"3918110739729735412812703372321634476922749810769795477323113295317098326469\",\n\t\t\t\t\t \"659595211998342112032231124403258238789761295830862227926617204748855071177\"\n\t\t\t\t\t]\n\t\t\t\t ]\n\t\t\t\t],\n\t\t\t\t\"IC\": [\n\t\t\t\t [\n\t\t\t\t\t\"12090554620905913999269511296228069288923128009598574755312442527252764243545\",\n\t\t\t\t\t\"20477553370846440301046582608494182925724854012349177770405179934985848699502\",\n\t\t\t\t\t\"1\"\n\t\t\t\t ],\n\t\t\t\t [\n\t\t\t\t\t\"21363409161656661765284862807955826021689494498345713938600256958010467481555\",\n\t\t\t\t\t\"6970854698956478603764888286629038914534847038473858754877750290063128523222\",\n\t\t\t\t\t\"1\"\n\t\t\t\t ]\n\t\t\t\t]\n\t\t\t }",
                        "uri": "",
                        "customData": ""
                    }
                ]
            }
        }
    ],
    "updateStandardsTimeline": true,
    "standardsTimeline": [],
    "updateIsArchivedTimeline": true,
    "isArchivedTimeline": []
}
```

Sample Transfer Msg

```json
{
    "creator": "bb1kfr2xajdvs46h0ttqadu50nhu8x4v0tc2wajnh",
    "collectionId": "21",
    "transfers": [
        {
            "from": "Mint",
            "toAddresses": ["bb178m3nrv6arrfwh6r6gcr60v6m63cyxrym5ahjg"],
            "balances": [
                {
                    "amount": "1",
                    "badgeIds": [
                        {
                            "start": "1",
                            "end": "1"
                        }
                    ],
                    "ownershipTimes": [
                        {
                            "start": "1",
                            "end": "1"
                        }
                    ]
                }
            ],
            "precalculateBalancesFromApproval": {
                "approvalId": "",
                "approvalLevel": "",
                "approverAddress": ""
            },
            "merkleProofs": [],
            "memo": "",
            "prioritizedApprovals": [],
            "onlyCheckPrioritizedCollectionApprovals": false,
            "onlyCheckPrioritizedIncomingApprovals": false,
            "onlyCheckPrioritizedOutgoingApprovals": false,
            "zkProofSolutions": [
                {
                    "proof": "{\n\t\t\t\t\t\t\t\"pi_a\": [\n\t\t\t\t\t\t\t \"15280415993796597666813636493043784530691061101504618964413605220785439881335\",\n\t\t\t\t\t\t\t \"675563788996052368699527111569929717352978256610453492975963571932469065914\",\n\t\t\t\t\t\t\t \"1\"\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"pi_b\": [\n\t\t\t\t\t\t\t [\n\t\t\t\t\t\t\t\t\"13271940717404841760534790023945884845854169265312102895125858252700907827176\",\n\t\t\t\t\t\t\t\t\"591918590265443693515148586084694063044314117360908071728035775984509485618\"\n\t\t\t\t\t\t\t ],\n\t\t\t\t\t\t\t [\n\t\t\t\t\t\t\t\t\"1321184000365240114236816479208164217123473043443213174227113077515267780427\",\n\t\t\t\t\t\t\t\t\"9588815572669609102065114656724798374518140131116623313758405358680261499082\"\n\t\t\t\t\t\t\t ],\n\t\t\t\t\t\t\t [\n\t\t\t\t\t\t\t\t\"1\",\n\t\t\t\t\t\t\t\t\"0\"\n\t\t\t\t\t\t\t ]\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"pi_c\": [\n\t\t\t\t\t\t\t \"20270283025961949711733235392141938263044103713056685530615033679931520723664\",\n\t\t\t\t\t\t\t \"8871872070133185879918010372399365027368084761154313139928014267382902159344\",\n\t\t\t\t\t\t\t \"1\"\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"protocol\": \"groth16\",\n\t\t\t\t\t\t\t\"curve\": \"bn128\"\n\t\t\t\t\t\t }",
                    "publicInputs": "[\n\t\t\t\t\t\t\t\"33\"\n\t\t\t\t\t\t ]"
                }
            ]
        }
    ]
}
```


## File: ./for-developers/badges-advanced/balances-transfers/balance-types.md

# 🪙 Balance Types

BitBadges offers different ways to store the badge balances and owners for your collection as explained [here](broken-reference) (please read this version first, if not already). The balances type for a collection is determined by the **balancesType** field of the collection interface.

The core collection details are always stored on-chain, but balances can be stored using different methods, each offering their own pros and cons.

<figure><img src="../../../.gitbook/assets/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Non-Public

```typescript
"balancesType": "Non-Public"
```

We do give the option to make balances non-public. This can either mean you want to keep balances private through a self-implementation. Or, you may not need balances altogether. If either of these criteria match, you can select this balance type, and we will not display anything about balances on the user interface (everything is left up to you entirely).

## Standard

```json
"balancesType": "Standard"
```

With standard balances, everything is facilitated on-chain in a decentralized manner. All balances are stored on the blockchain, and everything is facilitated through on-chain transfers and approvals. All transfers require sufficient balances and valid approvals for the collection, sender, and recipient.

* All transfers must specify the collection approvals, sender's outgoing approvals, and recipient's incoming approvals. The collection approvals are managed by the manager and can optionally override the user-level approvals.
* The "Mint" address has unlimited balances, can only send badges, not receive them. The circulating supply will live out according to the permissions, approvals, and transfers of the collection from the Mint address.
* Thus, the circulating supply will be restricted by transfers / approvals from the Mint address. You can customize the transferability according to the collection's approvals as explained in [Approvals](transferability-approvals.md) and [Approval Criteria](approval-criteria/).
* Permissions are also settable to control the updatability of approvals (whether approvals are frozen or editable).

## Off-Chain

With off-chain balances, you will create a new collection on-chain and will define details unique to this created collection such as badge metadata, standards, etc. **However, all transfers and approval transactions will throw an error if attempted because these are to be facilitated off-chain.**

Balances, at any given time, will be queried from the specified URI (stored via the **offChainBalancesMetadata** field of the collection).

With off-chain balances, you sacrifice decentralization and on-chain transfers for scalability, user experience, and more. Off-chain balances lend themselves nicely to many badge use cases because badge allocation is often centralized anyways.

```json
"offChainBalancesMetadataTimeline": [
  {
    "timelineTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "offChainBalancesMetadata": {
      "uri": "ipfs://QmXZTfhNAPJ32WsBaRRDSwxok9phVisCcDy8asBvcmBzsR",
      "customData": ""
    }
  }
]
```

#### Benefits

* **Significant Resource Reduction**: The architecture's off-chain nature results in a substantial reduction of resources used by your collection—potentially up to over 99%. This is primarily due to the absence of on-chain transfer transactions and balances. Only the core collection details need to be created / updated on-chain, and future balance updates do not require blockchain transactions (assuming the URI does not change).
* **Non-Blockchain Data and Tools**: Balances can be customized easier using non-blockchain tools and data. For example, you can give badges to those who have paid subscriptions through a non-blockchain service (Google Pay, etc). Or, you can access your private databases to assign badges dynamically.
* **No-Cost Updates:** If the balances URL (stored on-chain) remains the same, balances can be updated by simply editing what is returned from the server. This means balances can be updated without interacting with the blockchain and paying transaction fees.
* **Enhanced User Experience**: Users are relieved from the need to interact directly with the blockchain and incur gas fees. This streamlined user experience enhances accessibility and usability. Badges are automatically populated into a user's portfolio without the user ever executing a blockchain transaction.
* **Discardability:** Because balances are indexed off-chain, past transfer activity that is no longer relevant and needed can be permanently discarded rather than permanently stored on the blockchain and bloating it.

#### Drawbacks

* **Scalability vs. Functionality Trade-off**: While off-chain balances offer scalability and user-centric benefits, they entail trade-offs in terms of functionality and decentralization. Mainly,\
  since there are no on-chain transfers, certain on-chain functionality (such as approvals, customizable transferability, transfers w/ $BADGE, and claims) is not supported. Everything is implemented off-chain in a custom manner.
* **Centralized Trust Factor**: The URL-driven approach introduces a centralized trust element, as the blockchain has no control over the data returned by the URL or the assignment of the balances. This can be mitigated if certain criteria is met (immutable and using permanent storage like IPFS). Or, you can add additional checks against a malicious entity such as proving zkTLS data.
* **Off-Chain Balance Indexing:** Because balance updates are facilitated and indexed off-chain (if at all), there is no on-chain verifiable ledger of transfer transactions. Off-chain indexing does not sacrifice any functionality, but the accuracy and availability may not be on par with on-chain indexing.
  * Timestamping: There is no decentralized, verifiable log of EXACTLY when each balance update occurs because they occur on a hosted server. Indexers will attempt to fetch and catch each update as fast as possible, if applicable, but there is bound to be delay.
  * Loss of Historical Data: Logs of past balances may be lost forever if all parties discard / lose the data and can not be reproduced. However, this could also be a good thing as seen in the benefits.

#### Suitability of Off-Chain Balances

We envision collections adopting off-chain balances if they align with one of the following criteria:

1. **Non-Transferable / Soulbound**: If your collection's badges are intrinsically tied to specific users and are not intended for transfer ever, off-chain balances could make your collection scalability without sacrificing verifiability or centralization using permanent, immutable, and decentralized off-chain storage.
2. **Centralized Allocation Control**: In cases where a single entity should maintain complete control over badge allocation (concert tickets, diplomas, etc), the off-chain approach can be particularly beneficial.

#### Advantages Over Standard Solutions

Compared to traditional client-server non-blockchain based solutions, badge collections with off-chain balances offer numerous advantages, including:

* **Simplified Badge Management**: Outsourcing badge creation, maintenance, and verification reduces your workload.
* **Seamless Integration**: Integration with the complete suite of BitBadges tools.
* **Enhanced Security and Availability**: While balances are off-chain, the collection's core creation and foundation remain on the blockchain where it benefits from security, immutability, and availability.
* **Unified Digital Identity Building**: Users can consolidate their digital identity to their single address, eliminating fragmentation across various websites.

In conclusion, off-chain balances present an intriguing avenue to enhance scalability, user experience, and badge management. While there are considerations and trade-offs, the decision to adopt this approach hinges on your collection's specific goals and priorities. For additional resources and guidance, consult the Ecosystem page to identify suitable tools and tutorials for your use case.

**How are balances permanently frozen?**

The balances URL can be set to non-updatable via the manager permissions (**canUpdateOffChainBalancesMetadata**), and if the URL is hosted via a permanent file storage solution like IPFS, then the balances will be permanently frozen (never change) but always verifiable.

This is because the IPFS URIs are hash-based. So if the hash is permanently stored and frozen on-chain and the balances file is known, you can always verify the hash.

```json
"canUpdateOffChainBalancesMetadata": [
  {
    "timelineTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ]
  }
]
```

#### Custom Logic Implementation

Off-chain balances' updatable nature allows for the implementation of custom logic for what is returned by the URL (if not using a permanent URL). This empowers you to define and program your balance assignment process to align with your collection's unique requirements.

For example, you can dynamically revoke and assign based on if users pay their subscription fees for a month all without ever interacting with the blockchain (since the URL won't change). You simply need to just update the returned balances.

### Indexed vs Non-Indexed (On-Demand)

Off-chain balances can either be indexed or non-indexed. Note that we use non-indexed and on-demand interchangeably.

The differences are as follows:

* Indexed balances have a total verifiable supply. Non-indexed does not.
* At any time, for indexed balances, all owners and their balances are known. With non-indexed, this is not tracked, and we fetch on-demand from the source every time we need them with heavy caching.
* For indexed balances, a ledger of activity is tracked. For non-indexed, there is no ledger kept. You can only view the currently fetched balances at any given time.
* Indexed balances have a limit of unique owners (set by the indexer) for scalability reasons, whereas non-indexed has no such limit.

Technically speaking, the difference is that non-indexed balances are queried on a per-address basis and only return one balance at a time. Indexed balances return the **entire** list of owners via a JSON map when queried.

### Off-Chain - Indexed Balances

<pre class="language-json"><code class="lang-json"><strong>"balancesType": "Off-Chain - Indexed"
</strong></code></pre>

There are two options when creating off-chain balances: "Off-Chain - Indexed" and "Off-Chain - Non-Indexed".

For indexed balances, indexers are expected to do and know the following:

* Keep track of ALL owners and their balances at any given time
* Create a ledger of activity for any balance updates

We do this by the following:

* There is no enforceable total supply since everything is managed off-chain. The valid badge ID range is still specified on-chain.
* Each balances query will return a map of ALL balances for the collection. This is done via a JSON of user -> balance definitions. See below.

**What format should the balances be in?**

To facilitate the expected functionality of indexed balances, the returned balances are expected to be in a specific format. It should be a JSON object where the keys are BitBadges addresses / address list IDs and the values are Balance\<string>\[]. See [https://bitbadges-balances.nyc3.digitaloceanspaces.com/airdrop/balances](https://bitbadges-balances.nyc3.digitaloceanspaces.com/airdrop/balances).

Note that if you use address list IDs for the keys ([see here to learn more](../../core-concepts/address-lists-lists.md)), the corresponding address list must be a whitelist (whitelist = false) and stored on-chain for reproducability (not off-chain via the BitBadges servers or somewhere else).

See [here](../../bitbadges-sdk/common-snippets/off-chain-balances.md) for further info using the SDK for off-chain balances.

**How are balances refreshed on the BitBadges indexer for unfrozen off-chain collections?**

BitBadges uses a refresh queue to update balances. A refresh can be triggered via the site or the API. If the on-chain URL changes, we auto-trigger a refresh,

#### Custom Logic Implementation

Example:

```typescript
app.get('/api/v0/airdrop/balances', async (req, res) => {
    const allAirdropped = await AIRDROP_DB.list();
    const airdropped = allAirdropped.rows.map((row) => row.id);
    const balancesMap: OffChainBalancesMap<bigint> = {};
    for (const address of airdropped) {
        balancesMap[address] = [
            {
                amount: 1n,
                badgeIds: [
                    {
                        start: 1n,
                        end: 1n,
                    },
                ],
                ownershipTimes: [
                    {
                        start: 1n,
                        end: 18446744073709551615n,
                    },
                ],
            },
        ];
    }
    return res.send(balancesMap);
});
```

This dynamically updates what balances are returned from the URL based on who has received an airdrop or not (using a private airdrop database). This is all done off-chain, meaning balances are updated without a blockchain transaction (i.e. the on-chain URL stays the same as API\_URL/api/v0/airdrop/balances)/

### Off-Chain - Non-Indexed (On-Demand)

```json
"balancesType": "Off-Chain - Non-Indexed"
```

Non-indexed balances follow a similar approach to indexed balances, but there is no verifiable total supply defined on-chain. Balances are not indexed, meaning they are expected to be dynamically fetched on-demand, and there is no activity ledger recorded because of this.

At any given time, we do not know the entire list of owners and balances, unlike with indexed balances. As a result, we do not show these balances in search results like a user's portfolio by default. You have to manually fetch / calculate it, and then, we cache it to display in search results.

The benefit of this is that this approach is much more scalable to indexers. Indexers do not need to worry about caching and maintaining logs of balances. As a result, there is no limit on the number of unique owners, whereas there is a limit (currently 15000 for the BitBadges API / Indexer) for standard indexed balances.

All URIs must contain the "{address}" placeholder in the on-chain specified URI. This is to be replaced at fetch time with the user's BitBadges address. it is up to you whether you want to support native chain addresses as well, but the converted BitBadges address is a minimum requirement.

The return value from the URI should be dynamic in the following format:

```
{ balances: [....] }
```

Standard indexed balances return the whole map of user -> balances whereas non-indexed only returns the requested user's balances.

```json
"offChainBalancesMetadataTimeline": [
  {
    "timelineTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "offChainBalancesMetadata": {
      "uri": "https://api.bitbadges.io/balances/{address}",
      "customData": ""
    }
  }
]
```

The badges range on-chain (the ones via **badgeIdsToAdd**) is only used for the expected badge IDs of the collection.

#### Custom Logic Implementation

Example:

On-Chain URL: "http://localhost:3000/nonIndexed/{address}"

```typescript
app.get('/nonIndexed/:address', async (req, res) => {
  const address = req.params.address;
  const bitbadgesAddress = convertToBitBadgesAddress();

  //custom logic

  const balances: Balance<bigint>[] = [...];
  return res.status(200).send({ balances });
});
```


## File: ./for-developers/badges-advanced/balances-transfers/balances.md

# 📊 Balances

The Balance system in BitBadges is designed to represent ownership of badges across different IDs and time ranges. This document explains the Balance interface and how to interpret complex balance structures.

Ownership times are a new concept to BitBadges allowing you to set that someone owns a badge during a specific time but not other times.

### Balance Interface

```typescript
export interface Balance<T extends NumberType> {
  amount: T;
  badgeIds: UintRange<T>[];
  ownershipTimes: UintRange<T>[];
}
```

* `amount`: The quantity of badges owned.
* `badgeIds`: An array of ID ranges representing the badges owned.
* `ownershipTimes`: An array of time ranges during which the badges are owned.

### Interpreting Balances

When interpreting balances, it's crucial to understand that multiple ranges of badge IDs and ownership times within a single Balance structure represent all possible combinations.

#### Interpretation Algorithm

```javascript
for (balance of balances) {
  for (badgeIdRange of balance.badgeIds) {
    for (ownershipTimeRange of balance.ownershipTimes) {
      // User owns x(balance.amount) of (badgeIdRange) for the times (ownershipTimeRange)
    }
  }
}
```

#### Example

Consider the following balance:

```json
{
  "amount": 1,
  "badgeIds": [{ "start": 1, "end": 10 }, { "start": 20, "end": 30 }],
  "ownershipTimes": [{ "start": 20, "end": 50 }, { "start": 100, "end": 200 }]
}
```

This balance expands to:

1. 1x of IDs 1-10 from times 20-50
2. 1x of IDs 1-10 from times 100-200
3. 1x of IDs 20-30 from times 20-50
4. 1x of IDs 20-30 from times 100-200

### Balance Subtraction

When subtracting balances, you may need to represent the result as multiple Balance objects. For example, if we subtract the first set of balances from the example above (1x of IDs 1-10 from times 20-50), the result would be:

```json
[
  {
    "amount": 1,
    "badgeIds": [{ "start": 1, "end": 10 }, { "start": 20, "end": 30 }],
    "ownershipTimes": [{ "start": 100, "end": 200 }]
  },
  {
    "amount": 1,
    "badgeIds": [{ "start": 20, "end": 30 }],
    "ownershipTimes": [{ "start": 20, "end": 50 }]
  }
]
```

### Handling Duplicates

When duplicate badge IDs are specified in balances, they are combined and their amounts are added. For example:

```json
{
  "amount": 1,
  "badgeIds": [{ "start": 1, "end": 10 }, { "start": 1, "end": 10 }],
  "ownershipTimes": [{ "start": 100, "end": 200 }]
}
```

This is equivalent to and will be treated as:

```json
{
  "amount": 2,
  "badgeIds": [{ "start": 1, "end": 10 }],
  "ownershipTimes": [{ "start": 100, "end": 200 }]
}
```

### Best Practices

1. **Efficient Representation**: Try to represent balances in the most compact form possible by combining overlapping ranges.
2. **Careful Subtraction**: When subtracting balances, ensure that you correctly split the remaining balances to accurately represent the result.
3. **Avoid Duplicates**: While the system handles duplicates by combining them, it's more efficient to represent balances without duplicates in the first place.
4. **Time-Aware Operations**: Always consider the time dimension when performing operations on balances, as ownership can vary over time.
5. **Range Calculations**: Familiarize yourself with range operations, as they are crucial for correctly manipulating and interpreting balances.

By understanding these concepts and following these practices, you can effectively work with the BitBadges balance system, enabling complex ownership structures and time-based badge management.


## File: ./for-developers/badges-advanced/balances-transfers/creating-badges.md

# ➕ Valid Badge IDs

#### badgeIdsToAdd / validBadgeIds

* Regardless of balance storage method, the range of valid badge IDs (e.g., 1-100) must be defined on-chain in the core collection details.&#x20;
* Once an ID is added, it cannot be unadded. IDs must start at 1 and have no gaps.
* This range is specified during collection creation or update. Updates must obey the **canUpdateValidBadgeIds** permission, which can freeze or permit adding certain IDs.
* Note this is separate from the circulating supply. The circulating supply is managed through on-chain transfers / approvals or off-chain allocations (whichever is applicable). The circulating supply must obey the valid badge IDs defined on-chain.

**Creating Badges**

During creation and update transaction ([MsgCreateCollection](../../bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgcreatecollection.md) and [MsgUpdateCollection](../../bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgupdatecollection.md)), you can specify the badge IDs ranges that are valid via the **badgeIdsToAdd** field.

**Example**

```json
{
  "creator": "bb1kfr2xajdvs46h0ttqadu50nhu8x4v0tc2wajnh",
  ...
  "badgeIdsToAdd": [
      {
        "start": "1",
        "end": "100"
      }
  ],
  ...
  "collectionPermissions": {
    "canUpdateValidBadgeIds": [....],
    ...
  }
}
```


## File: ./for-developers/badges-advanced/balances-transfers/transferability-approvals.md

# 🤝 Transferability / Approvals

First, read [Transferability ](broken-reference)for an overview of approved transfers.

Note: The [Approved Transfers](transferability-approvals.md) and [Permissions ](broken-reference)are the most powerful features of the interface, but they can also be the most confusing. Please ask for help if needed.

Collections with "Off-Chain" balances and address lists do not utilize on-chain transferability, so this page is not applicable to them.

## Approvals Overview

### Approval Levels - Collection, Incoming, Outgoing

Approved transfers encompass three hierarchical levels: collection, incoming, and outgoing, as previously elaborated. The interfaces for these three levels share common elements, with slight variations in functionality:

* Incoming approvals exclude the "to" fields as they are automatically populated with the recipient's address.
* Outgoing approvals omit the "from" fields, as they are automatically filled with the sender's address.
* The collection level holds the capacity to override user-level (incoming / outgoing) approvals, but not vice versa.

**For a transfer to be approved, it has to satisfy the collection-level approvals, and if not overriden forcefully by the collection-level approvals, the user incoming / outgoing also have to be satisfied.**

<figure><img src="../../../.gitbook/assets/image (33).png" alt=""><figcaption></figcaption></figure>

### Approvals != Escrows

When it comes to approved transfers, it's important to note that they are just approvals and may not necessarily correspond directly to underlying balances. Approvers must ensure that sufficient balances are available to uphold the approvals' integrity, accounting for potential revokes or freezes. This responsibility extends to the collection-level transferability as well.

On a similar note, if approvals become no longer valid (such as approving a badge but it was revoked via a different approval), the former approval doesn't automatically get cancelled. It is the approver's responsibility to handle them accordingly.

### Mint - Unlimited Balances

For on-chain balances, the Mint address has unlimited balances. So, it is extra critical to set these approvals correctly.

The Mint address does not have incoming / outgoing approvals that can be controlled. For all Mint approvals, they must forcefully override the user-level outgoing approval because it cannot be managed.

### Representation

In the collection interface, they are represented as the following:

```json
{
    ...
    "collectionApprovals": [{ ... }, ...]
    ...
}
```

```typescript
export interface CollectionApproval<T extends NumberType> {
  toListId: string;
  fromListId: string;
  initiatedByListId: string;
  transferTimes: UintRange<T>[];
  badgeIds: UintRange<T>[];
  ownershipTimes: UintRange<T>[];
  approvalId: string;

  uri?: string;
  customData?: string;
  
  approvalCriteria?: ApprovalCriteria<T>;
}
```

Note; User incoming / outgoing approvals follow the same interface except **toList** is auto-populated with the user's address for incoming approvals and similarly the **fromList** for outgoingApprovals.

**Approved vs Unapproved**

Approvals are simply a set of criteria, so it is entirely possible the same transfer could satisfy multiple approvals on the same level.

We handle approvals per level in the following manner:

1. If the transfer is unhandled (doesn't match to any approval), it is DISAPPROVED by default.
2. If the transfer matches to multiple approvals, we take first-match (linear scan of array) by default. However, we allow the user to specify **prioritizedApprovals** and **onlyCheckPrioritizedApprovals** (in [MsgTransferBadges](../../bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgtransferbadges.md)) when transferring, so they can only use up their desired approvals.

We strongly recommend designing approvals in a way where no transfer can map to multiple. This improves the simplicity and readability of your collection, and users will never need the added complexity of **prioritizedApprovals** or **onlyCheckPrioritizedApprovals.**

**Who? When? What? - Main Fields**

To represent transfers, six main fields are used: **`toList`**, **`fromList`**, **`initiatedByList`**, **`transferTimes`**, **`badgeIds`**, and **`ownershipTimes`**. These fields collectively define the transfer details, such as the addresses involved, timing, and badge details. This representation leverages range logic, breaking down into individual tuples for enhanced comprehension.

* **toList, fromList, initiatedByList**: [AddressLists](../../core-concepts/address-lists-lists.md) specifying which addresses can send, receive, and initiate the transfer. If we use **toListId, fromListId, initiatedByListId**, these refer to the lists IDs of the respective lists. IDs can either be reserved IDs (see [AddressLists](../../core-concepts/address-lists-lists.md)) or IDs of lists created on-chain through [MsgCreateAddressLists](../../bitbadges-blockchain/cosmos-sdk-msgs/). Note that on-chain approvals cannot access off-chain lists.
* **transferTimes**: When can the transfer takes place? A [UintRange](../../core-concepts/uint-ranges.md)\[] of times (UNIX milliseconds).
* **badgeIds**: What badge IDs can be transferred? A [UintRange](../../core-concepts/uint-ranges.md)\[] of badge IDs.
* **ownershipTimes**: What ownership times for the badges are being transferred? (UNIX milliseconds)

For example, we might have something like the following:

* ```json
  "fromListId": "Mint", //reserved list ID for the "Mint" addres
  "toListId": "All", //reserved list ID for all addresses (excluding "Mint")
  "initiatedByListId": "All",
  "transferTimes": [
    {
      "start": "1691931600000",
      "end": "1723554000000"
    }
  ],
  "ownershipTimes": [
    {
      "start": "1",
      "end": "18446744073709551615" //Max possible value
    }
  ],
  "badgeIds": [
    {
      "start": "1",
      "end": "100"
    }
  ],
  ```

Let's break down the definition above.

* The "Mint" list ID is the reserved list corresponding to the Mint address. This approval only allows transfers from the "Mint" address. The transfer can be initiated by any user (because the AddressList "All" includes all addresses) and can have any address as the recipient.
* The ownership rights for any time of badge IDs 1-100 can be transferred from UNIX time 1691931600000 (Aug 13, 2023) to time 1723554000000 (Aug 13, 2024).

Note the approval only applies to the details defined and must match ALL details. For example, badge ID #101 is not defined by this approval even if all other criteria matches.

**Transferring From Mint Address**

As mentioned before, we check the collection level approvals first, and if not overriden, we check the user-level incoming/outgoing approvals.

The Mint address is a special case. It technically has its own approvals, but since it is not a real address, the user approvals are always empty and never usable. Thus, it is important that when you attempt transfers from the Mint address, you **override the outgoing approvals** of the Mint address (see [Overrides](approval-criteria/#overrides) on the next page for how).

It is also recommended that when dealing with approvals from the "Mint" address, the approval's **fromList** is only the "Mint" address and no other address. This helps readability and simplicity and avoiding unintentionally approving users to mint, which could be very bad. See Example 2 below.

Again, remember the Mint address has unlimited balances.

#### Approval IDs

All approvals must have a unique **approvalId** for identification per level. This is simply used for identification.

```json
{
    ...
    "approvalId": "abc123",
}
```

**Metadata**

We provide an optional **uri** and **customData** to allow you to add a link to something about your approval. See [Compatibility](../../bitbadges-api/concepts/designing-for-compatibility.md) for the expected format for the BitBadges API / Indexer.

This can typically be used for providing names, descriptions about your approvals. Or, we also use it to host N - 1 layers of a Merkle tree for a Merkle challenge of codes (N - 1 to be able to construct the path but not give away the value of leaves which are to be secret). Or, for whitelist trees where no leaves are secret, we can host the full tree. Learn more in the approval criteria merkle challenges section.

#### Approval Criteria

The **`approvalCriteria`** section corresponds to additional restrictions or challenges necessary to be satisfied for approval. It defines aspects like the quantity approved, maximum transfers, and more. There is a lot here, so we have dedicated a page to just explaining the [approval details here](approval-criteria/).

For the rest of this page, you can simply think of it as the challenges or restrictions that need to be obeyed to be approved.

**Breaking Down Range Logic**

Even though our interface uses range logic (UintRanges, AddressLists), you can think of it as we break everything down into single-value tuples (e.g., `(bob, alice, bob, 1, 1, 1000)`) and check each singular value tuple separately. This simplifies the matching process and enhances clarity.

#### Matching Transfers to Approvals

The process of matching transfers to approvals involves several steps. This is done on a per-level basis.

1. We start with the collection-level approvals.
2. Expand all approval tuples with range logic (AllWithMint, ...., \[IDs 1-100]) to singular tuple values (e.g. (bob, alice, bob, badge ID #1, ....)
3. Expand the current transfer tuple to singular tuple values.
4. Find all matches (for approvals, linear first match by default but can be customized with **prioritizedApprovals** and **onlyCheckPrioritizedApprovals**).
   1. If anything is unhandled on any approval level (accounting for overrides), the overall transfer is disapproved.
   2. In the case of overflowing approvals (e.g. we are transferring x10 but have two approvals for x3 and x12), we deduct as much as possible from each one as we iterate. So using the previous example, we would end up with x3/3 of the first approval used and x7/12 of the second used.
   3. We check the **`approvalCriteria`** for each match and ensure everything is satisfied. If not, it is not a match.
5. For any amounts / balances that were approved but do not override incoming / outgoing approvals respectively, we go back to step 2 and check the recipient's incoming approvals and the senders' outgoing approvals for those balances.

### Defaults and Auto Approvals

**Auto Approvals**

If **autoApproveSelfInitiatedOutgoingTransfers** is set to true, we automatically apply an unlimited approval (with no amount restrictions) to the user's outgoing approvals when the sender is the same as the initiator.

If **autoApproveSelfInitiatedIncomingTransfers** is set to true, we automatically apply an unlimited approval (with no amount restrictions) to the user's incoming approvals when the recipient is the same as the initiator.

In 99% of cases, the auto approvals should be true because the expected functionality is that if the user is initiating the transaction, they also approve it. However, this can be turned off and leveraged for specific use cases such as using an account for an escrow.

**Defaults**

We allow the collection to define default values for each user, and when the user first interacts with the collection, they will start with these values. The defaults include **balances**, **outgoingApprovals**, **incomingApprovals**, **autoApproveSelfInitiatedOutgoingTransfers,** and **autoApproveSelfInitiatedIncomingTransfers.**

For default balances, we refer you to the balance types and creating badges sections (i.e. these are the starting balances).

**Default Outgoing Approvals**

For outgoing approvals, the expected functionality is that everything is disapproved by default unless self initiated. Thus, the following is the typical default values.

```
"defaultOutgoingApprovals": [],
"autoApproveSelfInitiatedOutgoingTransfers": true
```

**Default Incoming Approvals - Forceful Transfers vs Opt-In Only**

However, with incoming approvals, the expected functionality is slightly different. There are a couple options. Do you want users to be able to transfer "forcefully" to an address without prior approval by default? Or, do you want users to have to self-initiate / opt-in first to receive badges?

In order to allow forceful transfers to an address without prior approval, the **incomingApprovals** must be set to something like below. Otherwise, if empty or \[], then all transfers must be initiated by or manually approved by the recipient by default (opt-in only).

```json
//"forceful" is allowed
"defaultIncomingApprovals": [
    {
      "fromListId": "AllWithMint",
      "initiatedByListId": "AllWithMint",
      "transferTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "badgeIds": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "ownershipTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "approvalId": "forceful-transfers-allowed"
    }
  ]
```

### **Approval Value vs Permission**

While the value may seem similar to the approval update permissions, the permission corresponds to the **updatability** of the approvals (i.e. **canUpdateCollectionApprovals**). The approvals themselves correspond to if a transfer is currently approved or not.

**Example**

Current Value - IDs 1-10 are approved

Permission - IDs 1-5 cannot be updated, 6-10 can

### **Example 1 - Putting It Together**

Bob is transferring x10 of **ownershipTimes** 1-Max of **badgeIds** 1-2 at time T to Alice.

#### Transfer Request:

Transfer: `(Bob, Alice, Bob, T, [1-2], [1-Max])`

#### Collection Approved Transfers:

1. `(Bob, Alice, Bob, T, [1-2], [1000-2000]) -> APPROVED`
2. `(Bob, Alice, All, T, [1-2], [1-2000]) -> APPROVED`
3. `(Bob, Alice, All, T, [1-2], [2001-Max]) -> APPROVED`

Let's say each approval has no amount restriction but does not override the user level incoming / outgoing approvals.

In this scenario, let's say the default "first match" approach is used:

1. The first approved transfer `(Bob, Alice, Bob, T, [1-2], [1000-2000])` matches the transfer request partially, but it only covers **ownershipTimes** from 1000 to 2000. We deduct this overlap but still have a lot remaining to be approved for (\[1-999], \[2001-Max]).
2. The second approved transfer `(Bob, Alice, All, T, [1-2], [1-2000]),` again partially matches, and we deduct. This partial match only handles 1-999 because we handled 1000-2000 already. Note that this approval says it can be initiated by "All" instead of Bob, but Bob's address is within the "All" list.
3. The third approved transfer `(Bob, Alice, All, T, [1-2], [1001-Max])` covers the rest. This transfer is approved on the collection level because the entire transfer was handled.

If Bob was requesting badge ID 3 to be transferred as well, it would fail because badge ID 3 is unhandled by all defined approvals (and disallowed by default if unhandled).

**Outgoing Approvals**

Because we did not override the user level approvals, we need to check that Bob approved this transfer in his approvals.

The process above would then be repeated for Bob's outgoing approvals. In this case, Bob is the initiator, so we automatically add an unlimited approval by default (see below).

**Incoming Approvals**

Likewise, we also need to check Alice's incoming approvals using the same process.

**Satisfied?**

If all levels are satisfied, the transfer is approved, and we deduct/increment the used approvals where necessary.

**Extending the Example: Prioritized Approvals**

Let's say that Bob only wants to use the second and third approvals from the collection level but not the first. By default, a first-match policy is applied, so it would by default use the first one as shown above.

When initiating the transfer (MsgTransferBadges), Bob can set **prioritizedApprovals** to be the second and third collection approvals. These would then be checked first, followed by the first approval.

If Bob additionally sets **onlyCheckPrioritizedApprovals** = true, we only check the ones specified in **prioritizedApprovals**.

### Example 2 - Collection

This would define a collection where badges 1-100 can be transferred from the Mint address (according to the first approval). Once transferred out of the Mint address, they can be transferred freely, thus making the collection transferable.

Note how the **fromList** of each approval are non-overlapping, so any transfer will only match to one of the two approvals (if either). The first approval is restricted to transfers from the Mint address whereas the second is all EXCEPT the Mint address.

```json
 "collectionApprovals": [
    {
      "fromListId": "Mint",
      "toListId": "AllWithMint",
      "initiatedByListId": "AllWithMint",
      "transferTimes": [
        {
          "start": "1691931600000",
          "end": "1723554000000"
        }
      ],
      "ownershipTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "badgeIds": [
        {
          "start": "1",
          "end": "100"
        }
      ],
      "approvalId": "claim-from-mint-address",
      ... //other criteria (including the IMPORTANT overrideFromOutgoingApprovals = true since we are dealing with transfers from the Mint address)
    },
    {
      "fromListId": "AllWithoutMint",
      "toListId": "AllWithoutMint",
      "initiatedByListId": "AllWithoutMint",
      "badgeIds": [
        {
          "start": "1",
          "end": "100"
        }
      ],
      "ownershipTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "transferTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "approvalId": "transferable"
    }
  ],
```

### Example 3 - Outgoing Approvals

This would set approve Charlie to send badges to Bob on this user's behalf.

```json
"outgoingApprovals": [
  {
    "toListId": "Bob",
    "initiatedByListId": "Charlie",
    "transferTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "badgeIds": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "ownershipTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "approvalId": "test",
    //see next page
    "approvalCriteria": //define approval criteria (how much? challenges? etc here)
  }
]
```

### Example 4 - Incoming Approvals

This would set approve this user to receive any transfer from Bob.

```json
"incomingApprovals": [
  {
    "fromListId": "Bob",
    "initiatedByListId": "AllWithMint",
    "transferTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "badgeIds": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "ownershipTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "approvalId": "test",
  }
]
```


## File: ./for-developers/badges-advanced/different-time-fields.md

# Different Time Fields

BitBadges uses various time-related fields to manage permissions, timelines, transfers, and ownership. Understanding these fields is crucial for effectively managing collections and badges.

### Time Representation

All times in BitBadges are represented as UNIX time, which is the number of milliseconds elapsed since the epoch (midnight at the beginning of January 1, 1970, UTC).

### Time Field Types

#### 1. permanentlyPermittedTimes

* Purpose: Defines the times when a permission will always be executable.
* Usage: Setting allowed periods for specific actions.

#### 2. permanentlyForbiddenTimes

* Purpose: Defines the times when a permission will always be forbidden.
* Usage: Setting restricted periods for specific actions.

#### 3. timelineTimes

* Purpose: Specifies when a field is scheduled to have a specific value in a timeline-based field.
* Usage: Scheduling changes to collection or badge properties over time.

#### 4. transferTimes

* Purpose: Defines when a transfer transaction can occur.
* Usage: Setting periods when badges can be transferred between addresses.

#### 5. ownershipTimes

* Purpose: Specifies the times that a user owns a badge.
* Usage: Defining the duration of badge ownership for users.

### Important Note

The `timelineTimes` in permissions correspond to the updatability of the timeline, while `timelineTimes` in the actual timeline represent the actual times for the values.

### Examples

#### Example 1: Presidential Election Badges

Scenario: Users participate in a US presidential election by casting votes through badge transfers.

* T1: Conclusion of voting
* T2: Start of presidential term
* T3: End of presidential term

Setup:

* `transferTimes`: \[{ start: T1, end: T2 }] (President badge can be transferred after voting concludes)
* `ownershipTimes`: \[{ start: T2, end: T3 }] (Defines the presidential term)

#### Example 2: Managing Collection Archival

Scenario: A collection can be optionally archived by the manager from T1 to T2, but is non-archivable at all other times.

Before archiving:

```
Permission:
permanentlyPermittedTimes: [{ start: T1, end: T2 }]
permanentlyForbiddenTimes: [everything but T1 to T2]
timelineTimes: [{ start: 1, end: MAX_TIME }]

Archived Timeline:
isArchived: false for [{ start: 1, end: MAX_TIME }]
```

After archiving for all times:

```
Permission: (unchanged)
permanentlyPermittedTimes: [{ start: T1, end: T2 }]
permanentlyForbiddenTimes: [everything but T1 to T2]
timelineTimes: [{ start: 1, end: MAX_TIME }]

Archived Timeline:
isArchived: true for [{ start: 1, end: MAX_TIME }]
```

#### Example 3: Permanently Locking Permissions

Scenario: Continuing from Example 2, the manager wants to permanently lock the permission.

Final state:

```
Permission:
permanentlyPermittedTimes: []
permanentlyForbiddenTimes: [{ start: 1, end: MAX_TIME }]
timelineTimes: [{ start: 1, end: MAX_TIME }]

Archived Timeline:
isArchived: true for [{ start: 1, end: MAX_TIME }]
```

### Best Practices

1. **Clear Timelines**: Always define clear and non-overlapping time ranges for each field to avoid confusion and conflicts.
2. **Permission Management**: Carefully consider the implications of setting `permanentlyPermittedTimes` and `permanentlyForbiddenTimes`, as these can significantly impact the flexibility of your collection.
3. **Timeline Planning**: When using `timelineTimes`, plan your collection's lifecycle in advance to minimize the need for frequent updates.
4. **Transfer Windows**: Use `transferTimes` to create specific windows for badge transfers, which can be useful for time-limited events or phased distributions.
5. **Ownership Tracking**: Leverage `ownershipTimes` to create badges with time-bound ownership, useful for temporary privileges or rotating responsibilities.
6. **Permission Locking**: Be cautious when permanently locking permissions (as in Example 3), as this action is irreversible and may limit future flexibility.
7. **Time Synchronization**: Ensure all systems interacting with your BitBadges collection are properly time-synchronized to avoid discrepancies in time-based operations.

By understanding and effectively using these time fields, you can create sophisticated and dynamic badge systems in BitBadges, enabling complex scenarios from voting systems to time-bound privileges and beyond.


## File: ./for-developers/badges-advanced/list-ids.md

# List IDs

As you may have noticed, we use a list ID system for the from, to, and initiatedBy in the collection approval interfaces.&#x20;

```typescript
{
    ...restOfApproval,
    "fromListId": "Mint",
    "initiatedByListId": "bb1..."
}
```

A summary is:

* These can either be registered on-chain as a reusable list with an ID and referenced
* They can follow a specific pattern for reserved IDs.&#x20;
  * Plain addresses (BitBadges supported only) as-is
  * Separate multiple addresses in list with a :
  * Prefix with a ! for inversion (blacklist)

```
Mint
```

```
bb1...:bb1....
```

Learn more

{% content-ref url="../core-concepts/address-lists-lists.md" %}
[address-lists-lists.md](../core-concepts/address-lists-lists.md)
{% endcontent-ref %}



## File: ./for-developers/badges-advanced/metadata.md

# Metadata

BitBadges allows defining metadata for both collections and individual badges using `collectionMetadataTimeline` and `badgeMetadataTimeline` respectively. Both timelines follow the same metadata interface, but with slight differences in implementation.

Other interfaces like lists, maps, etc will also have a corresponding metadata field that follows the same interface.

### Metadata Timelines

#### Collection Metadata Timeline

The `collectionMetadataTimeline` defines metadata for the entire collection over time.

Example:

```json
"collectionMetadataTimeline": [
  {
    "timelineTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "collectionMetadata": {
      "uri": "ipfs://Qmf8xxN2fwXGgouue3qsJtN8ZRSsnoHxM9mGcynTPhh6Ub",
      "customData": ""
    }
  }
]
```

#### Badge Metadata Timeline

The `badgeMetadataTimeline` defines metadata for individual badges over time. The order of `badgeMetadata` entries matters, as it uses a first-match approach via linear scan for specific badge IDs.

Example:

```json
"badgeMetadataTimeline": [
  {
    "timelineTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "badgeMetadata": [
      {
        "uri": "ipfs://Qmf8xxN2fwXGgouue3qsJtN8ZRSsnoHxM9mGcynTPhh6Ub/{id}",
        "badgeIds": [
          {
            "start": "1",
            "end": "10000000000000"
          }
        ],
        "customData": ""
      }
    ]
  }
]
```

### Metadata Interface

The BitBadges API, Indexer, and Site expect metadata to follow this format by default:

```typescript
export interface Metadata<T extends NumberType> {
  name: string;
  description: string;
  image: string;
  video?: string;
  category?: string;
  externalUrl?: string;
  tags?: string[];
  socials?: {
    [key: string]: string;
  }
  offChainTransferabilityInfo?: {
    host: string
    assignMethod: string
  }
}
```

#### Key Points:

1. **Dynamic Badge ID**: If the badge metadata URI includes `"{id}"`, it's replaced with the actual badge ID. For example, `"...abc.com/metadata/{id}"` becomes `"...abc.com/metadata/1"` for badge ID 1.
2. **Off-Chain Balances**: For collections hosting balances off-chain, you can specify details about where they are hosted and how they are assigned using the `offChainTransferabilityInfo` field.

### Best Practices

1. **Ordering**: For `badgeMetadataTimeline`, arrange entries from most specific to least specific, as the first match is used.
2. **URI Design**: Use the `{id}` placeholder in badge metadata URIs for dynamic content generation.
3. **Comprehensive Metadata**: Provide as much relevant information as possible in the metadata to enhance the user experience and discoverability of your badges.
4. **Time Ranges**: Ensure that your time ranges cover all possible times to avoid gaps where metadata might be undefined.
5. **Off-Chain Info**: If using off-chain balance management, clearly specify the host and assignment method in the `offChainTransferabilityInfo` field.

By following these guidelines and utilizing the flexible metadata structure provided by BitBadges, you can create rich, dynamic, and informative badge collections.


## File: ./for-developers/badges-advanced/overview.md

# Overview

This section is a knowledge dump for more advanced use cases and how badges operate behind the scenes.  For most use cases, you will not care about any of this as it will be handled for you via the site. And if you are self-implementing a badge-gated service, you can just fetch badge balances and metadata from the API without worrying about the underlying details.

```typescript
const res = await BitBadgesApi.getBadgeBalanceByAddress(collectionId, address, { ...options });
console.log(res);

const res = await BitBadgesApi.getBadgeMetadata(1, 5);
```

{% content-ref url="../bitbadges-api/" %}
[bitbadges-api](../bitbadges-api/)
{% endcontent-ref %}

This section will go into more advanced details like the badge interface, how it operates via the blockchain, how approvals are implemented, etc.


## File: ./for-developers/badges-advanced/permissions/README.md

# Permissions



## File: ./for-developers/badges-advanced/permissions/action-permission.md

# Action Permission

ActionPermissions are the simplest (no criteria). Just denotes what times the action is executable or not.

<pre class="language-json"><code class="lang-json"><strong>"collectionPermissions": {
</strong>    "canDeleteCollection": [...],
    ...
}
</code></pre>

```json
"userPermissions": {
    ...
    "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [...],
    "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [...],
}
```

```typescript
export interface ActionPermission<T extends NumberType> {
  permanentlyPermittedTimes: UintRange<T>[];
  permanentlyForbiddenTimes: UintRange<T>[];
}
```

**Examples**

Below, this forbids the action from ever being executed.

```json
"canDeleteCollection": [
  {
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
  }
]
```


## File: ./for-developers/badges-advanced/permissions/balances-action-permission.md

# Badge IDs Action Permission

The BadgeIdsAction permission denotes for what (badge ID, ownership times), can an action be executed? For example, can I create more of badge ID 1-10?

This permission refers to the UPDATABILITY of the balances and has no bearing on what the circulating supplys are currently set to.

```json
"collectionPermissions": {
    "canUpdateValidBadgeIds": [...],
    ...
}
```

```typescript
export interface BadgeIdsActionPermission<T extends NumberType> {
  badgeIds: UintRange<T>[];
  
  permanentlyPermittedTimes: UintRange<T>[];
  permanentlyForbiddenTimes: UintRange<T>[];
}
```

{% content-ref url="../balances-transfers/creating-badges.md" %}
[creating-badges.md](../balances-transfers/creating-badges.md)
{% endcontent-ref %}

```json
"canUpdateValidBadgeIds": [
  {
    "badgeIds": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ]
  }
]
```


## File: ./for-developers/badges-advanced/permissions/overview.md

# Overview

First, read [Permissions](broken-reference) for an overview.

Note: The [Approved Transfers](../balances-transfers/transferability-approvals.md) and [Permissions ](broken-reference)are the most powerful features of the interface, but they can also be the most confusing. Please ask for help if needed.

```json
"collectionPermissions": {
    ...
}
```

```json
"userPermissions": {
    ...
}
```

### Collection Permissions

#### Manager

The collectionPermissions only apply to the current manager of the collection. In other words, the manager is the only one who is able to execute permissions. If there is no manager for a collection, no permissions can be executed.

The current manager is determined by the **managerTimeline.** Transferring the manager is facilitated via the **canUpdateManager** permission.

```json
"managerTimeline": [
  {
    "manager": "bb1kfr2xajdvs46h0ttqadu50nhu8x4v0tc2wajnh",
    "timelineTimes": [
      {
        "start": 1,
        "end": "18446744073709551615"
      }
    ]
  }
]
```

### **User Permissions**

Besides the collection permissions, there are also userPermissions that can be set. Typically, these will remain empty / unset, so that the user can always have full control over their approvals. If empty, they are permitted by default (but not frozen).

However, setting user permissions can be leveraged in some cases for specific purposes.

* Locking that a specific badge can never be transferred out of the account
* Locking that a specific approval is always set and uneditable so that two mutually distrusting parties can use the address as an escrow

**Defaults**

We also give the option for the collection to define default user permissions. These will be used as the starting values when the balance is initially created in storage. This can be used in tandem with the other defaults. The default permissions are also not typically used, but again can be used in certain situations. For example, by default, approve all incoming transfers and lock the permission so all transfers always have incoming approvals and can never be disapproved.

### **Permitted and Forbidden Times**

Permissions allow you to define permitted or forbidden times to be able to execute a permission.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**States**

There are three states that a permission can be in at any one time:

1. **Forbidden + Permanently Frozen (permanentlyForbiddenTimes):** This permission is forbidden and will always remain forbidden.
   1. If a permission is explicitly allowed via the **permanentlyPermittedTimes, it will ALWAYS be allowed** during those permanentlyPermittedTimes (can't change it).
2. **Permitted + Not Frozen (Unhandled):** This permission is currently permitted but can be changed to one of the other two states.
   1. If not explicitly permitted or forbidden - NEUTRAL (not defined or unhandled), **permissions are ALLOWED by default** but can later be set to be permanently allowed or disallowed. There is no "forbidden currently but updatable" state.
3. **Permitted + Permanently Frozen (permanentlyPermittedTimes):** This permission is forbidden and will always remain permitted
   1. If a permission is explicitly forbidden via the **permanentlyForbiddenTimes, it will ALWAYS be disallowed** during those permanentlyForbiddenTimes.

There is no forbidden + not frozen state because theoretically, it could be updated to permitted at any time and executed (thus making it permitted).

**Examples**

This means the permission is permanently forbidden and frozen.

```typescriptreact
permanentlyPermittedTimes: []
permanentlyForbiddenTimes: [{ start: 1, end: GO_MAX_UINT_64 }]
```

This means it is permanently allowed and frozen.

```typescriptreact
permanentlyForbiddenTimes: []
permanentlyPermittedTimes: [{ start: 1, end: GO_MAX_UINT_64 }]
```

This means it is allowed currently but neutral and can be changed to be always permitted or always forbidden in the future.

```
permanentlyForbiddenTimes: []
permanentlyPermittedTimes: []
```

### First Match Policy

All permissions are a linear array where each element may have some criteria as well as **permanentlyForbiddenTimes** or **permanentlyPermittedTimes.** It can be interpreted as if the criteria matches, the permission is permitted or forbidden according to the defined times, respectively.

We do not allow times to be in both the permanentlyPermittedTimes and permanentlyForbiddenTimes array simultaneously.

**Unlike approvals, we only allow taking the first match in the case criteria satisfies multiple elements in the permissions array.** All subsequent matches are ignored. This makes it so that for any time and for each criteria combination, there is a deterministic permission state (permitted, forbidden, or neutral). This means you have to carefully design your permissions because order and overlaps matter.

Ex: If we have the following permission definitions in an array \[elem1, elem2]:

1. ```
   timelineTimes: [{ start: 1, end: 10 }]

   permanentlyPermittedTimes: []
   permanentlyForbiddenTimes: [{ start: 1, end: 10 }]
   ```
2. ```
   timelineTimes: [{ start: 1, end: 100 }]

   permanentlyForbiddenTimes: []
   permanentlyPermittedTimes: [{ start: 1, end: GO_MAX_UINT_64 }]
   ```

In this case, the timeline times 1-10 will be forbidden ONLY from times 1-10 because we take the first element that matches for that specific criteria (which is permanentlyPermittedTimes: \[], permanentlyForbiddenTimes: \[1 to 10]).

Times 11-100 would be permanently permitted since the first match for those times is the second element.

Similar to approved transfers, even though we allow range logic to be specified, we first expand everything maintaining order to their singular values (one value, no ranges) before checking for our first match.

### Satisfying Criteria

For permissions, all criteria must be satisfied for it to be a match. If you satisfy N-1 criteria, it is not a match.

For example, lets say you had a permission with badge IDs and ownership times:

```
badgeIds: [{ start: 1, end: 10 }]
ownershipTimes: [{ start 1, end: 10 }]

permanentlyForbiddenTimes: []
permanentlyPermittedTimes: [{ start: 1, end: GO_MAX_UINT_64 }]
```

This would result in the manager being able to create more of badges IDs 1-10 which can be owned from times 1-10.

However, this permission **does not** specify whether they can create more of badge ID 1 at time 11 or badge ID 11 at time 1. These combinations are considered unhandled or not defined by the permission definition above.

**Common Misunderstanding**

A common misunderstanding is that if the permission below is appended after the above one, this would forbid badges 11+ from ever being created. However, creating badge IDs 11+ at times 11+ would still be unhandled and **allowed by default**.

```
badgeIds: [{ start: 11, end: Max }]
ownershipTimes: [{ start 1, end: 10 }]

permanentlyForbiddenTimes: [{ start: 1, end: GO_MAX_UINT_64 }]
permanentlyPermittedTimes: []
```

To permanently forbid all badgeIds, you must brute force ALL other combinations such as

```
badgeIds: [{ start: 11, end: Max }]
ownershipTimes: [{ start: 1, end: Max }] // 1-10 never gets matched to bc of first match
//can also do start: 11

permanentlyForbiddenTimes: [{ start: 1, end: GO_MAX_UINT_64 }]
permanentlyPermittedTimes: []
```

**Brute-Forcing**

A common pattern you will see is to brute force all possible combinations. For example, in the above example we brute forced all possible combinations for badge IDs 11+. No subsequent element specifying a badge ID 11+ will ever get matched to.

To brute force a specific criteria (such as IDs 11+), you specify it, then for all other N - 1 criteria, you set them equal to ALL values. All values in the case of UintRanges is 1 - max Uint64. For address lists / IDs, this is all possible addresses / IDs.

The following brute forces badge IDs 1-10.

<pre class="language-json"><code class="lang-json"><strong>{
</strong>  "fromListId": "All",
  "toListId": "All",
  "initiatedByListId": "All",
  "badgeIds":  [{ "start": "1", "end": "10" }],
  "transferTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "ownershipTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "approvalId": "All", //forbids approval "xyz" from being updated

  "permanentlyPermittedTimes": [],
  "permanentlyForbiddenTimes": [{ "start": "1", "end": "18446744073709551615" }]
}
</code></pre>

### **Permission Categories**

There are five categories of permissions, each with different criteria that must be matched with. If you get confused with the different time types, refer to [Different Time Types](../different-time-fields.md) for examples and explanations.

{% content-ref url="action-permission.md" %}
[action-permission.md](action-permission.md)
{% endcontent-ref %}

{% content-ref url="timed-update-permission.md" %}
[timed-update-permission.md](timed-update-permission.md)
{% endcontent-ref %}

{% content-ref url="timed-update-with-badge-ids-permission.md" %}
[timed-update-with-badge-ids-permission.md](timed-update-with-badge-ids-permission.md)
{% endcontent-ref %}

{% content-ref url="balances-action-permission.md" %}
[balances-action-permission.md](balances-action-permission.md)
{% endcontent-ref %}

{% content-ref url="update-approval-permission.md" %}
[update-approval-permission.md](update-approval-permission.md)
{% endcontent-ref %}

### **Examples**

See [Example Msgs](../../core-concepts/broken-reference/) for further examples. Or, see the page for each permission category.

```json
"collectionPermissions": {
    "canArchiveCollection": [],
    "canCreateMoreBadges": [
      {
        "badgeIds": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ],
        "ownershipTimes": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ],
        "permanentlyPermittedTimes": [],
        "permanentlyForbiddenTimes": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ],
      }
    ],
    "canDeleteCollection": [],
    "canUpdateBadgeMetadata": [],
    "canUpdateCollectionApprovals": [
      {
        "fromListId": "AllWithMint",
        "toListId": "AllWithMint",
        "initiatedByListId": "AllWithMint",
        "timelineTimes": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ],
        "transferTimes": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ],
        "badgeIds": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ],
        "ownershipTimes": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ],
        "approvalId": "All",
        "permanentlyPermittedTimes": [],
        "permanentlyForbiddenTimes": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ]
      }
    ],
    "canUpdateCollectionMetadata": [],
    "canUpdateContractAddress": [],
    "canUpdateCustomData": [],
    "canUpdateManager": [],
    "canUpdateOffChainBalancesMetadata": [],
    "canUpdateStandards": []
  }
```


## File: ./for-developers/badges-advanced/permissions/timed-update-permission.md

# Timed Update Permission

```json
"collectionPermissions": {
    "canArchiveCollection": [...],
    "canUpdateOffChainBalancesMetadata": [...],
    "canUpdateStandards": [...],
    "canUpdateCustomData": [...],
    "canUpdateManager": [...],
    "canUpdateCollectionMetadata": [...],
    ...
}
```

```typescript
export interface TimedUpdatePermission<T extends NumberType> {
  timelineTimes: UintRange<T>[];
  
  permanentlyPermittedTimes: UintRange<T>[];
  permanentlyForbiddenTimes: UintRange<T>[];
}
```

**TimedUpdatePermission**s simply denote for what **timelineTimes**, can the manager update the scheduled value? These are only applicable to normal [timeline-based fields](../timelines.md) such as the collection metadata timeline. This permission refers to the UPDATABILITY of the timeline and has no bearing on what the timeline is currently set to.

The **timelineTimes** are which timeline time values can be updated. The permitted / forbidden times are when the permission can be executed (the update can take place). Note these may not be aligned. Maybe, you want to forbid updating the timeline from Jan 2024 - Dec 2024 during 2023.

**Examples**

Below, this forbids updating the entire timeline because all timelineTimes are specified.

```json
"canUpdateCollectionMetadata": [
  {
    "timelineTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
  }
]
```

Below, this forbids ever updating the times 1000-2000 only. All other times can still be updated.

```json
"canUpdateCollectionMetadata": [
  {
    "timelineTimes": [
      {
        "start": "1000",
        "end": "2000"
      }
    ],
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
  }
]
```


## File: ./for-developers/badges-advanced/permissions/timed-update-with-badge-ids-permission.md

# Timed Update With Badge Ids Permission

```json
"collectionPermissions": {
    "canUpdateBadgeMetadata": [...],
    ...
}
```

```typescript
export interface TimedUpdateWithBadgeIdsPermission<T extends NumberType> {
  timelineTimes: UintRange<T>[];
  badgeIds: UintRange<T>[];
  
  permanentlyPermittedTimes: UintRange<T>[];
  permanentlyForbiddenTimes: UintRange<T>[];
}
```

**TimedUpdatePermissionWithBadgeId**s simply denote for what **timelineTimes** and **badgeIds** combinations, can the manager update the scheduled value? These are only applicable to badge ID [timeline-based fields](../timelines.md) such as the badge metadata timeline. This permission refers to the UPDATABILITY of the timeline and has no bearing on what the timeline is currently set to.

The **timelineTimes** are which timeline time values can be updated. The **badgeIds** are which badge IDs can be updated. For a pair such as (Mon-Fri, IDs 1-10), this means the values corresponding to the badge IDs at the timeline times can be updated or not. Both have to match. IDs 11+ are not handled at all in this case. Sunday is not handled. Updating IDs 1-10 on Sunday is not handled.

**Examples**

Below, this forbids updating the entire timeline because all timelineTimes and badgeIds are specified.

```json
"canUpdateBadgeMetadata": [
  {
    "timelineTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "badgeIds": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
  }
]
```

A commonly set value for this permission may look like the following. Let's say you have a collection with 100 badges but in the future, you can create new badges 101+. This permission allows you to freeze the metadata of the current badges but allow you to set the metadata for any new badges in the future.

```json
"canUpdateBadgeMetadata": [
  {
    "timelineTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "badgeIds": [
      {
        "start": "1",
        "end": "100"
      }
    ],
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
  }
]
```


## File: ./for-developers/badges-advanced/permissions/update-approval-permission.md

# Update Approval Permission

Pre-Readings: [Transferability](../balances-transfers/transferability-approvals.md) and [Approval Criteria](../balances-transfers/approval-criteria/)

The ApprovalPermissions refer to the UPDATABILITY of the currently set approvals / transferability. These can be leveraged to freeze specific transferability / approvals in order to give users more confidence that they cannot be changed in the future. Note this refers to the updatability of them and has no bearing on what they are currently set to.

For what transfer combinations (see [Representing Transfers](../balances-transfers/transferability-approvals.md)), can I create / delete / update approvals?&#x20;

```json
"userPermissions": {
    "canUpdateIncomingApprovals": [...],
    "canUpdateOutgoingApprovals": [...],
    ...
}
```

```json
"collectionPermissions": {
    "canUpdateCollectionApprovals": [...]
    ...
}
```

The **canUpdateIncomingApprovals** and **canUpdateOutgoingApprovals** follow the same interface as **canUpdateCollectionApprovals** minus automatically populating the user's address for to / from for incoming / outgoing, respectively. We only explain the collection approval permission to avoid repetition.

```typescript
export interface CollectionApprovalPermission<T extends NumberType> {
  fromListId: string;
  toListId: string;
  initiatedByListId: string;
  transferTimes: UintRange<T>[];
  badgeIds: UintRange<T>[];
  ownershipTimes: UintRange<T>[];
  approvalId: string
  
  permanentlyPermittedTimes: UintRange<T>[];
  permanentlyForbiddenTimes: UintRange<T>[];
}
```

Ex: I can/cannot update the approvals for the transfer combinations ("All", "All", "All", 1-100, 1-10, 1-10, "All",  "All",  "All") tuple.

## ID Shorthands

IDs are used for locking specific approvals. This is because sometimes it may not be sufficient to just lock a specific (from, to, initiator, time, badge IDs, ownershipTimes) combination because multiple approvals could match to it.

To specify IDs, you can use the "All" reserved ID to represent all IDs, or you can use other shorthand methods such as "!xyz" to denote all IDs but xyz. These shorthands are the same as reserved lists, so we refer you[ there for more info](../../core-concepts/address-lists-lists.md). Just replace the addresses with the IDs.

## Break Down Logic

Because of the way breakdown logic is performed, the following is allowed.

Permission: Badge IDs 2-10 are locked as forbidden

Before: 1-10 -> Criteria ABC

After: 1 -> Criteria XYZ, 2-10 -> Criteria ABC

## Expected Behavior vs Non-Updatability

Approval permission updates are slightly tricky because even though an approval may be non-updatable according to the permissions set, its expected behavior may change due to how approvals are designed (i.e. using trackers).

* For example, lets say we want to freeze IDs 501-1000 and have an incrementing mint of x1 of ID 1, x1 of ID 2, up to ID 1000. If we simply freeze the IDs 501-1000, the approval could still be deleted for IDs 1-500, and the increment number (tracker) will then never reach 501 because it will be out of bounds every time. Thus, expected behavior for 501-1000 changes even though it is frozen.

### Definitions

To explain things easier, let's start with some definitions:

#### **Approval Tuple**

We define an approval tuple as a set of values (**from, to, initiated by, badgeIds, transferTimes, ownershipTimes, approvalId**). The tuple for a specific approval that is currently set will consist of all values for that approval.

Note that to match, all N criteria must match. If one doesn't, it isn't a match. For example, in the example below, badge ID 1 will never match to the tuple.

<pre class="language-json"><code class="lang-json"><strong>{
</strong>  "fromListId": "AllWithMint",
  "toListId": "AllWithMint",
  "initiatedByListId": "AllWithMint",
  "badgeIds":  [{ "start": "2", "end": "10" }],
  "transferTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "ownershipTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "approvalId": "All"
}
</code></pre>

#### **Non-Updatable**

For a given approval tuple, it is considered non-updatable according to the permissions if all possible combinations of the entire tuple are **permanently forbidden** from being updated in the permissions.&#x20;

<pre class="language-json"><code class="lang-json"><strong>{
</strong>  "fromListId": "AllWithMint",
  "toListId": "AllWithMint",
  "initiatedByListId": "AllWithMint",
  "badgeIds":  [{ "start": "2", "end": "10" }],
  "transferTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "ownershipTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "approvalId": "All", //forbids approval "xyz" from being updated
  
  "permanentlyPermittedTimes": [],
  "permanentlyForbiddenTimes": [{ "start": "1", "end": "18446744073709551615" }]
}
</code></pre>

Note that non-updatability is scoped to the tuple itself.

**Brute Forced**

Commonly, you will make some values non-updatable by specifying some criteria (e.g. IDs 2-10) and setting everything else to all possible values. For example, the permission above does this for badge IDs 2-10. We refer to this as brute forcing (i.e. above badge IDs 2-10 are brute forced but badge IDs 2-11 are not). In other words, for some criteria, all possible combinations of that criteria are COMPLETELY forbidden and non-updatable.

#### **Expected Behavior**

As explained above, expected behavior not only encompasses non-updatability, but it also makes sure that nothing any other approval or update can do can affect the expected behavior of this approval. This designation is especially important.

### Freezing Specific Approval Tuples

With the way trackers work, it is important to handle approval permissions correctly to protect against break-down attacks to ensure expected behavior.

Below, we will walk through the process of making a specific approval tuple non-updatable AND keeping its expected behavior.&#x20;

**Specific Approval ID**

If you want to do this for a specific approval that is set, the approval tuple should consist of the specific values for that specific approval. Because the **approvalId** is unique and included in the tuple, you know there are no other approvals that overlap.

Thus, you can simply brute force this tuple in the permissions and call it a day.

**Tuples with Overlaps**

For tuples which may span multiple approvals, the algorithm is essentially the following:

1. Forbid updates for the exact tuple values you want to freeze in permissions
2. To keep expected behavior, you need to forbid updates for all specific approvals that are currently set and overlap (even partially) with the values you are trying to freeze.
   * Ex: If you are trying to freeze badge IDs 1-10, you should also entirely freeze the approval abc123 which is for badge IDs 1-100.
   * Technically, this only needs to be done for approvals that are set and can affect the behavior of the tuple values, but to be safe, we recommend freezing all overlapping approvals or restructuring so they do not overlap. It is difficult to manage when part of an approval is frozen.

**Example**

Let's say you want to forbid ever updating the transferability for badges 1-10, and you have the following approvals currently set (for badges 1-100).

```json
"collectionApprovals": [
    {
      "fromListId": "Mint",
      "toListId": "All",
      "initiatedByListId": "All",
      "transferTimes": [
        {
          "start": "1691978400000",
          "end": "1723514400000"
        }
      ],
      "ownershipTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "badgeIds": [
        {
          "start": "1",
          "end": "100"
        }
      ],
      "approvalId": "abc",
      "approvalCriteria": {
        .... //uses trackers
      }
    }
  ]
```

Step 1: Brute force IDs 1-10 in the permissions to be forbidden.

<pre class="language-json"><code class="lang-json"><strong>{
</strong>  "fromListId": "All",
  "toListId": "All",
  "initiatedByListId": "All",
  "badgeIds":  [{ "start": "1", "end": "10" }],
  "transferTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "ownershipTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "approvalId": "All",
  "permanentlyPermittedTimes": [],
  "permanentlyForbiddenTimes": [{ "start": "1", "end": "18446744073709551615" }]
}
</code></pre>

Step 2: Find all matching approvals. In this case, we only have one and it matches because it uses overlaps since it uses IDs 1-100.

```json
{
    "fromListId": "Mint",
    "toListId": "All",
    "initiatedByListId": "All",
    "transferTimes": [
      {
        "start": "1691978400000",
        "end": "1723514400000"
      }
    ],
    "ownershipTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "badgeIds": [
      {
        "start": "1",
        "end": "100"
      }
    ],
    "approvalId": "abc",
    "approvalCriteria": {
      ....
    }
  }
```

In this particular case, the approval is updatable (IDs 11-100 are) and is not already frozen. Thus, expected behavior of badges 1-10 may not be guaranteed.

We need to handle this, which we can do by adding another permission brute forcing approval "abc".

```json
{
    "fromListId": "All",
    "toListId": "All",
    "initiatedByListId": "All",
    "transferTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "ownershipTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "badgeIds": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "approvalId": "abc",    
     
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [{ "start": "1", "end": "18446744073709551615" }]
  }
```


## File: ./for-developers/badges-advanced/self-hosted-balances/README.md

# Self-Hosted Balances



## File: ./for-developers/badges-advanced/self-hosted-balances/examples-tutorials/README.md

# Examples / Tutorials



## File: ./for-developers/badges-advanced/self-hosted-balances/examples-tutorials/indexed.md

# Indexed

Live: [https://bitbadges-balances.nyc3.digitaloceanspaces.com/airdrop/balances](https://bitbadges-balances.nyc3.digitaloceanspaces.com/airdrop/balances)

JSON:&#x20;

```json
{
  "bb1zd5dsage58jfrgmsu377pk6w0q5zhc672wamvw": [
    {
      "amount": "1",
      "badgeIds": [
        {
          "start": "1",
          "end": "1"
        }
      ],
      "ownershipTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ]
    }
  ],
  "bb1spgqdupvv8jex2v9zrvj9umqa26rrzc0cts4yk": [
    {
      "amount": "1",
      "badgeIds": [
        {
          "start": "2",
          "end": "2"
        }
      ],
      "ownershipTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ]
    }
  ]
}
```


## File: ./for-developers/badges-advanced/self-hosted-balances/examples-tutorials/non-indexed.md

# Non-Indexed

```typescript
import { BalanceArray, UintRangeArray, mustConvertToEthAddress, type Balance } from 'bitbadgesjs-sdk';
import { type Request, type Response } from 'express';
import Moralis from 'moralis';
import { serializeError } from 'serialize-error';
import typia from 'typia';

export const getBalancesForEthFirstTx = async (bitbadgesAddress: string): Promise<Array<Balance<bigint>>> => {
  const ethAddress = mustConvertToEthAddress(bitbadgesAddress);
  const response = await Moralis.EvmApi.wallets.getWalletActiveChains({
    address: ethAddress
  });

  const firstTxTimestamp = response.raw.active_chains.find((x) => x.chain === 'eth')?.first_transaction?.block_timestamp;
  const timestamp = firstTxTimestamp ? new Date(firstTxTimestamp).getFullYear() : undefined;

  // Badge ID 1 = 2015, 2 = 2016, and so on
  const badgeId = timestamp ? timestamp - 2014 : undefined;
  if (!badgeId) {
    return [];
  }

  const balances = BalanceArray.From([
    {
      amount: 1n,
      badgeIds: [{ start: BigInt(badgeId), end: BigInt(badgeId) }],
      ownershipTimes: UintRangeArray.FullRanges()
    }
  ]);

  return balances;
};

export async function getBalancesForEthFirstTxRoute(req: Request, res: Response) {
  try {
    typia.assert<string>(req.params.bitbadgesAddress);
    const bitbadgesAddress = req.params.bitbadgesAddress;
    const balances = await getBalancesForEthFirstTx(bitbadgesAddress);
    return res.status(200).send({ balances });
  } catch (e) {
    console.error(e);
    return res.status(500).send({
      error: process.env.DEV_MODE === 'true' ? serializeError(e) : undefined,
      errorMessage: e.message || 'Error fetching balances.'
    });
  }
}
```


## File: ./for-developers/badges-advanced/self-hosted-balances/overview.md

# Overview

For off-chain balances, the collection will be stored on the blockchain, but all balances will be allocated off-chain via a server endpoint. This allows you to have complete control over assignment of the balances at no cost and no transactions required. You can integrate with any application (even non-crypto ones).

Examples:

* Spreadsheets - Assign badges based on addresses in a spreadsheet.
* Subscriptions - Set up your own subscription service and allocate badges to subscribers!
* Custom Integrations - Integrate with any app you want!

There are two types of off-chain balances: indexed and non-indexed. See the [balances type documentation](../balances-transfers/balance-types.md) for more information. For both options, you must create or have a collection with the desired balances type. The recommended way to create a collection is via the Create form on the BitBadges app. You will be able to enter all self-hosted details (your URL) directly into the form.

**Refresh Queue**

Note that while balance updates on your site will be instant. BitBadges uses a queue-like system. Upon a refresh or changes detected, the balance update will get added to the queue. This may take some time to fully populate on the site.

**Claim / Assignment System**

Self-hosted balances can be customized to be assigned for anything. You can setup your own assignment process or connect it to a claiming tool (e.g. when a user does something, update their balances). This is all left up to you.

Note that self-hosted balances are not compatible with BitBadges claims. For BItBadges claims, the balances must be stored and maintained by BitBadges. One workaround is to use BitBadges claims for the claiming process and then migrate to a self-hosted option.

**URL Requirements**

The URLs should be a GET endpoints accessible to whoever needs it (e.g. BitBadges indexer). It is your responsibility to handle CORS errors and such yourself.

### Non-Indexed Balances (On-Demand)

For non-indexed balances, you simply need to set up a server which can return the current balances for a specified BitBadges address.

Couple notes:

* The URL stored on-chain must have {address} as a placeholder for the address to query.
* The URL param is expected to support converted BitBadges addresses. It is up to you whether you want to support native addresses as well, but converted BitBadges address support is mandatory. See [here for more information](../../accounts.md).

Example:

On-Chain URL: "http://localhost:3000/nonIndexed/{address}"

```typescript
app.get('/nonIndexed/:address', async (req, res) => {
  const address = req.params.address;
  const bitbadgesAddress = convertToBitBadgesAddress();

  //custom logic - (e.g. check subscription status or check some local DB value)

  const balances: Balance<bigint>[] = [...];
  return res.status(200).send({ balances });
});
```

### Indexed Balances

With indexed balances, you store and host the entire balance map all at one endpoint.

**Step 1: Create Your Map**

The map is simply a bitbadgesAddress/listId -> Balance\<NumberType>\[] map. You can create this yourself by using the **OffChainBalancesMap\<NumberType>** type.

Note that if you use address list IDs for the keys ([see here to learn more](../../core-concepts/address-lists-lists.md)), the corresponding address list must be a whitelist (whitelist = false) and should be stored on-chain for reproducability (not off-chain via the BitBadges servers or somewhere else). You should also not allocate more badge IDs in this map than what was created on-chain (via the "Mint" address).

You may also find the [**createBalanceMapForOffChainBalances**](https://bitbadges.github.io/bitbadgesjs/functions/createBalanceMapForOffChainBalances.html) function helpful.

```typescript
const transfers: TransferWithIncrements<bigint>[] = [...];

const balanceMap = await createBalanceMapForOffChainBalances(transfers);
```

For example,

```json
{
    "bb1qjgpfmk93lqdak3ea7xqp5ec6v8nd79kqtrajy": [
        {
            "amount": "1",
            "badgeIds": [
                {
                    "start": "1",
                    "end": "1"
                }
            ],
            "ownershipTimes": [
                {
                    "start": "1",
                    "end": "18446744073709551615"
                }
            ]
        }
    ],
    "bb1zd5dsage58jfrgmsu377pk6w0q5zhc672wamvw": [
        {
            "amount": "1",
            "badgeIds": [
                {
                    "start": "1",
                    "end": "1"
                }
            ],
            "ownershipTimes": [
                {
                    "start": "1",
                    "end": "18446744073709551615"
                }
            ]
        }
    ]
}
```

**Step 2: Host your map as a JSON file via some URL**

This can be via IPFS or any method of your choice.

Note permanent storage (i.e. IPFS) coupled with not being able to update the URL on-chain will make your balances permanent and immutable. This can be a good option if you want your collection to be frozen, non-transferable, and immutable.

**Step 3: Create Your Collection**

Create your collection and specify your URL via the **offChainBalancesMetadata** timeline. Decide whether you want to be able to update the URL in the future or not. Set the **managerTimeline** and **canUpdateOffChainBalancesMetadata** permission accordingly.

**Future Refreshes / Updates**

In the future, if you are allowed to update the URL on-chain you can do so via another MsgUpdateCollection transaction. This will auto-trigger a refresh on the BitBadges API / indexer as well.

You can also just update the balances JSON returned by the URL as well without interacting with the blockchain (i.e. URL stays the same). Note that the BitBadges indexer / website caches balances. To trigger a refetch manually, you can use the **POST /api/v0/refresh** endpoint or do it directly on the website.


## File: ./for-developers/badges-advanced/standards.md

# Standards

Standards are a generic concept that allows anyone to define how to interpret the details of a badge collection. All collections will implement the same interface on the blockchain, but the standard defines how these fields are interpreted and are expected to be defined. Standards can define anything from the expected genesis conditions to the expected metadata format to any expected features of the collection.

```json
"standardsTimeline": [
  {
    "timelineTimes": [...],
    "standards": ["transferable", "text-only-metadata", "non-fungible", "attendance-format"]1
  }
]
```

You can define and implement multiple standards, as long as they are compatible. There is no check in the blockchain logic that a specific standard is actually followed. The value stored on the blockchain is purely informational and for guidelines. It is the querier's responsibility to double check standards are being followed correctly and take action accordingly.

## **Compatibility with BitBadges API / Indexer**

Note the BitBadges API / Indexer expects certain formatting and interfaces to be followed to be compatible. See [BitBadges API Compatibility](../bitbadges-api/concepts/designing-for-compatibility.md). If you want compatibility, please make sure all standards are compatible.

## List of Standards

See [here](broken-reference).


## File: ./for-developers/badges-advanced/timelines.md

# Timelines

BitBadges uses timeline-based fields to allow dynamic, time-dependent values for various attributes. This feature enables automatic updates to field values based on the current time, without requiring additional blockchain transactions.

### Key Concepts

1. **Time Representation**:
   * Times are represented as UNIX time (milliseconds since the epoch).
   * Epoch: Midnight at the beginning of January 1, 1970, UTC.
2. **Value Assignment**:
   * Values are assigned to specific time ranges.
   * No overlapping time ranges are allowed for a single field.
3. **Default Behavior**:
   * If no value is set for the current time, the field assumes an empty/null/default value.

### Structure

Timeline-based fields extend the `TimelineItem` interface:

```typescript
export interface TimelineItem<T extends NumberType> {
  timelineTimes: UintRange<T>[];
}
```

### Example Timeline Fields

The collection interface includes the following timeline-based fields:

* `managerTimeline: ManagerTimeline<T>[]`
* `collectionMetadataTimeline: CollectionMetadataTimeline<T>[]`
* `badgeMetadataTimeline: BadgeMetadataTimeline<T>[]`
* `offChainBalancesMetadataTimeline: OffChainBalancesMetadataTimeline<T>[]`
* `customDataTimeline: CustomDataTimeline<T>[]`
* `standardsTimeline: StandardsTimeline<T>[]`
* `isArchivedTimeline: IsArchivedTimeline<T>[]`

### Example: CollectionMetadataTimeline

#### Protocol Buffers Definition

```protobuf
message CollectionMetadataTimeline {
  CollectionMetadata collectionMetadata = 1;
  repeated UintRange timelineTimes = 2;
}
```

#### Usage Example

```typescript
const collectionMetadataTimeline = [
  {
    timelineTimes: [{ start: 1n, end: 10n }],
    collectionMetadata: {
      uri: 'ipfs://abc123',
      customData: '',
    },
  },
  {
    timelineTimes: [{ start: 11n, end: 10000000n }],
    collectionMetadata: {
      uri: 'ipfs://xyz456',
      customData: '',
    },
  }
];
```

In this example:

* From time 1 to 10, the collection metadata URI is 'ipfs://abc123'.
* From time 11 to 10000000, the collection metadata URI is 'ipfs://xyz456'.
* At time 5, the first entry would be used.
* At time 20, the second entry would be used.

### Practical Application

This feature allows for automatic, time-based updates to collection attributes. For example, you can set a collection's metadata URL to change at specific times:

```typescript
const metadataTimeline = [
  {
    timelineTimes: [{ start: 1672531200000n, end: 1680307199000n }], // Jan 1, 2023 to Mar 31, 2023
    collectionMetadata: { uri: 'https://example1.com', customData: '' },
  },
  {
    timelineTimes: [{ start: 1680307200000n, end: 1704067199000n }], // Apr 1, 2023 to Dec 31, 2023
    collectionMetadata: { uri: 'https://example2.com', customData: '' },
  }
];
```

This setup would automatically switch the metadata URL from example1.com to example2.com on April 1, 2023, without requiring any additional blockchain transactions.


## File: ./for-developers/badges-advanced/uint-ranges.md

# Uint Ranges

Refer here:

{% content-ref url="../core-concepts/uint-ranges.md" %}
[uint-ranges.md](../core-concepts/uint-ranges.md)
{% endcontent-ref %}



## File: ./for-developers/bitbadges-api/README.md

# 📚 Indexer / API



## File: ./for-developers/bitbadges-api/api.md

# Getting Started

## Getting Started - API Keys

By default, certain routes are available publicly in a rate limited manner with no API key. However, API keys allow you access to all routes with higher limits.

1. Sign in on and create an API key by going to [https://bitbadges.io/developer](https://bitbadges.io/developer) -> API Keys tab.
2. Start sending requests to the base URL of [https://api.bitbadges.io/](https://api.bitbadges.io/) with the HTTP header x-api-key. All routes require an API key.
3. For higher tiers / paid plans, visit [https://bitbadges.io/pricing](https://bitbadges.io/pricing). To actually upgrade, see the Upgrading an API Key Tier demo on the next page.

<figure><img src="../../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

## Quickstarter

See the [quickstart repo](https://github.com/BitBadges/bitbadges-quickstart) for a fully configured example repository with fetching collections, accounts, and more with the API!

## Number Types

Note: Numbers are stringified in responses to avoid precision loss. You will have to convert them. The SDK does this for you if you use it.

## References

* [Main](https://bitbadges.stoplight.io/docs/bitbadges)
* [Postman](https://www.postman.com/bitbadges/workspace/bitbadges-api/collection/11647629-5bc57e3c-1818-4446-988e-23a9442cc0df?action=share\&creator=11647629)
* [OpenAPI](https://github.com/BitBadges/bitbadgesjs/blob/main/packages/bitbadgesjs-sdk/openapitypes/combined.yaml)

In this documentation, we often use the SDK format for explanation purposes. Please convert the corresponding function name to vanilla HTTP if you are not using the SDK from the documentation above.

```typescript
await BitBadgesApi.routeFn(...)
```

```
POST https://api.bitbadges.io/api/v0/routeFn
```

## Testnet Mode

A testnet version of the API is available with the base URL [https://api.bitbadges.io/testnet](https://api.bitbadges.io/testnet). Everything else is the same, just add the /testnet before all paths.

Note that this testnet API is an entirely separate service from normal API. Nothing carries over. It commmunicates with the frontend with testnet mode turned on and uses the testnet BitBadges blockchain.

## Using the API SDK (Recommended)

If you are using JavaScript / TypeScript, consider using the typed API SDK for convenience. This will give you typed routes, provide quality checks, and also auto-convert all responses to your desired number type (bigint, Number, etc).

```typescript
import { BigIntify, BitBadgesAPI } from 'bitbadgesjs-sdk';

export type DesiredNumberType = bigint;
export const ConvertFunction = BigIntify;

//BACKEND_URL for main API is https://api.bitbadges.io
//Make sure process.env.BITBADGES_API_KEY is set with a valid API key.

const BitBadgesApi = new BitBadgesAPI({
    apiKey: '...',
    //converts responses to your desired number type (bigint, Number, etc)
    convertFunction: ConvertFunction //Can also do Numberify, Stringify, etc
    apiUrl: '...' //defaults to official one if empty
});

//See https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html for documentation
//Some might require authentication. Some might be CORS only from the official site.
await BitBadgesApi.getAccounts(...);
await BitBadgesApi.getAddressLists(...);
await BitBadgesApi.getCollections(...);
await BitBadgesApi.simulateTx(...);
```

## Using BitBadges JS/SDK

Check out the BitBadges JS/SDK for implementing further functionality beyond just API requests / responses, such as manipulating balances, handling approvals, checking permissions, etc.

{% content-ref url="../bitbadges-sdk/" %}
[bitbadges-sdk](../bitbadges-sdk/)
{% endcontent-ref %}

## API Authorization

For most applications, you should be fine without needing to access private user authenticated information. However if you do, check out Sign In with BitBadges. This follows a standard OAuth 2.0 flow. Use the scopes to gain access to authenticated routes. Refer to the API reference to see what scopes are needed where.

{% content-ref url="../authenticating-with-bitbadges/" %}
[authenticating-with-bitbadges](../authenticating-with-bitbadges/)
{% endcontent-ref %}

## Bookmarking

Throughout the API, we use a bookmark technique. For the first request, you will not need to specify a bookmark (e.g. ""), and it will fetch the first page. Within the response, it will return a **bookmark** and **hasMore**. **hasMore** defines whether there are more pages to be fetched. To fetch the next page, you will specify the returned bookmark from the previous request to the next request. This process can be repeated until all are loaded.


## File: ./for-developers/bitbadges-api/concepts/README.md

# Concepts



## File: ./for-developers/bitbadges-api/concepts/designing-for-compatibility.md

# Designing for Compatibility

To make your collection compatible with the BitBadges Indexer / API (and thus the official website), please make sure everything is compatible when self-hosting.

#### Badge and Collection Metadata Format

{% content-ref url="../../badges-advanced/metadata.md" %}
[metadata.md](../../badges-advanced/metadata.md)
{% endcontent-ref %}

#### Off-Chain Balances Metadata

{% content-ref url="../../badges-advanced/balances-transfers/balance-types.md" %}
[balance-types.md](../../badges-advanced/balances-transfers/balance-types.md)
{% endcontent-ref %}


## File: ./for-developers/bitbadges-api/concepts/limits-restrictions.md

# API Limits & Restrictions

The following limits are in place to ensure API stability and performance. If these limits are too restrictive for your use case, please contact us.

## Request Limits

-   **Rate Limit**: 10,000 requests per day per API key
-   **Global Rate Limit**: Enforced to prevent infinite loops
-   **Refresh Rate**: Operations can only be refreshed once per hour

## Data Limits

-   **Batch Size**: Maximum 250 items per request for:
    -   Metadata URIs
    -   Account lookups
    -   Collection fetches
-   **IPFS Storage**: Maximum 100MB total uploads per address
-   **Collection Size**: Limited functionality for collections exceeding JavaScript's `Number.MAX_SAFE_INTEGER`

## Timeouts & Retries

This applies to any external fetches, including metadata URIs and other external sources like custom success hooks.

-   **URI Fetch Timeout**: 10 seconds maximum for direct source URI fetches
-   **Retry Policy**: For failed fetches, exponential backoff:
    ```
    Delay = 1 hour × 2^(number of attempts)
    ```

Note: These limits may change over time. Please refer to our latest documentation for current values.


## File: ./for-developers/bitbadges-api/concepts/managing-views.md

# Managing Views

Throughout the BitBadges API, we use a bookmark-based pagination system for efficient data retrieval. This system is particularly useful when dealing with large datasets that need to be fetched in smaller chunks.

Some endpoints like the get accounts or get collections will use a generic viewsToFetch and views object which can maintain multiple paginated views. Some endpoints will request the bookmark directly. Refer to the documentation for each endpoint to see how it handles pagination.

### How Bookmark Pagination Works

1. **First Request**: For your initial request, use an empty bookmark string (`""`).

```typescript
const firstRequest = {
    viewType: 'owners',
    viewId: 'owners',
    bookmark: '', // Empty for first page
};
```

2. **Response Structure**: Each paginated response includes:
   * The requested data
   * A `bookmark` string for the next page
   * A `hasMore` boolean indicating if more data exists

```typescript
{
    data: [...],
    views: {
        'owners': {
            ids: [...],
            pagination: {
                bookmark: 'abc123...', // Use this for next request
                hasMore: true
            }
        }
    }
}
```

3. **Subsequent Requests**: To fetch the next page, use the bookmark from the previous response:

```typescript
const nextRequest = {
    viewType: 'owners',
    viewId: 'owners',
    bookmark: 'abc123...', // Bookmark from previous response
};
```

4. **Completion**: Continue this process until `hasMore` is `false`.

## Understanding the Views Object

```
Note: This is planning to be deprecated in favor of more confined view routes. 
Please use those instead. They are much less confusing.
```

The views object is a central concept in the BitBadges API, used to manage paginated data across different interfaces (BitBadgesCollection, BitBadgesAddressList, BitBadgesUserInfo, etc). It follows this structure:

```typescript
views: {
    [viewId: string]: {
        ids: string[];          // Array of document IDs
        pagination: {
            bookmark: string;    // Bookmark for next page
            hasMore: boolean;    // Whether more data exists
        };
        type: string;           // The view type
    } | undefined;
}
```

### Key Components

1. **viewId**: A unique identifier for the view
2. **ids**: Array of document IDs that correspond to full documents in the response
3. **pagination**: Contains the bookmark and hasMore flag
4. **type**: Indicates the type of view (e.g., 'owners', 'activity', etc.)

### Document ID Mapping

Documents in the response are referenced by their `_docId` field. To access the full document, you map the IDs from the view to the corresponding array in the response. For example, the activity view documents are stored in the `activity` array, and the view IDs are stored in the `views.activity.ids` array.

```typescript
// Example of accessing activity documents from a view
getActivityView(viewId: string) {
    return (this.views[viewId]?.ids.map((x) => {
        return this.activity.find((y) => y._docId === x);
    }) ?? []);
}
```

### Common View Types

Different interfaces support different view types. See the corresponding documentation for each interface to see what views are supported.

#### Collections Interface

* `owners`: List of badge owners
* `activity`: Transfer activity
* `approvalTrackers`: Approval tracking documents

See all at [CollectionViewKey](https://bitbadges.github.io/bitbadgesjs/types/CollectionViewKey.html)

#### Account Interface

* `transferActivity`: User's transfer history
* `badgesCollected`: Badges owned by the user
* `createdBadges`: Collections created by the user
* `managingBadges`: Collections being managed
* `allLists`: Address lists the user is on

See all at [AccountViewKey](https://bitbadges.github.io/bitbadgesjs/types/AccountViewKey.html)

## Helper Functions

The BitBadges SDK provides several helper functions for managing views:

```typescript
// Check if more pages exist
const hasMore = collection.viewHasMore('owners');

// Get bookmark for next page
const nextBookmark = collection.getViewBookmark('owners');

// Fetch next page of data
await collection.fetchNextForView(BitBadgesApi, 'owners', 'owners');

// Get all documents for a view
const ownersView = collection.getOwnersView('owners');
```

## Best Practices

1. **Consistent ViewIds**: Use consistent viewIds when paginating through the same dataset
2. **Error Handling**: Always check for undefined views before accessing
3. **Document Mapping**: Use helper functions when available for mapping IDs to documents
4. **Pagination State**: Track both bookmark and hasMore status for proper pagination
5. **Response Merging**: Remember that each response is confined to its request - use helper functions or manually merge data as needed


## File: ./for-developers/bitbadges-api/concepts/native-chain-algorithm.md

# Native Chain Algorithm

### How is a user's "native" chain determined?

You may have noticed that on the BitBadges site and other places, a user's "preferred" or "main" blockchain is remembered and auto-populated. This is how we populate the **chain** and **address** field in account route responses. We determine the main chain in the following order.

1. Chain of last signed BitBadges transaction
2. Chain of last sign in on BitBadges app
3. Try to check any transaction history (e.g. submitted any transactions on Ethereum mainnet chain?)
4. Requested address format
5. Guess / default to Ethereum since it is the most popular


## File: ./for-developers/bitbadges-api/concepts/refresh-queue.md

# Refresh / Claim Completion Queue

The API / indexer makes use of a load-balanced refresh queue system whenever we need to fetch anything from a source URI (metadata, off-chain balances, etc). Because this is a queue-based system, certain metadata may take awhile to fully load and populate. Once we fetch the metadata, we cache it and return the fetched values until it is refreshed again.

**When do we trigger refreshes?**

Refreshes are triggered automatically when certain things occur on-chain, such as a collection is created / URI is changed. You can also manually trigger refreshes (note there are cooldown limits in place to prevent spam) to refresh the cached values via the refresh endpoints.

**What happens if the fetch fails?**

See [Restrictions / Limits](limits-restrictions.md). We implement an exponential retry system.

**Off-Chain Balances**

Note that for off-chain balances, we also throw an error if the fetched balances exceed the total supply of badges defined on-chain (i.e. you are trying to allocate more badges than you should).

**Checking Status**

If you are having issues, you can check the BitBadges collection page on site -> Actions -> Refresh for statuses. Or, if you need a programmatic solution, you can use following route to see its status and see if it has any error docs.

```typescript
await BitBadgesApi.getRefreshStatus()
```



## File: ./for-developers/bitbadges-api/concepts/use-via-pipedream.md

# Use via Pipedream

[Pipedream BitBadges Integration](https://pipedream.com/apps/bitbadges) allows you to interact with the BitBadges API via Pipedream. Connect your Pipedream account to the BitBadges API and start building!

This opens up a lot of possibilities for automating your workflows with BitBadges. For claim-speciifc automation, see the Pipedream section in the claims documentation.

{% content-ref url="../../claim-builder/integrate-with-pipedream/" %}
[integrate-with-pipedream](../../claim-builder/integrate-with-pipedream/)
{% endcontent-ref %}


## File: ./for-developers/bitbadges-api/indexer.md

# Indexer

If you want to run your own indexer and API, check out the source code at [https://github.com/bitbadges/bitbadges-indexer](https://github.com/bitbadges/bitbadges-indexer).

The indexer is split into two main parts: the poller and the API. The poller fetches the latest block from a connected node every second and updates the MongoDB database accordingly. The API is an Express.js API that makes the indexed data queryable to users.

Although you can query other blockchain nodes, it is strongly recommended that you run your own node and query that. HTTP requests can reach >100 per second.

### Running from Scratch

1. Install and setup CouchDB
2. Setup a valid .env file. See environment.d.ts below for the expected format of the .env file.&#x20;
3. Use **npm run setup** to setup the CouchDB databases. Note that you can run **npm run setup with-delete** to restart all indexer databases from scratch.
4. Use **npm run indexer-dev** to start in development mode.
5. Use **npm run build** and **npm run indexer** to start in production mode.

### Running with Docker

See [https://github.com/bitbadges/bitbadges-docker](https://github.com/bitbadges/bitbadges-docker).

### Customization Options (.env file)

Below are the supported customization options. Some may be applicable. Some may not.

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadges-indexer/blob/master/environment.d.ts" %}



## File: ./for-developers/bitbadges-api/upgrading-an-api-key-tier.md

# Upgrading an API Key Tier

1. Sign in and create your API key in the [developer portal -> API Keys tab](https://bitbadges.io/developer).

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

2. Once you've created it and copied it somewhere safe, select "Update Tier".

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

3. This will take you to the billing page. Select your desired tier. Note that if you have a coupon code, it will typically only apply to a specific tier.

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

4. Lastly, complete the form, selecting your newly created API key. Enter your email, enter promo code (if applicable), and complete the rest of the form.

<figure><img src="../../.gitbook/assets/image (5) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

5. Once that form is submitted, you're ready to start building! See the [BitBadges API documentation](https://docs.bitbadges.io) for more information on how to use the BitBadges API. The new tier may take 5-10 minutes to register, so please allow some time for the changes to take effect.


## File: ./for-developers/bitbadges-blockchain/README.md

# ⛓ BitBadges Blockchain



## File: ./for-developers/bitbadges-blockchain/chain-details.md

# Chain Details

Cosmos Chain ID (Mainnet) - bitbadges-1

Cosmos Chain ID (Testnet) - bitbadges-2

[Cosmos SDK Coin Denom](https://docs.cosmos.network/main/modules/bank) - "ubadge" (1 $BADGE = 1 \* 10^9 ubadge)

### Official Links

**RPCs**

[http://node.bitbadges.io:26657](http://node.bitbadges.io:26657)

Tendermint Node ID: 2703c1304a70186372aa726a762d60da94c29ffe

See genesis.json in source code repository for genesis file. See [here](htttps://github.com/bitbadges/bitbadgeschain) for source code repository.

If you are looking for the browser compatible version, you may have to use the IP address directly as the domain name does not support HTTPS but browsers auto-upgrade to HTTPS. Or, if you need an HTTPS connection, you can use the reverse proxy URL.

http://134.122.12.165:26657 = http://node.bitbadges.io:26657

https://node.bitbadges.io/rpc = http://node.bitbadges.io:26657

**Blockchain Node REST APIs**

[http://node.bitbadges.io:1317](http://node.bitbadges.io:1317)

If you are looking for the browser compatible version, you may have to use the IP address directly as the domain name does not support HTTPS but browsers auto-upgrade to HTTPS. Or, if you need an HTTPS connection, you can use the reverse proxy URL.

http://134.122.12.165:1317 = http://node.bitbadges.io:1317

https://node.bitbadges.io/api = http://node.bitbadges.io:1317

**State Snapshots (Unofficial)**

[https://snapshots.whenmoonwhenlambo.money/](https://snapshots.whenmoonwhenlambo.money/)

**BitBadges API / Indexer**

[https://api.bitbadges.io](https://api.bitbadges.io)

**Explorer**

[https://explorer.bitbadges.io](https://explorer.bitbadges.io)

**Web App**

{% embed url="https://bitbadges.io" %}

**Testnet**

Node ID: 745b694aeef8c2e831ed6ec65060230a91f17914

Hosted At: http://138.197.10.8:(1317 | 26657)


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/README.md

# 📩 Cosmos SDK Msgs

**What are Cosmos SDK Msgs? Msgs vs Transactions?**

In Cosmos SDK, Msgs are messages that represent actions to be executed on the blockchain, such as sending tokens.

Each transaction must consist of one or Msgs to be executed. Transactions also consist of other accompanying details such as the signature info.

**What Msgs does the BitBadges blockchain implement?**

The BitBadges blockchain utilizes various pre-written modules from the Cosmos SDK (auth, authz, genutil, bank, capability, staking, distr, gov, params, crisis, slashing, feegrant, group, wasm, ibc, upgrade, evidence, transfer, ica, vesting). The documentation for the pre-written modules can be found [here](https://docs.cosmos.network/main/modules).

The x/badges module is the core functionality of BitBadges written by us, and within this module, all the Msg types that correspond to badges are defined. We also use an x/wasmx module which helps to create compatible smart contracts (forked from Injective). The x/maps allows storing data in a structured format with many customization options for the map. The x/anchor alllows for storing unstructured data.

**How to broadcast transactions with Msgs?**

You can generate and submit your transactions (Msgs) via:

* [BitBadges SDK](../create-and-broadcast-txs/): Generate and broadcast transactions to a running node with TypeScript. See [tutorials](../create-and-broadcast-txs/). This is the recommended option.
* CLI: Run your own node and interact with the command line
* Other: [https://docs.cosmos.network/main/user/run-node/txs#using-rest](https://docs.cosmos.network/main/user/run-node/txs#using-rest)

**What is the creator field?**

The **creator** field for each message should be the transaction signer's BitBadges address.

## Msg Definitions

Below, we link the documentation for the Msgs from our x/badges and x/wasmx module.

**x/badges**

* [MsgCreateCollection](https://bitbadges.github.io/bitbadgesjs/classes/MsgCreateCollection.html) - Creates a new collection. For creation transactions, everything is considered "free" (no permission restrictions). For following update transactions, everything must follow the permissions set.
* [MsgUpdateCollection](https://bitbadges.github.io/bitbadgesjs/classes/MsgUpdateCollection.html) - Updates the details of a collection. Must be manager of the corresponding collection to execute and all updates must follow the permissions set.
* [MsgUniversalUpdateCollection](https://bitbadges.github.io/bitbadgesjs/classes/MsgUniversalUpdateCollection.html) - This is a universal all-in-one message that supports everything from both MsgCreateCollection and MsgUpdateCollection. If collectionId == 0, we treat it as a create transaction. If collectionId > 0, we update the corresponding collection.
  * Mainly used for legacy purposes. To avoid confusion, we recommend using MsgCreate or MsgUpdate because those will be typed correctly for your use case.
* [MsgTransferBadges](https://bitbadges.github.io/bitbadgesjs/classes/MsgTransferBadges.html) - Transfer badges between users, if approvals allow.
* [MsgUpdateUserApprov](https://bitbadges.github.io/bitbadgesjs/classes/MsgUpdateUserApprovals.html)[als](https://bitbadges.github.io/bitbadgesjs/classes/MsgUpdateUserApprovals.html) - Set incoming / outgoing approvals for a collection, in addition to permissions which define the updatability of the approvals.
* [MsgDeleteCollection](https://bitbadges.github.io/bitbadgesjs/classes/MsgDeleteCollection.html) - Deletes the collection, if permissions allow. Must be manager.
* [MsgCreateAddressLists](https://bitbadges.github.io/bitbadgesjs/classes/MsgCreateAddressLists.html) - Creates address list(s).

**x/wasmx**

* [MsgExecuteContractCompat](https://bitbadges.github.io/bitbadgesjs/classes/MsgExecuteContractCompat.html) - Helper Msg to support executing contracts from Ethereum wallets for EIP712. See [here](../create-a-wasm-contract.md) for tutorial.

**x/maps**

* MsgCreateMap - Creates a map, uniquely identifed by an ID
* MsgUpdateMap - Updates an existing map.
* MsgDeleteMap - Deletes a map
* MsgSetValue - Allows a user to specify a (key, value) pair if permissions allow.

**x/anchor**

* MsgAddCustomData - Add custom data to the blockchain. No structure to the data at all (just a string). Will return a location for where to find your data.

**Other Cosmos SDK Modules**

For other standard Cosmos SDK messages, you can check out the bitbadges SDK documentation (such as [MsgSend](https://bitbadges.github.io/bitbadgesjs/classes/MsgSend.html) here). Or, check the official Cosmos documentation as these were written by them!


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/cosmos-native-msgs.md

# Cosmos Native Msgs

We refer you to Cosmos SDK documentation for other Cosmos native Msgs.


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/msgsend.md

# MsgSend

MsgSend is the Msg to send $BADGE. It is a core Cosmos SDK msg (i.e. not written by BitBadges), o we refer you to their documentation for more information.

```typescript
/**
 * MsgSend represents a message to send coins from one account to another.
 *
 * @typedef {Object} MsgSend
 * @property {string} fromAddress - The sender of the transaction.
 * @property {string} toAddress - The recipient of the transaction.
 * @property {CosmosCoin[]} amount - The amount of coins to send.
 */
export interface MsgSend<T extends NumberType> {
  fromAddress: string
  toAddress: string
  amount: CosmosCoin<T>[]
}


/**
 * Type for Cosmos SDK Coin information with support for bigint amounts (e.g. { amount: 1000000, denom: 'ubadge' }).
 *
 * @typedef {Object} CosmosCoin
 * @property {NumberType} amount - The amount of the coin.
 * @property {string} denom - The denomination of the coin.
 */
export interface CosmosCoin<T extends NumberType> {
  amount: T,
  denom: string,
}

```

```json
{
  "fromAddress": "bb1pa6p7nsqg57yqv23khnu5dumfhycr459jjnzsg",
  "toAddress": "bb1uy4my3dwzwv9drgq06pt433z742l9vrlsm053p",
  "amount": [
    {
      "denom": "ubadge",
      "amount": "1"
    }
  ]
}
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-anchor/README.md

# x/anchor



## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-anchor/msgaddcustomdata.md

# MsgAddCustomData

MsgAddCustomData is a part of the x/anchor module which allows you to anchor any custom data to the blockchain. The blcokchain will store with an incrementing location ID along with the timestamp. This can be used to prove knowledge of something at a specific time by anchoring it to the chain.

```protobuf
message MsgAddCustomData {
  string creator = 1;
  string data    = 2;
}
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/README.md

# x/badges



## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgcreateaddresslists.md

# MsgCreateAddressLists



## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgcreatecollection.md

# MsgCreateCollection

Collections are initially created via [MsgCreateCollection](https://bitbadges.github.io/bitbadgesjs/classes/MsgCreateCollection.html) . The interface looks as follows.&#x20;

```typescript
export interface MsgCreateCollection<T extends NumberType> {
    creator: string;

    //collectionId

    balancesType?: string; //"Standard" | "Off-Chain"

    defaultBalances: UserBalanceStore;

    badgeIdsToAdd?: UintRange<T>[];

    collectionPermissions?: CollectionPermissions<T>;
    managerTimeline?: ManagerTimeline<T>[];
    collectionMetadataTimeline?: CollectionMetadataTimeline<T>[];
    badgeMetadataTimeline?: BadgeMetadataTimeline<T>[];
    offChainBalancesMetadataTimeline?: OffChainBalancesMetadataTimeline<T>[];
    customDataTimeline?: CustomDataTimeline<T>[];
    collectionApprovals?: CollectionApproval<T>[];
    standardsTimeline?: StandardsTimeline<T>[];
    isArchivedTimeline?: IsArchivedTimeline<T>[];
}
```

The collectionId will be assigned at execution time and is obtainable in the transaction response. Subsequent updates to the collection will be through MsgUpdateCollection.

**Creation Only Properties**

The creation or genesis transaction for a collection is unique in a couple ways.

1. There are no permissions previously set, so there are no restrictions for what can be set vs not. Subsequent updates to the collection must follow any previously set permissions.
2. This is the only time that you can specify **balancesType** and the **defaultBalances** information (defaultOutgoingApprovals, defaultIncomingApprovals, defaultAutoApproveSelfInitiatedOutgoingTransfers, defaultAutoApproveSelfInitiatedIncomingTransfers, and defaultUserPermissions)**.**&#x20;

**Rest of Fields**

For the rest of the fields, we refer you to the following section.


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgdeletecollection.md

# MsgDeleteCollection

Deleting a collection is self-explanatory. The manager can delete the collection with [MsgDeleteCollection](https://bitbadges.github.io/bitbadgesjs/classes/MsgDeleteCollection.html) as long as they have the permission to do so (the **canDeleteCollection** permission).&#x20;

Deleting a collection will wipe it from the blockchain entirely.

```typescript
export interface MsgDeleteCollection<T extends NumberType> {
    creator: string;
    collectionId: T;
}
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgtransferbadges.md

# MsgTransferBadges

Transferring badges on-chain can be facilitated with [MsgTransferBadges](https://bitbadges.github.io/bitbadgesjs/classes/MsgTransferBadges.html).

```typescript
export interface MsgTransferBadges<T extends NumberType> {
    creator: string;
    collectionId: T;
    transfers: Transfer<T>[];
}

export interface Transfer<T extends NumberType> {
    from: string;
    toAddresses: string[];
    balances: Balance<T>[];
    precalculateBalancesFromApproval?: ApprovalIdentifierDetails;
    merkleProofs?: MerkleProof[];
    memo?: string;
    prioritizedApprovals?: ApprovalIdentifierDetails[];
    onlyCheckPrioritizedApprovals?: boolean;
}

export interface ApprovalIdentifierDetails {
    approvalId: string;
    approvalLevel: string; //"incoming", "outgoing", or "collection"
    approverAddress: string; //leave "" if collection
}

export interface MerklePathItem {
    aunt: string;
    onRight: boolean;
}

export interface MerkleProof {
    aunts: MerklePathItem[];
    leaf: string;
}
```

**To / From Addresses**

The to and from addresses must be valid BitBadges addresses. The from address can also be "Mint".

**Precalculations**

If you are targeting to use an approval which uses the **predeterminedBalances** field (see [Approvals](../../../badges-advanced/balances-transfers/approval-criteria/)), then you want to calculate the balances at execution time because they are possibly dynamic and can change between submit time and execution time. For example, if badge IDs increment by 1 every transfer, at signing time, the user does not know what badges they will receive because there could be transfers in between sign time and execution time.

If this is the case, you can use **precalculateBalancesFromApproval** to specify which approval to precalculate from, and the balances will be calculated at execution time to what the current predetermined values are, rather than what is defined in **balances.**

**Merkle Proofs**

If any approval that you are targeting has a Merkle challenge, you must provide a valid Merkle proof via the **merkleProofs.**

**Prioritized Approvals**

By default, we linearly scan approvals in the order they are defined on-chain. However, sometimes, you may want to prioritize one approval over the other.

You can specify which ones to check first via **prioritizedApprovals**. If **onlyCheckPrioritizedApprovals** is true, we will not check any approval not in the prioritized ones.


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msguniversalupdatecollection.md

# MsgUniversalUpdateCollection

MsgUniversalUpdateCollection is a universal message that supports both creating and updating collections. If collection ID == 0, it is a create txn. This is mainly used for legacy purposes. We recommend using MsgCreateCollection and MsgUpdateCollection instead, respectively. We refer you to their documentation for further details.

```typescript
interface MsgUniversalUpdateCollection {
    badgeMetadataTimeline?: BadgeMetadataTimeline<T>[];
    badgeIdsToAdd?: UintRange<T>[];
    balancesType?: string;
    collectionApprovals?: CollectionApproval<T>[];
    collectionId: T;
    collectionMetadataTimeline?: CollectionMetadataTimeline<T>[];
    collectionPermissions?: CollectionPermissions<T>;
    creator: string;
    customDataTimeline?: CustomDataTimeline<T>[];
    defaultBalances?: UserBalanceStore;
    isArchivedTimeline?: IsArchivedTimeline<T>[];
    managerTimeline?: ManagerTimeline<T>[];
    offChainBalancesMetadataTimeline?: OffChainBalancesMetadataTimeline<T>[];
    standardsTimeline?: StandardsTimeline<T>[];
    updateBadgeMetadataTimeline?: boolean;
    updateCollectionApprovals?: boolean;
    updateCollectionMetadataTimeline?: boolean;
    updateCollectionPermissions?: boolean;
    updateCustomDataTimeline?: boolean;
    updateIsArchivedTimeline?: boolean;
    updateManagerTimeline?: boolean;
    updateOffChainBalancesMetadataTimeline?: boolean;
    updateStandardsTimeline?: boolean;
}
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgupdatecollection.md

# MsgUpdateCollection

For updating a collection's details on-chain, you can use [MsgUpdateCollection](https://bitbadges.github.io/bitbadgesjs/classes/MsgUpdateCollection.html). This is only executable by the manager, and all updates must obey the previously set permissions.

Note that if you only want to update off-chain balances stored at a URI and nothing else (URI stays the same), nothing on the blockchain will change, and this can all be facilitated off-chain (doesn't require this Msg).

```typescript
export interface MsgUpdateCollection<T extends NumberType> {
    creator: string;
    collectionId: T; //0 for new collections (will be assigned)

    //Note no defaults or balances types here because that is only for new collections

    badgeIdsToAdd?: UintRange<T>[];

    updateCollectionPermissions?: boolean;
    collectionPermissions?: CollectionPermissions<T>;
    updateManagerTimeline?: boolean;
    managerTimeline?: ManagerTimeline<T>[];
    updateCollectionMetadataTimeline?: boolean;
    collectionMetadataTimeline?: CollectionMetadataTimeline<T>[];
    updateBadgeMetadataTimeline?: boolean;
    badgeMetadataTimeline?: BadgeMetadataTimeline<T>[];
    updateOffChainBalancesMetadataTimeline?: boolean;
    offChainBalancesMetadataTimeline?: OffChainBalancesMetadataTimeline<T>[];
    updateCustomDataTimeline?: boolean;
    customDataTimeline?: CustomDataTimeline<T>[];
    updateCollectionApprovals?: boolean;
    collectionApprovals?: CollectionApproval<T>[];
    updateStandardsTimeline?: boolean;
    standardsTimeline?: StandardsTimeline<T>[];
    updateIsArchivedTimeline?: boolean;
    isArchivedTimeline?: IsArchivedTimeline<T>[];
}
```

**Update Flags**

We use an update flag + new value format. If the update flag is true, we will update it to the new value. If it is false, we do not update and ignore the value in the Msg and keep the currently set value.

**Permissions**

**All updates must obey the previously set permissions.** By previously set, we mean the ones before the Msg was started. If you update the permissions in the current Msg, those are applied last and will not be applicable until the following transaction.

**Rest of Fields**

For the rest of the fields, we refer you to the following section.


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgupdateuserapprovals.md

# MsgUpdateUserApprovals

To update approvals, you can use [MsgUpdateUserApprovals](https://bitbadges.github.io/bitbadgesjs/classes/MsgUpdateUserApprovals.html). Upon genesis, every user's approval store and permissions will be the defaults specified by the collection.&#x20;

From there, they can be updated according to the permissions set (i.e. the **userPermissions** previously set). Users can only update thier own approvals.

We use an update flag + new value format. If the update flag is true, we will update it to the new value. If it is false, we do not update and ignore the value in the Msg and keep what was previously set.

```typescript
export interface MsgUpdateUserApprovals<T extends NumberType> {
    creator: string;
    collectionId: T;
    updateOutgoingApprovals?: boolean;
    outgoingApprovals?: UserOutgoingApproval<T>[];
    updateIncomingApprovals?: boolean;
    incomingApprovals?: UserIncomingApproval<T>[];
    updateAutoApproveSelfInitiatedOutgoingTransfers?: boolean;
    autoApproveSelfInitiatedOutgoingTransfers?: boolean;
    updateAutoApproveSelfInitiatedIncomingTransfers?: boolean;
    autoApproveSelfInitiatedIncomingTransfers?: boolean;
    updateUserPermissions?: boolean;
    userPermissions?: UserPermissions<T>;
}
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/README.md

# x/maps



## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgcreateprotocol.md

# MsgCreateMap

MsgCreateMap creates a map on-chain. We refer you to here for more information on each individual field.

{% content-ref url="../../../core-concepts/maps.md" %}
[maps.md](../../../core-concepts/maps.md)
{% endcontent-ref %}

```typescript
export interface iMsgCreateMap<T extends NumberType> {
  creator: string;
  mapId: string;

  inheritManagerTimelineFrom: T;
  managerTimeline: iManagerTimeline<T>[];

  updateCriteria: iMapUpdateCriteria<T>;
  valueOptions: iValueOptions;
  defaultValue: string;

  metadataTimeline: iMapMetadataTimeline<T>[];

  permissions: iMapPermissions<T>;
}
```

```typescript
export interface iValueOptions {
  noDuplicates: boolean;
  permanentOnceSet: boolean;
  expectUint: boolean;
  expectBoolean: boolean;
  expectAddress: boolean;
  expectUri: boolean;
}
```

```typescript
export interface iMapPermissions<T extends NumberType> {
  canUpdateMetadata: iTimedUpdatePermission<T>[];
  canUpdateManager: iTimedUpdatePermission<T>[];
  canDeleteMap: iActionPermission<T>[];
}
```

```typescript
export interface iMapMetadataTimeline<T extends NumberType> {
  timelineTimes: iUintRange<T>[];
  metadata: iCollectionMetadata;
}
```

```typescript
export interface iMapUpdateCriteria<T extends NumberType> {
  managerOnly: boolean;
  collectionId: T;
  creatorOnly: boolean;
  firstComeFirstServe: boolean;
}
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgdeleteprotocol.md

# MsgDeleteMap

MsgDeleteProtocol deletes the map with the given name.

<pre class="language-typescript"><code class="lang-typescript"><a data-footnote-ref href="#user-content-fn-1">export</a> interface MsgDeleteMap {
  creator: string,
  mapId: string,
}
</code></pre>

[^1]: 


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgsetcollectionforprotocol.md

# MsgSetValue

MsgSetValue sets the specific key-value pair for the mapId. For example, set my BitBadges Follow Protocol collection to collection ID 12.&#x20;

All values are stringified for comaptibility, but it will check they are in proper format within the Msg logic. You can set **options.useMostRecentCollectionId** to auto-fetch the latest collection ID. This can be leveraged in multi-msg transactions where you want to create a collection and set the ID to the just created collection. Typically, you do not know the collection ID until after the collection is created which is why this feature is useful. See below

```typescript
export interface iMsgSetValue {
  creator: string;
  mapId: string;
  key: string;
  value: string;
  options: iSetOptions;
}

export interface iSetOptions {
  useMostRecentCollectionId: boolean;
}
```

**Combining with MsgCreateCollection or MsgUpdateCollection**

The two Msgs can be easily combined in the same transaction (as Cosmos transactions support multiple Msgs). See [here](broken-reference) for an example of how to do it with the SDK. Just make sure MsgCreateCollection is executed first and precedes when it is actually used.

```typescript
const msgs: MessageGenerated[] = [];
msgs.push(...bootstrapCollections().map(x => createProtoMsg(x))) //MsgCreateCollections
msgs.push(...bootstrapSetProtocols().map(x => createProtoMsg(x))); //MsgSetCollectionForProtocol

//Note how MsgCreateAddressLists is first in the array
const txn = createTransactionPayload(txContext, msgs);
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgupdateprotocol.md

# MsgUpdateMap

MsgUpdateMap updates the map with the matching ID. Similar to the x/badges Msgs, we use an update flag + value interface. If update flag = true, we update with the corresponding value. Else, we ignore it.

```typescript
export interface iMsgUpdateMap<T extends NumberType> {
  creator: string;
  mapId: string;

  updateManagerTimeline: boolean;
  managerTimeline: iManagerTimeline<T>[];

  updateMetadataTimeline: boolean;
  metadataTimeline: iMapMetadataTimeline<T>[];

  updatePermissions: boolean;
  permissions: iMapPermissions<T>;
}
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/README.md

# x/wasmx



## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msgexecutecontractcompat.md

# MsgExecuteContractCompat



```typescript
/**
 * MsgExecuteContractCompat defines a ExecuteContractCompat message.
 *
 * @typedef {Object} MsgExecuteContractCompat
 * @property {string} sender - The sender of the transaction.
 * @property {string} contract - The contract address to execute.
 * @property {string} msg - The message to pass to the contract. Must be a valid JSON string.
 * @property {string} funds - The funds to send to the contract. Must be a valid JSON string.
 */
export interface MsgExecuteContractCompat {
  sender: string
  contract: string
  msg: string
  funds: string
}
```

MsgExecuteContractCompat is a wrapper for CosmWASM's MsgExecuteContract that is compatible with all signing methods for BitBadges users. See [Create a Smart Contract](../../create-a-wasm-contract.md) tutorial for more information.


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msginstantiatecontractcompat.md

# MsgInstantiateContractCompat

```typescript
export interface MsgInstantiateContractCompat {
  sender: string
  codeId: string
  label: string
  funds: string
}
```

MsgInstantiateContractCompat is a wrapper for CosmWASM's MsgInstantiateContract that is compatible with all signing methods for BitBadges users. See [Create a Smart Contract](../../create-a-wasm-contract.md) tutorial for more information.


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msgstorecodecompat.md

# MsgStoreCodeCompat

```typescript
export interface MsgStoreCodeCompat {
  sender: string
  hexWasmByteCode: string
}
```

MsgStoreCompat is a wrapper for CosmWASM's MsgStoreCode that is compatible with all signing methods for BitBadges users. See [Create a Smart Contract](../../create-a-wasm-contract.md) tutorial for more information.


## File: ./for-developers/bitbadges-blockchain/create-a-wasm-contract.md

# Create a Smart Contract

BitBadges support CosmWASM smart contracts to allow you to extend the token interface for custom functionality as desired. However, they are not required at all, and we envision they will only be used in a very, very small percentage of cases.

If you do need to extend the interface with unsupported functionality but you think it would be a good fit to be added natively, please let us know. Our end goal is that no smart contracts are ever needed, and everything is supported natively!

#### CosmWASM Version

```go.mod
github.com/CosmWasm/wasmd v0.44.0
```

## CosmWasm - High-Level Overview

This is just a high-level overview to familiarize you with some of the main concepts of CosmWASM. Please refer to their official documentation for more thorough documentation.

**Store and Instantiate**

The first step is to store and instantiate your contract. We walk you through this in the tutorial below.

**Contract Addresses**

Every contract will have a Cosmos bech32 contract address (e.g. bb14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sc8kg9e).

**Execute**

The main execution part of every contract is ExecuteMsg. This is what users can call to interact. Your execute function will look similar to the following. They will interact via MsgExecuteContractCompat such as below.

The **msg** field in MsgExecuteContractCompat should be a JSON string compatible with the **ExecuteMsg** of your contract. Take note of single vs double quotes. Also, note whether you serialize to camelCase or another format.

If you want to execute with funds, the **funds** property will be in the format "1badge".

```typescript
const msgExecuteContract: MsgExecuteContractCompat = {
    sender: 'bb1uqxan5ch2ulhkjrgmre90rr923932w38gwez5d', //enter sender adress here
    contract:
        'bb14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sc8kg9e', //
    msg: '{"deleteCollectionMsg": {"collectionId": "1"}}',
    funds: '1badge',
};
```

```rust
//contract.rs
#[entry_point]
pub fn execute(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response<BitBadgesMsg>, StdError> {
    match msg {
        ExecuteMsg::TransferBadgeMsg { collection_id, transfers } => {
          execute_msg_transfer_badges(collection_id, transfers)
        }
        // Add other messages here as needed
    }
}
```

```rust
//msg.rs
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, JsonSchema)]
pub struct InstantiateMsg {}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub enum ExecuteMsg {
    #[serde(rename_all = "camelCase")]
    DeleteCollectionMsg {
        collection_id: String,
    }
}
```

**No tx.origin**

Note that Cosmos SDK / CosmWasm does not have a Solidity **tx.origin** equivalent. This may not be ideal, but it is what it is for security reasons. You may need to come up with creative workarounds or creative solutions in certain situations.

## **BitBadges Bindings Repository**

Please use and reference this library [here ](https://github.com/BitBadges/bitbadges-cosmwasm-bindings/tree/master/contracts/register_addresses)(bitbadges-cosmwasm-bindings) for contract examples, types, and Rust bindings throughout this tutorial.

**NOTE:** The BitBadges bindings from the above repository do not cover messages from pre-written modules that have already been implemented by the CosmWasm team, such as staking-related messages and fundamental ones like `MsgSend`. See their documentation if you want to interact with other pre-written modules as well. For this tutorial, we will focus on interacting with the x/badges module only.

This repository exports the types and Msg functions which can be used as

```rust
use bitbadges_cosmwasm::{
  Transfer, Balance, ....
};
```

```rust
use bitbadges_cosmwasm::{
  transfer_badges_msg, delete_collection_msg, BitBadgesMsg
}
```

```rust
pub fn execute_msg_transfer_badges(
    collection_id: String,
    transfers: Vec<Transfer>,
) -> StdResult<Response<BitBadgesMsg>> {
    let msg = transfer_badges_msg(
        collection_id,
        transfers,
    );

    Ok(Response::new().add_message(msg))
}

#[entry_point]
pub fn execute(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response<BitBadgesMsg>, StdError> {
    match msg {
        ExecuteMsg::TransferBadgeMsg { collection_id, transfers } => {
          execute_msg_transfer_badges(collection_id, transfers)
        }
        // Add other messages here as needed
    }
}
```

## Tutorial

This tutorial assumes some understanding of Rust and CosmWASM. Both these topics are heavily documented, so if something is confusing, please refer to the corresponding documentation (such as [https://cosmwasm.com/build/](https://cosmwasm.com/build/) or [https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)).

It is always recommended that you test everything on a testnet before deploying for real.

### **Step 1: Create Contract**

Create your contract.

The recommended way is to clone the bitbadges cosmwasm repository and create your contracts within the contracts folder (recommended). Use the preexisting contracts as a reference.

Or, you can custom implement from scratch. If you want to develop in your own directory (i.e. not cloning the repo above), you will need to import the published package version (see [bitbadges-cosmwasm](https://crates.io/crates/bitbadges-cosmwasm)).

```toml
[dependencies]
bitbadges-cosmwasm = { version = "X.X.X" }
```

**Creating the Contract**

We leave the actual logic of your contract for you to handle. Please reference the explanations above, view examples, or refer to CosmWASM documentation if needed.

**Building and Optimizing**

Once you have your contract, you can run **cargo build** and **source ./build.sh** to get a .wasm compiled version of your contract (assuming you cloned the repo, or else, do this step manually). Note that ./build.sh may need to be edited for your contract name if you cloned the sample repo and potentially the filepath.

build.sh

```bash
RUSTFLAGS='-C link-arg=-s' cargo wasm
cp ../../target/wasm32-unknown-unknown/release/YOUR_CONTRACT_NAME.wasm .
```

You can also use an optimizer instead of **build.sh** to further optimize your bytecode size. One example optimizer is [https://github.com/CosmWasm/rust-optimizer](https://github.com/CosmWasm/rust-optimizer).

However you choose to complete this step, at the end, you should have a compiled .wasm file.

### **Step 2: Storing and Instantiating the Contract**

The easiest way to do this is simply through the helper interface we have created. You can also do it via interacting with the x/wasm or x/wasmx modules via the CLI, but the interface is a lot more streamlined and has support for all supported chains (CLI only supports Cosmos signatures).

1\) gzip your .wasm file to obtain a .wasm.gz file

```
gzip contract.wasm
```

2\) Go to [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast) and select MsgStoreCode. Upload your .wasm.gz file. Submit the transaction.

3\) A notification should pop up with your code ID, assuming the transaction was successful.

4\) Refresh the page or clear all Msgs and start a new transaction. Now, select MsgInstantiateContractCompat. Set a label (name for your contract) and enter the code ID from step 3. Submit the transaction.

If you want to instantiate it with funds. the **funds** property will be in the format "1badge".

5\) A notification should pop up with your contract's address. Store this somewhere.

Your contract is now deployed on the blockchain and ready to be interacted with.

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Step 3: Interacting with the Contract**

Once deployed, you need to to let your users interact with it.

This can be done with MsgExecuteContractCompat. MsgExecuteContractCompat simply is a helper Msg that parses everything in a compatible manner (support for users from all supported chains rather than just Cosmos) and then calls the actual CosmWasm's **MsgExecuteContract.** This is the same as broadcasting any other transaction, so we refer you to [Creating, Signing, and Broadcasting Txs](create-and-broadcast-txs/) for a tutorial.

Consider building your own dApp frontend, so users can easily interact with your contract! Get started with the quickstart repo.

**Examples (Using the Example Contract in Repo)**

```typescript
const msgExecuteContract: MsgExecuteContractCompat = {
    sender: 'bb1uqxan5ch2ulhkjrgmre90rr923932w38gwez5d', //enter sender adress here
    contract:
        'bb14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sc8kg9e', //
    msg: '{"deleteCollectionMsg": {"collectionId": "1"}}',
    funds: '1badge',
};
```

```json
{
    "sender": "bb1pa6p7nsqg57yqv23khnu5dumfhycr459jjnzsg",
    "contract": "bb1eyfccmjm6732k7wp4p6gdjwhxjwsvje44j0hfx8nkgrm8fs7vqfstglsft",
    "msg": "{\"transferBadgesMsg\": {\"collectionId\": \"1\", \"transfers\": [ { \"from\": \"bb1uqxan5ch2ulhkjrgmre90rr923932w38gwez5d\", \"balances\": [ { \"amount\": \"1\", \"badgeIds\": [ { \"start\": \"1\", \"end\": \"1\" } ], \"ownershipTimes\": [ { \"start\": \"1\", \"end\": \"18446744073709551615\" } ] } ], \"toAddresses\": [ \"bb178m3nrv6arrfwh6r6gcr60v6m63cyxrym5ahjg\" ], \"precalculateBalancesFromApproval\": { \"approvalId\": \"\", \"approvalLevel\": \"\", \"approverAddress\": \"\" }, \"merkleProofs\": [], \"memo\": \"\", \"prioritizedApprovals\": [], \"onlyCheckPrioritizedApprovals\": false } ]}}",
    "funds": "1badge"
}
```

```json
{
    "sender": "bb1pa6p7nsqg57yqv23khnu5dumfhycr459jjnzsg",
    "contract": "bb14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sc8kg9e",
    "msg": "{\"universalUpdateCollectionMsg\":{\"creator\":\"bb1pa6p7nsqg57yqv23khnu5dumfhycr459jjnzsg\",\"collectionId\":\"0\",\"balancesType\":\"Standard\",\"defaultBalances\":{\"balances\":[],\"outgoingApprovals\":[],\"incomingApprovals\":[{\"fromListId\":\"All\",\"initiatedByListId\":\"All\",\"transferTimes\":[{\"start\":\"1\",\"end\":\"18446744073709551615\"}],\"badgeIds\":[{\"start\":\"1\",\"end\":\"18446744073709551615\"}],\"ownershipTimes\":[{\"start\":\"1\",\"end\":\"18446744073709551615\"}],\"amountTrackerId\":\"default-incoming-allowed\",\"challengeTrackerId\":\"default-incoming-allowed\",\"uri\":\"\",\"customData\":\"\",\"approvalId\":\"default-incoming-allowed\",\"approvalCriteria\":{\"mustOwnBadges\":[],\"merkleChallenge\":{\"root\":\"\",\"expectedProofLength\":\"0\",\"useCreatorAddressAsLeaf\":false,\"maxUsesPerLeaf\":\"0\",\"uri\":\"\",\"customData\":\"\"},\"predeterminedBalances\":{\"manualBalances\":[],\"incrementedBalances\":{\"startBalances\":[],\"incrementBadgeIdsBy\":\"0\",\"incrementOwnershipTimesBy\":\"0\"},\"orderCalculationMethod\":{\"useOverallNumTransfers\":false,\"usePerToAddressNumTransfers\":false,\"usePerFromAddressNumTransfers\":false,\"usePerInitiatedByAddressNumTransfers\":false,\"useMerkleChallengeLeafIndex\":false}},\"approvalAmounts\":{\"overallApprovalAmount\":\"0\",\"perToAddressApprovalAmount\":\"0\",\"perFromAddressApprovalAmount\":\"0\",\"perInitiatedByAddressApprovalAmount\":\"0\"},\"maxNumTransfers\":{\"overallMaxNumTransfers\":\"0\",\"perToAddressMaxNumTransfers\":\"0\",\"perFromAddressMaxNumTransfers\":\"0\",\"perInitiatedByAddressMaxNumTransfers\":\"0\"},\"requireFromEqualsInitiatedBy\":false,\"requireFromDoesNotEqualInitiatedBy\":false}}],\"autoApproveSelfInitiatedOutgoingTransfers\":true,\"autoApproveSelfInitiatedIncomingTransfers\":true,\"userPermissions\":{\"canUpdateOutgoingApprovals\":[],\"canUpdateIncomingApprovals\":[],\"canUpdateAutoApproveSelfInitiatedOutgoingTransfers\":[],\"canUpdateAutoApproveSelfInitiatedIncomingTransfers\":[]}},\"badgeIdsToAdd\":[{\"start\":\"1\",\"end\":\"10000\"}],\"updateCollectionPermissions\":true,\"collectionPermissions\":{\"canDeleteCollection\":[],\"canArchiveCollection\":[],\"canUpdateOffChainBalancesMetadata\":[],\"canUpdateStandards\":[],\"canUpdateCustomData\":[],\"canUpdateManager\":[],\"canUpdateCollectionMetadata\":[],\"canUpdateValidBadgeIds\":[],\"canUpdateBadgeMetadata\":[],\"canUpdateCollectionApprovals\":[]},\"updateManagerTimeline\":true,\"managerTimeline\":[{\"manager\":\"bb1pa6p7nsqg57yqv23khnu5dumfhycr459jjnzsg\",\"timelineTimes\":[{\"start\":\"1\",\"end\":\"18446744073709551615\"}]}],\"updateCollectionMetadataTimeline\":true,\"collectionMetadataTimeline\":[{\"collectionMetadata\":{\"uri\":\"ipfs://QmfCSNLayKfnaGQFZ5jFgKJoirsg9Uptp4djMU3sQ3itH3\",\"customData\":\"\"},\"timelineTimes\":[{\"start\":\"1\",\"end\":\"18446744073709551615\"}]}],\"updateBadgeMetadataTimeline\":true,\"badgeMetadataTimeline\":[{\"badgeMetadata\":[{\"uri\":\"ipfs://QmQKn1G41gcVEZPenXjtTTQfQJnx5Q6fDtZrcSNJvBqxUs\",\"customData\":\"\",\"badgeIds\":[{\"start\":\"1\",\"end\":\"18446744073709551615\"}]}],\"timelineTimes\":[{\"start\":\"1\",\"end\":\"18446744073709551615\"}]}],\"updateOffChainBalancesMetadataTimeline\":true,\"offChainBalancesMetadataTimeline\":[],\"updateCustomDataTimeline\":true,\"customDataTimeline\":[],\"updateCollectionApprovals\":true,\"collectionApprovals\":[{\"fromListId\":\"Mint\",\"toListId\":\"All\",\"initiatedByListId\":\"bb1pa6p7nsqg57yqv23khnu5dumfhycr459jjnzsg\",\"transferTimes\":[ {\"start\":\"1704908530053\",\"end\":\"1704994930053\"}],\"badgeIds\":[{\"start\":\"1\",\"end\":\"18446744073709551615\"}],\"ownershipTimes\":[{\"start\":\"1\",\"end\":\"18446744073709551615\"}],\"amountTrackerId\":\"4764e5b5b1ee2a9742e34ce64febc08a8935113d2717c0f00fffef99e16f726d\",\"challengeTrackerId\":\"4764e5b5b1ee2a9742e34ce64febc08a8935113d2717c0f00fffef99e16f726d\",\"uri\":\"\",\"customData\":\"\",\"approvalId\":\"4764e5b5b1ee2a9742e34ce64febc08a8935113d2717c0f00fffef99e16f726d\",\"approvalCriteria\":{\"mustOwnBadges\":[],\"merkleChallenge\":{\"root\":\"\",\"expectedProofLength\":\"0\",\"useCreatorAddressAsLeaf\":false,\"maxUsesPerLeaf\":\"0\",\"uri\":\"\",\"customData\":\"\"},\"predeterminedBalances\":{\"manualBalances\":[],\"incrementedBalances\":{\"startBalances\":[],\"incrementBadgeIdsBy\":\"0\",\"incrementOwnershipTimesBy\":\"0\"},\"orderCalculationMethod\":{\"useOverallNumTransfers\":false,\"usePerToAddressNumTransfers\":false,\"usePerFromAddressNumTransfers\":false,\"usePerInitiatedByAddressNumTransfers\":false,\"useMerkleChallengeLeafIndex\":false}},\"approvalAmounts\":{\"overallApprovalAmount\":\"0\",\"perToAddressApprovalAmount\":\"0\",\"perFromAddressApprovalAmount\":\"0\",\"perInitiatedByAddressApprovalAmount\":\"0\"},\"maxNumTransfers\":{\"overallMaxNumTransfers\":\"0\",\"perToAddressMaxNumTransfers\":\"0\",\"perFromAddressMaxNumTransfers\":\"0\",\"perInitiatedByAddressMaxNumTransfers\":\"0\"},\"requireToEqualsInitiatedBy\":false,\"requireFromEqualsInitiatedBy\":false,\"requireToDoesNotEqualInitiatedBy\":false,\"requireFromDoesNotEqualInitiatedBy\":false,\"overridesFromOutgoingApprovals\":true,\"overridesToIncomingApprovals\":true}}],\"updateStandardsTimeline\":true,\"standardsTimeline\":[ ],\"updateIsArchivedTimeline\":true,\"isArchivedTimeline\":[]}}",
    "funds": "1badge"
}
```


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/README.md

# 🔃 Create, Generate, and Sign Txs

To learn more about broadcasting transactions with Cosmos SDK, you can visit [https://docs.cosmos.network/v0.46/run-node/txs.html](https://docs.cosmos.network/v0.46/run-node/txs.html).

We recommend generating, signing, and broadcasting your transactions with the [BitBadges SDK](../../bitbadges-sdk/). The SDK provides easy-to-use TypeScript functions to construct transactions of all types and broadcast them to a blockchain node.&#x20;

You can also run the BitBadges blockchain software and interact with its CLI, but this is more complicated and only supports Cosmos signatures.


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/broadcast-to-a-node.md

# Broadcast to a Node

**Pre-Req:** You have the body variable with a valid signature (see prior pages).

### **Simulating**

A good practice to have is to simulate the transaction before you actually broadcast and update the **fee** from the transaction context with up to date values.&#x20;

To do this, you can use&#x20;

```
https://api.bitbadges.io/api/v0/simulate
```

**or**

```typescript
http://URL:1317/cosmos/tx/v1beta1/simulate
```

This will return the gas used on a dry run of the transaction and any errors if it finds any. You can leave all signature fields empty because simulations do not check any signatures.

Note this tutorial is slightly out of order for clarity, the simulation step should typically be done before the user signs, so they only have to sign the final Msg with the up to date gas.

Once simulated, replace the expected gas you want in the transaction context.

```typescript
export interface SimulateTxRouteSuccessResponse<T extends NumberType> {
    gas_info: {
        gas_used: string;
        gas_wanted: string;
    };
    result: {
        data: string;
        log: string;
        events: {
            type: string;
            attributes: {
                key: string;
                value: string;
                index: boolean;
            }[];
        }[];
        msg_responses: any[];
    };
}
```

### **Broadcasting**

You can replace the URL below with any valid BitBadges blockchain node.

```typescript
`http://URL:1317${generateEndpointBroadcast()}`
```

Or, you can use the BitBadges API to broadcast.

```typescript
https://api.bitbadges.io/api/v0/broadcast
```

<pre class="language-typescript"><code class="lang-typescript"><strong>await BitBadgesApi.broadcastTx(body);
</strong></code></pre>

This will give you a response immediately. You should then use the tx\_response.txhash to view it on an explorer, query the blockchain directly, see if it had errors, and so on. The response code should be 0 for a successful transaction. We refer you to Cosmos docs for more information about each indivdual item.

```typescript
export interface BroadcastTxRouteSuccessResponse<T extends NumberType> {
    tx_response: {
        code: number;
        codespace: string;
        data: string;
        events: {
            type: string;
            attributes: {
                key: string;
                value: string;
                index: boolean;
            }[];
        }[];
        gas_wanted: string;
        gas_used: string;
        height: string;
        info: string;
        logs: {
            events: {
                type: string;
                attributes: {
                    key: string;
                    value: string;
                    index: boolean;
                }[];
            }[];
        }[];
        raw_log: string;
        timestamp: string;
        tx: object | null;
        txhash: string;
    };
}
```

### Polling

Once you have the tx hash, you can poll a node until the transaction is confirmed like below. Note this is a blockchain REST API\_URL, not the BitBadges API. You can also view it on explorers.

Use [http://node.bitbadges.io:1317](http://node.bitbadges.io:1317) or one of the aliases below for the BitBadges maintained node.

http://134.122.12.165:1317

https://node.bitbadges.io/api

```typescript
const txHash = res.data.tx_response.txhash;
const code = res.data.tx_response.code;
if (code !== undefined && code !== 0) {
  throw new Error(`Error broadcasting transaction: Code ${code}: ${JSON.stringify(res.data.tx_response, null, 2)}`);
}

let fetched = false;
while (!fetched) {
  try {
    const res = await axios.get(`${process.env.API_URL}/cosmos/tx/v1beta1/txs/${txHash}`);
    fetched = true;

    return res;
  } catch (e) {
    // wait 1 sec
    console.log('Waiting 1 sec to fetch tx');
    await new Promise((resolve) => setTimeout(resolve, 1000));
  }
}

return res;
```


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/generate-msg-contents.md

# Generate Msg Contents

The first step is to know what Msg type you are trying to submit and build out the contents of the Msgs in the transaction.&#x20;

If you plan to use [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast), the transaction building is already handled for you behind the scenes. The only applicable section below is Building the Msgs. This site is also a good reference if you want to explore the different types of messages.

### **Building the Msgs**

You can build out the transaction from the exported Proto type definitions. This allows you to create transactions with multiple Msg types in one tx. It also supports all Msgs for the BitBadges blockchain (even standard Cosmos SDK ones). Note that certain NumberTypes may need to be stringified before creating a proto object.

See [https://github.com/BitBadges/bitbadgesjs/tree/main/packages/bitbadgesjs-sdk/src/proto](https://github.com/BitBadges/bitbadgesjs/tree/main/packages/bitbadgesjs-sdk/src/proto) for all proto Msg definitions.

```typescript
import { proto } from 'bitbadgesjs-sdk';

//proto.cosmos.module for standard Cosmos
//proto.badges for BitBadges x/badges
//proto.wasmx for BitBadges x/wasmx
//proto.protocols for BitBadges x/protocols
const ProtoMsgDeleteCollection = proto.badges.MsgDeleteCollection;

const protoMsgs = [
    new ProtoMsgDeleteCollection({ collectionId: '1', creator: 'bb...' }),
    //Add more here (executed in order)
];
```

### Building the Transaction

```typescript
const txContext = { ... } //See prior page

const txnPayload = createTransactionPayload(txContext, protoMsgs);
```

The outputted payload will be in the following format.

For Cosmos, you will use signDIrect.

For Ethereum/Solana/Bitcoin, you will use txnString.

If you stringify txnJSON and SHA256 it, you will get the content hash from the txnString.

```typescript
export interface TransactionPayload {
    legacyAmino: {
        body: TxBody;
        authInfo: AuthInfo;
        signBytes: string;
    };
    signDirect: {
        body: TxBody;
        authInfo: AuthInfo;
        signBytes: string;
    };
    txnString: string;
    txnJson: Record<string, any>;
}
```

### Next Steps

Once you have the generated transaction, you now need to determine how you want to sign and broadcast your transaction. You have two options:

1. Use [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast) - This is a visual UI that you can simply copy and paste your Msgs into. You can get the JSON string for each message with protoMsg.toJsonString(). Generating all additional transaction details, gas, fees, and signing is all outsourced to the user interface. This is the recommended option if you do not require programmatically submitting TXs. Navigate to [Sign + Broadcast - bitbadges.io](sign-+-broadcast-bitbadges.io.md) if this is your desired option.
2. Generate, sign, and broadcast directly to a running blockchain node. This is more technical and has more steps but can be done programmatically. Navigate to the corresponding Signing page if this is your desired option ([Signing - Cosmos](signing-cosmos.md), [Signing - Ethereum](signing-ethereum.md), [Signing - Solana](signing-solana.md), [Signing - Bitcoin](signing-bitcoin.md)).


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/sign-+-broadcast-bitbadges.io.md

# Sign + Broadcast - bitbadges.io

**Option 1: Copy / Paste**

To broadcast a Msg using this [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast) user interface, all you have to do is to copy and paste the Msg contents into the text box. You should have the **txn** object from prior pages in this tutorial. Or, you can start with the samples provided and customize from there.

**Option 2: Redirect**

Or, if you are wanting to redirect to this page, you can pass in the stringified URL **txsInfo** query param, which will be auto-populated. It is expected to be a JSON stringified TxInfo\[].

```typescript
export interface TxInfo {
  type: string, //'MsgCreateCollection'
  msg: object, //JSON stringified message
}
```

This transaction builder ONLY deals with the Msg contents and not anything about the transaction context (handled by the site behind the scenes). The interface will provide you with default examples. Make sure all properties align and no extra properties like account\_number, sequence, etc are pasted. These are handled behind the scenes.

If you open via a popup, such as below, it will pass back the txHash via a window callback and auto-close upon success.

```typescript
import { proto } from 'bitbadgesjs-sdk';

const MsgCreateProtocol = proto.protocols.MsgCreateProtocol;
const msgCreateProtocol = new MsgCreateProtocol({
  "name": "Test",
  "uri": "https://www.youtube.com/watch?v=5qap5aO4i9A",
  "customData": "Test",
  "isFrozen": false,
  "creator": chain.bitbadgesAddress
})
const url = 'https://bitbadges.io/dev/broadcast?txsInfo=[{ "type": "MsgCreateProtocol", "msg": ' + msgCreateProtocol.toJsonString() + ' }]';
const openedWindow = window.open(url, '_blank', 'location=yes,height=570,width=520,scrollbars=yes,status=yes');

setLoading(true);
// You can further customize the child window as needed
openedWindow?.focus();

//set listener for when the child window closes
const timer = setInterval(() => {
  if (openedWindow?.closed) {
    clearInterval(timer);
    setLoading(false);
  }
}, 1000);
```

<pre class="language-typescript"><code class="lang-typescript"><strong>// bitbadges.io code
</strong><strong>if (window.opener) {
</strong>    window.opener.postMessage({ type: 'txSuccess', txHash: txHash }, '*');
    window.close();
}
</code></pre>

```typescript
//https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage
const FRONTEND_URL = 'https://bitbadges.io';
const handleChildWindowMessage = async (event: MessageEvent) => {

  if (event.origin === FRONTEND_URL) {

    if (!event.source) {
      throw new Error('Event source is null');
    }

    const txHash = event.data.txHash;
    if (!txHash) {
      //To avoid the listening to self events if we are actually on bitbadges.io and just an overall quality check
      return
    }


    setLoading(false);
  }
};

// Add a listener to handle messages from the child window
useEffect(() => {
  window.addEventListener('message', handleChildWindowMessage);

  // Cleanup the listener when the component unmounts
  return () => {
    window.removeEventListener('message', handleChildWindowMessage);
  };
}, []);
```

<figure><img src="../../../.gitbook/assets/image (7) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-bitcoin.md

# Signing - Bitcoin

**Signing with Bitcoin - Phantom Wallet**

Using the payload / context obtained from previous steps. We use the **jsonToSign** field and sign it as a personal signMessage using phantom wallet.

```typescript
const getProvider = () => {
  if ('phantom' in window) {
    const phantomWindow = window as any;
    const provider = phantomWindow.phantom?.bitcoin;
    if (provider?.isPhantom) {
      return provider;
    }

    window.open('https://phantom.app/', '_blank');
  }
};

function bytesToBase64(bytes: Uint8Array) {
  const binString = String.fromCodePoint(...bytes);
  return btoa(binString);
}

const signTxn = async (context: ExternalTxContext, payload: TransactionPayload, messages: any[], simulate: boolean) => {
    const bitcoinProvider = getProvider();

    let sig = '';
    if (!simulate) {
      const message = payload.txnString;
      const encodedMessage = new TextEncoder().encode(message);
      const signedMessage = await bitcoinProvider.signMessage(address, encodedMessage);

      const base64Sig = bytesToBase64(signedMessage.signature);
      sig = Buffer.from(base64Sig, 'base64').toString('hex');
    }

    const txBody = createTxBroadcastBody(context, messages, sig);
    return txBody;
};
```

## Output

This will leave you with a variable which is to be submitted to a running blockchain node. See [Broadcast to a Node.](broadcast-to-a-node.md)


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-cosmos.md

# Signing - Cosmos

Pre-Requisite: You have generated the transaction context, payload, and Msgs (see prior pages).

#### Signing with Keplr

```ts
const signTxn = async (
    context: TxContext,
    payload: TransactionPayload,
    protoMsgs: any[],
    simulate: boolean
) => {
    if (!account) {
        throw new Error('Account does not exist');
    }
    const { sender } = context;
    await window.keplr?.enable(chainId);

    let signatures = [new Uint8Array(Buffer.from('0x', 'hex'))];
    if (!simulate) {
        const signResponse = await window?.keplr?.signDirect(
            chainId,
            sender.address,
            {
                bodyBytes: payload.signDirect.body.toBinary(),
                authInfoBytes: payload.signDirect.authInfo.toBinary(),
                chainId: chainId,
                accountNumber: new Long(sender.accountNumber),
            },
            {
                preferNoSetFee: true,
            }
        );

        if (!signResponse) {
            throw new Error('No signature returned from Keplr');
        }

        signatures = [
            new Uint8Array(
                Buffer.from(signResponse.signature.signature, 'base64')
            ),
        ];
    }

    const hexSig = Buffer.from(signatures[0]).toString('hex');

    const txBody = createTxBroadcastBody(context, protoMsgs, hexSig);
    return txBody;
};
```

### Output

This will leave you with a variable which is to be submitted to a running blockchain node. See [Broadcast to a Node.](broadcast-to-a-node.md)


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-ethereum.md

# Signing - Ethereum

Pre-Requisite: You have generated the transaction context, payload, and Msgs (see prior pages).

You can simply sign the **payload.txnString** with a personal\_sign. below, we use wasgmi's signMessageAsync but you can replace this with any wallet's implementation of personal\_sign.

```typescript
const signTxn = async (context: ExternalTxContext, payload: TransactionPayload, messages: any[], simulate: boolean) => {
  const sig = simulate
    ? ''
    : await signMessageAsync({
        message: payload.txnString
      });
 
  const txBody = createTxBroadcastBody(context, messages, sig);
  return txBody;
};
```

## Output

This will leave you with a variable which is to be submitted to a running blockchain node. See [Broadcast to a Node.](broadcast-to-a-node.md)


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-solana.md

# Signing - Solana

Pre-Requisite: You have generated the transaction context, payload, and Msgs (see prior pages).

**Signing with Solana - Phantom Wallet**



Phantom / Solana do not allow message signatures > \~1000 bytes. To workaround this, we allow signing the SHA256 hash of the JSON in cases where payload.jsonToSign.length > 1000.

```typescript
const getProvider = () => {
    if ('phantom' in window) {
        const phantomWindow = window as any;
        const provider = phantomWindow.phantom?.solana;
        if (provider?.isPhantom) {
            return provider;
        }

        window.open('https://phantom.app/', '_blank');
    }
};

const signTxn = async (context: ExternalTxContext, payload: TransactionPayload, messages: any[], simulate: boolean) => {
  if (!account) throw new Error('Account not found.');

  let sig = '';
  if (!simulate) {
    //Phantom has a weird error where messages must be < ~1000 bytes
    //If we are within limit, we can have user sign the JSON
    //Else, we hash the JSON and have user sign the hash
    const encodedMessage = new TextEncoder().encode(payload.txnString);

    const signedMessage = await getProvider().request({
      method: 'signMessage',
      params: {
        message: encodedMessage,
        display: 'utf8'
      }
    });
    sig = signedMessage.signature.toString('hex');
  }

  //We need to pass in solAddress manually here
  const txBody = createTxBroadcastBody(context, messages, sig, address);
  return txBody;
};
```

## Output

This will leave you with a variable which is to be submitted to a running blockchain node. See [Broadcast to a Node.](broadcast-to-a-node.md)


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/transaction-context.md

# Transaction Context

You have two options for generating, signing, and brodcasting messages.

1. Use [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast) - This is a visual UI that you can simply copy and paste your transaction Msg contents into or provide them in the URL parameters. Generating all additional transaction details, gas, fees, and signing is all outsourced to the user interface. This is the recommended option if you do not require programmatically submitting TXs.
2. Generate, sign, and broadcast directly to a running blockchain node. This is more technical and has more steps but can be done programmatically.

If you plan to use Option 1, you may proceed to the next page because generating the transaction context is already handled via the user interface.

If you plan to use option 2, see below.

### Generating Transaction Context

The first step is to fetch and identify the transaction context and the account details for who is going to sign. You will need the following information below.

Pre-Reqs: For a user who has not yet interacted with the blockchain, the fetched public key will be null and accountNumber will be -1. To get an account number, they need to receive $BADGE somehow (this is also a pre-requisite to pay for any fees).

```typescript
import { createTxMsgSend, SupportedChain } from 'bitbadgesjs-sdk'

//TODO: Fetch the account details (see below)

//Pre-Reqs: Ensure users are registered (i.e. have a valid account number) or else this will fail
const txContext = {
  testnet: false,
  sender: {
    //Must be in native format ('0xabc..' vs 'bc1...' etc)
    address: account.address,
    sequence: account.sequence,
    accountNumber: account.accountNumber,
    //Public key is only needed for Cosmos native signatures (see below). '' if non-Cosmos
    publicKey: account.publicKey
  }, 
  //TODO: adjust accordingly
  fee: {
    amount: `0`,
    denom: 'ubadge',
    gas: `400000`
  },
  memo: ''
};
```

**Get Public Key - Cosmos**

For Keplr / Cosmos, you will need to specify the public key in the txContext. You can simply use getKey() then convert to base64.

Note: It will also be returned with the account details from the BitBadges API (if the user has interacted with the chain before via a signature).

```typescript
const getPublicKey = async () => {
    const account = await window?.keplr?.getKey('bitbadges-1')
    if (!account) return '';
    return Buffer.from(account.pubKey).toString('base64')
}
```

**Fee**

Generating the fee can be tricky. It should be reasonable for the current gas prices but also not too expensive. To get the **gas**, we recommend simulating the transaction right before broadcasting to see how much gas it uses on a dry run. We will walk you through how to do this in the broadcast tutorial. You can also fetch the estimated gas prices via the BitBadgesApi.getStatus() route.

**Sender Details**

To fetch a user's account details, the easiest way is to use the routes from the BitBadges API in [Users](../../create-and-broadcast-txs/broken-reference/). You can also query a node directly.

This will return the user's BitBadges address, account ID, sequence (nonce), and public key. If the user has previously interacted with the blockchain, all this information will already be populated.

<figure><img src="../../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/bitbadges-blockchain/overview.md

# Overview

BitBadges offers an L1 delegated proof-of-stake blockchain built with [Cosmos SDK](https://docs.cosmos.network/main). The blockchain is able to attain instant transaction finality using Tendermint and natively supports users from multiple Layer 1 blockchains (Ethereum, Bitcoin, Cosmos, Solana) via IBC and account lists.

The source code can be found at [https://github.com/bitbadges/bitbadgeschain](https://github.com/bitbadges/bitbadgeschain). The blockchain supports the Inter-Blockchain Communication Protocol (IBC) and CosmWASM.


## File: ./for-developers/bitbadges-blockchain/rest-api-docs-node.md

# REST API Docs - Node

Swagger API Documentation for REST API of a BitBadges Node: [http://134.122.12.165:1317/.](http://134.122.12.165:1317/). This is an alias of http://node.bitbadges.io:1317 but that URL does not work with HTTPS and browsers auto-upgrade to HTTPS.

This is not to be confused with the BitBadges API / Indexer API. This is the blockchain node's REST API.&#x20;



## File: ./for-developers/bitbadges-blockchain/run-a-node/README.md

# Run a Node

In this guide, we will provide detailed instructions for setting up and running a BitBadges blockchain node. This should not be used as a universal guide, as there are many methods and best practices that you can use. However, we will cover each step thoroughly and include examples to ensure a smooth setup.&#x20;

The BitBadges blockchain is built using the Cosmos SDK, so if you have prior experience running a Cosmos SDK blockchain node, you will find this process quite familiar. If you encounter any issues during the setup process, you can also refer to other Cosmos SDK node documentation, such as "[Cosmos SDK - Running a Node](https://docs.cosmos.network/main/user/run-node/run-node)" or "[Cosmos Tutorials - Run in Production documentation](https://tutorials.cosmos.network/tutorials/9-path-to-prod/1-overview.html)." These resources provide additional in-depth information and examples. Make sure that you replace everything with the corresponding BitBadges details where necessary.

**Becoming a Betanet Validator:** If you aspire to become a betanet validator, reach out to us to receive a tokens for staking.

**Chain IDs:** When a chain ID is required, use the following:

-   "bitbadges-1" for the mainnet chain ID
-   "bitbadges-2" for the testnet chain ID

**Genesis JSON:** See [https://github.com/bitbadges/bitbadgeschain](https://github.com/bitbadges/bitbadgeschain). Note different versions (testnets vs mainnet) will have different genesis JSONs.

**BitBadges Public RPCs:** https://node.bitbadges.io/rpc (alias of http://node.bitbadges.io:26657)&#x20;

Node ID (mainnet): 2703c1304a70186372aa726a762d60da94c29ffe

**Handling Upgrades:** BitBadges uses the x/upgrade module from Cosmos SDK for upgrades and expects upgrades to be handled with zero-dwontime using Cosmovisor.

**Discord:** Communications and announcements for node operators is facilitated via our Discord.


## File: ./for-developers/bitbadges-blockchain/run-a-node/cosmovisor.md

# Cosmovisor

**Installing Cosmovisor**

The first step is to download Cosmovisor as an executable using [their documentation](https://docs.cosmos.network/v0.50/build/tooling/cosmovisor). Below is the Dockerized way we do it.

```dockerfile
FROM --platform=linux golang:1.21 AS builder

ENV COSMOS_VERSION=v0.47.5
RUN apt-get update && apt-get install -y git curl
RUN apt-get install -y make wget

WORKDIR /root
RUN git clone --depth 1 --branch ${COSMOS_VERSION} https://github.com/cosmos/cosmos-sdk.git

WORKDIR /root/cosmos-sdk/tools/cosmovisor

RUN make cosmovisor
```

**Environment Variables**

You will then need to set the following environment variables. The DAEMON\_HOME will be the home of your config files.&#x20;

<pre class="language-docker"><code class="lang-docker"><strong>DAEMON_HOME=/root/.bitbadgeschain
</strong>DAEMON_NAME=bitbadgeschaind
</code></pre>

**Initializing Executables**

Then, run the following to setup your Cosmovisor directory. The executable should be named bitbadgeschaind (if not, please rename).

```bash
cosmosvisor init ./bitbadgeschaind
```

This will create the necessary folders and copy the executable into the DAEMON\_HOME/cosmovisor/genesis/bin.

IMPORTANT: Depending on your sync method (explained later), you will need to download all relevant executables. If you are syncing from genesis, you will need all executables to be able to sync to the current state. If you are syncing from a later time, you will only need the binaries used after that time. See Adding Upgrades below. You must repeat this process for all such executables.

**Adding Upgrades**

For a given upgrade, it will have a new binary and a \<upgrade-name>. \<upgrade-name> is the name used in the x/upgrade module when proposing a new software upgrade.

Depending on your version of cosmovisor, you may be able to run the following. Again, make sure the binary name is bitbadgeschaind.

```
cosmovisor add-upgrade ...
```

Or, to manually upgrade, do the following.

1. Download the new binary and name it bitbadgeschaind. Do this in a separate folder to not interfere with anything currently running.
2. Create the DAEMON\_HOME/cosmovisor/upgrades/\<upgrade-name> and DAEMON\_HOME/cosmovisor/upgrades/\<upgrade-name>/bin directory.
3. Copy the new upgrade executable to the folder (keeping its name as bitbadgeschaind).

```dockerfile
# upgrade name = abc123
RUN mkdir ${DAEMON_HOME}/cosmovisor/upgrades/abc123/
RUN mkdir ${DAEMON_HOME}/cosmovisor/upgrades/abc123/bin
RUN cp /path_to_executable ${DAEMON_HOME}/cosmovisor/upgrades/abc123/bin/bitbadgeschaind
```


## File: ./for-developers/bitbadges-blockchain/run-a-node/overview.md

# Overview

In this guide, we will provide detailed instructions for setting up and running a BitBadges blockchain node. This should not be used as a universal guide, as there are many methods and best practices that you can use. However, we will cover each step and include examples to ensure a smooth setup.

The BitBadges blockchain is built using the Cosmos SDK, so if you have prior experience running a Cosmos SDK blockchain node, you will find this process quite familiar. If you encounter any issues during the setup process, you can also refer to other Cosmos SDK node documentation, such as "[Cosmos SDK - Running a Node](https://docs.cosmos.network/main/user/run-node/run-node)" or "[Cosmos Tutorials - Run in Production documentation](https://tutorials.cosmos.network/tutorials/9-path-to-prod/1-overview.html)." These resources provide additional in-depth information and examples. Make sure that you replace everything with the corresponding BitBadges details where necessary.

**Becoming a Validator:** If you aspire to become a validator, reach out to us to receive a tokens for staking.

**Chain IDs:** When a chain ID is required, use the following:

* "bitbadges-1" for the mainnet / betanet chain ID
* "bitbadges-2" for the testnet chain ID

**Genesis JSON:** See [https://github.com/bitbadges/bitbadgeschain](https://github.com/bitbadges/bitbadgeschain). Note different versions (testnets vs betanet vs mainnet) will have different genesis JSONs.

**BitBadges Public RPCs:** https://node.bitbadges.io/rpc (alias of http://node.bitbadges.io:26657)

Node ID (betanet): 3958a0e660599d8146e7f2a6da8d4df83561b0fc

**State Snapshots:** See [Chain Details](../chain-details.md)

**Handling Upgrades:** BitBadges uses the x/upgrade module from Cosmos SDK for upgrades and expects upgrades to be handled with zero-downtime using Cosmovisor.

**Discord:** Communications and announcements for node operators is facilitated via our Discord.


## File: ./for-developers/bitbadges-blockchain/run-a-node/run-a-local-dev-node.md

# Run a Local Dev Node

Running a local development node follows pretty much the same instructions as the mainnet ones except the following.

* Chain ID should be something non-conflicting (i.e. not bitbadges-1 or -2)
* No need for seed nodes or peers (since you are running a single node local chain)
* Assuming you want to start a new chain with the latest binary, you will not have any upgrades to handle. Genesis -> Current Block will always be the current, latest binary.
  * If you are using Docker, you should be using the latest binary image instead of the mainnet node one. The mainnet node one has all binaries built.
* You can also start with an existing genesis / snapshot if you would like.
* You may have to setup a validator to be able to start producing blocks

Please reach out in the dev Discord if you are stuck or need help!

**Ignite CLI**

Throughout BitBadges' development phase, we used Ignite CLI to help scaffold, build,  and serve our chain. This is also a great option for bootstrapping a local development node. Visit their documentation for more information. You will need to download the bitbadgeschain  source code to use Ignite CLI and use Ignite on the source folder.

**Setting Up a Validator**

See [**https://docs.cosmos.network/v0.45/run-node/run-node.html**](https://docs.cosmos.network/v0.45/run-node/run-node.html) for more information if you need to setup a local validator to start your chain. Replace simd with your run command.

**Funding Your Address**

With a local development chain started from scratch, you probably want to have an address that is seeded with some starting balances. You can fund your address by editing the DAEMON\_HOME/config/genesis.json -> app\_state.bank.balances path as seen below.

You can use any converted BitBadges address (e.g. an Ethereum address converted), but we recommend using an address you can sign with via the CLI.  To get one or view your existing ones, run&#x20;

```
cosmovisor run keys ...
```

```json
...
  "bank": {
      ...
      "balances": [
        {
          "address": "bb1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs7gvmv",
          "coins": [
            {
              "denom": "ubadge",
              "amount": "1"
            }
          ]
        },
...
```

**Interacting with the Chain**

Cosmos SDK has an in-depth CLI for interacting with the chain and getting details about it. To see all commands or get help, simply run any command with --help (or an invalid command will auto print the help messages). &#x20;

The main ones you will be using are **tx** and **query** to sign transactions and query state, respectively**.**&#x20;

For example,

```bash
# --from keystorename is to sign the tx
cosmovisor run tx badges transfer-badges ... --from keystorename
```

```
cosmovisor run query badges get-balance ...
```

We refer you to the CLI docs or other Cosmos SDK documentation for more information. The best way to get started is to simply just try stuff in the CLI, in our opinion.

**Ports**

http://localhost:1317 will be the node's REST API port for queries. Navigate to it in a browser to see.

http://localhost:26657 will be the Tendermint RPC. You can also navigate here in the browser.

<!-- **Running the Full-Stack**

To run the indexer and frontend along with a local development chain, we refer you to the documentation for those. Make sure that the URLs are configured properly (i.e. pointing to localhost and not the main deployed one).&#x20;

Please reach out if you have problems. -->


## File: ./for-developers/bitbadges-blockchain/run-a-node/run-a-mainnet-node.md

# Run a Mainnet Node

## DAEMON\_HOME

Your DAEMON\_HOME is the folder that will contain everything about the blockchain state, configuration, genesis, etc. Ensure that this folder persists across upgrades and changes. This is especially important if you plan to run the node using a container approach (Docker, Kubernetes, etc).

## Fetch / Build Binaries

### Download

Download the executable directly from GitHub. For the latest releases, check the [releases page](https://github.com/BitBadges/bitbadgeschain/releases). Choose the correct executable for your machine and operating system.

```
wget https://github.com/BitBadges/bitbadgeschain/releases/download/v1.0-betanet/bitbadgeschain-linux-amd64
```

Example: [https://github.com/BitBadges/bitbadgeschain/releases/tag/v1.0-betanet](https://github.com/BitBadges/bitbadgeschain/releases/tag/v1.0-betanet)

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1)   (7).png" alt=""><figcaption></figcaption></figure>

If this is your first time downloading, you will need to also download the Wasm VM runtime library as well. This is the libwasmvm.x86\_64.so file and should be placed into /usr/lib. If not, you will get "error while loading shared libraries: libwasmvm.x86\_64.so: cannot open shared object file: No such file or directory".

Example

<pre><code>wget https://github.com/BitBadges/bitbadgeschain/releases/download/v1.0-betanet/bitbadgeschain-linux-amd64
<strong>wget https://github.com/BitBadges/bitbadgeschain/releases/download/v1.0-betanet/libwasmvm.x86_64.so
</strong><strong>mv libwasmvm.x86_64.so /usr/lib/
</strong></code></pre>

### **Build from Source**

We refer you to the README of the blockchain code repository.

### **Docker**

Running with Docker may be the easiest option, but it also is not compatible with automatic upgrades through Cosmovisor (see section below). This means you will sacrifice availability (which is especially important for validators who are slashed when down).

```bash
docker pull bitbadges/bitbadgeschain:latest
```

## Handling Upgrades - Cosmovisor

BitBadges handles binary upgrades using Cosmovisor, a tool for automating upgrades with zero downtime. You can find detailed information in the [Cosmos documentation](https://tutorials.cosmos.network/tutorials/9-path-to-prod/7-migration.html) and the [Cosmovisor documentation](https://docs.cosmos.network/main/tooling/cosmovisor.html). It is expected all validators are using Cosmovisor.

Upgrades will be announced in the Discord and are facilitated with the x/upgrades module behind the scenes. You, as the node operator, will have until the upgrade time to successfully handle the upgrade. If not completed by upgrade time, your node will halt at the upgrade height. If your node is a validator, it will be slashed.

### **Installation / Setup**

{% content-ref url="cosmovisor.md" %}
[cosmovisor.md](cosmovisor.md)
{% endcontent-ref %}

## RUN\_COMMAND

Depending on your setup method, you may have different commands to run the binary. Throughout the rest of this documentation, we use RUN\_COMMAND to avoid repeating ourselves. Please replace your command wherever you see RUN\_COMMAND

**Cosmovisor**

```bash
# The "run" is important. Ex:
# cosmovisor run init -> Blockchain initialixation
# cosmosvisor init -> Cosmosvisor folder initialization
cosmovisor run ....
```

**Plain Executable**

```
./bitbadgeschaind ....
```

**Docker**

<pre class="language-bash"><code class="lang-bash"><strong># Replace DAEMON_HOME
</strong><strong>docker run -it \
</strong>    -p 26656:26656 \
    -p 26657:26657 \
    -p 26660:26660 \
    -p 6060:6060 \
    -p 9090:9090 \
    -p 1317:1317 \
<strong>    --mount type=bind,source="$DAEMON_HOME",target=/root/.bitbadgeschain \
</strong>    bitbadges/bitbadgeschain:latest ... 
</code></pre>

## Initialization / Syncing

In order to catch up to the current consensus, you will need to get your node synced. This can be done from genesis (time consuming but no trust needed) or from a recent snapshot of the state (much faster but requires slight trust assumptions).

### **From Snapshosts (Recommended)**

If you do not want to reconstruct the entire history of the chain from genesis, you can start from a checkpoint. This can potentially save you days of syncing but requires you to trust an existing node.

{% embed url="https://explorer.bitbadges.io/BitBadges%20Mainnet/statesync" %}

**State Sync**

You can configure your config.toml to use the Cosmos SDK state sync feature to quickly sync from a trusted node. Feel free to use the official RPC node to do this. We refer you to here [https://docs.tendermint.com/v0.34/tendermint-core/state-sync.html](https://docs.tendermint.com/v0.34/tendermint-core/state-sync.html) or you can reference other Cosmos SDK state sync documentation.

**From Snapshots**

You can get the necessary files from an existing snapshot, add them to your DAEMON\_HOME, and start the chain. See [Chain Details](../chain-details.md) for providers.

For [https://snapshots.whenmoonwhenlambo.money/bitbadges-1](https://snapshots.whenmoonwhenlambo.money/bitbadges-1), use this command. Replace /cosmos/.bitbadgeschain with your home directoyry.

```
lz4 -c -d bitbadges-1-snapshot-latest.tar.lz4 | tar -x -C /cosmos/.bitbadgeschain
```

### **From Block Sync**

Syncing from genesis or via block sync means that you start with the blank genesis state and verify all transactions from the start block to the current block (time consuming). This is not recommended unless you need to run a full archive node.

**Chain Binaries**

The chain binary may be upgraded over time. To continue syncing, you will always need the relevant binary for the current block. This means you must handle ALL chain upgrades (since you are syncing from genesis). See Cosmovisor section.

**Chain Forks**

```
NOTE: We had a hard fork after block 711315
```

Normal Comet BFT block sync will not work from block 711315 -> 711316 due to this fork. You will need to manually handle this.

For handling this, you can either:

1. Start with block 711316 genesis or later (recommended). Everything will work as intended.

<pre><code>cd DAEMON_HOME/config
<strong>rm genesis.json
</strong>curl -o genesis.json https://raw.githubusercontent.com/BitBadges/bitbadgeschain/master/genesis-711316.json
RUN_COMMAND comet unsafe-reset-all
RUN_COMMAND start
</code></pre>

2. Or if you really need blocks 1-711315 for a full archive node (maybe like an explorer). Please reach out if you are planning to use this approach as we can help you through this process.

See ./scripts/handle-fork-711315.sh in the btibadgeschain GitHub repository for a full script. Or, do the following below:

You can get blocks 1-711315 via running it below or via a snapshot (recommended).

```
cd DAEMON_HOME/config
rm genesis.json
curl -o genesis.json https://raw.githubusercontent.com/BitBadges/bitbadgeschain/master/genesis.json
RUN_COMMAND start 
```

If you want to migrate and join together the blockstores / transaction indexes so they are all in one place:

<pre class="language-bash"><code class="lang-bash"># Backup the /data folder for blocks 1-711315 somewhere for later use
# Get the chain up and running for 711316+ (see above). Sync a few blocks. Stop the chain. 

<strong>git clone https://github.com/bitbadges/bitbadgeschain
</strong><strong># Edit migrate.go to use your intended source / target DB paths
</strong><strong># Run migrate.go which copies all blockstores / transaction data and sets base height back to 1
</strong><strong># Note: If you need more than just block data (cs.wal, state.db, or evidence.dd), this is left  up to you. 
</strong>go run scripts/migrate.go -source /path/to/snapshot/data -target /path/to/target/data
</code></pre>

**Testnet Genesis**

Note: Replace the genesis files with the corresponding testnet ones if you are planning to run a testnet node

## Configuration

To initialize a new chain, run the following (depending on your build method). CHAIN\_ID will be "bitbadges-1" for mainnet. Initialization should only be performed once.

```
RUN_COMMAND init <moniker> --chain-id CHAIN_ID
```

You'll need to replace `<moniker>` with a custom username for your node and the CHAIN\_ID for the chain you want (bitbadges-1 for mainnet).

Take note of where your configuration files live. We expect it to be in /root/.bitbadgeschain but if it isn't, you will need to make sure it is correct with --home flags. We call this DAEMON\_HOME.

If you are getting directories do not exist error, you may have to do the following first. These will be overwritten when the init command is executed, but it is just to get the errors out of there.

<pre><code><strong>cd DAEMON_HOME
</strong>mkdir config
mkdir data
mkdir wasm
</code></pre>

Inside the DAEMON\_HOME/config folder, you'll find two files: `config.toml` and `app.toml`. Both files contain extensive comments to help you customize your node settings. You can also run `RUN_COMMAND start --help` for explanations.

Tweak these as desired. Some important ones are highlighted below.

**Setting Seed Nodes**

In order to pull data from other nodes, you need to have seed nodes or peers to pull from. You may use 2703c1304a70186372aa726a762d60da94c29ffe@node.bitbadges.io:26656 for our official node ID. To establish connections with trusted nodes, edit `config.toml`. For instance:

```toml
seeds = "2703c1304a70186372aa726a762d60da94c29ffe@node.bitbadges.io:26656"
```

These entries follow the format `nodeId@listenaddress:port`. Additionally, you can set up seed nodes by specifying them in the `seeds` field. Or, private peers at `private_peer_ids.`

**Listen Addresses / Firewalls**

Ensure that the listen address settings are correct, using your IP address or domain name if configured. Also, make sure that your firewall exposes the necessary ports (22, 1317, 9090, 26656, 26657, 26660). See here for more information and other best practices running a node in production: [https://docs.cosmos.network/main/user/run-node/run-production#go](https://docs.cosmos.network/main/user/run-node/run-production#go).

## Running the Node

Once you have the node all configured, run the following to start the chain. You should see blocks being synced if configured correctly.

```
RUN_COMMAND start
```

**Other Considerations**

Setting up your node infrastructure correctly and with best practices is crucial to ensure security. There are many options for this, so below we just give some general guidelines.

* DDoS Mitigation: Being part of a network with a known IP address can expose you to DDoS attacks. Learn how to mitigate these risks [here](https://tutorials.cosmos.network/tutorials/9-path-to-prod/5-network.html#ddos). Consider using sentry nodes and proxies.
* Key Management: Implement best practices for key management, including key management systems such as [TMKMS](https://hub.cosmos.network/main/validators/kms/kms.html). This is especially important for validators.
* Redundancy: Plan for infrastructure failures such as power outages to ensure the continuous operation of your validator. Consider setting up your software as a service to avoid relaunching it manually every time. Refer to the [Cosmos documentation](https://tutorials.cosmos.network/tutorials/9-path-to-prod/6-run.html#as-a-service) for guidance on configuring your node as a service.
* Consider also running your node + Cosmovisor as a service, so it relaunches automatically. See [https://tutorials.cosmos.network/tutorials/9-path-to-prod/6-run.html](https://tutorials.cosmos.network/tutorials/9-path-to-prod/6-run.html) and [https://tutorials.cosmos.network/tutorials/9-path-to-prod/7-migration.html](https://tutorials.cosmos.network/tutorials/9-path-to-prod/7-migration.html)

## Running a Validator

As explained in the [Launch Phases](../../../overview/launch-phases.md) docs, reach out to us in Discord if you plan to run a validating node and need $STAKE. This is free and only requires a quick application process.

**Setup - Validator Keys**

Follow the instructions in the [Cosmos documentation](https://docs.cosmos.network/main/run-node/keyring) and/or the [Cosmos Tutorials](https://tutorials.cosmos.network/tutorials/9-path-to-prod/3-keys.html) to set up your validator keys. Replace `simd` with `bitbadgeschaind` or `myproject` with `bitbadgeschain`.

A validator handles [two](https://hub.cosmos.network/main/validators/validator-faq.html#what-are-the-different-types-of-keys) perhaps three, different keys. Most likely keys 2 and 3 [are the same](https://github.com/cosmos/cosmos-sdk/blob/v0.46.1/proto/cosmos/staking/v1beta1/tx.proto#L45-L47). Each has a different purpose:

1. The **Tendermint consensus key** is used to sign blocks on an ongoing basis. It is of the key type `ed25519`, which the KMS can keep. When Bech-encoded, the address is prefixed with `bbvalcons` and the public key is prefixed with `bbvalconspub`.
2. The **validator operator application key** is used to create transactions that create or modify validator parameters. It is of type `secp256k1`, or whichever type the application supports. When Bech-encoded, the address is prefixed with `bbvaloper`.
3. The [**delegator application key** ](https://hub.cosmos.network/main/validators/validator-faq.html#are-validators-required-to-self-delegate-atom)is used to handle the stake that gives the validator more weight. When Bech-encoded, the address is prefixed with `bb` and the public key is prefixed with `bbpub`.

**Consensus Key**

The consensus key is HOT, meaning it is needed on the validator node to sign blocks. It is strongly recommended that this is set up with a signing service and key management system.

By default, when you ran the **init** command, it creates a key for you in `..../config/priv_validator_key.json.`

This is convenient if you are starting a testnet, for which the security requirements are low. However, for a more valuable network, you should not store it directly in the node's filesystem. It should be stored in a more secure manner, such as with a signing service or key management system.

**Operator / Delegator Key**

The application / operator key should be COLD and NOT be stored on the validator node. This is just your standard public/private key pair used to sign transactions.

This can be generated (if you don't already have one) by running the following command.

```
bitbadgeschaind keys --keyring-backend file --keyring-dir /root/.bitbadgeschain/keys
add <name>
```

Adjust the command accordingly. **Note you should run this and store it on your local desktop, not the validating node.**

### Joining the Validator Set

If you intend to run a validator node, execute the following command adjusted accordingly to join the set of validators (assuming you're not part of the initial genesis set). Run with --help for more details. Replace bitbadgeschaind tx with your run command (dependent on your build method). This is the same command as how you started the node (but replace start with tx).

```shell
RUN_COMMAND tx staking create-validator /path/to/validator.json \
  --chain-id="name_of_chain_id" \
  --gas="auto" \
  --gas-adjustment="1.2" \
  --gas-prices="0.025ubadge" \
  --from=mykey
```

This should be signed with your normal key pair for signing transactions. Ensure you have enough $BADGE credits to cover gas and your stake. The `validator.json` file should contain relevant information about your validator, including the consensus public key, moniker, website, security contact, details, commission rates, and min-self-delegation.

You can obtain the public validator consensus public key using the`bitbadgeschaind tendermint show-validator` command.


## File: ./for-developers/bitbadges-sdk/README.md

# ⚒ BitBadges SDK



## File: ./for-developers/bitbadges-sdk/common-snippets/README.md

# Common Snippets

In this section, we provide common snippets and examples for the SDK. Some of these were auto-generated with AI, so please let us know if there are issues.


## File: ./for-developers/bitbadges-sdk/common-snippets/address-conversions.md

# Address Conversions

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> Address Utils

```ts
import { convertToBitBadgesAddress, convertToBtcAddress, convertToEthAddress } from "bitbadgesjs-sdk"

let address = convertToBitBadgesAddress("0x14574a6DFF2Ddf9e07828b4345d3040919AF5652")
// "bb1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw"

let address = convertToEthAddress("bb1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw")
// "0x14574a6DFF2Ddf9e07828b4345d3040919AF5652"
```


## File: ./for-developers/bitbadges-sdk/common-snippets/address-lists.md

# Address Lists

AddressLists are the base type for lists. The BitBadgesAddressList class you see returned from the API extends this. Learn more about lists in the core concepts.

```typescript
const list = new AddressList({
  addresses: ['bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh'],
  whitelist: true,
  customData: '',
  uri: '',
  createdBy: 'bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh',
  listId: 'abc123',
})

const isInList = list.checkAddress('bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh') // true
const invertedList = list.toInverted()
const isInListNow = invertedList.checkAddress('bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh') // false

list.remove('bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh')
const isEmpty = list.isEmpty()


const MintList = AddressList.Reserved('Mint')
const All = AddressList.AllAddresses();
```


## File: ./for-developers/bitbadges-sdk/common-snippets/aliases.md

# Aliases

Aliases are random unusable addresses from some seed randomness. They are slightly longer than traditional BitBadges addresses and have no corresponding private key. These are the same as the **aliasAddress** field returned from the API collections and accounts.

See below for how we generate badge, collection, and list aliases.

```typescript
const badgeAlias = generateAlias('badges', getAliasDerivationKeysForBadge(1n, 10000n))
const collectionAlias = generateAlias('collections', getAliasDerivationKeysForCollection(1n))
const listAlias = generateAlias('lists', getAliasDerivationKeysForCollection(1n))
// bb1u4xn6kst47y2hgl3532emz5dlg93te3dhdqsgwucpxu560u8zflqmwy06p
```



## File: ./for-developers/bitbadges-sdk/common-snippets/badge-metadata.md

# Badge Metadata

#### Tutorial: Managing Badge Metadata in TypeScript

**1. Introduction to `BadgeMetadataDetails`**

The `BadgeMetadataDetails` type captures comprehensive details about the metadata of a badge. It contains fields such as badge IDs (ranges), associated metadata, a URI, and custom data. This is what is used via the **cachedBadgeMetadata** field from collection responses.

**2. Removing Metadata for Specific Badge IDs**

To delete metadata associated with specific badge IDs:

```typescript
const currentMetadata: BadgeMetadataDetails<bigint>[] = [...]; // your current metadata array

const badgeIdsToRemove = UintRangeArray.From([
  { start: 5n, end: 10n }
];

const updatedMetadata = removeBadgeMetadata(currentMetadata, badgeIdsToRemove);
console.log(updatedMetadata); // This will show metadata without the removed badge IDs.
```

**3. Updating Metadata for Badges**

If you wish to update specific badge metadata in the badge metadata details:

```typescript
const currentMetadata: BadgeMetadataDetails<bigint>[] = [...]; // your current metadata array

const metadataToUpdate: BadgeMetadataDetails<bigint> = new BadgeMetadataDetails<bigint>({
  badgeIds: [{ start: 7n, end: 7n }],
  metadata: { /* your metadata details here */ },
  uri: "http://new-metadata-url.com", //Or 'Placeholder' or something else
  customData: "Some custom information",
});

const newMetadataArray = updateBadgeMetadata(currentMetadata, metadataToUpdate);
console.log(newMetadataArray); // This will show the array with the updated metadata.
```

**4. Fetch Metadata Details for a Specific Badge ID**

To retrieve metadata details for a particular badge ID:

```typescript
const badgeIdToFetch = 12n;

const badgeMetadataDetails = getMetadataDetailsForBadgeId(badgeIdToFetch, currentMetadata);
console.log(badgeMetadataDetails); // This will display the metadata details for the specified badge ID.
```

**5. Fetch Only the Metadata for a Specific Badge ID**

To only retrieve the metadata (without the surrounding details) for a particular badge ID:

```typescript
const badgeIdToFetch = 15n;

const badgeMetadata = getMetadataForBadgeId(badgeIdToFetch, currentMetadata);
console.log(badgeMetadata); // This will show only the metadata for the given badge ID.
```

**Conclusion**

These functions provide a robust toolkit for managing badge metadata. Whether you're updating, fetching, or deleting metadata associated with badges, you have a systematic and structured approach available.


## File: ./for-developers/bitbadges-sdk/common-snippets/balances.md

# Balances

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> Balances



### Tutorial: Using the TypeScript SDK for Balance Operations

**1. Define the Balance**

Here's how you create a balance using the provided `Balance` interface:

<pre class="language-typescript"><code class="lang-typescript"><strong>const userBalance = BalanceArray.From([{
</strong>  "amount": 5n, // example badge amount using the BigInt type
  "badgeIds": [{ start: 1n, end: 5n }],
  "ownershipTimes": [{ start: 1628770800000n, end: 1628857200000n }] // example timestamps using BigInt
}])
</code></pre>

Note: The `UintRange` type is assumed to be an object with `start` and `end` properties of type `bigint`. Adjust as necessary based on the actual definition.

**2. Add Balance**

To add a balance to an array of existing balances:

```typescript
const balanceToAdd = {
  amount: 3n,
  badgeIds: [{ start: 6n, end: 8n }],
  ownershipTimes: [{ start: 1628860800000n, end: 1628947200000n }]
};
userBalance.addBalances([balanceToAdd]);
```

This will add `balanceToAdd` to the list of existing balances.

**3. Subtract Balance**

To subtract a balance from an array of existing balances:

```typescript
const balanceToRemove = {
  amount: 2n,
  badgeIds: [{ start: 2n, end: 3n }],
  ownershipTimes: [{ start: 1628784400000n, end: 1628870800000n }]
};
userBalance.subtractBalances([balanceToRemove], false) //second param is to allow underflow (negatives)
```

**Conclusion**

This SDK provides a clear and structured way to manage and operate on badge balances. With the `addBalance` and `subtractBalance` functions, you can effortlessly update and maintain badge balances in your application.\
\
Given the new functions you've shared, I'll provide a tutorial snippet for each of them.

### Tutorial: Retrieving Balances Based on Badge ID and Time

**1. Get Balance for a Specific ID and Time**

If you need to retrieve the balance for a specific badge ID and a specific ownership time, you can use the `getBalanceForIdAndTime` function:

```typescript
const badgeIdToLookup = 3n;
const timeToLookup = 1628784400000n;  // example timestamp using BigInt
const specificBalance = balances.getBalanceForIdAndTime(badgeIdToLookup, timeToLookup);

console.log(specificBalance); // This will show the balance for the specified badge ID and time, if found.
```

**2. Get Balances for a Specific Badge ID**

To get all balances associated with a specific badge ID:

```typescript
const badgeIdToLookup = 4n;
const badgeBalances = balances.getBalancesForId(badgeIdToLookup);

console.log(badgeBalances); // This will display all the balances for the given badge ID.
```

**3. Get Balances for a Specific Time**

If you need to retrieve all badge balances for a specific ownership time:

```typescript
const timeToLookup = 1628784400000n;
const timeSpecificBalances = balances.getBalancesForTime(timeToLookup);

console.log(timeSpecificBalances); // This will show all the balances that have the specified ownership time.
```

Alright, given the new function `getBalancesForIds` which retrieves balances for a range of badge IDs and a range of times, let's create a tutorial snippet for it:

4. **Get Balances for Specific Ranges of Badge IDs and Times**

If you need to retrieve balances for a range of badge IDs and a range of ownership times, you can utilize the `getBalancesForIds` function:

```typescript
// Define the range of badge IDs and times you want to look up
const idRangesToLookup = [
    { start: 1n, end: 3n },
    { start: 5n, end: 7n }
];

const timeRangesToLookup = [
    { start: 1628770800000n, end: 1628857200000n },  // example timestamp range using BigInt
    { start: 1628943600000n, end: 1629030000000n }   // another timestamp range
];

// Retrieve the balances
const specificBalances = balances.getBalancesForIds(idRangesToLookup, timeRangesToLookup);
console.log(specificBalances); // This will show the balances that fall within the specified badge ID ranges and time ranges.
```

**Conclusion**

The provided functions in this SDK make it easy to retrieve specific badge balances based on different criteria, such as badge ID and ownership time. Utilize these functions to access and display relevant data as per your application's requirements.


## File: ./for-developers/bitbadges-sdk/common-snippets/get-unhandled-approvals.md

# Approvals / Transferability

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> Approvals / Transferability

You can use the following functions to get the approval combinations that have unhandled. If unhandled, they are disapproved.

```typescript
export function getUnhandledCollectionApprovals(
  collectionApprovals: CollectionApprovalWithDetails<bigint>[],
  ignoreTrackerIds?: boolean
  doNotMerge?: boolean
)
```

```typescript
export function getUnhandledUserOutgoingApprovals(
  approvals: UserOutgoingApprovalWithDetails<bigint>[],
  userAddress: string,
  doNotMerge?: boolean
)
```

```typescript
export function getUnhandledUserIncomingApprovals(
  approvals: UserIncomingApprovalWithDetails<bigint>[],
  userAddress: string,
  doNotMerge?: boolean
)
```

Use the following functions to add the default user approvals to an existing set of approvals. For incoming, this will be: if unhandled, approve only if to == initiatedBy. For outgoing, vice versa.

```typescript
export function appendSelfInitiatedOutgoingApproval(currApprovals: UserOutgoingApprovalWithDetails<bigint>[], userAddress: string): UserOutgoingApprovalWithDetails<bigint>[]
```

```typescript
export function appendSelfInitiatedIncomingApproval(currApprovals: UserIncomingApprovalWithDetails<bigint>[], userAddress: string): UserIncomingApprovalWithDetails<bigint>[] 
```


## File: ./for-developers/bitbadges-sdk/common-snippets/numbertype-conversions.md

# NumberType Conversions

A problem with creating a JavaScript SDK for a Cosmos SDK based blockchain is that JavaScript's number primitive cannot natively handle numbers > Number.MAX\_SAFE\_INTEGER, but the blockchain allows amounts greater than that.

To combat this, we have made all TypeScript types in the SDK generic via a NumberType interface.

```typescript
export type NumberType = bigint | number | string | boolean;
```

Types that you will find in the SDK that are number-based will all be generically typed, so that you can use any of the above NumberTypes, according to your preferences.

It is recommended that you use bigint and/or stringified because these can represent all possible numbers and do not lose precision. Also, note that for almost all SDK functions, we only take bigints.

For example, the following will represent a BadgeMetadata type where all numbers are stringified (i.e. "100" or "123").

```typescript
const stringifiedMetadata: BadgeMetadata<string> = new BadgeMetadata({ uri: ... });
```

**Converting Between NumberTypes**

To convert between different number types, all types come with a converter function (**.convert()**). This allows you to convert all the stringified numbers to another format (such as JS number or JS bigint). To convert, you can simply do the following:

```typescript
import { BigIntify, BadgeMetadata, JSPrimitiveNumberType, NumberType, convertBadgeMetadata } from "bitbadgesjs-sdk";

const stringifiedMetadata: BadgeMetadata<string> = new BadgeMetadata({ uri: ... });
const bigIntifiedMetadata = stringifiedBadgeMetadata.convert(BigIntify);
```

We export the following types and converter functions for your convenience.

```typescript
export type NumberType = bigint | number | string | boolean;
export type JSPrimitiveNumberType = string | number | boolean;

export const BigIntify = (item: NumberType) => numberify(item, StringNumberStorageOptions.BigInt) as bigint;
export const Stringify = (item: NumberType) => numberify(item, StringNumberStorageOptions.String) as string;
export const Numberify = (item: NumberType) => numberify(item, StringNumberStorageOptions.Number) as number;
export const NumberifyIfPossible = (item: NumberType) => numberify(item, StringNumberStorageOptions.NumberIfPossible) as number | string;
```

**Example Application**

In our API, JS bigints cannot be natively sent over HTTP. So, we use the following execution flow:

1. Before sending to the client, stringify everything before sending over HTTP
2. The client can use the converter functions to coonvert all types to their preferred method


## File: ./for-developers/bitbadges-sdk/common-snippets/off-chain-balances.md

# Off-Chain Balances

We refer you to [here](../../badges-advanced/self-hosted-balances/).


## File: ./for-developers/bitbadges-sdk/common-snippets/timelines.md

# Timelines

As you may have noticed, many of the collection fields are timeline-based, meaning they can be scheduled to have different values at different times. Check out the [Timeline helpers](https://bitbadges.github.io/bitbadgesjs/functions/getCurrentValuesForCollection.html) from bitbadgesjs-sdk in the SDK.

**Examples:**

If you are using the BitBadgesCollection interface, this is achievable simply with the helper functions. There is one for every timeline.

```typescript
const manager = collection.getManager(); //Can pass in a time too (defaults to now)
```

Or, you can do it manually

<pre class="language-typescript"><code class="lang-typescript"><strong>const manager = getCurrentValuesForCollection(collection).manager;
</strong></code></pre>

<pre class="language-typescript"><code class="lang-typescript"><strong>const manager = getValuesAtTimeForCollection(collection, Date.now() + 1000 * 60).manager;
</strong></code></pre>

You can also get all possible values for timelines as such. This will set all missing times with empty or default values.

```typescript
function getFullManagerTimeline(
    timeline: ManagerTimeline<bigint>[]
): ManagerTimeline<bigint>[];
```

```typescript
function getFullCollectionMetadataTimeline(
    timeline: CollectionMetadataTimeline<bigint>[]
): CollectionMetadataTimeline<bigint>[];
```

And so on for all other timelines.


## File: ./for-developers/bitbadges-sdk/common-snippets/transfers-w-increments.md

# Transfers

The `TransferWithIncrements` type provides a convenient method for handling batch transfers, especially when you need to distribute badges sequentially or when badges have varying ownership times. By combining this with the `getBalancesAfterTransfers` function, you can effortlessly manage and update badge balances in your application.

```typescript
import { BalanceArray, TransferWithIncrements, getAllBadgeIdsToBeTransferred, getAllBalancesToBeTransferred } from '../packages/bitbadgesjs-sdk'

const startingBalances = BalanceArray.From([
  {
    amount: 100n,
    badgeIds: [{ start: 1n, end: 100n }],
    ownershipTimes: [{ start: 1628770800000n, end: 1628857200000n }],
  },
])

const batchTransfer = new TransferWithIncrements<bigint>({
  from: 'Mint', // replace with your address

  balances: startingBalances,

  toAddresses: [], // this will be empty because we're using `toAddressesLength`
  toAddressesLength: 100n,

  incrementBadgeIdsBy: 1n,
  incrementOwnershipTimesBy: 86400000n, // assuming this is 1 day in milliseconds in BigInt form
})


const allBadgeIds = getAllBadgeIdsToBeTransferred([batchTransfer]) // returns [{ start: 1n, end: 100n }]
const allBalancesToBeTransferred = getAllBalancesToBeTransferred([batchTransfer]) // returns [{ amount: 100n, badgeIds: [{ start: 1n, end: 100n }], ownershipTimes: [{ start: 1628770800000n, end: 1628857200000n }] }
```


## File: ./for-developers/bitbadges-sdk/common-snippets/uint-ranges.md

# Uint Ranges

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> UintRanges



#### Tutorial: Managing and Querying Unsigned Integer Ranges

**1. Introduction to `UintRange`**

The `UintRange` interface captures a range of unsigned integers using a start and end property. This is handy when representing intervals or spans of values.

**2. Sorting and Merging Ranges**

To sort a list of ranges and merge adjacent or overlapping ones:

```typescript
const ranges = UintRangeArray.From([
  { start: 10n, end: 20n },
  { start: 5n, end: 12n },
  { start: 21n, end: 25n }
]);
ranges.sortAndMerge();

console.log(ranges); // Expected: [{ start: 5n, end: 25n }]
```

**3. Searching Within Ranges**

To search for a specific ID within a list of ranges and return its index and a boolean indicating if it was found:

```typescript
const idToSearch = 15n;
const [index, isFound] = ragnes.search(idToSearch)
console.log(`Index: ${index}, Found: ${isFound}`);
```

**4. Inverting Ranges**

To invert a list of ranges between a minimum and maximum ID:

<pre class="language-typescript"><code class="lang-typescript"><strong>ranges.invert(1n, 30n);
</strong>console.log(invertedRanges); // This would show the gaps between the given ranges within the specified bounds.
</code></pre>

**5. Removing One Range From Another**

To remove one range from another and also get the removed part:

```typescript
const rangesToRemove = [{ start: 10n, end: 20n }];

ranges.remove(rangesToRemove);
console.log("Remaining:", ranges);

const [inCurrButNotOther, overlaps, inOtherButNotCurr] = ranges.getOverlapDetails(rangesToRemove)
```

**6. Checking for Overlaps**

To determine if there are overlaps within a list of ranges:

```typescript
const overlaps = ranges.overlaps([{ ...}]);
console.log(`Ranges Overlap: ${overlappingCheck}`);
```

**Conclusion**

The functions provided offer a comprehensive toolkit for managing and querying unsigned integer ranges. Whether you're checking for overlaps, inverting ranges, or removing specific integers from a range, you now have the tools to do it efficiently and systematically.



```typescript
import { GO_MAX_UINT_64, UintRange, UintRangeArray } from 'bitbadgesjs-sdk'

//Singular range functions
const range = new UintRange<bigint>({ start: 1n, end: 10n })
const size = range.size() //10n
const fullRange = UintRange.FullRange() // 1n - GO_MAX_UINT_64
const isFull = fullRange.isFull()
const inverted = range.invert() // 11n - GO_MAX_UINT_64
const overlaps = range.overlaps(inverted) // false
const doesFiveExist = range.search(5n) // true
const overlapDetails = range.getOverlapDetails(fullRange) // [[], [{ start: 1n, end: 10n }], [{ start: 11n, end: GO_MAX_UINT_64 }]]
const overlappingRanges = range.getOverlaps(fullRange) // [{ start: 1n, end: 10n }]

const rangeArr = UintRangeArray.From<bigint>([{ start: 1n, end: 10n }, { start: 11n, end: 20n }])
const rangeArrSize = rangeArr.size() // 20n
const rangeArrFull = UintRangeArray.FullRanges() // 1n - GO_MAX_UINT_64
const rangeArrIsFull = rangeArrFull.isFull()
const rangeArrInverted = rangeArr.toInverted({ start: 1n, end: GO_MAX_UINT_64 }) // 21n - GO_MAX_UINT_64

const unsortedArr = UintRangeArray.From<bigint>([{ start: 11n, end: 20n }, { start: 1n, end: 15n }])
const hasOverlaps = unsortedArr.hasOverlaps() // true
unsortedArr.sortAndMerge() // [{ start: 1n, end: 20n }]

const sortedArr = unsortedArr.clone()
const [inCurrButNotOther, overlaps, inOtherButNotCurr] = sortedArr.getOverlapDetails(unsortedArr) // [[], [{ start: 1n, end: 20n }], []]

sortedArr.remove({ start: 1n, end: 10n }) // [{ start: 11n, end: 20n }]

const [idx, found] = sortedArr.search(11n) // [0n, true]
const exists = sortedArr.searchIfExists(11n) // true
const index = sortedArr.searchIndex(11n) // 0n
```


## File: ./for-developers/bitbadges-sdk/overview.md

# Overview

The BitBadges SDK is a bundle of TypeScript libraries that provide all the tools and functions needed for you to build your own frontend or interact with the BitBadges API, blockchain, and indexer.

GitHub: [https://github.com/bitbadges/bitbadgesjs](https://github.com/bitbadges/bitbadgesjs)

Full Documentation: [https://bitbadges.github.io/bitbadgesjs/](https://bitbadges.github.io/bitbadgesjs/)

```
npm install bitbadgesjs-sdk
```

This library provides miscellaneous functionality to help you interact with BitBadges, such as types, API routes, managing metadata requests, logic with ID ranges and balances, etc.

```typescript
const bitbadgesAddress = convertToBitBadgesAddress(address);
const ethAddress = bitbadgesToEth(bitbadgesAddress);
```

It also exports functions for broadcasting transactions and interacting with the blockchain. See [Broadcasting Txs](../bitbadges-blockchain/create-and-broadcast-txs/) for how to use.

```typescript
const nodeUrl = ...

const postOptions = {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: generatePostBodyBroadcast(signedTx),
}

const broadcastEndpoint = `${nodeUrl}${generateEndpointBroadcast()}`
const broadcastPost = await fetch(
  broadcastEndpoint,
  postOptions,
)

const response = await broadcastPost.json()
```

For most use cases, you will not need to broadcast transactions. If you do, consider first exploring the helper broadcast tool at [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast).


## File: ./for-developers/bitbadges-sdk/sdk-types.md

# SDK Types

### Custom Types

All types used in the SDK are exported via two ways.&#x20;

**Classes**

The first is via a JavaScript class. These will always begin with a capital letter. This class will always have the core functions below. Other specific functions may also be implemented.

```typescript
export declare class CustomTypeClass<T extends CustomType<T>> implements CustomType<T> {
    toJson(): JsonObject;
    toJsonString(): string;
    equals<U extends CustomType<U>>(other: CustomType<U> | null | undefined, normalizeNumberTypes?: boolean | undefined): boolean;
    clone(): T;
    getNumberFieldNames(): string[]; //Used behind the scenes
    convert<U extends NumberType>(_convertFunction?: (val: NumberType) => U): CustomType<any>;
}
```

The .convert() function is especially useful when dealing with different NumberTypes (bigint -> string).

```typescript
import { Balance, Numberify } 

const balance = new Balance<bigint>({
    amount: 1n,
    badgeIds: [{ start: 1n, end: 100n }],
    ownershipTimes: [{ start: 1n, end: 100n }]
})
const convertedBalance = balance.convert(Numberify); //1, 100 instead of 1n, 100n
```

**Interfaces**

The second is a JavaScript interface. This is the same as the class version minus all functions (just the core JSON object).

```typescript
export interface iBalance<T extends NumberType> {
    amount: T;
    badgeIds: iUintRange<T>[];
    ownershipTimes: iUintRange<T>[];
}
```

**Which one to use?**

Many functions support both; however, you may have to convert between them occasionally for compatibility. We recommend using the classes, but we recognize that many developers prefer the interfaces.&#x20;

### Typed Arrays

Some types also have a typed array exported as well. Similar to a Uint8Array in Javascript, these have all the features of traditional arrays. Thus, you can use .find, .map, .filter(), etc. Plus, additional functions will be available on them (e.g. array.addBalances for the BalanceArray type).&#x20;

```typescript
//Option 1
const balances = new BalanceArray()
balances.push(...)

//Option 2
const balances = BalanceArray.From([{ ... })

balances.addBalances([{ ... }]); //adds balances in-place
```

### **Proto Types**

The blockchain behind the scenes uses the Protocol Buffer type language. Within the SDK, we auto-generate all these proto types for you, but these are typically not the ones you should use in development (only when broadcasting transactions (see [here](../bitbadges-blockchain/create-and-broadcast-txs/))).&#x20;

Some might have duplicates between the two types.

```typescript
import { Balance } from "bitbadgesjs-sdk/dist/proto/balances";
import { Balance } from "bitbadgesjs-sdk";
```

The Proto types are exported via the following

```typescript
import { proto } from "bitbadgesjs-sdk";
const MsgCreateProtocol = proto.protocols.MsgCreateProtocol;
```

If you ever end up with something like the following, this is also the proto definition. We recommend using the proto.abc.xyz method to avoid confusion.

```typescript
import { MsgUpdateCollection } from "bitbadgesjs-sdk/dist/proto/badges";
```


## File: ./for-developers/claim-builder/auto-completing-claims/automate-w-zapier/README.md

# Integrate with Zapier



## File: ./for-developers/claim-builder/auto-completing-claims/automate-w-zapier/automatic-claim-tutorial.md

# Automatic Claim Tutorial

### Overview

The other option is to trigger claims automatically with Zapier. You will configure the Zap to automatically complete the claim for the user upon a custom trigger. For example, upon purchasing an item, auto-send them a purchased item badge.

To do this, you **MUST** get the users' crypto addresses somehow before the action is executed. This can be beforehand or somehow obtained during the duration of the Zap. We leave this up to you. If you cannot obtain users' addresses, this approach will not work.

We want to note that functionality is slightly different for badges with on-chain balances as opposed to off-chain badges or address lists.

* On-Chain: The check and complete claim action will **RESERVE** the right for the user to complete the claim. However, it does not actually automatically trigger anything on the blockchain. This is because such a transaction requires a signature from the recipient. Thus, the user still has to go to the BitBadges site and complete the claim process, although the reservation process is automatic.
* Off-Chain and Other Claims: For badges with off-chain balances or other claim types, there is no reservation process. The claims are automatically completed. For off-chain badge claims, this means the badges will be auto-distributed. For address lists, this means the address will be automatically appended to the list.

You will use the BitBadges API Zapier plugin with the Complete Claim action to perform the final claim completion. This approach takes special configuration explained in the tutorial below to ensure the claim process is correct and only executable by the Zap. See the tutorial for more information.

<figure><img src="../../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Create the Claim

The first step is to create the claim via the Bitbadges site; however, note that the configuration of the claim must be correct to ensure correct behavior of the claim process and allow Zapier to communicate. Select the Zapier approach when creating, and it should guide you through the process.

Note: Many in-site plugins may become incompatible due to the user not completing in-site. However, you gain access to any custom trigger from 7000+ apps on Zapier.

<figure><img src="../../../../.gitbook/assets/image (195).png" alt=""><figcaption></figcaption></figure>

## Tutorial

Example walkthrough of a custom Zap. Customize to your use case.

Step 1: Create and setup your Zap on [https://zapier.com/](https://zapier.com/). The site will walk you through it all.

Step 2: Select and configure your trigger. Triggers are the action that initiate the automation flow. In this cases, this is a new Udemy course being completed. We leave the selection of the trigger up to you. This will depend on your intended use case.

<figure><img src="../../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Step 3: Configure the Complete Claim by BitBadges integration. The password and other config parameters will be constant and obtained when creating the claim. However, the address may be fetched from prior integrations or manually provided. This is up to you.

<figure><img src="../../../../.gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure>

You can get the claim information from the form when you are creating the claim.

Step 4: Simulate / Test

You may use the simulation feature to test that your claim communicates and will pass without actually executing the action.

Note that behind the scenes, this is just a simulation (does not actually complete the claim) if sent manually from the test step. The claim will actually be completed for successful Zaps once live.

Step 5: Track Progress

For most use cases, just submitting the claim is typically adequate. However, you can also track it with the other BitBadges action in Zapier (Get Claim Attempt Status). You will pass the ID received from the submission to this. Note that we use a queue system so it may take some time to officially process.

And, it is as easy as that!


## File: ./for-developers/claim-builder/auto-completing-claims/automate-w-zapier/overview.md

# Overview

Zapier BitBadges Integration: [https://zapier.com/apps/bitbadges/integrations](https://zapier.com/apps/bitbadges/integrations)

**What is Zapier?**

Zapier is an online automation tool that connects your favorite apps, such as Gmail, Slack, Mailchimp, and more than 2,000 others. You can automate repetitive tasks with workflows known as Zaps. A Zap connects two or more apps to automate part of your business or personal tasks. A Zap is created using a trigger and one or more actions. A trigger is an event in an app that starts the Zap. After a trigger occurs, Zapier automatically completes an action—or series of actions—in another app. This seamless connection between apps enables complex tasks to be completed automatically, saving time and improving productivity.

See all supported apps here: [https://zapier.com/apps](https://zapier.com/apps).

<figure><img src="../../../../.gitbook/assets/image (72).png" alt=""><figcaption></figcaption></figure>

**How does Zapier x BitBadges work?**

Couple ways:

* Claims can be auto-completed from Zapier
* Post-success Zaps can implement utility or rewards
* Dynamic stores can be implemented with automatic updates of the list
* Claim infomration like codes can be automatically distributed to users

<figure><img src="../../../../.gitbook/assets/image (197).png" alt=""><figcaption></figcaption></figure>

When automating claims with Zapier, you will follow the approach of upon doing something (custom trigger), perform an action  (claim a badge, distribute a code, add to dynamic store).

<figure><img src="../../../../.gitbook/assets/image (89).png" alt=""><figcaption></figcaption></figure>

## **Error Handling**

You should also account for the fact that Zaps can partially execute. For example, if you have a Zap with 10 plugins and it fails on the 8th plugin, the Zap will not be considered a success but 8/10 plugins would be executed already. There is no rollback feature.

Similarly, if you are triggering a Zap during a claim's execution, there is no guarantee that the overall claim is successful because other plugins might fail.

## Triggers

The custom trigger step is left up to you to implement from any of the 7000+ app integrations.&#x20;

## **Actions**

With the claim or action step of the automated flow, you have a couple options depending on your use case.

{% content-ref url="../../automate-w-zapier/distribute-claim-information-tutorial/" %}
[distribute-claim-information-tutorial](../../automate-w-zapier/distribute-claim-information-tutorial/)
{% endcontent-ref %}

{% content-ref url="automatic-claim-tutorial.md" %}
[automatic-claim-tutorial.md](automatic-claim-tutorial.md)
{% endcontent-ref %}


## File: ./for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/README.md

# Automate Any Part of the Process

You can also get creative and customize other parts of the claim too, like the distribution of secret information like codes.&#x20;

<figure><img src="../../../../.gitbook/assets/image (196).png" alt=""><figcaption></figcaption></figure>

You can send the claim code, for example, via the Email by Zapier Plugin or Gmail plugin, and once the user receives the email, they can log on to the BitBadges site and select their address to receive the badges for when claiming.

<figure><img src="../../../../.gitbook/assets/image (142).png" alt=""><figcaption></figcaption></figure>



## File: ./for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/google-forms.md

# Google Forms

## Setting Up a Claim with Google Forms Zapier

The easiest way is to simply create a Zap using the Google Forms and BitBadges integrations. See the link below for a full tutorial.

<figure><img src="../../../../.gitbook/assets/image (145).png" alt=""><figcaption></figcaption></figure>

{% content-ref url="./" %}
[.](./)
{% endcontent-ref %}

## Setting Up a Claim with Google Forms Script Editor

This guide will walk you through setting up a Google Form to generate unique claim codes using a seed code from the BitBadges Codes plugin.

### Prerequisites

* A Google account
* Access to Google Forms
* A claim with the BitBadges Codes plugin

### Steps

#### 1. Create a Google Form

* Go to Google Forms.
* Create a new form or open an existing one. Customize as needed.

#### 2. Open the Script Editor

* In your Google Form, click on the three dots in the upper right corner.
* Select Script editor.

<figure><img src="../../../../.gitbook/assets/image (138).png" alt=""><figcaption></figcaption></figure>

#### 3. Add the Script

1\. Delete any existing code in the script editor.

2\. Copy and paste the following code into the script editor.\


```javascript
var SEED_CODE = 'ENTER_SEED_CODE_HERE';

function onFormSubmit(e) {
  var form = FormApp.getActiveForm();
  var submissionNumber = getSubmissionNumber();
  var code = generateCodeFromSeed(SEED_CODE, submissionNumber);
  setCustomConfirmation(form, code);
}

function generateCodeFromSeed(seedCode, submissionNumber) {
  var data = seedCode + '-' + submissionNumber;
  var hash = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, data);
  var hexHash = hash.map(function(byte) {
    var hex = (byte & 0xFF).toString(16);
    return (hex.length === 1 ? '0' : '') + hex;
  }).join('');
  return hexHash + '-' + submissionNumber;
}

function getSubmissionNumber() {
  var form = FormApp.getActiveForm();
  return form.getResponses().length;
}

function setCustomConfirmation(form, code) {
  var confirmationMessage = "Thank you for completing the survey. Your unique code is: " + code + '. Provide this in the form on BitBadges when claiming.'
  form.setConfirmationMessage(confirmationMessage);
}
```

3\. Replace 'ENTER\_SEED\_CODE\_HERE' with your actual seed code. To get your seed code, use the Codes plugin on BitBadges:

* Click on the Distribute button which opens up the modal.
* Select Batch.
* Copy the seed code.

<figure><img src="../../../../.gitbook/assets/image (139).png" alt=""><figcaption></figcaption></figure>

#### 4. Set Up the Trigger

* In the script editor, click on the clock icon to open the Triggers page.
* Click on + Add Trigger.
* Set the following options:
  * Choose which function to run: onFormSubmit
  * Choose which deployment should run: Head
  * Select event source: From form
  * Select event type: On form submit

<figure><img src="../../../../.gitbook/assets/image (140).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/image (137).png" alt="" width="554"><figcaption></figcaption></figure>

#### 5. Save and Close

Save your script by clicking on the disk icon or pressing Ctrl + S. Close the script editor.

#### 6. Test Your Form

Submit a response to your form.

* Check the confirmation message to see your unique code.
* Note that the forms are assigned based on number of responses (including any test submissions). If you want to reset from scratch, you can delete all saved responses in your form.



**Add-Ons**

Consider adding functionality to the script like sending the code via emails, protecting against multiple submissions, etc. We leave thi sup to you and your needs.



## File: ./for-developers/claim-builder/automate-w-zapier/dynamic-store-zaps.md

# Dynamic Store Zaps

We refer you [here](../dynamic-stores/adding-data.md) for more information.&#x20;

Zaps to add users to a dynamic store may be the most common use case for the BitBadges Zapier integration, notably because they can operate without crypto addresses in favor of emails. You can simply just use the Zap to parse email or user ID or username -> add to the store and let BitBadges handle the rest of the crypto-native stuff.

<figure><img src="../../../.gitbook/assets/image (175).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/automate-w-zapier/post-success-zaps.md

# Post-Success Zaps

Post-success Zaps are a great way to implement custom utility from over 7000+ apps upon claim successes.

There are two options:

1. Use Webhooks by Zapier plugin and catch a POST request + Post-Success Zap plugin in your claim. This is recommended as it is much more feature complete and allows you to get social identifiers like emails, apps, etc.
2. Use the Claim Success trigger provided by BitBadges x Zapier Integration

For this tutorial, we will showcase Option 1:

1. Setup your Zap with Webhooks by Zapier and catch a POST request

<figure><img src="../../../.gitbook/assets/image (204).png" alt=""><figcaption></figcaption></figure>

2. Configure your Post-Success Zapier Webhook plugin in the BitBadges site. Add the webhook URL it gives you from Step 1. For Zapier, the validation secret is not as important, but you can additionally add a step to check it within the Zap. The JSON preview it shows you will give you all the available fields you can use.&#x20;

<figure><img src="../../../.gitbook/assets/image (207).png" alt=""><figcaption></figcaption></figure>

3. Use the Send Test Request in the BitBadges site to complete the test / simulation step in your Zap.

<figure><img src="../../../.gitbook/assets/image (205).png" alt=""><figcaption></figcaption></figure>

4. Configure your action with any app and dynamically replace values where needed. For example, if your action is an outbound send email, you will need to parse the email from the webhook and automatically populate the recipient address for the email.

<figure><img src="../../../.gitbook/assets/image (206).png" alt=""><figcaption></figcaption></figure>

5. Setup the rest of your Zap, create the claim, and you are good to go!


## File: ./for-developers/claim-builder/bitbadges-api-claims/README.md

# BitBadges API & Claims



## File: ./for-developers/claim-builder/bitbadges-api-claims/auto-complete-claims-w-bitbadges-api.md

# Auto-Complete Claims w/ BitBadges API

Note: This is a more advanced option that is incompatible with in-site plugins. Before going through the entire process, consider whether you can implement your use case with a plugin-only approach.&#x20;

Typically, we recommend making a custom webhook / plugin over this. Get creative! Use existing plugins, Zapier, create custom plugins, etc as an alternative to needing a complete auto-complete implementation.

<figure><img src="../../../.gitbook/assets/image (4) (1).png" alt=""><figcaption></figcaption></figure>

### Auto-Completion

You can use the BitBadges SDK to auto-complete claims for users.

```typescript
const res = await BitBadgesApi.completeClaim(claimId, address, { ... });
console.log(res.claimAttemptId);

//Sleep 2 seconds to wait for it to be processed in the queue

const res = await BitBadgesApi.getClaimAttemptStatus(res.claimAttemptId);
console.log(res); // { success: true }
```

When creating on the BitBadges site, go to the API Code tab, and you should see code snippets customized to your claim.

<figure><img src="../../../.gitbook/assets/image (119).png" alt=""><figcaption></figcaption></figure>

Couple notes with auto-completing claims:

* If your claim is setup to require proof of sign in, proof of other socials sign ins (Sign In with Discord, etc), you must have the proper session authentication handled.
* Otherwise, you can setup your claim to be open to anyone but restricted by non-session criteria. For example, do not require proof of address but all claimees must present a valid password (potentially only known by you or the code which is expected to claim).

**Simulating**

You can also simulate the claim (which is instant and not put into the queue). There are also options within this request to simulate specific plugins only for further fine-grained testing (\_specificInstanceIds). The complete claim route automatically simulates and returns instantly if simulation fails. If simulation passes, it is put into the queue.

The body is the same as the completeClaim route. See below.

```typescript
const res = await BitBadgesApi.simulateClaim(claimId, address, { ...body });
```

**Custom Body**

Custom plugins may also require custom body inputs from the user. If you are using a custom plugin not created by you, refer to that plugin's documentation or contact the creator for more input on the custom body schema.

You will need to pass \_expectedVersion. This is the version number of the claim that you expect to complete. If there is a version mismatch at claim time, the claim will fail. This is to avoid instances where the claim creator maliciously changes criteria / actions without you knowing. You can specify -1 for don't check, but this is not recommended.

The custom body (if needed) should be in the following format

```typescript
{
    _expectedVersion: '0', //version of the claim (obtained from fetching the claim)
    [instanceId: string]: { ...pluginBody }
}
```

For example,

```typescript
{
    _expectedVersion: '0', //version of the claim 
    [`abc123`]: { //password plugin w/ instance ID = "abc123"
        password: "abc123"
    },
    [`codes1234`]: { //codes plugin w/ instance ID = "codes1234"
        code: "supersecretcode"
    },
}
```

**Customization**

The rest is left up to you. You decide when to trigger this code. It could be when a user signs in, you can auto-trigger based on certain criteria, or anything else you want.


## File: ./for-developers/claim-builder/bitbadges-api-claims/fetching-claims.md

# Fetching Claims

More documentation is available via the API routes for fetching claims.

Go to the JSON tab of the claim details in-site to see an example one. Note that fetchPrivateParams: true is necessary to get certain private information. You must have permissions to view private parameters.

```typescript
// GET https://api.bitbadges.io/api/v0/claim/claimId?...
const claimsRes = await BitBadgesApi.getClaim({ 
    claimId, 
    fetchPrivateParams: false, 
    fetchAllClaimedUsers: true, 
    privateStatesToFetch: [instanceId],
});
```

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/bitbadges-api-claims/verifying-claim-attempts-w-the-api.md

# Verifying Claim Attempts w/ the API

IMPORTANT: Verifying claim attempts are two-fold:

* Authentication: Authenticate the user (can be done with Sign In with BitBadges or however)
* Verifying Claim Attempt: Lookup the claim attempt via the BitBadges API and cross-check the user has satisfied the criteria

Note: You may opt to simply receive a post-success webhook which would take the API verification step out of it.

```typescript
// Pre-Req: Set up your claim at https://bitbadges.io/create
// Pre-Req: User is authenticated

// 1. By address (if you already have it)
// GET https://api.bitbadges.io/api/v0/claims/success/{claimId}/{address}
// successCount will be 1 for on-demand claims and the number of completions for standard
const res = await BitBadgesApi.checkClaimSuccess(claimId, address);
if (res.successCount >= 1) { doSomething(); }

// 2. By attempt ID 
// GET https://api.bitbadges.io/api/v0/claims/status/{claimAttemptId}
const res = await BitBadgesApi.getClaimAttemptStatus(claimAttemptId);
if (res.success) { doSomething() }

// You may also browse all claim-based API routes in the reference like a fetch all claim
// attempts for a user, but the above two are typically what you are looking for.
```

**Claim Attempt IDs vs By Address**

If you already have the user address, you can simply use option 1.

If you want to verify by claim attempt ID, you can use option 2. Claim attempt IDs can be obtained if you are completing the claim on behalf of the user (e.g. via Zapier or the API), or you can set up a custom webhook to receive it.

Note: If you are receiving a post-success webhook, you already know the claim has gone through by the nature of it, so you do not need to verify it.

This will also allow you to map a user address / claim attempt to another social that you may identify your users by. For example, if you authenticate with email, you can request us to verify the user email, receive the email, and use the (ID, email) pair instead of an address.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Use one of the plugins pictured below or a custom plugin to do so when setting up your claim.

<figure><img src="../../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

**More Advanced Ways**

Note: You may also implement other ways of verifying claim attempts such as parsing state directly, storing data yourself from webhooks, etc. You can also trust the post-success webook to only be fired upon success. For these, we refer you to the corresponding documentation such as the API. The process is flexible, but the above should be all you need.


## File: ./for-developers/claim-builder/checking-custom-criteria.md

# Checking Custom Criteria

If the in-site plugins are not enough on the criteria side, consider one of the following:

## Dynamic Stores

Dynamic stores can be created in the developer portal. They are simply a list of users stored by BitBadges, managed by you. You attach it to a claim and gate the claim to users in the list.

Stores are nice because they are not tied to a specific claim, and you do not have to deal with addresses if not needed. They are serverless.

You can:

1. Update users manually in-site
2. Update programmatically via the API
3. Update via Zapier - Triggers from 7000+ apps -> add to dynamic store

{% content-ref url="dynamic-stores/" %}
[dynamic-stores](dynamic-stores/)
{% endcontent-ref %}

<figure><img src="../../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

## Custom Webhooks / Plugins

Configure your claim with custom webhooks. Use the "Check Your Own Criteria" plugin. Alternatively, you can use the Forms / Collect Inputs plugin to instead let us store the requests for you, and you can fetch the details in-site / export to CSV format.

Note: The in-site webhook plugins are streamlined alternatives to building your own custom plugins which are a little more feature-rich and reusable.

Be mindful though that if you are checking criteria, you should have verification BEFORE the claim is completed. Post-success hooks cannot affect the outcome.

{% content-ref url="plugins/" %}
[plugins](plugins/)
{% endcontent-ref %}

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

## Auto-Completion

You could also initiate the completion of claims on behalf of users with the API or via Zapier. This is advanced and a custom plugin / webhook is oftnetimes a better alternative.


## File: ./for-developers/claim-builder/claim-links.md

# Claim Links (URLs)

If users claim in-site, simply direct them to the claim page, such as the following:

[https://bitbadges.io/claims/ad831a95b20ab0aeaa1695ae8ada7bb6](https://bitbadges.io/claims/ad831a95b20ab0aeaa1695ae8ada7bb6)

Or if it is tied with an application, address list, or badge, direct them to the corresponding page there.

#### Auto-filled Details (Advanced / Experimental)

The following details can be auto-filled for the user if specified in the query parameters.

* `code`: The unique code for the Codes plugin (assumes only one code plugin)
* `password`: A password for the Passwords plugin (assumes only one password plugin)
* `claimId`: The unique identifier for the claim. This lets us know which one to highlight.
* `customBody`: The preconfigured JSON encoded claim body for the user. See the API for more information. Note that you will have to URL encode it.
* `approvalLevel`: "collection" | "incoming" | "outgoing". We scan for the claimId (collection level first) but for on-chain collections, you may have claims for user level approvals as well. This is used in the case of duplicate claimIds on different levels.

https://bitbadges.io/collections/1?code=ABC123\&password=securepass\&claimId=98765\&customBody={"exampleInstanceId":%20"abc123"}


## File: ./for-developers/claim-builder/completion-methods.md

# Completion Methods

With BitBadges claims, you will have a couple ways of completing claims. Note on-demand do not have a completion "action", so this is only applicable to standard claims.

**Option 1: Directly In-Site (Recommended)**

Users can claim directly on the corresponding page directly in the BitBadges site. We envision this is to be used for almost all cases. Custom logic can be implemented through custom plugins or webhooks or other means.

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Option 2: Auto-Claim by Zapier**

You can can extend BitBadges Claims with our custom Zapier integration that allows you to connect claims with over 7000+ apps. See all supported apps here: [https://zapier.com/apps](https://zapier.com/apps).

For example, make a purchase on Shopify -> get allocated a badge or complete a course on Udemy -> get a completion badge. The "airdrop" is a claim completion.

<figure><img src="../../.gitbook/assets/image (87).png" alt=""><figcaption></figcaption></figure>

Note: Zapier can also be used to automate other parts of the claim, like specific plugins or implementing post-claim rewards.

**Option 3: Auto-Claim by API**

You can implement a hybrid approach on your own using the BitBadges API and connect it behind the scenes. This allows you full flexibility over the claiming process.

```typescript
const res = await BitBadgesApi.completeClaim(claimId, address, { ... });
```

**Get Creative!**

A common theme you may see when implementing claims is to get creative and think outside the box. There are a ton of integrations and features already implemented. Even if your use case doesn't exactly match the implementation, you can get creative and implement workarounds.

For example,

* Give out claim codes / passwords to those who meet the criteria on your end rather than needing a direct integration.
* Many apps and services are email based rather than username based. Consider using the Email plugin universally.

## Claiming on Behalf of Others

With each claim, there is only one address (the claiming address). There is no initiator and recipient like with standard approvals. If you want to initiate a claim on behalf of others, you have to get a little creative.

**Password (Secrets) Approach**

The typical approach (used for Zapier and other examples) is to disable all user authentication (Signed In to BitBadges) but gate the claim with a password or other secret information. This allows you (who has knowledge of the password) to complete claims.

Because the authentication check is disabled, you can specify any claiming address. However, note that this disables the authentication check for everyone. You must gate the claim in other ways (like the password).

<figure><img src="../../.gitbook/assets/image (187).png" alt=""><figcaption></figcaption></figure>

**OAuth - Complete Claim Scope**

Or, you could also be authorized to complete claims on behalf of the user via the BitBadges API, but this is only used in some cases. You will need separate authorizations from every claiming user. See Sign In with BitBadges for how to implement.


## File: ./for-developers/claim-builder/concepts/README.md

# Concepts



## File: ./for-developers/claim-builder/concepts/claim-numbers.md

# Claim Numbers

By default, we use an incrementing claim number system for standard claims. For example, claim #1, then claim #2, etc.&#x20;

However, certain implementations may custom assign claim numbers, which can be used to implement custom logic, such as distributing specific badges.

Only one plugin is allowed to assign claim numbers which is determined by the **assignMethod** of the claim. If the assignMethod === a plugin's unique instance ID, we allow it to assign claim numbers.

<figure><img src="../../../.gitbook/assets/image (186).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/gating-badge-distribution.md

# Gating Badge Distribution

One utility offered with claims is to gate badge distribution as the reward via the Create -> Badges flow. This uses a special clai type.

For off-chain balances, we can just allocate the balances directly after claiming.

For on-chain badge balances, a successful claim will result in reserving the right to claim, not actually completing the claim. This is because the claim criteria is checked off-chain, and we need an on-chain transfer transaction. It is a two-step process.

Behind the scenes, we reserve the unique claim code for the user. The on-chain transaction will eventually specify that claim code in the eventual transfer transaction. On-chain, these are the leaves of [Merkle challenge](../../badges-advanced/balances-transfers/approval-criteria/merkle-challenges.md) in the approval criteria and are one-time use only to prevent replay attacks. These are not the same codes as the Codes plugin, if enabled.

**When to use claims vs self-hosted balances?**

For claims that gate badge distribution, you may want to evaluate the tradeoff of claims vs self-hosted balances. Claims are handled on a trigger basis. When something occurs or the user attempts to claim, a claim can be completed and transfer badges or perform another claim action.

However, note claims may not be the right choice for you, especially if you already have all the data you need already. If you already have the data, you may consider self-hosting the balances / airdropping badges to your users. This removes the middle action step required to complete the process.

<figure><img src="../../../.gitbook/assets/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/identify-by-socials-emails.md

# Identify By Socials / Emails?

Do you identify your users by emails or a supported social username?

Select one of the webhook plugins (or forms for serverless) when setting up your claim. This will set you up to be able to track and maintain a map of (attempt ID / address) -> user socials or emails, enabling you to continue identifying your users how you already do!

Note: Verifying claim attempts are two-fold: 1) authenticate the user and 2) verify the claim. In this instance, step 1 would be authenticating the user email / social on your end if needed.&#x20;

{% content-ref url="../plugins/creating-a-custom-plugin/alternatives.md" %}
[alternatives.md](../plugins/creating-a-custom-plugin/alternatives.md)
{% endcontent-ref %}

<figure><img src="../../../.gitbook/assets/image (225).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/monetizing-apps-badges.md

# Payment Checking

If your use case requires monetization (such as memberships or recurring payments), we host an in-site Stripe plugin for you to use. While $BADGE is the native credits of the blockchain and we do offer accepting $BADGE fees per on-chain approval use, we do not recommend using it for payment purposes. We recommend to accept payments using existing processors like Stripe.&#x20;

Note: This is provided for convenience and is not the only solution. You can choose to self-implement payments however you want. Ex: Self-host and gate by emails who have paid.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Setting Up Your Account

To setup a Stripe Connect account, go to the connected accounts section of the Developer Portal ([https://bitbadges.io/developer](https://bitbadges.io/developer)).&#x20;

### Creating a Claim

Once setup, you can then get started creating claims with the Stripe Payment plugin. Users will be prompted to complete the checkout process before claiming.

Note: Refunds are possible (learn more below). In the event of an auto-refund, the Stripe fees are not returned, and you make up the difference.

To mitigate refunds, the golden rule for designing payment-gated claims that avoids any refund logic is that a a specific claim attempt from a user will either always succeed or always fail. It should never be able to succeed at time A but not at time B. In other words, assume that if the queue is backed up for 100 days, that should not alter whether a claim succeeds or fails.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Payment Capture

Since claims and Stripe are two separate services, we can either capture payments immediately before or after the claim has been completed. For our design, we capture claims before to guarantee payment before the claim.

#### How Claims Work Behind the Scenes (The Basic Process)

1. The claim is fully completed / simulated to see if it will succeed (both external and internal logic). This also includes a ready to capture payment check to ensure the user has completed checkout and we are ready.&#x20;
2. If all claim checks pass, the claim is queued. We cache any external logic.
3. We capture the payment here.
4. The claim is added to a queue
5. At the queue's final processing time, we rerun the claim's internal logic (state handling) to ensure it still passes and there are no race conditions. We reuse any external logic from Step 1.
   1. If the sanity check fails, we have to issue a refund to the customer at this point. This is rare but can happen with poor claim design.

This process is often immediate (<1 second), but the time ultimately goes at the speed of the queue.

#### Capture Before Claim

* **What happens**: The payment is captured immediately before the final processing of the claim but after confirming a full simulation.
* **Advantage**: Guarantees payment for successful claims. 100% of users who complete the claim have guaranteed payment went through.
* **Risk**: In the rare case of the sanity check of failing after Step 1) full simulation succeeded, we automatically issue refunds to the customer. Stripe fees are NOT returned, you make up the difference in the refund to each customer (poor user experience as well - 2 charges on statements plus additional processing).
* **Proper Design:** This can always be mitigated with proper claim design. **T**he golden rule is design your claims such that a specific claim attempt from a user will either always succeed or always fail. It should never be able to succeed at time A but not at time B.
  * When might the refund case occur?
    * **Max Uses Exceeded:** 1000 users submit at exact same time with only 1 claim use left. All 1000 get added to the queue. We have to refund 999 of them.
    * **Claim Codes:** If you give out a one-time use code to two users and they both submit at the same time and both make it into the queue, we will have to refund one.
  * Note though, these cases are rare but need to be accounted for
    * It only applies to internal state race conditions, not external fetches
    * Even just a second or two between claim submissions typically would invalidate the initial simulation (Step 1) leading to it never being placed in the queue and payment never being captured.
    * We do our best on our end to mitigate and prevent such cases before they happen


## File: ./for-developers/claim-builder/concepts/receiving-attestations.md

# Receiving Attestations

Within the user inputs for both pre-built and custom plugins, we support accepting the "Attestation" type. This allows you to securely receive user selected attestations they have saved or uploaded which may be private via webhooks or plugins. This is only possible with standard in-site claims because the user has to be signed in and select it manually.

You will receive the attestation in the payload of your request via the **key** you configure. The builder should give you a preview.

{% content-ref url="../plugins/creating-a-custom-plugin/alternatives.md" %}
[alternatives.md](../plugins/creating-a-custom-plugin/alternatives.md)
{% endcontent-ref %}

IMPORTANT: Don't trust, verify! You should also note that we simply provide you with the attestation. Treat BitBadges as the middleman. All custom checks like the content of the messages, issuer is correct, etc.

You need to verify the attestations on your side. Verification is done according to the expected format. If you need to check BitBadges core ones (scheme == 'bbs' || scheme == 'standard'), you can use the SDK's **verifyAttestation** function or API **verifyAttestation** route. If it is a third-party upload, see the corresponding documentation.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/signed-in-vs-select-address.md

# Signed In vs Select Address

To require the user to be signed in, select the Signed In to BitBadges plugin. If not selected, we allow any address to be manually entered without address verification or sign in requirements. However, disabling "Signed In with BitBadges" allows any user to claim on another's behalf. Make sure this is intended and all other criteria properly gates the claim.

By not including a sign-in requirement, this makes the user experience better (no signatures). This is also helpful on mobile or other places where users may not have access to their wallets. However, this can be mitigated with approved sign-ins or other approaches like embedded wallets, but those require prior setup. 

**Auto-Completing Claims**

If you are planning to auto complete claims behind the scenes via the API or via Zapier, note that you have two approaches.

1. OAuth Sign In with BitBadges - The Signed In requirement will pass if you have the Complete Claims ("completeClaims") scope.
2. Disable + Gate In Another Way - For example, our Zapier flow does not check user sign in but gates with a password that only Zapier knows.

<figure><img src="../../../.gitbook/assets/image (198).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/standard-vs-on-demand.md

# Standard vs On-Demand

Claims, at their core, are just criteria checks, but there are two ways we can check this criteria. The first is standard claims which require a "complete claim" process or action:

* Criteria is checked at completion time
* Claim numbers are assigned
* Can maintain statefulness
* Ledger of users who have claimed

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

The second is on-demand (sometimes described as non-indexed). These are a special type of claim that has unique properties. Notably, they are autonomous, self-contained, can be fetched on-demand, stateless, does not require any user inputs, sessions, and can function with just a user address / creator parameters.

The critieria is not indexed anywhere but rather calculated on-demand.

* No indexing
* No claim numbers
* No verifiable list of users who have claimed
* Limited in feature set because you need to be able to check criteria at any time, so you cannot use authenticated sessions or other apporaches
* Calculated in real-time
* No success webhooks

For example, checking a minimum balance of $BADGE is safe to use on-demand because we always know a user's balance at any given time wihtout user interaction and just their address. Another common on-demand check is badge ownership as shown below.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/universal-approach-claim-codes.md

# Universal Approach - Claim Codes

We want to highlight that claim codes are a universal approach that can be used with any application / criteria. For example,

-   Give codes to finishers of a race
-   Give codes to attendees of an event
-   Give codes to those who sign in to your website
-   Distribute codes via email, SMS, etc
-   And so on. You distribute according to your needs!

No need for a custom integration or to identify the user by an identifier. Simply identify them with a code.

Use the Codes plugin to set the codes for your claim. We recommend auto-generating them for sufficient randomness, but you may also custom create them.

**Generate Codes from Seed Snippet**

Auto-generated codes are calculated from a seed code, rather than needing to store all N codes. Note indexes are zero-based (code #1 = idx 0).

```typescript
import CryptoJS from 'crypto-js';
const { SHA256 } = CryptoJS;
export const generateCodesFromSeed = (
    seedCode: string,
    numCodes: number
): string[] => {
    let currCode = seedCode;
    const codes = [];
    for (let i = 0; i < numCodes; i++) {
        currCode = SHA256(`${seedCode}-${i}`).toString();
        codes.push(`${currCode}-${i}`);
    }
    return codes;
};
```

**Generate Codes from Seed API Endpoint**

Or, outsource the generation to our [API Route](https://bitbadges.stoplight.io/docs/bitbadges/abee9e7fa5f8d-get-code-codes-plugin)

## **Save for Later Links**

You may also consider using a save for later link. See example below.

[https://bitbadges.io/saveforlater?value=38d3fe58dffea3f7a675b587bc9239e0360047b7482d245f6770deb589aef869](https://bitbadges.io/saveforlater?value=38d3fe58dffea3f7a675b587bc9239e0360047b7482d245f6770deb589aef869)

## **Zapier**

The get code via idx from seedCode route is also available in Zapier opening up some cool possibilities like auto-distribution.

{% content-ref url="../automate-w-zapier/distribute-claim-information-tutorial/" %}
[distribute-claim-information-tutorial](../automate-w-zapier/distribute-claim-information-tutorial/)
{% endcontent-ref %}


## File: ./for-developers/claim-builder/dynamic-stores/README.md

# Dynamic Stores



## File: ./for-developers/claim-builder/dynamic-stores/adding-data.md

# Adding Data

**Method 1: UI**

You can directly manage your store in the interface.

**Method 2: API**

```typescript
await BitBadgesApi.performStoreAction(...)
await BitBadgesApi.performBatchStoreAction(...)
```

If you want to use the BitBadges API to send hooks / POST requests to, you can do so manually. We refer you to the interface in the developer portal for getting the exact route / body you might need.

<figure><img src="../../../.gitbook/assets/image (173).png" alt=""><figcaption></figcaption></figure>

**Method 3: Zapier**

Use the BitBadges Zapier integration to automate workflows for you. Zapier connects to over 7000+ integrations. In this case, your trigger will be the app you want to integrate nad the action will be BitBadges Add User to Dynamic Store.

Typically, you will want to field map data from your trigger (e.g. Eventbrite attendee email) into the BitBadges Store Action step. For documentation on how to do this, see Zapiers documentation.

* [Field Mapping](https://help.zapier.com/hc/en-us/articles/31709122224653-Enter-data-in-Zap-fields#01JC4MFMXXJXSS7GBAYZP32XKZ)
* [Send Data Between Steps By Mapping Fields](https://help.zapier.com/hc/en-us/articles/8496343026701-Send-data-between-steps-by-mapping-fields)

You may notice that we have a few different identifier fields (email, address, id, username). Leave the ones you don't need blank. Which field you populate should correspond to the store type you have created.

<figure><img src="../../../.gitbook/assets/image (176).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (174).png" alt=""><figcaption></figcaption></figure>

You can also use the Zapier approach to check criteria as well. For example,

1. Setup a Google Form that users can enter their email (or parse the Gmail from the metadata).
2. Setup a Zap to trigger upon Google Forms responses.
3. Check if existing Mailchimp subscriber using email provided via the Mailchimp integration plugin.
4. Add email to dynamic store if subscribed (note: we only allow claims for verified emails)

If setting up an in-site claim, you can redirect the users to the form via the URL Click plugin, Custom Instructions Plugin, or just in the description as well.


## File: ./for-developers/claim-builder/dynamic-stores/overview.md

# Overview

#### What are Dynamic Stores?

A flexible storage system on BitBadges' side for maintaining lists of:

* Email addresses
* User Crypto addresses
* User IDs / usernames names from platforms like Discord, etc

These can be thought of as a separate store for maintaining a list of users. You then "attach" stores to a claim and gate the claim by checking if a user is in the store. You control it. We store it. Update it:

* Manually in-site in the developer portal
* Automatically w/ API calls

```typescript
await BitBadgesApi.performStoreAction(...)
await BitBadgesApi.performBatchStoreAction(...)
```

* Automatically w/ Zapier - Listen to 7000+ apps and add users to store in no-code

To get started, go to the Developer Portal. This will walk you through the process of creating, attaching, and adding data to the store.

Once your store is created, you can add users / data to it. Note that we add via a queue-based approach, so the data may take a couple moments to populate.

**Attach to a Claim**

The interface should walk you through the process of attaching it to a claim:
1. Directly in claim builder, you should see your stores in the templates section
2. In the stores tab, click Create Claim for a one-click create a claim which is auto-configured
3. Add the corresponding plugin (email for email stores) and add the store in the parameters select

**Store ID and Store Secret**

When creating your store, you will get a store ID and secret. These are to be provided by the API / Zapier when managing data. You can also manage the store without the secret if you are signed in with the owner address.

#### Core Advantages

**1. Reusability**

* Not tied to specific plugins or claims
* Can be shared across multiple verification processes

**2. Dynamic Management**

* Real-time updates on the go (dynamic instead of static)
* For example, as users check in to an event, you can dynamically add them to the store which would then make the plugin pass for those users dynamically

**3. Outsourced Storage**

* As opposed to a traditional plugin where you maintain a validation endpoint and potentially store data, this is outsourced to us.
* The roles are flipped. We handle the storage and validation, and you just send update hooks as they come in.

**4. Not Address Dependent**

* All accounting for claims and other BitBadges services is done primarily with crypto addresses. For example, to complete a claim, you need to specify a claiming address. However, many apps and services do not have such a link from user ID on the app -> crypto address.&#x20;
  * This approach allows you to not need to worry about addresses and only the app identifiers / emails. BitBadges handles the rest.&#x20;

<figure><img src="../../../.gitbook/assets/image (222).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (168).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (223).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/implementing-custom-utility.md

# Implementing Custom Utility

Need to perform some additional action upon the user claiming successfully?

## **Preconfigured Plugins**

The easiest and most typical approach is to just do this with preconfigured plugins. No code required. Many use cases are already implemented for you and will auto execute for you if configured. For example, the Send BitBadges Notification plugin or Assign Discord Role.

<figure><img src="../../.gitbook/assets/image (189).png" alt=""><figcaption></figcaption></figure>

## **Integrations**

Some integrations may check claims automatically for you. For example, create a WordPress gated site by just entering the claim ID to check in the settings.

{% content-ref url="../authenticating-with-bitbadges/framework-templates/wordpress.md" %}
[wordpress.md](../authenticating-with-bitbadges/framework-templates/wordpress.md)
{% endcontent-ref %}

## **In-Site Rewards - URLs / Content**

When creating rewards on the claim builder page, you can also link gated content / URLs to only be visible to users upon successfully claiming.

You may want additional authentication depending on your tolerance level. You can even consider this in-site URL to initially be a Sign In with BitBadges URL here with eventual redirect support to your destination URL. Authentication becomes streamlined this way.

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Use the BitBadges API

To lookup claim state or recent claim attempts by address or other claim information, use the BitBadges API to query this data. Then, implement your logic as you see fit.

{% content-ref url="bitbadges-api-claims/verifying-claim-attempts-w-the-api.md" %}
[verifying-claim-attempts-w-the-api.md](bitbadges-api-claims/verifying-claim-attempts-w-the-api.md)
{% endcontent-ref %}

## Use Post-Success Zaps

If you want to automate this process, consider using Zapier to auto-execute logic upon claim successes per user.

For example, new claim -> add to Mailchimp list or add to Google Sheets.

<figure><img src="../../.gitbook/assets/image (219).png" alt=""><figcaption></figcaption></figure>

{% content-ref url="automate-w-zapier/post-success-zaps.md" %}
[post-success-zaps.md](automate-w-zapier/post-success-zaps.md)
{% endcontent-ref %}

## **Use Post-Success Webhooks / Plugins / Serverless Request Bin**

<figure><img src="../../.gitbook/assets/image (217).png" alt=""><figcaption></figcaption></figure>

Set up a custom success webhook or plugin (post-success) and receive the configured information (plus any custom user inputs or configured user socials you want to receive) via the payload. By the nature of it being a post-success webhook, you do not even need to verify the claim attempt was successful.

Or, the Collect User Inputs (request bin) plugin is a serverless alternative! Instead of needing your own handler, we store the requests for you. You access them in-site or via the API.

<figure><img src="../../.gitbook/assets/image (218).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/integrate-with-pipedream/README.md

# Integrate with Pipedream



## File: ./for-developers/claim-builder/integrate-with-pipedream/build-custom-plugins.md

# Build Custom Plugins

Building custom plugins with Pipedream could streamline a lot of the development process for you. This is a unique feature that Zapier doesn't offer because you can execute custom code from their SDK rather than just automated workflows that are setup.

Below, we provide an overview in how to do so. For further implementation guides, see the official Pipedream docs and the Custom Plugins docs. All principles of creating and setting up your custom BitBadges plugin apply. This will just streamline the authentication and logic handling on your end.&#x20;

{% content-ref url="../plugins/" %}
[plugins](../plugins/)
{% endcontent-ref %}

Note when building custom plugins, it is typically not recommended to trust full on automation workflows since these are asynchronous and may not handle the claim plugin logic quick enough. Please use direct API calls or code executed directly, or if you do trigger a full automation workflow, return a quick 200 OK and expect logic to be processed asynchronously (e.g. post-claim rewards).

[https://pipedream.com/docs](https://pipedream.com/docs)

**Pipedream SDK**

If you only need your own authentication and not end users, you can simply set this up with the standard SDK code.&#x20;

```javascript
import { axios } from "@pipedream/platform"
export default defineComponent({
  props: {
    slack: {
      type: "app",
      app: "slack",
    }
  },
  async run({steps, $}) {
    return await axios($, {
      url: `https://slack.com/api/users.profile.get`,
      headers: {
        Authorization: `Bearer ${this.slack.$auth.oauth_access_token}`,
      },
    })
  },
})
```

**Pipedream Connect**

Pipedream Connect allows you to actually obtain the access tokens for your users and directly execute API requests on their behalf all programmatically. This takes all of the authentication setup out for you. This is great for seamlessly building third-party custom plugins. Simply setup Pipedream Connect in your app, and then, you have SDK access to 1000s of API integrations at your fingertips. We refer you to their docs for setting this up.

Note that there are two flows for authenticating users:

* Manually triggered by your frontend - If you already have a frontend, you may consider just handling it all there.
* [Connect links](https://pipedream.com/docs/connect/connect-link) - You redirect the user to a Pipedream connect URL and Pipedream handles it for you. This could be useful if you want to make a headless plugin without a custom frontend.

Your frontend URL or connect URL can be configured in the tutorial / user input redirect URI when building your custom plugin. Then, once you have the authentication, you can handle your logic in the plugin handler as you see fit.&#x20;

Or, alternatives including adding custom instructions or developing a configuration tool.

<figure><img src="../../../.gitbook/assets/image (211).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/integrate-with-pipedream/end-to-end-example.md

# End to End Example

This will walk you through an entire end-to-end auto-completion flow for Pipedream. This will assume you need the whole stack of per-user authorizatioon and auto-completing claims. If you do not, you can remove some of these steps and adapt for your use case.

Note: This is not the only way to implement. It is just a guided tutorial.

With user authentication, you will need your users to go through the Pipedream Connect authorize flow somehow. Each user will be identified by an `external_user_id` that you set, and once they authorize, you can specify to use that user's authorization details in the automation workflow. Their authorization details are stored under that user ID within your Connect app.

See docs here: [https://pipedream.com/docs/connect](https://pipedream.com/docs/connect). When creating a project, you can also get a step by step tutorial through the Connect tab.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

We leave this step open ended up to you. For the sake of the tutorial, we are going to assume that the claim is to be auto-completed upon user authorization. We will also use the Pipedream SDK Connect Link feature to outsource the frontend code, but Pipedream also is flexible for more custom flows.

You will need to create a **token** (short-lived) which can be used to create a Connect Link (see [https://pipedream.com/docs/connect/connect-link](https://pipedream.com/docs/connect/connect-link)). Note the `external_user_id`you use for this user. This is done server-side.

This is also open-ended. For this tutorial, we are going to use a proxy handler endpoint to generate the Connect Link to not need frontend code at all.

If you want to have a headless no frontend plugin, you can consider adding the Custom Instructions plugin in a claim with a link to a proxy handler endpoint. Because tokens are short-lived and generated dynamically, this should be a proxy one that generates the Connect URL and redirects users there (User -> Proxy Handler -> Generate Connect Link -> Redirect to Connect Link).

Let's say our proxy handler endpoint is hosted on `https://my-proxy-handler.com/generate-connect-link`. You will redirect your users to this endpoint to initiate the Connect Link flow. Consider adding this in the claim description or custom instructions plugin or however you want to expose it to your users.

The proxy handler endpoint is as follows:

```typescript
import express from 'express';
import { serverConnectTokenCreate } from '@pipedream/sdk/server';

const app = express();
const PORT = process.env.PORT || 3000;

// Configuration for Pipedream
const PIPEDREAM_CONFIG = {
    clientId: process.env.PIPEDREAM_CLIENT_ID,
    clientSecret: process.env.PIPEDREAM_CLIENT_SECRET,
    appSlug: process.env.PIPEDREAM_APP_SLUG, // Your app's slug from Pipedream
};

// Proxy handler endpoint
app.get('/generate-connect-link', async (req, res) => {
    try {
        //TODO: Get the user ID from query params or however you want to identify the user
        const externalUserId = req.query.userId;

        if (!externalUserId) {
            return res.status(400).json({ error: 'Missing userId parameter' });
        }

        // Generate the short-lived token
        const { token, expires_at } = await serverConnectTokenCreate({
            external_user_id: externalUserId,
            credentials: {
                clientId: PIPEDREAM_CONFIG.clientId,
                clientSecret: PIPEDREAM_CONFIG.clientSecret,
            },
        });

        // Success / error handler URIs
        const successRedirectUrl =
            'https://my-success-redirect-url.com/auth-callback';
        const errorRedirectUrl =
            'https://my-error-redirect-url.com/error-callback';

        // Construct the Connect Link URL
        const connectUrl = `https://pipedream.com/_static/connect.html?token=${token}&connectLink=true&app=${PIPEDREAM_CONFIG.appSlug}&success_redirect_url=${successRedirectUrl}&error_redirect_url=${errorRedirectUrl}`;

        // Redirect the user to the Pipedream Connect flow
        res.redirect(connectUrl);
    } catch (error) {
        console.error('Error generating Connect link:', error);
        res.status(500).json({
            error: 'Failed to generate Connect link',
            details: error.message,
        });
    }
});

// Optional: Callback endpoint for after authorization
app.get('/auth-callback', (req, res) => {
    res.send('Authorization successful! You can close this window.');

    //TODO: Trigger the workflow here if you want to auto-complete the claim automatically (see below)
});

app.get('/error-callback', (req, res) => {
    res.send('Authorization failed!');
});

// Start the server
app.listen(PORT, () => {
    console.log(`Proxy handler running on port ${PORT}`);
});
```

The final Pipedream Connect URL the user will be redirected to is:

```
https://pipedream.com/_static/connect.html?token={token}&connectLink=true&app={appSlug}&success_redirect_url={successRedirectUrl}&error_redirect_url={errorRedirectUrl}
```

Once the user has completed the authorization, you can now use that `external_user_id`to perform authenticated requests. If you want to do this in a headless way, you can use the success callback URL to automatically do it upon completion.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

For this tutorial, we will auto-complete a claim with their no-code workflow interface ([https://pipedream.com/docs/connect/workflows](https://pipedream.com/docs/connect/workflows)). Follow along here for implementation details. Alternatively, you can directly execute code too without a workflow using their SDK or also fetch the user's authorization credentials and use them in your own code. We recommend the interface for ease of use and testing.

Below, we will explain at a high level and will skip over some lower level details.

1. Create a workflow in the Pipedream site with a HTTP POST webhook trigger.
2. Configure authorization for the webhook. This can be done in a couple ways.
   1. Use Pipedream OAuth
   2. Check for a secret hardcoded value (add a step after) to make sure you are the origin of the request
   3. No authentication - if you do not add authentication, the only thing saving the endpoint from unwanted requests is the knowledge of the endpoint itself. It is important to not leak it if this is your approach
3. When adding your custom actions, select to use the end user's authentication. See the Pipedream docs for testing this. You will probably need to generate a test account and specify the external user ID in the headers.
   1. Ex: For adding a Slack action with the user's authentication, add another step with Slack and select the little switch icon to use user authentication.
4. We recommend using the API request w/ code (NodeJS) feature. You customize your criteria checks here. You may setup custom parameters parsed from the trigger per claim or static hardcoded props. We leave this open-ended up to you. The only requirement is that if a user that does not meet the criteria, this step should throw an error / fail.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

5. Lastly, set up the BitBadges action step as the final action in the workflow. We refer you to the workflow actions for the options here. Typically, you will auto-complete claims if you have the user's crypto address. If not, it may involve setting up and adding a dynamic store. Make sure to test or simulate before actually claiming for real. Also, ensure you are dynamically adding the user info from prior steps and not hardcoding it.

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

6. The workflow setup is now complete. The workflow will be triggered upon the HTTP request. It will then use the provided `external_user_id`and execute the claim criteria checks from your configured apps and finally, it will complete a BitBadges claim or add to a dynamic store as the final action properly gating the claim.

You can then invoke the workflow per unique `external_user_id`as shown here with the SDK. Or, you can also trigger via HTTP.

```typescript
import { createBackendClient, HTTPAuthType } from "@pipedream/sdk/server";

// These secrets should be saved securely and passed to your environment
const pd = createBackendClient({
  environment: "development", // change to production if running for a test production account, or in production
  credentials: {
    clientId: "{oauth_client_id}",
    clientSecret: "{oauth_client_secret}",
  },
  projectId: "{your_project_id}"
});

await pd.invokeWorkflowForExternalUser(
  "{your_endpoint_url}", // pass the endpoint ID or full URL here
  "{your_external_user_id}" // The end user's ID in your system
  {
    method: "POST",
    body: {
      message: "Hello World"
    }
  },
  HTTPAuthType.OAuth // Will automatically send the Authorization header with a fresh token
)
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/overview.md

# Overview

Similar to Zapier, Pipedream allows you to build automation workflows. We recommend checking out what is possible via Zapier first. Everything there can be done with Pipedream as well. Pipedream may have less connected apps, but it is more extendible and developer friendly.

**Custom Plugins**

Because Pipedream allows more customization on your level (in addition to just automation workflows), you can use their SDK to implement custom plugins seamlessly. This streamlines the development process and helps you connect to 1000s of applications seamlessly!

{% content-ref url="build-custom-plugins.md" %}
[build-custom-plugins.md](build-custom-plugins.md)
{% endcontent-ref %}

**Automation Workflows**

Automation workflows with Pipedream and BitBadges allow you to auto-complete claims, auto-add users to dynamic stores, implement post-claim logic, and more

Get started by creating a workflow with the BitBadges configuration. Then, you can copy/paste the code provided from the actions / triggers in the subpages of this section to programmatically interact with the BitBadges API. We refer you to the Zapier flows documentation for the high-level concepts and designs.

{% embed url="https://pipedream.com/apps/bitbadges" %}

{% content-ref url="../auto-completing-claims/automate-w-zapier/" %}
[automate-w-zapier](../auto-completing-claims/automate-w-zapier/)
{% endcontent-ref %}

{% content-ref url="workflow-actions/" %}
[workflow-actions](workflow-actions/)
{% endcontent-ref %}

{% content-ref url="workflow-triggers/" %}
[workflow-triggers](workflow-triggers/)
{% endcontent-ref %}

For the inputs, there are two ways of configuring. You may nee dto slightly adapt the templates to fit your desired flow.

Props - You set it manually via the props

```typescript
export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    },
    claimInfo: {
      type: "string",
      "label":  "Claim Information",
      optional: false, // Use optional: false instead of required: true
    },
...
```

Dynamic - Parse from the trigger / another step (steps.trigger.event)

```typescript
export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      const response = await axios($, {
        method: 'POST',
        url: `https://api.bitbadges.io/api/v0/claims/status/${steps.trigger.event.claimAttemptId}`,
 ...
```

<figure><img src="../../../.gitbook/assets/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>



## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/README.md

# Workflow Actions



## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/add-user-to-dynamic-store.md

# Add User to Dynamic Store

```typescript
import { axios } from "@pipedream/platform"

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      await axios($, {
        method: 'POST',
        url: `https://api.bitbadges.io/api/v0/storeActions/add/${steps.trigger.event.dynamicDataId}/${steps.trigger.event.dataSecret}`,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'x-api-key': this.bitbadges.$auth.api_key
        },
        data: {
          "address": steps.trigger.event.address,
          "id": steps.trigger.event.id,
          "email": steps.trigger.event.email,
          "username": steps.trigger.event.username
        }
      })

      return { success: true }
    } catch (error) {
      $.export('error', error)
      throw error
    }
  },
})
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/complete-claim.md

# Complete Claim

To complete a claim, enter this code in your workflow with [the BitBadges integration](https://pipedream.com/apps/bitbadges) and adapt as needed. &#x20;

The **claimInfo** is in the format: ${claimId}-${passwordPluginInstanceId}-${password}. You can setup the password plugin manually or select the Automation Workflow completion method -> Copy.

This is the approach we use for automation workflows. We remove any sign in requirements, but anyone claim must specify the secret password (only known to Pipedream / Zapier).

```
62f59244fc1003e331f183c4b3907f87-ecdb0ed0513716af3124899f6e7b5da70eb85c4399dafe2bf970236b34940da9-30892aa1bb0f84b19ecf244958c9cd4676400e13a24791e7512bc88efa217c89
```

<figure><img src="../../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

```typescript
import { axios } from "@pipedream/platform";

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    },
    claimInfo: {
      type: "string", // Claim details passed as a string in the format "claimId-passwordPluginId-password"
    },
    address: {
      type: "string", // Address of the user
    },
    isSimulation: {
      type: "boolean", // Boolean to determine if this is a simulated run
      default: false,
    },
  },
  async run({ steps, $ }) {
    const details = this.claimInfo.split("-");
    if (details.length !== 3) {
      throw new Error("Invalid claim details parsed");
    }

    const claimId = details[0];
    const passwordPluginId = details[1];
    const password = details[2];

    const endpoint = `https://api.bitbadges.io/api/v0/claims/${
      this.isSimulation ? "simulate" : "complete"
    }/${claimId}/${this.address}`;

    const data = {
      _expectedVersion: -1, 
      [`${passwordPluginId}`]: {
        password: password,
      },
    };

    try {
      const response = await axios($, {
        method: "post",
        url: endpoint,
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
          "x-api-key": `${this.bitbadges.$auth.api_key}`,
        },
        data,
      });

      const result = response;

      // Note: This means a successful trigger (add to queue), not a claim completion
      // You can use the claimAttemptId to poll
      return {
        success: true,
        claimAttemptId: result.claimAttemptId || "",
        currentTimestamp: Date.now()
      };
    } catch (error) {
      throw new Error(`Failed to complete claim: ${error.message}`);
    }
  },
});
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-attempt-status.md

# Get Claim Attempt Status

```typescript
import { axios } from "@pipedream/platform"

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      const response = await axios($, {
        method: 'POST',
        url: `https://api.bitbadges.io/api/v0/claims/status/${steps.trigger.event.claimAttemptId}`,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'x-api-key': this.bitbadges.$auth.api_key
        },
        data: {}
      })

      return {
        success: response.success,
        error: response.error
      }
    } catch (error) {
      $.export('error', error)
      throw error
    }
  },
})
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-code-by-idx.md

# Get Claim Code by Idx

```typescript
import { axios } from "@pipedream/platform"

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      const codeIdx = this.sub_by_one 
        ? steps.trigger.event.code_idx - 1 
        : steps.trigger.event.code_idx;

      const response = await axios($, {
        method: 'POST',
        url: 'https://api.bitbadges.io/api/v0/codes',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'x-api-key': this.bitbadges.$auth.api_key
        },
        data: {
          'seedCode': steps.trigger.event.seed_code,
          'idx': codeIdx
        }
      })

      return response;
    } catch (error) {
      $.export('error', error)
      throw error
    }
  },
})
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/README.md

# Workflow Triggers



## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/poll-claim-attempts.md

# Poll Claim Attempts

For polling claim attempts, we recommend that you jsut set up a custom success webhook with the HTTP trigger on Pipedream. This can be directly configured into your workflow by just adding the POST endpoint URL it gives you.

<figure><img src="../../../../.gitbook/assets/image (212).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/image (213).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/other-tutorials/README.md

# Other



## File: ./for-developers/claim-builder/other-tutorials/add-telegram-bot-to-channel.md

# Add Telegram Bot to Channel

This guide will walk you through the process of adding the BitBadges bot (@bitbadges\_bot) to your Telegram channel. By integrating this bot, you can enhance your channel with BitBadges functionality.

### Prerequisites

* You must be an admin of the Telegram channel where you want to add the bot.
* You need to have the Telegram app installed on your device.

### Steps to Add the BitBadges Bot

#### 1. Find the BitBadges Bot

1. Open your Telegram app.
2. In the search bar at the top, type "@bitbadges\_bot".
3. Tap on the BitBadges bot in the search results.

#### 2. Start a Chat with the Bot

1. Tap on the "Start" button to initiate a conversation with the bot.
2. The bot may send you a welcome message with instructions.

#### 3. Add the Bot to Your Channel

1. Go to your Telegram channel.
2. Tap on the channel name at the top to open the channel info.
3. Scroll down and tap on "Administrators".
4. Tap on "Add Administrator".
5. Search for "@bitbadges\_bot" and select it from the results.
6. Review the bot's permissions. Ensure it has the necessary permissions to function properly in your channel.
7. Tap "Done" to add the bot as an administrator.

####


## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/README.md

# Get Integration User IDs



## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/discord.md

# Get Discord Server ID

To get your discord server ID, this can be done by right clicking on the  server -> Copy Server ID,

<figure><img src="../../../../.gitbook/assets/image (60).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/get-discord-user-id.md

# Get Discord User ID

<figure><img src="../../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/x-twitch-github-ids.md

# X / Twitch / GitHub IDs

X / Twitter - [https://www.wikihow.com/Find-Your-User-ID-on-Twitter#:\~:text=Visit%20a%20site%20like%20What's,as%20you%20know%20their%20username.](https://www.wikihow.com/Find-Your-User-ID-on-Twitter)

GitHub  - [https://caius.github.io/github\_id/](https://caius.github.io/github\_id/)

Twitch - [https://www.streamweasels.com/tools/convert-twitch-username-to-user-id/](https://www.wikihow.com/Find-Your-User-ID-on-Twitter)


## File: ./for-developers/claim-builder/other-tutorials/in-site-guides.md

# In-Site Guides

The best way to get started with a tutorial is to use the Claim Tester in-site, and simply browse the guides section or experiment by adding plugins. The guides section will have a ton of common patterns and show you how to implement ideas that may or may not be supported natively. Find a similar use case to yours and apply the same steps. Even if there is nothing similar, most of the same principes to apply to almost all integrations.

If you need to see the resulting claim JSON (for advanced implementations), you can also see this in-site under the JSON tab of the claim details.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>



## File: ./for-developers/claim-builder/overview.md

# Overview

```
Note: This documentation is not meant to explain everything in the claim builder interface. It is to provide developer documentation for more advanced use cases.
```

**What are claims?**

BitBadges claims are designed to be a comprehensive tool directly within the site or via the API for you to custom gate your utility. Claims can be simply thought of as: **Meet criteria? -> Offer utility / rewards.** The implementation process aims to be super flexible, allowing you maximum customization.

<figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

**How do claims work? What are plugins?**

Claims are made up of one or more plugins executed in order. By default, all must pass, but this can be customized. Out of the box, we offer plenty of built-in plugins and features with no code required and directly claimable by users in the site. Or, you can extend its functionality with helper tools, custom plugins, Zapier, our API, and more!

Note: Certain plugins may become unavailable due to design decisions. For example, claim codes make no sense for on-demand claims since there is no "complete claim" action.

**Get Creative**

While we do offer a ton of functionality directly in-site, your desired functionality may not be directly supported. Before considering custom implementations, get creative!

* Use claim codes or a password which can be used as a universal approach (no need for a specific app integration)
* Can your users be identified by email? Addresses? Use those plugins or dynamic stores
* Does Zapier support your approach? They have 7000+ apps and integrations natively. Pipedream?

There may also be plenty of ways for you to implement the same thing with varying tradeoffs. Select the best for your use case.

**How to create / manage claims?**

Claims are created and managed in the developer portal.

**What is possible in-site?**

Most of the time, you can directly do everything without a line of code. Get creative and experiment!

* Gate URLs / Content to those who claim with the Rewards tab
* Use the Discord Role Assigner plugin to create gated channels
* Use Stripe Payments to create payment-gated claims
* And much more

**Can claims connect to other BitBadges services?**

Claims are the universal connector. You can not only check criteria from any BitBadges service (badge ownership, >100 points) but also use claims on the reward side (gate mints, award points).

<figure><img src="../../.gitbook/assets/image (221).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/README.md

# Plugins



## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/README.md

# BitBadges Created Plugins

##


## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/authentication-based-plugins.md

# Socials / Email Plugins

**Plugin IDs: `twitter, github, discord, google, email, twitch, and other socials`**

These plugins restrict the number of times specific users from different social platforms can use the claim.&#x20;

**Usernames vs IDs**

We differentiate by account IDs (should be constant) and usernames for display purposes / ease of use.  For the email plugin, we use { id: bob@gmail.com, username: id@gmail.com }

```typescript
export const IdsVsUsernamesExplanationMap: Record<string, string> = {
  bluesky: 'Username: Handle format (e.g. alice.bsky.social)\nID: Decentralized identifier (e.g. did:plc:abcdef123...)',

  discord: 'Username: Current format is just the username (e.g. discord_user)\nID: Snowflake format - 17-20 digit number (e.g. 123456789012345678)',

  twitter: 'Username: @ handle without the @ symbol (e.g. elonmusk)\nID: Numerical string, typically 7-20 digits (e.g. 44196397)',

  github: 'Username: Case-insensitive alphanumeric with hyphens (e.g. octocat)\nID: Numerical identifier (e.g. 583231)',

  google: 'Username: Email address (e.g. user@gmail.com)\nID: Sub identifier from OAuth - alphanumeric string (e.g. 110248495415936123456)',

  facebook: 'Username: Custom username in URL (e.g. zuck)\nID: Numerical string, typically 15+ digits (e.g. 4)',

  reddit: 'Username: u/ prefix without the u/ (e.g. spez)\nID: Base36 string (e.g. 13h2kf)',
  
  twitch: 'Username: Lowercase alphanumeric (e.g. ninja)\nID: Numerical user ID (e.g. 19571641)',

  telegram: 'Username: Optional @ handle without @ (e.g. durov)\nID: Numerical user ID, can be negative for groups (e.g. 12345)',

  farcaster: 'Username: Case-insensitive handle (e.g. dwr)\nID: Numerical FID (e.g. 2)',

  slack: 'Username: Lowercase with underscores (e.g. slack_user)\nID: Uppercase string starting with U (e.g. U0G9QF9C6)'
};
```

**Custom Claim Numbers**

We also support assigning specific claim numbers if assignMethod === instance ID. We will use the zero-based index in the list of \[...usernames, ...ids]. Note we take first match so duplicates here are not supported.

**Private Lists**

The user list is only allowed to be private. You may consider hosting the list on your end, so users know if they can claim or not.

### Public Parameters

* **maxUsesPerUser**: The maximum number of uses allowed per user.
* **blacklist:** Whether this should deny users on the IDs / usernames or not

### Private Parameters

If both are left blank, we do not check any whitelist restrictions.&#x20;

* **usernames**: An optional list of whitelisted usernames who are allowed to claim.
* **ids:** An optional list of whitelisted user IDs who are allowed to claim.

### State

State is maintained by tracking the number of claims each user makes. It keeps a record of user IDs and usernames.

Note that in order to maintain correctness, we replace all "." values with "\[dot]" to ensure the keysa re a single string. If micro-managing state through the API, you will need to do this.

```json
{
  "ids": {
    "user_id": 1
  },
  "usernames": {
    "username": "user_id"
  }
}
```

#### Default State

The default state of the plugin is defined as follows:

```json
{
  "ids": {},
  "usernames": {}
}
```

#### Public State

State is not made public to users.


## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/codes.md

# Codes

### Plugin ID: `codes`

This plugin manages a code challenge, where users must provide a valid one-time-use code to claim. Note that codes are assigned a zero-based index and we keep track of which indices have been used. This allows for the code to be rotated and consistency with on-chain approvals. Thus, note that the code value changing does not mean its used status changes.

We also support specific claim numbers dependent on the zero-based codeIdx using the assignMethod == instanceId.

{% content-ref url="../../concepts/universal-approach-claim-codes.md" %}
[universal-approach-claim-codes.md](../../concepts/universal-approach-claim-codes.md)
{% endcontent-ref %}

### Public Parameters

* **numCodes**: The total number of codes that can be generated or used. Unless in edge cases, this should match the total possible number of claims.
* **hideCurrentState**: If true, we will NOT reveal the state to users by default.
  * If you are claim creator / authorized viewer, use the fetch private parameters flag and it will return the state.
  * The **publicState** will just be an empty {} by default.
  * Note that this hides it within the context of the claim, but if the claim action is public (e.g. public badge assignment, public lists), the state may still be leaked there.

### Private Parameters

* **codes**: An array of valid codes that users can provide.
* **seedCode**: A seed used to generate a list of valid codes.

### State

State is maintained by tracking which codes have been used.

```json
{
    "usedCodeIndices": {
        "0": 1,
        "1": 1
    }
}
```

#### Default State

The default state of the plugin is defined as follows:

```json
{
    "usedCodeIndices": {}
}
```

#### Public State

State is made public with a `usedCodeRanges` array. Code indices are zero-based.

```json
{
    "usedCodeRanges": [
        {
            "start": 0,
            "end": 1
        }
    ]
}
```

### Custom Body Type

The custom body type for the codes plugin requires a `code` string parameter in the request:

```typescript
type CustomBodyType = {
    code: string;
};
```

This code will be validated against the list of valid codes defined in the private parameters. The code must match exactly (case-sensitive) and must not have been previously used.


## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/discord-server.md

# Discord Server

### Plugin ID: `discord-server`

### Public Parameters

* **serverName**: The server name to display

### Private Parameters

* **serverId:** The server ID of the Discord server. This is the ID number (e.g. 846474505189588992).

### State

State is not maintained for this plugin.


## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/geolocation.md

# Geolocation

### Plugin ID:  geolocation

This plugin checks the location of a specific IP address. This should be treated as a "best effort".

### Public Parameters

```typescriptreact
https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
```

* **allowedCountryCodes:** String array of country codes allowed. If blank, all are allowed by default.
* **disallowedCountryCodes**: String array of country codes allowed. If blank, none are disallowed by default.
* **pindrop:** The latitude, longitude, and radius of the pindrop location. Radius is in coordinates, so please convert first from miles or km or whatever unit you are using.

```typescript
const { latitude, longitude, radius } = pindrop;
```

### Private Parameters

* **None**

### State

State is not maintained for this plugin.


## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/github-contributions.md

# GitHub Contributions

### Plugin ID: `github-contributions`

### Public Parameters

* **repository**: The repository path - Ex: bitbadges/bitbadgeschain

### Private Parameters

* None

### State

State is not maintained for this plugin.


## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/halt.md

# Halt

### Plugin ID: `halt`

This plugin make the claim auto-fail if in the claim.

### Public Parameters

* **None**

### Private Parameters

* **None**

### State

State is not maintained for this plugin.


## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/ip-restrictions.md

# IP Restrictions

### Plugin ID: `ip`

This plugin rezstricts how often an IP address can claim.

### Public Parameters

* **maxUsesPerIp:** Max times a specific IP can claim

### Private Parameters

* **None**

### State

State is maintained by incrementing the uses by 1 **every** claim.

```
{
  ipsUsed: {
    "127.0.0.1": 10 // claimed 10 times
  }
}
```

#### Default State

The default state of the plugin is defined as follows:

```
{
  ipsUsed: {}
}
```

**Public State**

None


## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/min-usdbadge.md

# Min $BADGE

### Plugin ID: min-badge

### Public Parameters

* **minBalance**: The minimum balance of $BADGE a user must own. We check >= to this value.

### Private Parameters

* None

### State

State is not maintained for this plugin.


## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/number-of-uses.md

# Number of Uses

**Plugin ID: `numUses`**

This plugin restricts the number of times specific addresses can claim and the maximum overall amount of times users can claim.

### Public Parameters

#### Public Parameters

* **maxUses**: The maximum number of uses allowed for the code overall.
* **hideCurrentState**: If true, we will NOT reveal the state to users by default.
  * If you are claim creator / authorized viewer, use the fetch private parameters flag and it will return the state.
  * The **publicState** will just be an empty {} by default.
  * Note that this hides it within the context of the claim, but if the claim action is public (e.g. public badge assignment, public lists), the state may still be leaked there.
* **displayAsUnlimited:** This is a UI display option. When enabled, we label the claim as "unlimited uses" to the user. Note this does NOT actually make it unlimited behind the scenes. We still track normally. If you use this option, we recommend setting maxUses to something crazy that will never be met like > 1000000000 uses.
  * Please use with hideCurrentState = true.
  * This is typically used with Sign In with BitBadges claims.

**Private Parameters**

None

### State

State is maintained by incrementing the numUses by 1 **every** claim by any user. For each user, we track the claim numbers assigned to that user.

```
{
  claimedUsers: {
    "bb1...": [0, 1]
  },
  numUses: 0
}
```

#### Default State

The default state of the plugin is defined as follows. Claim numbers are zero-based.

```
{
  claimedUsers: {},
  usedClaimNumbers: [{ start: 0, end: 1000000000 }],
  numUses: 0
}
```

**Public State**

State is made public as-is, plus the **usedClaimNumbers** object.

Note: The **claimedUsers** object is not made public by default for scalability reasons. You need to manually set the **fetchAllClaimedUsers** flag to true in the API request to get the claimed users. If not specified, the **claimedUsers** object will be an empty object {}.

```
{
  claimedUsers: {
    "bb1...": [0, 1]
  },
  usedClaimNumbers: [{ start: 0, end: 1 }],
  numUses: 0
}
```


## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/ownership-requirements.md

# Ownership Requirements

### Plugin ID: must-own-badges

### Public Parameters

* **ownershipRequirements**: The ownership requirements a user must satisfy. See the link below for format and documentation.

### Private Parameters

* None

### State

State is not maintained for this plugin.

### Ownership Requirements

```typescript
const ownershipRequirements = {
    $and: [
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 1n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 0n, end: 0n },
                },
            ],
        },
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 2n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 0n, end: 0n },
                },
            ],
        },
    ],
};

const popupParams = {
    ...ownershipRequirements,
};
```

#### **Asset Ownership Requirements**

The **assetOwnershipRequirements** uses an $and, $or, and base case schema to allow you to implement custom logical requirements. For $and requirements, all criteria in the array must be satisfied. For $or, one of the criteria in the array needs tobe satisfied. You can implement the "not" case by saying owns x0 of a badge.

```typescript
assetOwnershipRequirements: {
    $or: [
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 1n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 0n, end: 0n },
                },
            ],
        },
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 2n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 1n, end: 1n },
                },
            ],
        },
    ];
}
```

**Options**

As an alternative to $or, we also support specifying **options.numMatchesForVerification** which sets a threshold for how many assets in the current group the criteria needs to pass for. For example, below requires 1 / 1000 badges to be owned out of the IDs 1-1000.

```typescript
assetOwnershipRequirements: {
  assets: [
    {
      chain: 'BitBadges',
      collectionId: 1n,
      assetIds: [{ start: 1n, end: 1000n }],
      ownershipTimes: UintRangeArray.FullRanges(),
      mustOwnAmounts: { start: 1n, end: 1n }
    }
  ],
  options: { numMatchesForVerification: 1n }
}
```

**BitBadges Badge Collections**

For BitBadges assets, we expect the chain = ' BitBadges', all collection IDs to be numeric, and all assetIds to be UintRanges. Querying a user owns a badge at a specific time is also supported via ownership times.

```typescript
{
  chain: 'BitBadges',
  collectionId: 1n,
  assetIds: [{ start: 1n, end: 1000n }],
  ownershipTimes: UintRangeArray.FullRanges(),
  mustOwnAmounts: { start: 0n, end: 0n }
}
```

**BitBadges Address Lists**

For BitBadges address lists, they are supported with the collection ID = 'BitBadges Lists'. The assetIds will be the string list ID. A user will be considered to own x1 if they are on the list and x0 if they are not on the list. Note that with blacklists, they are flipped. Not being on a blacklist equals x1 owned.

```typescript
{
    chain: 'BitBadges',
    collectionId: 'BitBadges Lists',
    assetIds: ["listId"],
    ownershipTimes: UintRangeArray.FullRanges(),
    mustOwnAmounts: { start: 1n, end: 1n }
}
```

**Ethereum / Polygon / Solana NFTs (Beta)**

We also support verifying Ethereum Polygon NFTs through this interface. However, note that we use external APIs to check this, so is not reliant on our infrastructure. Use at your own risk.

```typescript
{
    $and: [
        {
            assets: [
                {
                    chain: 'Polygon', //Or 'Ethereum'
                    collectionId: '0x9a7f0b7d4b6c1c3f3b6d4e6d5b6e6d5b6e6d5b6e',
                    assetIds: ['1'],
                    ownershipTimes: [],
                    mustOwnAmounts: { start: 0n, end: 0n },
                },
            ],
        },
    ];
}
```

#### **Ownership Times** <a href="#ownership-times" id="ownership-times"></a>

```
ownershipTimes: []
```

The default when ownership times is empty or missing is to verify at the current time. If this is the case, we dynamically add the current time as \[{ start: currTime, end: currTime }].

```typescript
ownershipTimes: UintRangeArray.FullRanges();
```

For assets that support ownership times like BitBadges badges, you can specify custom times to check.


## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/password.md

# Password

### Plugin ID: `password`

This plugin restricts access based on a password that must be provided by the claimer.

### Public Parameters

-   **None**

### Private Parameters

-   **password**: The password required to successfully make a claim.

### Custom Body Type

The custom body type for the password plugin requires a `password` string parameter in the request:

```typescript
type CustomBodyType = {
    password: string;
};
```

This password will be validated against the password defined in the private parameters. The password must match exactly (case-sensitive).

### State

State is not maintained for this plugin as it relies solely on the provided password for validation.


## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/signed-in-to-bitbadges.md

# Signed in to BitBadges

### Plugin ID: `initiatedBy`

This plugin ensures that claims are initiated by a specific address (their signed in one). This serves as validation that the recipient of the claim is also the initiator because signing into BitBadges requires a signature and thus proof of address.

### Public Parameters

* **None**

### Private Parameters

* **None**

### State

State is not maintained for this plugin as it relies solely on the validation of the address provided.


## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/transfer-times.md

# Transfer Times

This plugin restricts claims based on specified transfer times, allowing claims only within certain time ranges.

### Public Parameters

* **transferTimes**: An array of time ranges during which transfers are allowed, defined using the `UintRangeArray` type.

### Private Parameters

* **None**

### State

State is not maintained for this plugin as it relies solely on the provided transfer times for validation.


## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/twitch-follow-subscription.md

# Twitch Follow / Subscription

### Plugin ID: `twitch-follow / twitch-subscription`

### Public Parameters

* **channelName**: Channel login name. For example, twitch.tv/CHANNEL\_NAME\_HERE

### Private Parameters

* None

### State

State is not maintained for this plugin.


## File: ./for-developers/claim-builder/plugins/bitbadges-created-plugins/whitelist.md

# Whitelist

### Plugin ID: `whitelist`

This plugin restricts claims to be received by users who are on a predefined whitelist.

With this plugin, we reuse the [Address List ](../../../core-concepts/address-lists-lists.md)types. IDs will be the list ID. Only one list vs list ID should be defined out of the parameters. The lsit can either be made public with the claim or kept private.

We also support specific claim numbers dependent on the zero-based index using the assignMethod == instanceId. This is only applicable if it is a whitelist. Also, duplicates are not handled for this. We always take first match.

### Public Parameters

* **list**: An [Address List ](../../../core-concepts/address-lists-lists.md)specifying who can claim vs not.
* **listId**: The  [Address List ](../../../core-concepts/address-lists-lists.md)ID that points to a valid address list for who can claim vs not.
* **maxUsesPerAddress**: The maximum number of uses allowed for each address.

### Private Parameters

* **list**: An [Address List ](../../../core-concepts/address-lists-lists.md)specifying who can claim vs not.
* **listId**: The  [Address List ](../../../core-concepts/address-lists-lists.md)ID that points to a valid address list for who can claim vs not.

### State

State is maintained by incrementing the numUses by 1 **every** claim by any user. For each user, we track the claim numbers assigned to that user.

```
{
  addresses: {
    "bb1...": 10 // claimed 10 times
  }
}
```

#### Default State

The default state of the plugin is defined as follows:

```
{
  addresses: {}
}
```

**Public State**

State is made public as-is.


## File: ./for-developers/claim-builder/plugins/configuration-tools.md

# Configuration Tools

Configuration tools are a helper layer abstracted over the core plugin implementations. Instead of creating new, individual plugins for each use case, you can often reuse existing ones. Configuration tools help the user configure the parameters of existing plugins.

For example,&#x20;

* Google Calendar can be implemented by configuring the Email plugin with the attendee emails
* Auto-configure approved user addresses with the Address Restrictions plugin
* Or any application can be implemented by issuing claim codes with the Codes plugin.

```
Note: This is a more advanced option and is not a great user experience. 
This should only be used in select cases.

Please create custom plugins for better UX.
```

Prompt the user to add the copy / paste the stringified JSON to the Configuration Tools tab on the claim builder.

<figure><img src="../../../.gitbook/assets/image (214).png" alt=""><figcaption></figcaption></figure>

```json
{"pluginId":"codes","version": "0", "publicParams":{"numCodes":1},"privateParams":{"codes":["code123"]}}
```


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/README.md

# Creating a Custom Plugin



## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/alternatives.md

# Pre-Built Webhook Plugins

Configure prebuilt webhook plugins in the claim builder without needing to create an entirely new custom plugin. Just enter the endpoint and configure what you want to receive.If you do not want to actually set up a full handler, you can also use the Forms plugin which allows you to store and view the requests in-site (serverless).

<figure><img src="../../../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

**Note**: These plugins only support a simple POST request and expect a 200 OK response. If you require more custom logic or reusability, a custom plugin is necessary.

### Configuration

* **POST Routes**: Customizable routes for your needs.
* **User Details**: Optionally select to receive user details, like their address, custom inputs, or connected socials (only identifying information and no authentication tokens or details)
* **Validation Secret**: Customize a validation secret to confirm requests are from BitBadges. This is what is entered in the form.
* **Expected Response:** 200 OK within 10 seconds
  * For non-critical logic, consider returning 200 early and asynchronously process.
  * Stateless

### Forms Plugin  - Serverless

The forms plugin is a serverless alternative. This is titled "Collect User Inputs" in the site.

Think of this like a request storage bin. We store the requests that would've been sent to the webhooks for you. You can then view them in-site or fetch them from the API when needed.

```typescript
// Pre: Get the attempt ID. If you do not have it already, see the API reference endpoints

// GET /api/v0/requestBin/attemptData/{claimId}/{claimAttemptId}
const res = await BitBadgesApi.getAttemptDataFromRequestBin("claim123", "attempt123", { ... });
console.log(res);
// { bitbadgesAddress, email, claimAttemptId } 
```

<figure><img src="../../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

### Implementation - Handlers

The request/response flow mirrors that of custom plugins, with the `pluginSecret` replaced by the inputted validation secret. For detailed implementation guidance, refer to the respective documentation. The configuration is done in-site via the claim builder.

1. Setup your plugin handler (see plugin documentation for more information)
2. Create your claim and configure the webhook as one of the plugins, specifying your endpoint
3. Test it out to make sure it is working


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/README.md

# Implement Your Plugin

###


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/api-handler.md

# API Handler

The outgoing request (from BitBadges to your plugin) will be made up of the custom body inputs (passed from your frontend), the claim parameters, plus some contextual information about the claim and the claiming user.

* **Plugin Secret:** A plugin secret value that you can use to verify BitBadges as the origin of the call. This is secret only to you and can be obtained via the developer portal when creating your plugin.
* **Claiming Address:** The **bitbadgesAddress** of the user who is attempting to claim. We also provide the mapped equivalents (**ethAddress**, etc).
  * Note the claiming address may not be verified (signed in) dependeing on the configuration (the user must have the Signed In to BitBadges plugin). If you need to make sure that the user is signed in, use the **isAddressSignedIn** field. This will be true if the claiming user is signed in as the claiming address. All other socials you can assume have been verified / signed in.
* **Claim Information**: Lastly, we also pass the **claimId,** as well as the claim's **createdAt** and **lastUpdated** timestamps. These can be used, for example, to implement version control systems on your end.
* **Claim Attempt ID:** The claim attempt ID is the ID of the attempt, and you can use it to track the status of the claim (whether it eventually fails or succeeds).
* **Attempt Status:** The attempt status (attemptStatus) will be 'executing' during the execution of the claim. If you subscribe to success status webhooks (in the configuration), we will also send a second request (with same body and headers) and \_attemptStatus='success'. This can be used to trigger post-claim logic that needs to wait until completion.
* **Simulation (Dry Run) Flag:** The **\_isSimulation** flag tells you whether this is a known dry run.

For POST, PUT, and DELETE requests, we pass the values over the body. For GET, we pass them over the GET params. You are responsible for making sure the endpoint is accessible (e.g. no CORS errors, etc.). Make sure it is the desired type as well (i.e. GET vs POST vs DELETE vs PUT).

```typescript
const payload = {
    ...customBody, //if applicable
    ...allConfiguredParams, //if applicable

    // Context info

    email: 'bob@abc.com', //If pass email is configured
    discord: { id: '...', username: '...', discriminator: '...' }, //If configured
    twitch: { id: '...', username: '...' }, //If configured
    twitter: { id: '...', username: '...' }, //If configured
    github: { id: '...', username: '...' }, //If configured
    google: { id: '...', username: '...' }, //If configured
    pluginSecret: pluginDoc.pluginSecret,
    claimId: context.claimId,
    claimAttemptId: context.claimAttemptId,
    bitbadgesAddress: context.bitbadgesAddress, //If pass address is configured
    ethAddress: context.ethAddress, //If pass address is configured
    solAddress: context.solAddress, //If pass address is configured
    btcAddress: context.btcAddress, //If pass address is configured
    _attemptStatus: context._attemptStatus,
    lastUpdated: context.lastUpdated,
    createdAt: context.createdAt,
    version: context.version,
};
```

### **Identifying the Claiming User**

If you need to identify the claiming user, we pass their address + other requested socials to your endpoint. The socials will all be verified and signed in on our side. The address will be authorized if your plugin specifies the require sign in? option or the claim creator requires sign in.

Although that may not be enough if you identify your users in another way, or you may just not want to fully trust BitBadges. You can also simply check via a secret authorization code. Give them the authorization code on your end while authenticated. Have them enter it as a custom user input in-site. Then, verify it on your end.

### **Responses**

All responses expect a 200 success OK status code within 10 seconds for a successful attempt. For any of the below, do not assume that a 200 OK response means a successful claim and a successful set of the new state. Think of this as a hypothetical state transition IF the claim is eventually successful.

Note: Ensure the returned JSON object keys do not contain any "." characters because that may mess up the state handler. For example, emails should be bob@abc\[dot]com rather than bob@abc.com.

**Stateless Preset**

The stateless preset is simple. If we receive the 200, the plugin is successful. Nothing else is checked via the response. Everything is handled on your end (if you have state).

<figure><img src="../../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) ( (1).png" alt=""><figcaption></figcaption></figure>

**Claim Token Preset**

This preset expects a { claimToken} in the response. The claim token is a one-time use only claim code. Issuing claim tokens is left up to you.

<figure><img src="../../../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Claim Numbers Preset**

This preset expects a { claimNumber } in the response. The claim number is the claim number that will be assigned if the claim number is successful. Claim numbers are 0-based, so claimNumber === 0 is the first claim, and so on.

IMPORTANT: Only one plugin can control claim number assignment. If you select this approach, claims that use this plugin will not be compatible with any other plugin that uses the claim number preset.

Another important decision you will have to consider is whether to reuse your plugin for address lists because claim numbers do not matter for address list plugins. So basically, your plugin will function like the stateless preset for address list claims, if selected.

### **Success Hook Responses**

For success hooks (\_attemptStatus=success), we also expect a 200 OK within 10 seconds. If you need to do asynchronous processing, return 200 OK early and process as you desire.

Otherwise, for failed attempts, we will retry later with an exponential backoff policy.

### **Error Responses**

If your plugin fails, we will save the error for debugging / monitor purposes. It may be displayed to the claiming user and / or claim cretor, so make errors informative but do not reveal sensitive information.

Please follow the { message } interface for returned JSON error responses.

### Example Plugin Handler

<pre class="language-typescript"><code class="lang-typescript"><strong>//TODO: Fill in missing information
</strong>const handlePlugin = async (req: NextApiRequest, res: NextApiResponse) => {
  try {
    //Step 1: Handle the request payload from the plugin
    const body = req.body; //We assume the plugin sends the payload in the body of the request (change this for GET)
    const { claimId, pluginSecret, bitbadgesAddress, ethAddress, solAddress, btcAddress, lastUpdated, createdAt } = body;
    const { ...otherCustomProvidedInputs } = body;
    
    //Handle anything specific to dry runs _isSimulation

    //Step 2: Verify BitBadges as origin by checking plugin secret is correct
    const YOUR_PLUGIN_SECRET = '';
    if (pluginSecret !== YOUR_PLUGIN_SECRET) {
      return res.status(401).json({ message: 'Invalid plugin secret' });
    }

    //Step 3: Implement your custom logic here. Consider checking the plugin's creation / last updated time to implement version control.
    //TODO: 

    //Step 4: Return the response to the plugin based on your configured state function preset
    // const claimTokenRes = { claimToken: '...'  }
    // const statelessRes = {};
    return res.status(200).json({});
  } catch (err) {
    console.log(err);
    return res.status(401).json({ message: `${err}` });
  }
};

export default handlePlugin;
</code></pre>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/design-considerations.md

# Design Considerations

### Your Plugin Status !== Claim Success Status

For processing hooks, note that your plugin may succeed, but this does not mean the overall claim will succeed. Other plugins may fail, or other stuff may go wrong.

If you receive a post-success hook, you can be sure the claim has succeeded. Or, you can use the attempt ID to verify it on your end as well,

### Asynchronous Processing

Claims are processed in an asynchronous manner. For processing hooks, your plugin may succeed, but the claim may not complete until a later time.

Best practices:

* If using state management on BitBadges end for custom plugins, design your plugin to avoid race conditions. For example, do not return the same one-time use claim token to multiple attempts. Most plugins are stateless (on BitBadges end) though and do not have to worry about this. It should always be eventually oconsistent.
* Do not depend on the BitBadges claim state like number of claims completed. It may not be up to date or real-tie at the time of your plugin's execution. Your custom parameters are okay to depend on.

This is not really applicable to post-success hooks.

### State Management

An important aspect to consider is how you will handle state (if applicable). The golden rule here is that a successful response from your plugin DOES NOT mean the overall claim attempt was successful. Other plugins might fail. Or vice versa, your plugin may fail, but the claim succeeds. We only update state on our end if your plugin passed and was in the success path (we short-circuit OR requirements).

You have a couple options:

* Use the preset response patterns to customize how BitBadges controls state for your plugin on our end. This is eventually consistent meaning that you return an intent from your handler, and we update only upon successful claim (and in the success path).
  * A typical flow is to associate certain state with unique claim tokens and let BitBadges handle the claim tokens being marked as USED vs UNUSED.
* Manage state on your end, but be mindful of the way BitBadges processes claims.

### Reusing for On-Demand Claims

To be used with on-demand claims, the plugin must meet specific requirements and have specific properties:

* Stateless - No per-attempt state
* No User Inputs - The plugin should be able to function at any time without any custom user inputs. Note this also includes socials or connected sessions.
* Only Needs Context - The plugin should be able to function with just the contextual information passed. The context mainly includes the plugin information, claim information, and the claimee's address.

Typically, these are only possible with crypto-native plugins. For example,

* Check >1 ETH in account from address
* Check POAP ownership
* Check badge ownership

Parameters are okay because they are hardcoded and not changed (e.g. set min ETH to 1).

### **Authentication / Sensitive Values**

As a design decision, we do NOT want to handle your authentication or sensitive values. Treat BitBadges as a middleman. Authentication should either be fully managed by BitBadges (identifers passed to you like email, usernames) or fully managed by you from start to finish. This applies to both the creator and the end claiming user.

If you need to make authenticated requests on behalf of the user (beyond just receving identification information), you will need to implement authentication on your end. You may let the claim creator store sensitive information in the private parameters of the plugin.

Consider a workaround such as storing any information yourself, mapping it to a token or code, giving that code to the user / creator, and having them enter it in the flow. You then use the token / code to lookup the information in your handler.

This approach follows the same flow as OAuth authorization codes, except with a custom claim code. You should follow all the same best practices (expiring tokens, PKCE for preventing authorization code interception attacks, and more).

<figure><img src="../../../../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/getting-started.md

# Getting Started

To create, publish, and maintain your plugin, go to [https://bitbadges.io/developer](https://bitbadges.io/developer) and use the Plugins tab. This should walk you through the whole process of configuration and submitting it to be used on the BitBadges site. If you are confused at any point, refer back to this documentation.

For testing purposes, you can setup using Pipedream's request bin ([https://pipedream.com/requestbin](https://pipedream.com/requestbin)) and just monitor incoming requests that way.

<figure><img src="../../../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/hook-types-and-simulations.md

# Hook Types and Simulations

### Timing of Hooks

BitBadges can send the request at two different times (during processing hooks and success hooks after successful claim). Certain settings in the creation form can be set to customize how or if we send these. You may choose to receive or ignore them.

* Processing hooks (\_attemptStatus = "executing") are checked during the execution of the claim, and the results could influence whether the claim succeeds or not.
* Post-Success hooks (\_attemptStatus = "success") are only sent after the claim is successful and cannot affect the outcome of the claim. Typically used for post-claim actions or success logic. If a 200 OK is not received, we will use exponential backoff to retry until successful.

<figure><img src="../../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Simulations

```
NOTE: Catching simulations is important. 

You do not want to execute success logic on a dry run.
```

We allow users to simulate claims as a dry run before they actually submit for real. The BitBadges site will always simulate once before submitting, but you should not depend on every claim attempt having a prior simulation.

The scope of the dry run is left up to you, but we recommend as a rule of thumb is that if the user successfully simulates, they are expected to always pass at execution time.

To determine whether you are receiving a simulation hook or a "for real" hook, you can use the \_isSimulation flag that is passed. The claimAttemptId will also be empty / blank, but the rest of the payload should remain the same.

You can select to not receive simulation hooks at all in the usage settings when creating your plugin in the developer portal.


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/parameters.md

# Parameters

Each plugin can configure the expected schema of parameters inputted by the claim creator and the end user. These will all be available in the payload of your handler in addition to contextual information like address, attempt ID, etc.

```json
{
    ...context,
    ...publicParams, // Public to the end users
    ...privateParams, // Private to BitBadges and the claim creator
    ...userInputs
}
```

Parameters will be passed to your backend handler in the payload.

<figure><img src="../../../../../.gitbook/assets/image (163).png" alt=""><figcaption></figcaption></figure>

## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/user-inputs.md

# Custom Inputs

### Handling User / Creator Inputs

If your plugin requires inputs from the claiming user or claim creator, you can do this in the BitBadges site (recommended) or via a window.postMessage from a custom frontend / tool. All inputs will be passed along to your handler via the payload. If none are provided, we assume there is nothing needed to be passed.

<figure><img src="../../../../../.gitbook/assets/image (165).png" alt=""><figcaption></figcaption></figure>

Note to be compatible with Zapier (and possibly API auto-claiming) or on-demand claims, user inputs are typically not allowed (because the user is not manually initiating anything).&#x20;

**Option 1: Completely In-Site**

When creating the plugin, configure the expected schemas. We will prompt the users / creators to enter such information in-site via a form. All outsourced to BitBadges.

<figure><img src="../../../../../.gitbook/assets/image (121).png" alt=""><figcaption></figcaption></figure>

**Option 2: Custom Frontend**

Consider creating your own frontend that the user will be redirected to via the redirect URL.You will need to combine approaches. This typically follows a code approach. For example, handle secure stuff on your end -> grant an authorization / claim code -> have user add it directly in the site -> use the code for whatever.

**Supported Schema Types**

Primitives: String, Number, Boolean

Date: UNIX millisecond timestamp

URL: Stringified URL

Attestations (for user inputs): [User inputted attestation proofs](../../../../core-concepts/verifiable-attestations/) array.

### Identifying the Claiming User

You can also select to automatically pass supported identifying details about the user (e.g. crypto addresses, Discord, X, GitHub, etc).  Note no access tokens or auth details are passed along so private, authorized requests are not possible with this information.

We will authenticate the user on our end where needed, and you can use their identifying information to execute queries (e.g. public GitHub contributions). The only one that may not be verified in some cases is the claiming address. This depends on the configuration (the user must have the Signed In to BitBadges plugin). If you need to make sure that the user is signed in, check the **isAddressSignedIn** field. This will be true if the claiming user is signed in as the claiming address.

<figure><img src="../../../../../.gitbook/assets/image (215).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../../.gitbook/assets/image (216).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/managing-your-plugin.md

# Managing Your Plugin

### Updating Your Plugin / Version Control

Management of your plugin is done through the developer portal. You may configure different versions of your plugin. New claims will always use the latest **finalized** version. Existing claims will remain on the version they were created with. Unfinalized versions can ONLY be used by you in the claim tester.

We leave updates and version control management up to you. It is your responsibility to keep claims compatible and functioning. If you need to implement a breaking change, you can also consider using the createdAt, lastUpdated, or version fields passed via the context to implement version control and handle it on your end. Or, you can also create a new plugin.

## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/testing-your-plugin.md

# Testing Your Plugin

There are two approaches to testing your plugin.

**Local Development**

Use your favorite tool to simulate requests to your handler such as the one below. Replace with your corresponding details.

```bash
curl -X POST https://yourhandler.com  -H 'Content-Type: application/json' -d '{
  "pluginSecret": "068145b0058668ac5b880e23ca2556e4207efe8066227f4eb3466a6b0d16daa4",
  "claimId": "abcxyz123",
  "claimAttemptId": "...",
  "lastUpdated": 1800000000000,
  "createdAt": 1800000000000,
  "version": "0",
  "_attemptStatus": "executing",
  ...USER_ID_DETAILS, //whatever is configured
  ...YOUR_INPUTS
}'
```

**Test Requests**

In the creation / update interface, there will be a Send Test Request button which will send a formatted request from your browser. This uses mocked data, and should only be used for testing purposes.

<figure><img src="../../../../.gitbook/assets/image (147).png" alt=""><figcaption></figcaption></figure>

**Claim Tester**

The easiest way to test your plugin integration with BitBadges is with the Claim Tester tab in the developer portal. This is the only place you will be able to test unfinalized versions of your plugin.

<figure><img src="../../../../.gitbook/assets/image (8) (1) (1).png" alt=""><figcaption></figcaption></figure>

## File: ./for-developers/claim-builder/plugins/overview.md

# Overview

Plugins / webhooks are simply HTTP requests.

1. Configure your plugin / webhook in the BitBadges site
2. Set up your handler at the specified URL / method. Use the payload to implement your logic. The payload includes context about the attempt plus can include the user address, email, social usernames, custom inputs, and more.
   1. Check the pluginSecret to verify BitBadges as the origin of the request if this is important
3. Return the expected response that was configured (e.g. 200 OK)

<figure><img src="../../../.gitbook/assets/image (5) (1).png" alt=""><figcaption></figcaption></figure>

```typescript
const handlePlugin = async (req: NextApiRequest, res: NextApiResponse) => {
  //Step 1: Handle the request payload from the plugin
  const body = req.body; //For POST
  const { _isSimulation, claimId, pluginSecret, bitbadgesAddress, ethAddress, solAddress, btcAddress, lastUpdated, createdAt } = body;
  const { ...otherCustomProvidedInputs } = body;
  
  //Step 1.5: Catch simulations if applicable. Don't run success logic on a dry run
  // if (_isSimulation) return doDryRunStuffOnly();
  
  //Step 2: Verify BitBadges as origin by checking plugin secret is correct
  const YOUR_PLUGIN_SECRET = '';
  if (pluginSecret !== YOUR_PLUGIN_SECRET) {
    return res.status(401).json({ message: 'Invalid plugin secret' });
  }
  
  //Step 3: Implement your custom logic here. Consider checking the plugin's creation / last updated time to implement version control.
  
  //Step 4: Return expected responses
  return res.status(200).json({});
};

export default handlePlugin;
```

We have designed plugins in a way to allow you maximum customization by letting you handle as much of the plugin logic as possible. This is a design decision as we believe the core logic of the distribution process should be decentralized and community-driven (not centralized on BitBadges servers).

**Potential Parties**

* Claim Creator - Entity creating the claim that uses the plugin
* Claiming User - End user attempting to claim
* Plugin Creator - Entity creating the plugin

**Timing of Requests**

Plugins can either be:

* Success hooks: Only sent after the claim succeeds. Typically for post-claim logic or rewards
* Processing hooks: Sent during execution and can affect the overall outcome of the claim depending on the response.

We also allow users to simulate (dry run) their claim attempts. Plugins are expected to handle these as necessary. These are all configurable in the creation process in-site.

**Parts of the Plugin**

* Backend Handler (Your API) - All plugins have a backend handler that we expect a 200 OK response from, along with other details depending on the configuration, at claim time.
* Claim Creator Input Handlers (Public / Private Parameters) - The creator will need to configure public and private parameter, if applicable. This can be done in-site or outsourced to a configuration tool.
* User Input Handlers (Custom Input Body) - The user may also need to enter inputs for the claim attempt. This can also be done in-site or outsourced to your own custom frontend.

<figure><img src="../../../.gitbook/assets/image (5) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**State Management**

If there is any core state required to be used, this must be managed on BitBadges side to avoid race conditions. To workaround this, the plugin will pass along expected updates IF the claim is passed (e.g. mark this one time use claim token as USED IF the claim is successful).

The golden rule here is that a successful response from your plugin DOES NOT mean the overall claim attempt was successful. Other plugins might fail. The other way around is also true. If your plugin fails, the overall claim may still be successful (e.g. 1 out of 10 plugins must pass but yours fails).

**Published Plugins**

Plugins are private and only usable by the creator and approved users by default, but you can publish them as well. Published plugins will be displayable in the directory (after a review process) and selectable by anyone creating a claim.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Plugin IDs vs Instance IDs**

Plugin IDs are constant and specific to a specific plugin type. For example, the password pluginId is "password".

Instance IDs are a unique identifier for a specific plugin in your claim. This is to handle duplicates. For example, you may have two password plugins, one with instance Id "abc" and one with "def". This is just used as a unique identifier and can really be anything. If you only have one instance of a specific type, you can name it the same as the pluginId as well.


## File: ./for-developers/claim-builder/success-logic.md

# Success Logic

Certain claims may make use of the **satsifyMethod** property to implement dynamic logic. This option is currently only available behind the scenes. Frontend defaults to all are required (satisfyMethod = undefined). By default, all plugins must pass without any custom success logic specified.

<figure><img src="../../.gitbook/assets/image (188).png" alt=""><figcaption></figcaption></figure>

This works in the following ways:

* By default, if  **satisfyMethod** is falsy (undefined), ALL plugins are required in order for the overall claim to succeed.
* The "numUses" plugin or those critical to assigning claim numbers are required and cannot be optional
* Claimees are allowed to select which plugins they want to execute / be applied. Behind the scene this uses the **\_specificInstanceIds** property on the simulate / complete API claim request.
* For stateful plugins, we ONLY update the state for the plugins in the success path (we will short circuit where necessary).
  * For example, if there is a requirement group with 2 out of 8 plugins needing success and the first two pass, we will not even check or apply state for the other six.

```typescript
export interface iSatisfyMethod {
  type: 'AND' | 'OR' | 'NOT';
  /** Conditions can either be the instance ID of the plugin to check success for or another satisfyMethod object. */
  conditions: Array<string | iSatisfyMethod>;
  options?: {
    /** Only applicable to OR logic. Implements M of N logic. */
    minNumSatisfied?: number;
  };
}
```



## File: ./for-developers/concepts/README.md

# 🧠 Core Concepts

Before developing with BitBadges, we strongly recommend you read through the pages in this section to understand the behind the scenes of BitBadges.

Also if you haven't already, read the [How It Works](../../overview/how-it-works/) section for understanding the core concepts of badges and badge collections.&#x20;

This section also assumes you have a basic understanding of blockchains and [Cosmos SDK](https://docs.cosmos.network/main). We will do our best to explain where there is a possibility for confusion.



**Can't find what you are looking for?**

Although we try to provide in-depth tutorials and examples in this documentation, we may have not covered everything, or some things may be confusing. Feel free to check out the source code directly at [https://github.com/bitbadges](https://github.com/bitbadges). The BitBadges website and indexer / API code has implemented and used everything outlined in this section.&#x20;

If you do come across something not in the docs or something could be improved, it would be greatly appreciated if you could contact us to get it added or create a [tutorial](../tutorials.md)!


## File: ./for-developers/concepts/accounts-technical.md

# 👥 Accounts (Technical)

## Pre-Readings

* [Cosmos SDK Accounts](https://docs.cosmos.network/main/basics/accounts)
* [Ethereum Accounts](https://ethereum.org/en/whitepaper/#ethereum-accounts)

### Accounts and Validator Operators

For accounts (standard senders of transactions) and validator operators, we support users from four L1 blockchain ecosystems currently (Ethereum, Bitcoin, Solana, and Cosmos).

### **Ethereum**

BitBadges allows Ethereum addresses to use Ethereum's ECDSA secp256k1 curve for keys. The public key for these accounts will be a custom type (forked from [Ethermint](https://github.com/cosmos/ethermint)). This satisfies the [EIP84](https://github.com/ethereum/EIPs/issues/84) for full [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) paths. The root HD path for BitBadges Ethereum-based accounts is `m/44'/60'/0'/0`. BitBadges uses the Coin type `60` to support Ethereum type accounts, unlike  other Cosmos chains that use Coin type `118.`

**Signing Method:** All transactions should be signed with EIP712. EIP712 transactions can be generated via the BitBadges SDK.

### **Solana**

BitBadges also extends the SDK's functionality to support Solana signatures signing with a ed25519 key. Addresses are expected to be in the native Base58 format.

**Signing Method:** Transactions will be signed in JSON stringified format with all keys alphabetically sorted. JSON messages can also be generated via the SDK.

### **Cosmos**

Normal Cosmos accounts are also supported with all the Cosmos SDK's native functionality. We refer you to their documentation for further information.

### Bitcoin

BitBadges supports Bitcoin P2WPKH addresses and BIP322 message verification.

**Signing Method:** Transactions will be signed in JSON stringified format with all keys alphabetically sorted. JSON messages can also be generated via the SDK.

### Addresses and Public Keys[​](https://docs.injective.network/learn/basic-concepts/accounts#addresses-and-public-keys) <a href="#addresses-and-public-keys" id="addresses-and-public-keys"></a>

#### **Address Conversion**&#x20;

<pre class="language-typescript"><code class="lang-typescript"><strong>import { ethToBitBadges, bitbadgesToEth } from 'bitbadgesjs-sdk';
</strong><strong>
</strong><strong>const bitbadgesAddress = ethToBitBadges(address);
</strong>const ethAddress = bitbadgesToEth(bitbadgesAddress);
const bitbadgesAddressFromSolana = solanaToBitBadges(address);
//Note there is no bitbadgesToSolana or ethToSolana due to how the addresses work
</code></pre>

Behind the scenes, the blockchain always uses the mapped BitBadges address, never a Solana or Ethereum address. The Solana / Ethereum addresses are only for visually displaying to the user.

The Bech32 format is the default format for Cosmos-SDK queries and transactions through CLI and REST clients.&#x20;

#### **Representation** <a href="#addresses-and-public-keys" id="addresses-and-public-keys"></a>

Ethereum Example:

* Address (Bech32): `bb14au322k9munkmx5wrchz9q30juf5wjgz2cfqku`
* Address ([EIP55](https://eips.ethereum.org/EIPS/eip-55) Ethereum Hex): `0xAF79152AC5dF276D9A8e1E2E22822f9713474902`

Solana Example:

* Address (Base58): 6H2af68Yyg6j7N4XeQKmkZFocYQgv6yYoU3Xk491efa5
* Address (Bech32): bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl

Bitcoin Example&#x20;

* Address (Native - P2WPKH): bc1q9s7rynm5pwhluhecsmlku8rn5yej5wdgj0gv3e
* Address (Bech32): bb19s7rynm5pwhluhecsmlku8rn5yej5wdg8g75f9

#### **Public Key Types**

For standard Cosmos accounts, the public key will have the `"@type": "/cosmos.crypto.secp256k1.PubKey"`.

For Solana accounts, the public key will have the `"@type": "/cosmos.crypto.ed25519.PubKey"`.

For standard Ethereum accounts, the public key will have the `"@type": "/ethereum.PubKey"`.

`{"@type":"/ethereum.PubKey","key":"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2"}`

### Deriving BitBadges Ethereum Account from a private key/mnemonic[​](https://docs.injective.network/learn/basic-concepts/accounts#deriving-injective-account-from-a-private-keymnemonic) <a href="#deriving-injective-account-from-a-private-keymnemonic" id="deriving-injective-account-from-a-private-keymnemonic"></a>

Below you will see an example code snippet on how to derive a BitBadges Account from a private key and/or a mnemonic phase:

```typescript
import { Wallet } from 'ethers'
import { Address as EthereumUtilsAddress } from 'ethereumjs-util'

const mnemonic = "indoor dish desk flag debris potato excuse depart ticket judge file exit"
const privateKey = "afdfd9c3d2095ef696594f6cedcae59e72dcd697e2a7521b1578140422a4f890"
const defaultDerivationPath = "m/44'/60'/0'/0/0"
const defaultBech32Prefix = 'bb'
const isPrivateKey: boolean = true /* just for the example */

const wallet = isPrivateKey ? Wallet.fromMnemonic(mnemonic, defaultDerivationPath) : new Wallet(privateKey)
const ethereumAddress = wallet.address
const addressBuffer = EthereumUtilsAddress.fromString(ethereumAddress.toString()).toBuffer()
const bitbadgesAddress = bech32.encode(defaultBech32Prefix, bech32.toWords(addressBuffer))
```

Let's see an example code snipped on how to derive a public key from a private key:

```typescript
import secp256k1 from 'secp256k1'

const privateKey = "afdfd9c3d2095ef696594f6cedcae59e72dcd697e2a7521b1578140422a4f890"
const privateKeyHex = Buffer.from(privateKey.toString(), 'hex')
const publicKeyByte = secp256k1.publicKeyCreate(privateKeyHex)

const buf1 = Buffer.from([10])
const buf2 = Buffer.from([publicKeyByte.length])
const buf3 = Buffer.from(publicKeyByte)

const publicKey = Buffer.concat([buf1, buf2, buf3]).toString('base64')
const type = '/ethereum.PubKey'
```

#### Acknowledgements

Credit to [https://docs.injective.network/learn/basic-concepts/accounts](https://docs.injective.network/learn/basic-concepts/accounts) and [https://docs.evmos.org/protocol/concepts/accounts](https://docs.evmos.org/protocol/concepts/accounts).


## File: ./for-developers/concepts/accounts.md

# 👤 Accounts

This page will give you an overview of BitBadges accounts. It should be enough information for most, but for more low-level interaction, [the next page](accounts-technical.md) will give you more in-depth explanations.&#x20;

#### **How is BitBadges able to support addresses from different blockchains?**

To enable interoperability between different blockchains, each individual L1 blockchain will have its native addresses mapped to an equivalent Cosmos bech32 address and an account ID number. An account ID number will be assigned to the address when it interacts with the BitBadges blockchain or is sent $BADGE for the first time.&#x20;

As an example, the Ethereum null address 0x0000000000000000000000000000000000000000 maps to the BitBadges address bb1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs7gvmv and will be assigned an account ID number upon interaction with the BitBadges blockchain. It would also map to an equivalent Bitcoin address as well.

<figure><img src="../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

#### **Representation** <a href="#addresses-and-public-keys" id="addresses-and-public-keys"></a>

Ethereum Example:

* Address (Bech32): `bb14au322k9munkmx5wrchz9q30juf5wjgz2cfqku`
* Address (Native - [EIP55](https://eips.ethereum.org/EIPS/eip-55) Ethereum Hex): `0xAF79152AC5dF276D9A8e1E2E22822f9713474902`

Solana Example:

* Address (Native - Base58): 6H2af68Yyg6j7N4XeQKmkZFocYQgv6yYoU3Xk491efa5
* Address (Bech32): bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl

Bitcoin Example&#x20;

* Address (Native - P2WPKH): bc1q9s7rynm5pwhluhecsmlku8rn5yej5wdgj0gv3e
* Address (Bech32): bb19s7rynm5pwhluhecsmlku8rn5yej5wdg8g75f9

#### Why can I convert Solana address to a  BitBadges / Eth / BTC address but not the other way around?

You may notice that you cannot go from a BitBadges / Eth address directly to a Solana address but you can the other way around. This is because conversion from a Solana address requires a hash, so if you just have the postimage of the hash (an Eth / BitBadges address), you cannot deduce the preimage without prior knowledge of it.

#### **Which address should I use (native or mapped one)? How to convert?**

For user experience, you should always display the user's native address on a frontend. However, the BitBadges blockchain **only** uses the mapped BitBadges addresses behind the scenes, never a native address. This can be converted behind the scenes using the converter functions from [BitBadges SDK](../bitbadges-sdk/) (address-converter). This can be done with any validly formatted address.

<pre class="language-typescript"><code class="lang-typescript"><strong>import { ethToBitBadges, bitbadgesToEth, convertToBitBadgesAddress } from 'bitbadgesjs-sdk';
</strong><strong>
</strong><strong>
</strong><strong>const bitbadgesAddress1 = convertToBitBadgesAddress(address);
</strong><strong>const bitbadgesAddress = ethToBitBadges(address);
</strong>const ethAddress = bitbadgesToEth(bitbadgesAddress);
const bitbadgesAddressFromSolana = solanaToBitBadges(address);
//Note there is no bitbadgesToSolana or ethToSolana due to how the addresses work
</code></pre>

#### **How do I query details for an address?**

1. You can use the [BitBadges API](../bitbadges-api/api.md) to get information about an address (recommended option). This is the recommended options because we have indexed all the data already for you.
2. You an also query a BitBadges blockchain node directly, either through the CLI or  [REST API ](https://docs.cosmos.network/v0.46/run-node/interact-node.html).&#x20;


## File: ./for-developers/concepts/address-mappings-lists.md

# 📧 Address Lists (Lists)

[AddressLists](https://bitbadges.github.io/bitbadgesjs/interfaces/iAddressList.html) are a powerful feature with range logic similar to UintRanges. They allow us to specify a list of addresses, identified by a listId.

```typescript
export interface AddressList {
    listId: string;

    addresses: string[];
    whitelist: boolean;

    uri: string;
    customData: string;
}
```

### Inverting (Whitelist vs Blacklist)

These are invertible meaning we can create a list that includes all addresses EXCEPT some specified addresses (whitelist = false). Or, we can create a list that includes ONLY some specified addresses (whitelist = true). More commonly, this is thought of as a blacklist or whitelist.

**IMPORTANT:** When you invert, the inversion by default includes the "Mint" address. This is important when handling the **fromList** of approvals. You do not want to accidentally approve users to transfer from the "Mint" address.

### **Storage**

**On-Chain:** AddressLists are **permanent and not updatable** once created, if stored on-chain. These can be created using [MsgCreateAddressLists](../create-and-broadcast-txs/cosmos-sdk-msgs/).

They can be used to define transferability on-chain. For example, list "xyz" can only transfer to list "abc" initiated by the reserved "Manager" list.

The same address list is not unique to a collection on-chain and can be used for defining transferability by any collection.

**Off-Chain:** Address lists can also be created off-chain through our indexer / API. These are updatable and deletable, along with additional options. However, this is a centralized solution and doesn't use the blockchain. Everything is simply stored on our centralized servers

### **Reserved Address List IDs**

There are a couple IDs for AddressLists that are reserved for efficient shorthand methods. To enable this, "\_" and ":" and "!" are not allowed anywhere in a standard ID.

-   If prefixed with "!", it denotes to invert the address list (e.g. "!id123" inverts the "id123" address list)
-   Any valid Cosmos (bech32) address is reserved as the list that ONLY includes that specific address.
-   "Mint" specifies the "Mint" address only.
-   "AllWithoutAddress1" denotes all valid user addresses excluding Address1 (e.g. "AllWithoutMint")
-   "AllWithoutAddress1:Address2:Address3" denotes all valid user addresses excluding Address 1,2,and3 (e.g. "AllWithoutMint:bb123...:bb456...")
-   "All" or "AllWithMint" denotes all valid user addresses as well as the "Mint" address

See below for the function for generating them.

### Custom IDs

Reserved address lists are provided for convenience, so you don't actually have to create an AddressList on-chain first. However, long list IDs are very inefficient, especially if used multiple times (e.g. "AllWithoutMint:bb123...:bb456...").&#x20;

For efficiency, consider creating a list with a unique short ID and reference the list that way. You can create a list which is all addresses except Mint, bb123..., bb456... and identified by the ID "abc". Instead of repeating the long "AllWithoutMint:bb123...:bb456..." wherever the ID is needed, you can simply repeat "abc" which saves a lot of resources.

### Examples

This is the list which includes all addresses except "bb123...." and "bb456...."

```typescript
{
  "listId": "abcdef",
  "addresses": ["bb123...", "bb456...."],
  "whitelist": false,
  ...
}
```

<pre class="language-typescript"><code class="lang-typescript"><a data-footnote-ref href="#user-content-fn-1">function</a> getReservedList(
  addressListId: string,
  allowAliases?: boolean,
): AddressList {
  let inverted = false
  let addressList: AddressList | undefined = undefined

  if (addressListId[0] === '!') {
    inverted = true
    addressListId = addressListId.slice(1)
  }

  if (addressListId === 'Mint') {
    addressList = {
      listId: 'Mint',
      addresses: ['Mint'],
      whitelist: true,
      uri: '',
      customData: '',
      createdBy: '',
    }
  } else if (addressListId.startsWith('AllWithout')) {
    addressList = {
      listId: addressListId,
      addresses: [],
      whitelist: false,
      uri: '',
      customData: '',
      createdBy: '',
    }

    const addresses = addressListId.slice(10).split(':')

    for (let address of addresses) {
      addressList.addresses.push(address)
    }
  } else if (addressListId === 'AllWithMint' || addressListId === 'All') {
    addressList = {
      listId: addressListId,
      addresses: [],
      whitelist: false,
      uri: '',
      customData: '',
      createdBy: '',
    }
  } else if (addressListId === 'None') {
    addressList = {
      listId: 'None',
      addresses: [],
      whitelist: true,
      uri: '',
      customData: '',
      createdBy: '',
    }
  } else {
    //split by :
    const addressesToCheck = addressListId.split(':')
    let allAreValid = true
    //For tracker IDs, we allow aliasses(aka non valid addresses)
    if (!allowAliases) {
      for (let address of addressesToCheck) {
        if (address != 'Mint' &#x26;&#x26; !convertToBitBadgesAddress(address)) {
          allAreValid = false
        }
      }
    }

    if (allAreValid) {
      addressList = {
        listId: addressListId,
        addresses: addressesToCheck,
        whitelist: true,
        uri: '',
        customData: '',
        createdBy: '',
      }
    }
  }

  if (inverted &#x26;&#x26; addressList) {
    addressList.whitelist = !addressList.whitelist
  }

  if (!addressList) {
    throw new Error(`Invalid address list ID: ${addressListId}`)
  }

  return addressList
}
</code></pre>

[^1]:


## File: ./for-developers/concepts/balances.md

# 📊 Balances

For an overview, first read [Balances / Transfers](../../overview/how-it-works/time-dependent-ownership.md).

```typescript
export interface Balance<T extends NumberType> {
  amount: T;
  badgeIds: UintRange<T>[]
  ownershipTimes: UintRange<T>[]
}
```

**Interpreting Balances**

When interpreting balances, there are certain rules to keep in mind. If we have multiple ranges of badge IDs and ownership times defined within a single Balance structure, it means that we own all possible combinations.&#x20;

```
for (balance of balances) {
    for (badgeIdRange of balance.badgeIds) {
        for (ownershipTimeRange of balanace.ownershipTimes) {
            //User owns x(balance.amount) of (badgeIdRange) for the times (ownershipTimeRange)
        }
    }
}
```

For example, lets say we have a balance of&#x20;

<pre class="language-json"><code class="lang-json"><strong>{ 
</strong>    amount: 1, 
    badgeIds: [{ start: 1, end: 10}, {start: 20, end: 30}], 
    ownershipTimes: [{start: 20, end: 50}, {start: 100, end: 200}] 
}
</code></pre>

This can be expanded and thought of as owning:

* x1 of IDs 1-10 from times 20-50&#x20;
* x1 of IDs 1-10 from times 100-200
* x1 of IDs 20-30 from times 20-50
* x1 of IDs 20-30 from times 100-200

If we wanted to subtract the first set of balances (x1 of IDs 1-10 from times 20-50), we would then need to represent it as two separate balances:&#x20;

```
{ 
    amount: 1, 
    badgeIds: [{ start: 1, end: 10}, {start: 20, end: 30}], 
    ownershipTimes: [{start: 100, end: 200}] 
}
```

```
{ 
    amount: 1, 
    badgeIds: [{start: 20, end: 30}], 
    ownershipTimes: [{start: 20, end: 50}}] 
}
```

**Duplicates**

If you specify duplicate badge IDs in balances such as:

```
{ 
    amount: 1, 
    badgeIds: [{ start: 1, end: 10}, {start: 1, end: 10}], 
    ownershipTimes: [{start: 100, end: 200}] 
}
```

This is equivalent and will be treated as:

```
{ 
    amount: 2, 
    badgeIds: [{ start: 1, end: 10}], 
    ownershipTimes: [{start: 100, end: 200}] 
}
```


## File: ./for-developers/concepts/chain-details.md

# ✏ Chain Details

Cosmos Chain ID (Mainnet) - bitbadges-1

Cosmos Chain ID (Testnet) - bitbadges-2

[Cosmos SDK Coin Denom](https://docs.cosmos.network/main/modules/bank) - "ubadge" (1 $BADGE = 1 \* 10^9 ubadge)


## File: ./for-developers/concepts/uint-ranges.md

# 🔢 Uint Ranges

<pre class="language-typescript"><code class="lang-typescript"><strong>export interface UintRange&#x3C;T extends NumberType> {
</strong>  start: T;
  end: T;
}
</code></pre>

A core type behind the scenes in BitBadges is the [UintRange](https://bitbadges.github.io/bitbadgesjs/interfaces/iUintRange.html) type, which simply defines a range of numbers from some start value to some end value, inclusive. This allows us to apply powerful range logic.

These are typically used for representing badge IDs and time ranges. For example, transferring badges will require an UintRange\<number>\[] of badgeIds to be specified. If you say to transfer \[{ start: 1, end: 10}, {start: 20, end: 50}], it will transfer the badge IDs 1-10 and 20-50.

**Restricted Values**

If used for badge IDs or times, we only allow the start and end to be within the range of 1 to Go's math.MaxUint64 or 18446744073709551615 (**so no zero value and no value greater than that**).

To represent a "full" or "complete" range, use \[{ start: 1, end: 18446744073709551615 }]. If we invert a range, we get all the values from 1 to 18446744073709551615 that are not in the current range.

```json
"transferTimes": [
  {
    "start": "1",
    "end": "18446744073709551615"
  }
]
```


## File: ./for-developers/core-concepts/README.md

# 🧠 Concepts



## File: ./for-developers/core-concepts/accounts-technical.md

# Accounts (Low-Level)

## Pre-Readings

* [Cosmos SDK Accounts](https://docs.cosmos.network/main/basics/accounts)
* [Ethereum Accounts](https://ethereum.org/en/whitepaper/#ethereum-accounts)

### Accounts[​](https://docs.injective.network/learn/basic-concepts/accounts#injective-accounts) <a href="#injective-accounts" id="injective-accounts"></a>

For accounts (standard senders of transactions) , we support users from four L1 blockchain ecosystems currently (Ethereum, Bitcoin, Solana, and Cosmos). These are mapped behind the scenes through mapping addresses to an equivalent BitBadges address and being signature compatible (able to verify signatures of the native signature schemes).

### Signing Transactions <a href="#injective-accounts" id="injective-accounts"></a>

For non-Cosmos signatures, we map everything to a SHA256 content hash to get a string such as:

```
This is a BitBadges transaction with the content hash: b0d2944e1e367cc394d0e305f94eccf543983265a32b5cb71800da7d6df57679
```

We then verify the signatures of the transaction string as a personal message signature via the respective signature algorithm (e.g. ECDSA for Ethereum).

### **Cosmos**

Normal Cosmos accounts are also supported with all the Cosmos SDK's native functionality. We refer you to their documentation for further information.

### **Ethereum**

BitBadges allows Ethereum addresses to use Ethereum's ECDSA secp256k1 curve for keys.

### **Solana**

BitBadges also extends the SDK's functionality to support Solana signatures signing with a ed25519 key. Addresses are expected to be in the native Base58 format.

### Bitcoin

BitBadges supports Bitcoin P2WPKH addresses and BIP322 signature verification.

### **Public Key Types**

For standard Cosmos accounts and Bitcoin accounts, the public key will have the `"@type": "/cosmos.crypto.secp256k1.PubKey"`.

For Solana accounts, the public key will have the `"@type": "/cosmos.crypto.ed25519.PubKey"`.

For standard Ethereum accounts, the public key will have the `"@type": "/ethereum.PubKey"`.

`{"@type":"/ethereum.PubKey","key":"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2"}`

### Deriving BitBadges Ethereum Account from a private key/mnemonic[​](https://docs.injective.network/learn/basic-concepts/accounts#deriving-injective-account-from-a-private-keymnemonic) <a href="#deriving-injective-account-from-a-private-keymnemonic" id="deriving-injective-account-from-a-private-keymnemonic"></a>

Below you will see an example code snippet on how to derive a BitBadges Account from a private key and/or a mnemonic phase:

```typescript
import { Wallet } from 'ethers'
import { Address as EthereumUtilsAddress } from 'ethereumjs-util'

const mnemonic = "indoor dish desk flag debris potato excuse depart ticket judge file exit"
const privateKey = "afdfd9c3d2095ef696594f6cedcae59e72dcd697e2a7521b1578140422a4f890"
const defaultDerivationPath = "m/44'/60'/0'/0/0"
const defaultBech32Prefix = 'bb'
const isPrivateKey: boolean = true /* just for the example */

const wallet = isPrivateKey ? Wallet.fromMnemonic(mnemonic, defaultDerivationPath) : new Wallet(privateKey)
const ethereumAddress = wallet.address
const addressBuffer = EthereumUtilsAddress.fromString(ethereumAddress.toString()).toBuffer()
const bitbadgesAddress = bech32.encode(defaultBech32Prefix, bech32.toWords(addressBuffer))
```

Let's see an example code snipped on how to derive a public key from a private key:

```typescript
import secp256k1 from 'secp256k1'

const privateKey = "afdfd9c3d2095ef696594f6cedcae59e72dcd697e2a7521b1578140422a4f890"
const privateKeyHex = Buffer.from(privateKey.toString(), 'hex')
const publicKeyByte = secp256k1.publicKeyCreate(privateKeyHex)

const buf1 = Buffer.from([10])
const buf2 = Buffer.from([publicKeyByte.length])
const buf3 = Buffer.from(publicKeyByte)

const publicKey = Buffer.concat([buf1, buf2, buf3]).toString('base64')
const type = '/ethereum.PubKey'
```

#### Acknowledgements

Credit to [https://docs.injective.network/learn/basic-concepts/accounts](https://docs.injective.network/learn/basic-concepts/accounts) and [https://docs.evmos.org/protocol/concepts/accounts](https://docs.evmos.org/protocol/concepts/accounts).


## File: ./for-developers/core-concepts/address-lists-lists.md

# Address Lists

[AddressLists](https://bitbadges.github.io/bitbadgesjs/interfaces/iAddressList.html) are a powerful feature with range logic similar to UintRanges. They allow us to specify a list of addresses, identified by a listId.

```typescript
export interface AddressList {
    listId: string;

    addresses: string[];
    whitelist: boolean;

    uri: string;
    customData: string;
}
```

### When to use lists?

**Using Lists Instead of Badges**

Theoretically, address lists are just a simplified version of the badge interface. Thus, all address lists can be implemented as a badge where the list is determined by who has a positive balance of the badge. However, sometimes, this simplicity may be desired, such as not dealing with balances, ownership times, permissions, etc. On the BitBadges site, we allow you to create both lists and badges, depending on your desired level of customization.

**Using Lists to Define Transferability / Approvals**

When defining transferability and approvals on-chain, you need to define the list of addresses who can send, receive, and initiate the transfer. The AddressList interface is reused for this on-chain.

We currently only support permanent lists on-chain vis the MsgCreateAddressList interface.

### Inverting (Whitelist vs Blacklist)

Lists are invertible meaning we can create a list that includes all addresses EXCEPT some specified addresses (whitelist = false). Or, we can create a list that includes ONLY some specified addresses (whitelist = true). More commonly, this is thought of as a blacklist or whitelist.

**IMPORTANT:** When you invert, the inversion by default includes the "Mint" address. This is important when handling the **fromList** of approvals. You do not want to accidentally approve users to transfer from the "Mint" address.

### **Storage**

**On-Chain:** AddressLists are **permanent and not updatable** once created, if stored on-chain. These can be created using [MsgCreateAddressLists](../bitbadges-blockchain/cosmos-sdk-msgs/). They can be used to define transferability on-chain. For example, those on list "xyz" can only transfer to list "abc" initiated by those on the reserved "AllWithoutMint" list.

An address list is not unique to a collection on-chain and can be used for defining transferability by any collection.

**Off-Chain:** Address lists can also be created off-chain through BitBadges. These are updatable and deletable, along with additional options (private? viewable with link? survey mode?). However, this is a centralized solution and doesn't use the blockchain. Everything is simply stored on our centralized servers.

### **Reserved Address List IDs**

There are a couple IDs for AddressLists that are reserved for efficient shorthand methods. To enable this, "\_" and ":" and "!" are not allowed anywhere in a standard ID.

* "All" denotes all valid user addresses (as well as the "Mint" address which is important when specifying the sender list of transferability)
* Any valid Cosmos (bech32) address is reserved as the list that ONLY includes that specific address.
  * "Mint" specifies the "Mint" address only.
  * "bb1abc..." specified the list with "bb1abc...." only
* Combination shorthands
  * Using the ":" character, you can combine multiple addresses such as "Mint:bb1abc...". This would represent the list with Mint and bb1abc...
* Inversion shorthands
  * If prefixed with "!", it denotes to invert the address list.
    * "!id123" inverts the "id123" address list
    * "!Mint" inverts the Mint list
    *   "!Mint:bb1abc..." inverts the "Mint:bb1abc..." list which means all but the two specified addresses

        The above bullet may look a little weird to developers because it may only seem like the "Mint' is inverted but others aren't. You can also wrap everything in a parentheses such as "!(Mint:bb1abc...)" if you would like

Use the SDK functions below for generating IDs / lists.

```typescript
function getReservedList(
  addressListId: string, allowAliases?: boolean,
): AddressList

export const generateReservedListId = (
  addressList: AddressList,
): string
```

### Custom IDs

Reserved address lists are provided for convenience, so you don't actually have to create an AddressList on-chain everytime first. However, long list IDs are very inefficient, especially if used multiple times (e.g. "AllWithoutMint:bb123...:bb456...").

For efficiency, consider creating a list with a unique short reusable ID and reference the list that way, rather than the long ID. You can create a list which is all addresses except Mint, bb123..., bb456... and identified by the ID "abc". Instead of repeating the long "AllWithoutMint:bb123...:bb456..." wherever the ID is needed, you can simply repeat "abc" which saves a lot of resources.

### Examples

This is the list which includes all addresses except "bb123...." and "bb456...."

```typescript
{
  "listId": "abcdef",
  "addresses": ["bb123...", "bb456...."],
  "whitelist": false,
  ...
}
```


## File: ./for-developers/core-concepts/maps.md

# Maps / Protocols

Maps are similar to anchors, but they allow you to store data on-chain in a structured way. They are simply key-value maps, and the configuration can be set with customization options like "no duplicates", "expect integere values"", and so on. With maps, you can create universal, reusable, flexible protocols for your users.

```json
{
    "bb...1234": "English",
    "bb...5678": "Spanish"
}
```

```json
{
    "BitBadges Follow Protocol": 12, //collection ID 12 is used for my follows
    "Experiences Protocol": 13
}
```

This is all facilitated through the x/maps module and its correspondingMsgs. See the Msgs for more information.

```typescript
export interface iMap<T extends NumberType> {
    creator: string;
    mapId: string;
    inheritManagerTimelineFrom: T;
    managerTimeline: iManagerTimeline<T>[];
    updateCriteria: iMapUpdateCriteria<T>;
    valueOptions: iValueOptions;
    defaultValue: string;
    permissions: iMapPermissions<T>;
    metadataTimeline: iMapMetadataTimeline<T>[];
}
```

**Reserved Maps**

All maps are identified by a **mapId.** The following **mapId** values are reserved:

* Any valid Bech32 BitBadges address - These are reserved for maps that can only be created by that specific address. This can be a place to store important values custom to you (that address).
* Any numeric ID is reserved for the corresponding badge collection with a matching ID. This can only be created by the badge collection manager. This can be used to store core details that belong on-chain for the collection not handled by the core badge collection interface.

**Use Cases**

* Alternative permissions - Store other permissions related to a collection in these maps on-chain
* Router for important information - For example, lets say thte collection has credentials attached to it. This can point to where the credentials can be found or important info needed to verify them.
* Protocols - On the next page, we expand on the concept of protocols which allow users to specify what collection they want to use for a certain protocol (e.g. use my collection 10 for the Follow Protocol).

**Manager**

The manager is similar to the badges interface. They are granted admin privileges to update certain things about the map.This is handled by **managerTImeline** and the **canUpdateManager** permission.

Maps also have the option to **inheritManagerTimelineFrom** a specific collection. This emans that the manager of the badge collection specified will be used instead of the **managerTimeline** field.

**Genesis Conditions**

Protocols may have expected genesis conditions or additional checks to be correctly implemented. There are no checks on-chain for genesis conditions but these can be handled by you.

**Map Type**

There are really four different map types.

* Manager only means only the manager can update values
* Collection ID means map key smust be numeric and only owners of badge ID N from the collection ID specified can update key = N.
* Creator only means keys are address-based. You can only update the value for your address. This uses mapped BitBadges addresses.
* First come, first serve means that map slots are open but once claimed, they can not be overwritten unless unset by the user who claimed the slot.

```typescript
export interface iMapUpdateCriteria<T extends NumberType> {
    managerOnly: boolean;
    collectionId: T;
    creatorOnly: boolean;
    firstComeFirstServe: boolean;
}
```

**Permissions / Expected Values**

```typescript
export interface iValueOptions {
    noDuplicates: boolean;
    permanentOnceSet: boolean;
    expectUint: boolean;
    expectBoolean: boolean;
    expectAddress: boolean;
    expectUri: boolean;
}
```

```typescript
export interface iMapPermissions<T extends NumberType> {
    canUpdateMetadata: iTimedUpdatePermission<T>[];
    canUpdateManager: iTimedUpdatePermission<T>[];
    canDeleteMap: iActionPermission<T>[];
}
```

**Map Metadata**

Map metadata follows the same interfaces as badges and address lists.

```typescript
export interface iMapMetadataTimeline<T extends NumberType> {
    timelineTimes: iUintRange<T>[];
    metadata: iCollectionMetadata;
}
```


## File: ./for-developers/core-concepts/uint-ranges.md

# Uint Ranges

<pre class="language-typescript"><code class="lang-typescript"><strong>export interface UintRange&#x3C;T extends NumberType> {
</strong>  start: T;
  end: T;
}
</code></pre>

### Overview

The `UintRange` type is a fundamental component in BitBadges, representing an inclusive range of numbers from a start value to an end value. This type enables powerful range-based operations and is primarily used for badge IDs and time ranges.

### Usage

#### Badge IDs

When transferring badges, specify an array of `UintRange<number>` to indicate which badge IDs to transfer.

Example:

```typescript
const badgeIdsToTransfer: UintRange<number>[] = [
  { start: 1, end: 10 },
  { start: 20, end: 50 }
];
```

#### Time Ranges

`UintRange` is also used for time-based operations, such as `transferTimes`. In this context, the values represent UNIX milliseconds since the epoch.

Example:

```typescript
const transferTimes: UintRange<string>[] = [
  { start: "1630000000000", end: "1640000000000" }
];
// This represents a transfer time range from 2021-08-26 to 2021-12-20
```

### Restrictions

Unless otherwise specified, we only allow numbers in the ranges to be from 1 to Go Max UInt64

* Valid ranges: 1 to 18446744073709551615 (Go's `math.MaxUint64`)
* Zero and values greater than the maximum are not allowed

### Special Cases

#### Full Range

To represent a complete range, use:

```typescript
const fullRange: UintRange<string> = {
  start: "1",
  end: "18446744073709551615"
};
```

#### Range Inversion

Inverting a range results in all values from 1 to 18446744073709551615 that are not in the current range.


## File: ./for-developers/core-concepts/verifiable-attestations/README.md

# Attestations - Advanced



## File: ./for-developers/core-concepts/verifiable-attestations/creating-a-attestation.md

# Creating an Attestation

Pre-Readings: [Verifiable Attestations](./)

On the official site, we provide interfaces to create attestations (Create -> Attestations). You can also self-generate locally and upload via the BitBadges API as well. Below, we provide information on how it works behind the scenes.

<figure><img src="../../../.gitbook/assets/image (135).png" alt=""><figcaption></figcaption></figure>

**Programmatic Generation / Verification**

The creation interface is as follows. All attestations are a series of one or more **messages** which can be either in 'json' or 'plaintext' **messageFormat**. You can use the corresponding API endpoint to create programmatically.

```typescript
await BitBadgesApi.createAttestation(...)
await BitBadgesApi.updateAttestation(...)
```

```typescript
export interface CreateAttestationPayload {
    /**
     * Proof of issuance is used for BBS+ signatures (scheme = bbs) only.
     * BBS+ signatures are signed with a BBS+ key pair, but you would often want the issuer to be a native address.
     * The prooofOfIssuance establishes a link saying that "I am the issuer of this attestation signed with BBS+ key pair ___".
     *
     * Fields can be left blank for standard signatures.
     */
    proofOfIssuance: {
        message: string;
        signature: string;
        signer: string;
        publicKey?: string;
    };

    /** The message format of the messages. */
    messageFormat: 'plaintext' | 'json';

    /** Whether or not the attestation is displayable on the user's profile / queryable by ID.
      If true, the attestation can be queried by anyone with the ID. */
    publicVisibility?: boolean;

    /**
     * The scheme of the attestation. BBS+ signatures are supported and can be used where selective disclosure is a requirement.
     * Otherwise, you can simply use your native blockchain's signature scheme.
     */
    scheme: 'bbs' | 'standard' | 'custom' | string;

    /** The original provider of the attestation. Used for third-party attestation providers. */
    originalProvider?: string;

    /** The type of the attestation (e.g. credential). */
    type: string;
    /**
     * Thesse are the attestations that are signed.
     * For BBS+ signatures, there can be >1 messages, and the signer can selectively disclose the attestations.
     * For standard signatures, there is only 1 attestationMessage.
     */
    messages: string[];

    /**
     * This is the signature and accompanying details of the messages. The siganture maintains the integrity of the messages.
     *
     * This should match the expected scheme. For example, if the scheme is BBS+, the signature should be a BBS+ signature and signer should be a BBS+ public key.
     */
    dataIntegrityProof: {
        signature: string;
        signer: string;
        publicKey?: string;
        isDerived?: boolean; //Used for BBS signatures to differentiate original vs derived proofs
    };

    /** Metadata for the attestation for display purposes. Note this should not contain anything sensitive. It may be displayed to verifiers. */
    name: string;
    /** Metadata for the attestation for display purposes. Note this should not contain anything sensitive. It may be displayed to verifiers. */
    image: string;
    /** Metadata for the attestation for display purposes. Note this should not contain anything sensitive. It may be displayed to verifiers. */
    description: string;
}
```

### **Schemes / Expected Formats**

The **messageFormat** = 'json' or 'plaintext' will determine what format the messages should be in.

The **scheme** field will determine a lot about the attestation:

* 'bbs': The N **messages** must be signed using the BBS+ signature algorithm. A proof of issuance is also required. The schema of the message is left up to the issuer. See below.
* 'standard': Only 1 attestation message is expected. The message should be signed using a standard wallet signature. The schema of the message is left up to the issuer. See below.
* 'custom' or anything else: If you do not want to use a BitBadges native scheme, you can also simply add your own. Feel free to use existing models such as the [W3C Verifiable Credentials](https://www.w3.org/TR/vc-data-model-2.0/) model, create your own, or anything else.

More can be found in the individual scheme documentation later in this section.

### Creating / Verifying Signatures

Note: When received from the BitBadges API directly, you can assume that signatures are already correct for non-custom implementations (bb or standard). However, it is always best practice to verify them on your end as well.

Public keys are currently only needed to be provided for Cosmos signatures in order to verify. Otherwise, you can leave them blank.

#### Standard Signatures

For standard signatures (**scheme** = 'standard'), you can sign 1 message (so **messages**.length = 1), and the **dataIntegrityProof** will be the resulting signature of the only message from your main key pair supported natively by BitBadges. See the signing transaction flow for more information on manually implementing signatures. No **proofOfIssuance** is required (can be left blank).

```typescript
const sig = await chain.signChallenge(attestation.messages[0]);
const pubKey = await chain.getPublicKey(chain.address);

body = {
    ...attestation,
    dataIntegrityProof: {
        signer: chain.address,
        signature: sig.signature,
        publicKey: pubKey,
    },
    proofOfIssuance: {
        signature: '',
        signer: '',
        message: '',
    },
};
```

#### **BBS+ Signatures**

For BBS+ signatures (**scheme** = 'bbs'), you can sign N **messages** and the **dataIntegrityProof** will be the BBS signature of those N message. On the BitBadges site, all BBS+ key pairs are one-time use only. The key pair is generated, signs the transaction, and then is discarded because it is never needed again.

Note: blsSign creates the original and proofs can be derived from that (see later pages in this section).

<pre class="language-typescript"><code class="lang-typescript">import { BlsKeyPair, blsSign, generateBls12381G2KeyPair } from '@mattrglobal/bbs-signatures';

<strong>const signature = await blsSign({
</strong>  keyPair: keyPair!,
  messages: attestation.messages.map((message) => Uint8Array.from(Buffer.from(message, 'utf-8')))
});

setAttestation((prev) => ({
  ...prev,
  dataIntegrityProof: {
<strong>    signer: Buffer.from(keyPair?.publicKey ?? '').toString('hex'),
</strong>    signature: Buffer.from(signature).toString('hex'),
    isDerived: false
  }
}));
</code></pre>

Because BBS+ are not actually signed by your "main" address, we also require a **proofOfIssuance** to establish this link.

```typescript
const message = `I approve the issuance of credentials signed with BBS+ ${attestation.dataIntegrityProof.signer} as my own.\n\n`;
const sig = await chain.signChallenge(message);
const publicKey = await chain.getPublicKey(chain.bitbadgesAddress);
body = {
    ...attestation,
    proofOfIssuance: {
        message,
        signer: chain.address,
        signature: sig.signature,
        publicKey,
    },
};
```

### Alternative Schemes

Note that non-BitBadges native schemes / approaches may have different verification algorithms. Please make sure your approach follows the verification approach.


## File: ./for-developers/core-concepts/verifiable-attestations/creating-and-verifying-a-proof.md

# Verification / Presentations

Pre-Readings: [Verifiable Attestations](./)

Putting it all together, you now need to present the attestation to a verifier when it is needed to be checked.

**Presentations**

Presentations are done with the proof interface which should give the verifier everything they need to check everything. We recommend leveraging our authentication flow (Sign In with BitBadges) and claims (BitBadges Claims) to be used in conjunction with proof verification / presentation.

* Sign In with BitBadges: Proofs / attestations that are stored in the user's BitBadges account can be revealed / passed along to the authentication provider (the verifier) within the sign-in flow.
* BitBadges Claims: Create a custom plugin or webhook that accepts and verifies attestation(s) from the claiming user when they attempt to claim.

These flows natively have protective measures against replay attacks, time windows for verification, and more.

{% content-ref url="../../authenticating-with-bitbadges/" %}
[authenticating-with-bitbadges](../../authenticating-with-bitbadges/)
{% endcontent-ref %}

{% content-ref url="../../../overview/claim-builder/" %}
[claim-builder](../../../overview/claim-builder/)
{% endcontent-ref %}

All attestations should be verified on your end as well. Treat BitBadges as an untrusted middleman. Don't trust, verify!

```typescript
import { BitBadgesApi, verifyAttestation } from 'bitbadgesjs-sdk';

//To outsource to server
await BitBadgesApi.verifyAttestation({ attestation });

//To do it locally
await verifyAttestation(attestation);
```

For any non-BitBadges schemes, we do not maintain any message schemas, verifying integrity, etc. This should all be handled on your end.

**Verification**

Once received, the verifier can then check whatever is needed according to the agreed approach:

* Verifying signatures
* Verifying on-chain anchors / timestamps
* Content is well-formed

Additionally, you should consider:

* If a malicious party gets a cryptographic signature, the signature will still be the same and valid. Thus, it is important to protect against replay attacks, man in the middle attacks, and verify any address ownership as needed. Thus, verification is typically a two-step approach, 1) verify the credential and 2) verify the address of the recipient.
* While the attestation / proof itself can prove the issuer signed the data, it has nothing natively about the holder or presenter. This also needs to be verified.
* The verifier also needs to check the content of the attestation messages and any other app-specific criteria. A valid signature means nothing if the mesage content is not as expected.


## File: ./for-developers/core-concepts/verifiable-attestations/custom-creation-links.md

# Custom Creation Links

To make it convenient for you to redirect users and auto-create attestations, you can create unique create / update links with the details auto-filled out. There are two query parameters that can be passed.

**attestationId:** ID of the existing attestation. Only needed for updates. For create links, leave blank.

**toSet:** A JSON-stringified `CreateAttestationPayload`object that we will set. Not all properties are required. We will only overwrite the ones provided. We refer you to the previous page for configuration.

```
https://bitbadges.io/attestations/create?toSet={}&attestationId=...
```

For example

<pre class="language-typescript"><code class="lang-typescript"><strong>const content: Partial&#x3C;CreateAttestationPayload> = {
</strong>  "messageFormat": "plaintext",
  "type": "credential",
  "scheme": "standard",
  "name": "Custom Name",
  "image": "ipfs://QmNytJNN44stkMndshtdfcCW2mzaCm6A23maiKaQvUqoj8",
  "description": "",
  "messages": [
    "super secret message"
  ]
}

const url = 'https://bitbadges.io/attestations/create?toSet=' + JSON.stringify(content)
</code></pre>

```
https://bitbadges.io/attestations/create?toSet={ "messageFormat": "plaintext", "type": "credential", "scheme": "standard", "name": "Custom Name", "image": "ipfs://QmNytJNN44stkMndshtdfcCW2mzaCm6A23maiKaQvUqoj8", "description": "gfdsgxdfgsdf", "messages": [ "super secret message" ] }
```


## File: ./for-developers/core-concepts/verifiable-attestations/custom-schemes/README.md

# Custom Schemes



## File: ./for-developers/core-concepts/verifiable-attestations/custom-schemes/witness-proofs.md

# WITNESS Proofs

Create WITNESS proofs and custom upload them to BitBadges via our attestation interface.

**Overview**

Anyone can use Witness to create verifiable [provenance](https://docs.witness.co/concepts/provenance) and issue [digital ownership](https://docs.witness.co/concepts/provenance) for any data without the upfront friction or cost of blockchains. This allows developers to build traditionally scalable applications that benefit from Web3 incentives such as:

-   Tokenization: NFTs, tokens, points
-   Universal Verifiability: attestations, logs, timestamps
-   Financialization: mint fees, referral fees, smart contracts composability

We refer you to [their docs](https://docs.witness.co/) for further implementation details.&#x20;

**Scheme Name**

The **scheme** property should be:

```typescriptreact
scheme: "witness-proof"
```

You can also set the originalProvider:

```
"originalProvider": "Witness"
```

**Message Interface**

```
"messageFormat": "json"
```

We expect the following interface for message content (stringified JSON) to be compatible with our UI.&#x20;

```typescript
interface WitnessProof {
    proof: {
        leafHash: string;
        leafIndex: bigint;
        leftHashes?: string[];
        rightHashes?: string[];
        targetRootHash: string;
    };
    chainId?: string;
    preimage?: string;
    timestamp?: number;
    txHash?: string;
}
```

```json
{
  "preimage": "Testing witness proofs",
  "proof": {
    "leafIndex": "30800033",
    "leafHash": "0x570751d4efee586ef4baa79c336778de08b019b69f182e68561ba2b44bce2d7c",
    "leftHashes": [
      "0xfd663a79b001aa5bcd55ce32aae934fc69281bc19b83f287236b572acaf57962",
      ...
    ],
    "rightHashes": [
      "0x3c6710710882171f7a3b07172d7637cfbf385e46fcfe8560eb2822410c4eca8d",
       ...
    ],
    "targetRootHash": "0xf34cf9b13d69ee9af5110841baf2a9b294ff13926d4f60e13222edaa7243de68"
  },
  "timestamp": 10000000, //Unix milli timestamp
  "chainId": "8453", //Defaults to this for "Base"
  "txHash": "0x842f3a5ac844ee222865cb03ea28c04f0eb65a4896b83d40c5cb4900cb7ffcc1"
}
```

Note: When stringified, it would be like this where we have an array of stringified JSON proofs with length 1.

```json
"messages": [
    "{\n  \"preimage\": \"Testing witness proofs\",\n  \"proof\": {\n    \"leafIndex\": \"30800033\",\n    \"leafHash\": \"0x570751d4efee586ef4baa79c336778de08b019b69f182e68561ba2b44bce2d7c\",\n    \"leftHashes\": [\n      \"0xfd663a79b001aa5bcd55ce32aae934fc69281bc19b83f287236b572acaf57962\",\n      \"0x44b18b19f7da0a75ea66af7fa9cdd3e5f376749ff3c201beaa867abfbd99270d\",\n      \"0xb52cfafbe335afc9eb38b74b1b9186c5426807985b99ecc568c338ed22f6d739\",\n      \"0x027cd88daedfbbf04cea7abd17b70504bdfb56d27541e654f5762d44f06e3cce\",\n      \"0xa0f9df4a46928425bb01b40bca6ead558358c62f4b692392cc4e8c76fe2c1fb1\",\n      \"0x53a276dac9002ecb766cb865198e912baf114fd3c95079f19ef2d9abe3a078f4\",\n      \"0xe1af8f9e39e7b57a7eee0d3f47cf111a3291c29ce757d6d542aca8d590bb1013\",\n      \"0xf1250deb418ab6f57d4482e1243cd8aadd021afd546a18a0a067757a0ad6198d\",\n      \"0x1351fef7c4972ebb9ac5b0691c411cf40e1773fbb8168e664bb0b13cffcfa07d\",\n      \"0x2d7002b8f80a5ff993c605298a6453293bc1bc827334fb9d46d6030e01992808\",\n      \"0x000f731409fed7667e5d01e2cf9d8d0da96556bbb2fb7e3b3b8e1028dab70d62\",\n      \"0x6b610a565e82e7eef56d58e66867b32cbd09865d09d991d0835e24786757214e\",\n      \"0xd73a3a8609a8b46cf508d84e040e785ad3cb7cdbc63e18fdf72b4d663f5e0a5f\",\n      \"0xedcbfd0e6a5172e1f0639e9f7e45cdd0bfdc7d05f27cb517deeb17c382b97f6d\"\n    ],\n    \"rightHashes\": [\n      \"0x3c6710710882171f7a3b07172d7637cfbf385e46fcfe8560eb2822410c4eca8d\",\n      \"0x4b3e0a2b6e91e1b788833344c3a1ce8380a5f444156cd314727348fc740ca427\",\n      \"0x8cb377e84af2f9415442daf363253aad4624b4df6bb3f2ce6c5c56d3bcfb2c49\",\n      \"0xdae86492eda6c7ea786ca598c978dade5d0939f28e0fc90f77a0289e1a8628c0\",\n      \"0xdd8c18abd775815100d4999419a2a3a718efcc35f1ffcd150f0068f829ad634a\",\n      \"0x94f2dd188c291f98615941697f93e7c17ca97083993d6bf14a4e5376a3d0c1b0\",\n      \"0x19ce36b7f94c5158073e825d622a58b455f65bc167cc35a2f758cc6d0e21fafb\",\n      \"0x1d8eb78409c5c2699dea20d3b4090afeedf8c3bfd911f2a7b695234d24946ec6\",\n      \"0x9667094385f73adf330afe89f20ee16a1d63f718c17b34eba93e45dfd003deb5\"\n    ],\n    \"targetRootHash\": \"0xf34cf9b13d69ee9af5110841baf2a9b294ff13926d4f60e13222edaa7243de68\"\n  },\n  \"timestamp\": 10000000,\n  \"chainId\": \"8453\",\n  \"txHash\": \"0x842f3a5ac844ee222865cb03ea28c04f0eb65a4896b83d40c5cb4900cb7ffcc1\"\n}"
]
```

\
**Other Fields**

There is no need for **proofOfIssuance** or **dataIntegrityProof** (can be left blank) since everything is included in the message content already.

Everything else is customizable as-is.

**Full Example Attestation**

```json
{
    "updateHistory": [
        {
            "txHash": "",
            "block": "188097",
            "blockTimestamp": "1730123159671",
            "timestamp": "1730123162836"
        }
    ],
    "_docId": "009a55376a52b5df74e15f47397052b3abbf74aee60d8f7399357d566c35e56a",
    "_id": "5d044ba2f73444dd747cd11a",
    "createdBy": "bb1dpxqmz2h835lq88qulvytnq6mpu4x5ylwhmhh9",
    "messageFormat": "json",
    "attestationId": "009a55376a52b5df74e15f47397052b3abbf74aee60d8f7399357d566c35e56a",
    "inviteCode": "b969dd52bf7a9e8ce0811eb214e8249a88cff064b1e61221a3f4c1fda446e423",
    "scheme": "witness-proof",
    "dataIntegrityProof": {
        "signer": "",
        "signature": "",
        "publicKey": ""
    },
    "holders": [],
    "name": "dfgsdfg",
    "image": "ipfs://QmNytJNN44stkMndshtdfcCW2mzaCm6A23maiKaQvUqoj8",
    "description": "gfdsgxdfgsdf",
    "proofOfIssuance": {
        "signature": "",
        "signer": "",
        "message": ""
    },
    "anchors": [],
    "messages": [
        "{\n  \"preimage\": \"Testing witness proofs\",\n  \"proof\": {\n    \"leafIndex\": \"30800033\",\n    \"leafHash\": \"0x570751d4efee586ef4baa79c336778de08b019b69f182e68561ba2b44bce2d7c\",\n    \"leftHashes\": [\n      \"0xfd663a79b001aa5bcd55ce32aae934fc69281bc19b83f287236b572acaf57962\",\n      \"0x44b18b19f7da0a75ea66af7fa9cdd3e5f376749ff3c201beaa867abfbd99270d\",\n      \"0xb52cfafbe335afc9eb38b74b1b9186c5426807985b99ecc568c338ed22f6d739\",\n      \"0x027cd88daedfbbf04cea7abd17b70504bdfb56d27541e654f5762d44f06e3cce\",\n      \"0xa0f9df4a46928425bb01b40bca6ead558358c62f4b692392cc4e8c76fe2c1fb1\",\n      \"0x53a276dac9002ecb766cb865198e912baf114fd3c95079f19ef2d9abe3a078f4\",\n      \"0xe1af8f9e39e7b57a7eee0d3f47cf111a3291c29ce757d6d542aca8d590bb1013\",\n      \"0xf1250deb418ab6f57d4482e1243cd8aadd021afd546a18a0a067757a0ad6198d\",\n      \"0x1351fef7c4972ebb9ac5b0691c411cf40e1773fbb8168e664bb0b13cffcfa07d\",\n      \"0x2d7002b8f80a5ff993c605298a6453293bc1bc827334fb9d46d6030e01992808\",\n      \"0x000f731409fed7667e5d01e2cf9d8d0da96556bbb2fb7e3b3b8e1028dab70d62\",\n      \"0x6b610a565e82e7eef56d58e66867b32cbd09865d09d991d0835e24786757214e\",\n      \"0xd73a3a8609a8b46cf508d84e040e785ad3cb7cdbc63e18fdf72b4d663f5e0a5f\",\n      \"0xedcbfd0e6a5172e1f0639e9f7e45cdd0bfdc7d05f27cb517deeb17c382b97f6d\"\n    ],\n    \"rightHashes\": [\n      \"0x3c6710710882171f7a3b07172d7637cfbf385e46fcfe8560eb2822410c4eca8d\",\n      \"0x4b3e0a2b6e91e1b788833344c3a1ce8380a5f444156cd314727348fc740ca427\",\n      \"0x8cb377e84af2f9415442daf363253aad4624b4df6bb3f2ce6c5c56d3bcfb2c49\",\n      \"0xdae86492eda6c7ea786ca598c978dade5d0939f28e0fc90f77a0289e1a8628c0\",\n      \"0xdd8c18abd775815100d4999419a2a3a718efcc35f1ffcd150f0068f829ad634a\",\n      \"0x94f2dd188c291f98615941697f93e7c17ca97083993d6bf14a4e5376a3d0c1b0\",\n      \"0x19ce36b7f94c5158073e825d622a58b455f65bc167cc35a2f758cc6d0e21fafb\",\n      \"0x1d8eb78409c5c2699dea20d3b4090afeedf8c3bfd911f2a7b695234d24946ec6\",\n      \"0x9667094385f73adf330afe89f20ee16a1d63f718c17b34eba93e45dfd003deb5\"\n    ],\n    \"targetRootHash\": \"0xf34cf9b13d69ee9af5110841baf2a9b294ff13926d4f60e13222edaa7243de68\"\n  },\n  \"timestamp\": 10000000,\n  \"chainId\": \"8453\",\n  \"txHash\": \"0x842f3a5ac844ee222865cb03ea28c04f0eb65a4896b83d40c5cb4900cb7ffcc1\"\n}"
    ],
    "createdAt": "1730123162836",
    "originalProvider": "Witness"
}
```


## File: ./for-developers/core-concepts/verifiable-attestations/deriving-a-proof.md

# Deriving a Proof

### **Standard Signatures**

For standard proofs (scheme = 'standard'), selective disclosure is not possible / supported. Simply copy and paste the **dataIntegrityProof** from the attestation exactly as is. No **proofOfIssuance** is needed.

### Alternative Non-Native Approaches

For custom approaches, this is really left open-ended. You may use the **proofOfIssuance** or **dataIntegrityProof** or any part of the interface however you would like.

In alternative approaches like these, BitBadges is just the middleman, so schemas, well-formedness, and other verification is outsourced to the issuer and / or verifier.

### **BBS+ Proofs - Verifying Proof of Issuance**

An important aspect of verifying BBS+ attestations is to verify the link between the "main" issuer and the BBS+ public key. This is done with the **proofOfIssuance** provided. You should verify that the main issuer has given valid approval to use such an approval as issued by themselves. For BitBadges, we use the scheme of the following.

```typescript
'I approve the issuance of attestations signed with BBS+ a5159099a24a8993b5eb8e62d04f6309bbcf360ae03135d42a89b3d94cbc2bc678f68926373b9ded9b8b9a27348bc755177209bf2074caea9a007a6c121655cd4dda5a6618bfc9cb38052d32807c6d5288189913aa76f6d49844c3648d4e6167 as my own.\n\n';
```

We then verify that the signer of the proof of issuance matches the issuer (createdBy) and he key they approved is the BBS key used for the proof.

```typescript
const bbsSigner = body.proofOfIssuance.message.split(' ')[9];
if (bbsSigner !== body.dataIntegrityProof.signer) {
    throw new Error('Proof signer does not match proof of issuance');
}
const address = body.proofOfIssuance.signer;
const chain = getChainForAddress(address);

if (
    convertToBitBadgesAddress(address) !==
    convertToBitBadgesAddress(body.createdBy)
) {
    throw new Error('Signer does not match creator');
}

await getChainDriver(chain).verifySignature(
    address,
    body.proofOfIssuance.message,
    body.proofOfIssuance.signature,
    body.proofOfIssuance.publicKey
);
```

### **BBS+ Proofs - Creation and Verification**

For verifying BBS+ signatures, it is important to note whether you are verifying a derived proof or the original signature. This is determined by **dataIntegrityProof.isDerived.** Typically, we expect the **dataIntegrityProof.signature** to always be a derived proof when using the **iAttestationsProof** interface.

Note: A proof can only be derived from the original. You cannot derive a proof from another proof.

To create the proof from the original attestation, the following code can be used. **revealed** is he zero-based indices of the messages that are revealed (i.e. messages elem 0 is revealed = \[0])

We use a generic "nonce" as the nonce because we expect proofs to be verified using an alternative sign-in flow that handles replay attacks there / verification.

<pre class="language-typescript"><code class="lang-typescript">import { createAttestationsProof } from "bitbadgesjs-sdk";

const derivedProof = await createAttestationsProof({
<strong>  signature: Uint8Array.from(Buffer.from(attestation.dataIntegrityProof.signature, 'hex')),
</strong>  publicKey: Uint8Array.from(Buffer.from(attestation.dataIntegrityProof.signer, 'hex')),
  messages: attestation.messages.map((message) => Uint8Array.from(Buffer.from(message, 'utf-8'))),
  nonce: Uint8Array.from(Buffer.from('nonce', 'utf8')),
  revealed: attestation.messages
    .map((_, idx) => (proof.messages.includes(attestation.messages[idx]) ? idx : -1))
    .filter((x) => x !== -1)
});

setProof(
  new AttestationsProof({
    ...proof,
    dataIntegrityProof: {
      signature: Buffer.from(derivedProof).toString('hex'),
      signer: attestation.dataIntegrityProof.signer,
      isDerived: true
    }
  })
);
</code></pre>

To verify the original, you need all N messages and will use blsVerify. To verify a derived proof, you only need to know the messages used to derive the proof.

```typescript
import { BitBadgesApi, verifyAttestation } from 'bitbadgesjs-sdk';

//To outsource to server
await BitBadgesApi.verifyAttestation({ attestation });

//To do it locally
await verifyAttestation(attestation);
```


## File: ./for-developers/core-concepts/verifiable-attestations/design-considerations.md

# Design Considerations

Attestations are super open-ended with many different approaches with varying tradeoffs. Below, we outline some additional design considerations or things you may want to think of.&#x20;

## **Badges with Attestations**

Leveraging on-chain badges or tokens could be useful to you if you need stateful data, a ledger of activity, transferability requirements, and more. For example,

-   To "have the credential", you must prove ownership of the badge and the credential. This can be used in cases where the credential itself can be public and is to be displayed in a portfolio (BitBadges) but has certain aspects that may need to maintain private (attestations). The design also may enable credentials to be transferable.
-   Badges can also be used for on-chain, tamper-proof, decentralized revocation or suspension statuses. In the credential somewhere, you say that this badge must not be burned or revoken on-chain for it to be valid.

### Malicious Issuers

All attestations / credentials inherently get their credibility from the issuer, so there is already a bit of trust there. However, additional measures can be taken to protect against a malicious issuer. Some examples include:

-   On-chain ID -> data integrity maps to prevent issuer from issuing duplicates (each credential ID can only correspond to one credential)
-   Anchors / Data Commitments - The issuer or holder can commit to proof of knowledge on-chain at some point which can be verified later. This gives a verifiable timestamp for when the data was known by. See below for more info.

### Custom Logic

It is important to note that proof verification is not limited to that is provided in the interface, you will typically also need to check the attestation messages are as expected against other private values (e.g. matching attestation data to a user). A valid proof is not sufficient if the data is not as expected. This is application-specific, but we expect you to handle everything for proper verification.

### Replay Attacks

Signatures are static, always verifiable, and not "revokable". If a signature gets in a malicious parties' hands, the signature will still be valid. There are many things that can be done to help mitigate this:

-   Revocation registries
-   Authenticating the holder at verification time
-   And many more approaches

### On-Chain Anchors + Update History

While a cryptographic signature proves data integrity / proof of knowledge, you may also need to verify knowledge or integrity with timestamps. For this, consider creating on-chain anchor transactions which can be used for such purposes. Anchors do not necessarily have to reveal private information. Posting a hash, encryption, etc is sufficient as long as it can prove what you need it to prove.

For BitBadges, anchors are facilitated through the x/anchor module (MsgAddCustomData). It is a very simple module that allows you to store arbitrary strings.

If an anchor is created through the BitBadges site, we use the following algorithm. If we have N attestation messages, we also have N entropies. We can then post the SHA256 hash of (message + entropy) on-chain. When revealed to a verifier in a proof, they can verify that data integrity has been maintained if they have the palintext message + entropy value. The random hash posted on-chain reveals nothing confidential but provides a verifiable timestamp for the data. This is facilitated through the x/anchor module's MsgAddCustomData.

```typescript
{
    type: 'MsgAddCustomData',
    msg: {
      data: JSON.stringify(
        attestation.messages.map((message, idx) => {
          return CryptoJS.SHA256(message + entropies[idx]).toString();
        })
      )
    }
}
```

Update history is also maintained by BItBadges in a centralized manner, but anchors could be useful to provide additional information to verifiers about when the data changed, verifiable timestamps, etc.

Other approaches like WITNESS proofs and many others are available. These just need to go on a trusted blockchain (not necessarily BitBadges blockchain).


## File: ./for-developers/core-concepts/verifiable-attestations/overview.md

# Overview

An attestation represents claims about a subject. They can come in many different forms (signatures, BBS, simple URLs) as long as they are verifiable. Each scheme can offer varying tradeoffs. We support a couple natively while also allowing you to custom upload your attestation.

Currently, our core suite supports two approaches. Both are cryptographically signed, and thus, data integrity is maintained. These are stored off-chain (centralized) but can be anchored or posted on-chain if desired.

* BBS+: Messages are signed with the BBS+ signature scheme and a proof of issuance is linked with another proof message signature. BBS+ signatures allow for zero-knowledge selective disclosure (reveal only M of N messages).&#x20;
  * The BBS+ signature algorithm allows an issuer to sign N messages to produce a signature. From that signature, a holder can derive a cryptographic proof that only reveals any subset of the N messages. This allows selectvie disclosure of the credential. For example, you may only want to reveal your GPA to an employer, but the diploma credential has other identifying fields like courses taken, student records, etc.
  * To create the link between a "main" crypto address and the BBS+ public key, we sign a message from the main address saying that attestations from BBS+ key can be treated as my own.
* Standard Signatures: Messages are signed via any supported wallet / ecosystem (Bitcoin, Ethereum, Solana, Cosmos). These do not support selective disclosure.

To get started, simply create an attestation in-site.

<figure><img src="../../../.gitbook/assets/image (134).png" alt="" width="375"><figcaption></figcaption></figure>


## File: ./for-developers/core-concepts/verifiable-attestations/proofs-vs-attestations.md

# Proofs vs Attestations

Attestations are the original document from which different proofs can be derived from, depending on the selected scheme. For example, for BBS signatures, you can selectively reveal M of N messages.

```
Proofs are a derivation from the core attestation with a few changes.
```

Proofs follow a very similar interface plus/minus a few fields, but proofs may change the following details, depending on the implementation:

* May have different metadata or visibility properties
* Can selectively disclose certain information but not others (for approaches that support selective disclosure).

There are user interfaces for handling this all on the frontend. However, below, we go into detail for how you can do it yourself. Check out [https://bitbadges.io/attestations/proofgen](https://bitbadges.io/attestations/proofgen) for a helper tool for generating BBS+ signatures.

Most notably, for BBS derived proofs, the dataIntegrityProof.isDerived will be true.

```typescript
export interface iAttestationsProof<T extends NumberType> {
    createdBy: string;
    scheme: 'bbs' | 'standard' | string;
    originalProvider: string;

    messages: string[];

    dataIntegrityProof: {
        signature: string;
        signer: string;
        publicKey?: string;
    };

    proofOfIssuance: {
        message: string;
        signer: string;
        signature: string;
        publicKey?: string;
    };

    name: string;
    image: string;
    description: string;

    entropies?: string[];
    updateHistory?: iUpdateHistory<T>[];
    anchors?: {
        txHash?: string;
        message?: string;
    }[];
}
```


## File: ./for-developers/create-and-broadcast-txs/cosmos-sdk-msgs/msgcreateaddressmappings.md

# MsgCreateAddressLists

To create an on-chain AddressList, you can use the MsgCreateAddressLists. See [here](../../core-concepts/address-lists-lists.md) to learn more about AddressLists.

Reminder: on-chain address lists are immutable, permanent. and non-deletable.

```typescript
export interface MsgCreateAddressLists {
  creator: string;
  addressLists: AddressList[];
}
```

```typescript
export interface AddressList {
  listId: string;

  addresses: string[];
  whitelist: boolean;

  uri: string; 
  customData: string;
}
```



**Combining with MsgCreateCollection or MsgUpdateCollection**

Oftentimes, you want to create a new AddressList, so it can be used in a MsgCreateCollection or MsgUpdateCollection (for example, defining transferability using a new, custom list ID).

Before an AddressList can be used, it needs to be defined on-chain. The two Msgs can be easily combined in the same transaction (as Cosmos transactions support multiple Msgs). See [here](../../bitbadges-sdk/common-snippets/creating-signing-and-broadcasting-txs.md) for an example of how to do it with the SDK. Just make sure MsgCreateAddressLists is executed first and precedes when it is actually used.

```typescript
const msgs: MessageGenerated[] = [];
msgs.push(...bootstrapLists().map(x => createProtoMsg(x))); //MsgCreateAddressLists
msgs.push(...bootstrapCollections().map(x => createProtoMsg(x))) //MsgCreateCollections

//Note how MsgCreateAddressLists is first in the array
const txn = createTransactionPayload(txContext, msgs);
```



## File: ./for-developers/getting-started.md

# 🚴‍♂️ Getting Started

> **Need help?** Join our Discord for support from the BitBadges team and community developers.
>
> **Need $BADGE credits?** Contact us on Discord - we offer subsidized credits for developers during beta!
>
> **No-Code / In-Site Solutions** Check out the [Create tab](https://bitbadges.io/create) or the [developer portal](https://bitbadges.io/developer) first to see what all is possible. Most of the time, you can just do everything with no code directly in-site! No need for any direct integration. Let us handle everything!
>
> Get creative. You can gate URLs, Discords, and integrate with many of your favorite tools without a single line of code!
>
> **Video Tutorial Series** Check out our three intro to development video tutorial courses ([Intro to BitBadges](https://www.udemy.com/course/multichain-dapps/learn/), [The BitBadges Token Standard](https://www.udemy.com/course/multichain/learn/lecture/46271653#overview), and [Developing MultiChain Applications](https://www.udemy.com/course/crosschain-dapps/learn/lecture/46271733#overview)).

## Explore First, Read Later

We strongly recommend, if you have not already, to explore the claim tester and other creation options in-site. Many of your questions should be answered by the interface and is much easier to understand than a bunch of long text here in this documentation. Just go explore and experiment first.

Most of your setup and management (and oftentimes all) will be done directly in-site via the developer portal or Create tab. Get started at [https://bitbadges.io/create](https://bitbadges.io/create).&#x20;

## Gate Any Service In 2 Steps

Any service can be gated by ANY criteria simply in just 2 steps.

1. **Authenticate** - We recommend Sign In with BitBadges but it could be any approach

{% content-ref url="authenticating-with-bitbadges/" %}
[authenticating-with-bitbadges](authenticating-with-bitbadges/)
{% endcontent-ref %}

2. **Verify Claim Success** - Check the user satisfies a BitBadges claim (via post-success hooks, API, many ways!)

Claims are the universal connectors. Claim criteria can be anything from a payment to badge ownership to Discord servers. Implement it any way you want (including custom logic) at [https://bitbadges.io/create](https://bitbadges.io/create)!

## Quick Start - Claims

This includes documentation everything from custom plugins to Zapier to dynamic stores and mroe

{% content-ref url="../overview/claim-builder/" %}
[claim-builder](../overview/claim-builder/)
{% endcontent-ref %}

## Quick Start - API

{% content-ref url="bitbadges-api/" %}
[bitbadges-api](bitbadges-api/)
{% endcontent-ref %}

{% content-ref url="bitbadges-sdk/" %}
[bitbadges-sdk](bitbadges-sdk/)
{% endcontent-ref %}

{% content-ref url="authenticating-with-bitbadges/" %}
[authenticating-with-bitbadges](authenticating-with-bitbadges/)
{% endcontent-ref %}

```bash
npm i bitbadgesjs-sdk
```

```ts
import { BitBadgesAPI } from 'bitbadgesjs-sdk';

const api = new BitBadgesAPI({
  ...YOUR_CONFIG_AND_API_KEY
});

await BitBadgesAPI.getCollection(...);
```

Try our interactive quickstart demo: [BitBadges Quickstart](https://bitbadges.io/quickstart). If that is what you need, clone it: [BitBadges Quickstart Repository](https://github.com/BitBadges/bitbadges-quickstart). Or, see out [Auth.js/Next.js Template](https://github.com/BitBadges/bitbadges-authjs-example).


## File: ./for-developers/sign-in-with-bitbadges/approaches/redirected-callback.md

# Redirect Callback

The standard OAuth callback approach is used for immediate authentication. To enable callbacks, the parameters must have a redirect URI set that matches your app's configured one. With the callback, the user will never even see the code. Everything is handled behind the scenes immediately.

**How do callbacks work?**

A high-level overview is:

1. Users navigate to the custom SIWBB URL for your authentication request.
2. The user will be walked through the authentication process. Upon completion, an authorization code is transmitted to the redirect URI via the query parameters `code` and `state`.
3. The redirect URI can then fetch the details from the API using the transmitted code with knowledge of the configured app's client secret.

**Generating the URL**

The important part here is to correctly specify a valid **redirectUri** letting us know that you expect to receive the details immeditately.

{% content-ref url="../../authenticating-with-bitbadges/authentication-url-+-parameters/generating-the-url.md" %}
[generating-the-url.md](../../authenticating-with-bitbadges/authentication-url-+-parameters/generating-the-url.md)
{% endcontent-ref %}

**Implementation - Backend**

```typescript
// GET /api/callback?code=...&state=...
const callbackHandler = async (req: NextApiRequest, res: NextApiResponse) => {
    //Parse the code and state from the query parameters
    const code = req.query.code;
    const state = req.query.state as string;

    //TODO: Fetch authentication details (see Verification page)
    //      const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({ code, ... });
    //TODO: Any application specific requirements

    //Learn more in the verification steps
};
```

At your redirect URI, you will need to set up a handler to handle the code / state that is passed. The code and state will be passed in via the HTTP query parameters. This follows typical OAuth2 flow. We refer you to OAuth tutorials for more details.

To ensure the security of the data exchange process, consider the following practices:

* Validate the `state` parameter according to your requirements (if applicable)
* Use HTTPS to protect the data in transit, ensuring that all communications between your server and the client are encrypted.


## File: ./for-developers/sign-in-with-bitbadges/overview.md

# Overview

Sign In with BitBadges (SIWBB) is a unified multi-chain authentication solution that works across all blockchain ecosystems. It replaces traditional "Sign In with X" buttons and can be configured to handle the following all in one flow:

* Multi-chain authentication
* Verification of attestation signatures
* Badge ownership verification
* Integration with 7000+ supported apps and plugins
* BitBadges API scope authorizations

Outsource the heavy lifting of authentication to us, allowing you to focus on your core utility. We aim to provide maximum flexibility in the design process.

#### OAuth Endpoints

* **Authorization:** `https://bitbadges.io/siwbb/authorize?your_params`
* **Token:** `https://api.bitbadges.io/api/v0/siwbb/token`
* **Revoke:** `https://api.bitbadges.io/api/v0/siwbb/token/revoke`&#x20;

[**Demo**](https://bitbadges.io/siwbb/authorize?expectAttestations=true\&client_id=example-client-id\&redirect_uri=https://example.com&)

<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (180).png" alt=""><figcaption></figcaption></figure>

## Implementation Flow

1. **Authentication- BitBadges Side**
   * User accesses BitBadges URL (direct or popup)
   * Proves address ownership and other criteria (badges, attestations, etc.)
   * Receives authorization code from BitBadges (QR or behind the scenes via redirect)
2. **Integration- Your App Side**
   * Receive authentication response
   * Check criteria on your end
   * Implements security measures (prevent replay attacks, etc.)
   * Focus on your core utility

## Getting Started

Check out our [BitBadges quickstart repo](https://github.com/BitBadges/bitbadges-quickstart) for a complete implementation example and reference code.

Note: SIWBB is fully OAuth 2.0 compatible and works with standard OAuth frameworks and tools.

**Hybrid No Wallet dApps**

Sign In with BitBadges is unique because it allows you to build hybrid dApps, as we term them. Hybrid dApps outsource ALL of the wallet connection, signing, authentication to us. You have no need to implement anything wallet-related on your app side if not needed.

However, if your app already uses wallets, you can still use SIWBB.  The flow is the exact same, and as the user navigates to the SIWBB page, the user's wallet should auto-connect, resulting in a seamless experience.


## File: ./for-developers/sign-in-with-bitbadges/setting-up-an-app.md

# Setting Up an App

### App Registration

* Register at [https://btibadges.io/developer](https://btibadges.io/developer) -> OAuth Apps
* Take note of your client ID / secret

### Key Components

#### 1. Client ID

* Unique identifier for your app
* Assigned upon registration

#### 2. Client Secret

* Cryptographic key for API authentication
* Keep confidential; never expose in client-side code. Treat like a password.
* Required to fetch user authentication details

#### 3. Redirect URIs

* Endpoints where users are redirected after authentication
* Must be pre-registered and use HTTPS
* Not needed for delayed/QR code authentication. Only for immediate digital redirects.

### Security Notes

* Treat client secret as securely as a password
* Ensure exact match between registered and used redirect URIs (if applicable)
* Use HTTPS for all redirects for security reasons


## File: ./overview/claim-builder/README.md

# 🏗️ BitBadges Claims



## File: ./overview/comparing-bitbadges-to-other-protocols.md

# ⚖️ BitBadges L1 vs Others

## Comparing BitBadges L1 to Other Protocols

BitBadges is a unique L1 (Layer 1) blockchain built using the Cosmos SDK that aims to simplify the multi-chain experience. The BitBadges token (badge) standard is not EVM-compatible, ERC-20 compatible, or Bitcoin Ordinals compatible. Instead, we offers our own flexible, ever-evolving token standard, making it easier to build multi-chain applications. This is because it is compatible with ANY wallet from ANY chain, all with ONE interface.

While BitBadges may lack some of the native smart contract support and interoperability features of other protocols, its self-contained design and API-like token standard can be a compelling solution for certain use cases.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Chain Architecture

BitBadges is its own L1 blockchain, not a layer-2 or sidechain solution. It is built using the Cosmos SDK, which gives it flexibility and scalability. It also connects to the IBC ecosystem and all other Cosmos features.

Protocols like Bitcoin Oracles, Ethereum NFTs, and Solana NFTs are all deployed on their respective chain and not compatible with each other. If you wanted to implement a token-gated application for all those chains, you would need to issue tokens on every chain. With BitBadges, it is one token in one place for all users from any chain.

### Security Model

Yes, BitBadges may not be as secure or decentralized (yet) as some other protocols. It is its own L1, and over time, we will only get more decentralized and secure. However, we actually envision BitBadges being a flexible part of any application stack and used where needed rather than an all encompassing solution.

For example, when building an application, you may use BitBadges for authentication / website gating but still accept payments in your native or preferred currency.

### Cross-Chain Interoperability

BitBadges is not interoperable in the traditional sense, as it is a self-contained L1 blockchain. BitBadges does not "pull" or "connect" data from other chains. All relevant data is stored on the BitBadges chain, simplifying application development.

However, it supports users and wallets from any chain, allowing for easy multi-chain token transfers and multi-chain application development (e.g. Ethereum users can transfer badges to Solana users to Bitcoin users). For example, Bitcoin users can sign BitBadges transactions with their Bitcoin wallets.

### Token Standard

BitBadges offers its own token standard built from the ground up that functions more like an API where everything is already implemented natively, and you just customize the requests (as Cosmos SDK Msgs) behind the scenes. This is how the BitBadges site is all no-code by default.

This approach vastly differs to existing ones requiring an individual smart contract for all tokens. Protocols like Ethereum rely on ERC-20 tokens, which require individual smart contract deployments and management. This approach gets complex, vulnerable to security flaws, and does not support the required structure.

### Smart Contract Support

While BitBadges does not natively support EVM or ERC-20 contracts, it does support CosmWASM contracts, allowing for the extension of functionality and the creation of dApps. However, our goal is to keep evolving our token standard so that no custom contracts are EVER needed.

Protocols like Ethereum and Solana have robust smart contract support, enabling a wide range of decentralized applications.


## File: ./overview/contributing.md

# 👨💻 Contributing

Everything is open-sourced and can be found at [https://github.com/bitbadges](https://github.com/bitbadges). Contributions to the core source code are greatly appreciated.&#x20;

Additionally, you can contribute by building on top of BitBadges. This can be anything from a dApp (decentralized application) to a developer tool to your own frontend for badges! If you do, reach out to us, so we can add it to [Ecosystem](ecosystem.md).

**Rewarding Developers**

In the future, we plan to host hackathons, bug bounties, and setup a developer funding pool where developers are rewarded for contributing and building with BitBadges.

**Improvement Proposals**

The official BitBadges improvement proposals repository can be found at [https://github.com/BitBadges/BBIPs](https://github.com/BitBadges/BBIPs).&#x20;

**Bug Bounties**

TBD

**Bounties**

Below are some ideas for community distribution and verification tools that need to be built, and we are willing to provide compensation for. Reach out if interested

Discord Badge-Gating - Gate servers, channels, etc to only specific badge holders

Discord / Twitter Bot - Bot that posts for every badge mint, transfer, etc

Privacy-Preserving / ZK Verification - Given an address list or list of balances, enable a user to prove that they own the badge without revealing their usernames.



Let us know if you have another idea and how we can help.


## File: ./overview/ecosystem.md

# 🌴 Ecosystem



## File: ./overview/ecosystem/README.md

# 🌴 Ecosystem



## File: ./overview/ecosystem/blockin.md

# Blockin

{% content-ref url="https://app.gitbook.com/o/7VSYQvtb1QtdWFsEGoUn/s/AwjdYgEsUkK9cCca5DiU/" %}
[Blockin](https://app.gitbook.com/o/7VSYQvtb1QtdWFsEGoUn/s/AwjdYgEsUkK9cCca5DiU/)
{% endcontent-ref %}


## File: ./overview/ecosystem/chrome-extension.md

# Browser Extensions

The BitBadges browser extension provides a quick preview of a user's badges and portfolio directly via the extension popup, meaning you never have to leave the site you are currently on. You can add custom requirements as seen below which check for ownership of a custom set of requirements that you want to check.

Note: Chrome should have full settings functionality, but others may be limited.

**Chrome**

Install Link: [https://chromewebstore.google.com/detail/bitbadges-chrome-extensio/ocdlkggomnifibfadgaakkilojelgacj?authuser=0\&hl=en](https://chromewebstore.google.com/detail/bitbadges-chrome-extensio/ocdlkggomnifibfadgaakkilojelgacj?authuser=0\&hl=en)

Settings Page: [https://bitbadges.io/chrome-extension](https://bitbadges.io/chrome-extension)

**Edge**

Install Link: [https://microsoftedge.microsoft.com/addons/detail/bitbadges-extension/llcengdgmhalkamkhkoaeoaelghblfij](https://microsoftedge.microsoft.com/addons/detail/bitbadges-extension/llcengdgmhalkamkhkoaeoaelghblfij)

**Firefox**

Install Link: [https://addons.mozilla.org/en-US/firefox/addon/bitbadges-extension/](https://addons.mozilla.org/en-US/firefox/addon/bitbadges-extension/)

**Opera**

Coming Soon...



<figure><img src="../../.gitbook/assets/image (109).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/ecosystem/linkedin-certifications.md

# LinkedIn Certifications

Easily add badges, lists, or attestations to your LinkedIn certtfications with one click!

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/ecosystem/metamask-snap.md

# MetaMask Snap

BitBadges has created a MetaMask Snap extension to help guard your wallet and automatically check badge / asset ownership for addresses in your transactions and signatures.

**Installation:** [https://snaps.metamask.io/snap/npm/bitbadges-snap/](https://snaps.metamask.io/snap/npm/bitbadges-snap/)

**Configure Settings:** [https://bitbadges.io/snap](https://bitbadges.io/snap)

<figure><img src="../../.gitbook/assets/image (94).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/ecosystem/wordpress-plugin.md

# WordPress Plugin

{% content-ref url="../../for-developers/authenticating-with-bitbadges/framework-templates/wordpress.md" %}
[wordpress.md](../../for-developers/authenticating-with-bitbadges/framework-templates/wordpress.md)
{% endcontent-ref %}


## File: ./overview/faq.md

# ❓ FAQ

### **Badge vs $BADGE?**

Whenever we say **$BADGE**, we are referring to the BitBadges blockchain gas credit system used for paying transaction fees. This is the in-app compute credits system. All transactions on the BitBadges blockchain require $BADGE to be paid as a fee. This is not to be confused with badges / badge collections.

### **Main use case for BitBadges?**

The main use case we envision is authentication. Almost all existing products today require some sort authentication, digital tokens, or token-gating (e.g. tiered services) in their backend infrastructure. And oftentimes, this infrastructure costs millions of dollars and utilizes thousands of hours in maintenance, especially if using a centralized service. With BitBadges, all authentication and token-gating can be **outsourced** to **greatly** reduce maintenance, overhead, and cost, as well as improving security, verifiability, availability, and much more.

### **Are there plans to support digital collectibles (tokens with value) rather than just badges?**

We want to focus on badges and leave "valuable" tokens to each respective blockchain ecosystem. We want BitBadges to be a hub for achievements, reputation, authentication, etc, not a place for buying, selling, and speculating. That is why $BADGE should be treated as an in-app credits system, not a financial asset.

### **Are smart contracts needed?**

No, badges do not require smart contracts and are no-code by default! All badges follow the same state-of-the-art interface with lots of functionality supported. Although, you can create a smart contract to add custom functionality not already implemented.

### **Is BitBadges an L1 blockchain or an L2?**

BitBadges is its own Layer-1 blockchain built with Cosmos SDK. We also offer many off-chain services built on top of the blockchain as well.

### **Why the registry architecture over unique smart contracts for every collection?**

Typical NFTs and digital tokens (ERC721, ERC20) all require their own unique smart contracts to be implemented which follow their respective interface. However, BitBadges is not built like this. BitBadges uses a single registry and the same code is reused for all collections.

We do this for multiple reasons:

1. Security: The same code is being reused and over time, it will become more battle-tested and more secure. This is as opposed to unique smart contracts that can often have vulnerabilities, as seen with the large amount of hacks occurring in the Ethereum ecosystem.
2. Scalability: Since duplicate code doesn't need to be deployed, this solution is much more scalable.
3. Consistency: This provides a much cleaner and more consistent interface for querying, indexing, and maintenance.

Yes, this may sacrifice a little customizability, but we allow you to extend the interface and implement any custom logic required with smart contracts, if necessary. We believe the pros vastly (security, scalability, and ease of use) vastly outweigh the cons.

### **Are badges ERC-721 compatible?**

While our token standard takes inspiration from existing standards like ERC-721, our token standard has its own properties and architecture.

Our default metadata standard (what is used on the BitBadges website) does extend the ERC-721 metadata standard, so metadata should be compatible.

### **Are there plans to make an ERC for our standard?**

Although, we are not opposed to publishing our interface as a standard for other blockchain ecosystems (e.g. EIP/ERC for Ethereum), we do not have any plans currently to do so currently.

This is for a couple reasons. Firstly, our token standard is ever-evolving, so it doesn't make sense to freeze it to a permanent interface. Secondly, this would limit the standard to one ecosystem, where a main pillar of BitBadges is to be multi-chain and span across multiple blockchain ecosystems.

Feel free to use novel concepts from BitBadges in your authored improvement proposals though, as long as BitBadges is cited and co-authors (contact us).

Once development is BitBadges is complete and final, we would like to make the standard official and immutable, but we are a long ways from development being complete :)

### **What happens if there is convergence to a single blockchain?**

Personally, we believe it will always be a multi-chain world, and there will never be 100% convergence to a single ecosystem. Even if one blockchain ecosystem like Ethereum (EVM) becomes dominant, there will always be new blockchain experiments and ecosystems popping up, which means there will always be a need for multi-chain infrastructure like BitBadges.


## File: ./overview/getting-started.md

# 🔨 Getting Started

BitBadges is proud to offer no-code / low-code flows for all our major services. Simply navigate to the Create tab in-site, and get started creating badges, attestations, claims, address lists, explore listings, applications, and more! The site should walk you through the entire process, and refer to the documentation where needed. Please reach out in Discord if you are having trouble, have feedback, or have feature requests.

Claims are the universal connectors. Gate anything with any criteria. For example:

1. Create your badge and create badge-gated claims to implement badge-gated utility
2. Award points and create points-gated claims&#x20;
3. Or, just create standalone claims

<figure><img src="../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/how-do-i-check-xyz.md

# 💻 How Do I Check...?

On the criteria side, you can check any criteria. This is all configured in your claim builder via plugins! Get started in the Developer Portal.

Plenty of in-site plugins are available, but you can always bring your own logic. Explore the claim builder and the rest of this documentation for more information.

```
Any service can be gated by any criteria with a claim
```

{% content-ref url="claim-builder/" %}
[claim-builder](claim-builder/)
{% endcontent-ref %}

<figure><img src="../.gitbook/assets/image (224).png" alt=""><figcaption></figcaption></figure>

## Checking BitBadges Services - Badge Ownership, Points, List Membership

Configure your claim with in-site plugins for each respective service. Check badge ownership with the Badge Requirements plugin. Check points with the Points checker plugin. And so on. These are all supported for on-demand claims too.

<figure><img src="../.gitbook/assets/Screenshot 2025-03-17 at 8.47.22 AM.png" alt=""><figcaption></figcaption></figure>

## Claim Codes / Passwords

Configure the claim to check for one-time use only claim codes or secret passwords the user must provide. This is a universal option that can be used for any use case. No need for a specific integration or identifying a user specifically. Simply hand out the claim codes and let them claim.



<figure><img src="../.gitbook/assets/Screenshot 2025-03-17 at 8.46.31 AM.png" alt=""><figcaption></figcaption></figure>

## Receiving Attestations

Configure a custom webhook or plugin to request user attestations stored in their account.

## Checking Payments

Use the Stripe Payment plugin to gate claims to those who have paid.



<figure><img src="../.gitbook/assets/Screenshot 2025-03-17 at 8.45.49 AM.png" alt=""><figcaption></figcaption></figure>

## Gating by Address, Username, or Email List

Configure the corresponding plugin to check if the claiming user is on the list. Lists can be static (just copy and paste them into the plugin itself) or dynamic (see dynamic stores below).

<figure><img src="../.gitbook/assets/Screenshot 2025-03-17 at 8.48.22 AM.png" alt=""><figcaption></figcaption></figure>



## Dynamic Stores

Dynamic stores are a powerful option for gating by address, username, or email. These are standalone stores managed by you, stored by us. You control who is in the store's list via the site, Zapier Zaps, or custom API calls. It is completely flexible! You can then attach your store to your claim and check that in real-time.

<figure><img src="../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

## Check Your Own Criteria

If you want to custom check criteria, configure your own custom plugin (publishable and reusable) or a webhook where you can receive user inputs, attestations, social identifiers, and more! Or, you can also auto-complete claims on behalf of users with the API or Zapier.


## File: ./overview/how-do-i-gate-xyz.md

# 🔐 How Do I Gate...?

BitBadges provides flexible ways to gate (restrict access to) various types of content and utilities. Explore the claim builder and the rest of this documentation for more information.

Even if you create a badge, list, or other item, you will eventually create a badge-gated claim (separate), for example, to gate your app or service.

```
Any service can be gated by any criteria with a claim
```

{% content-ref url="claim-builder/" %}
[claim-builder](claim-builder/)
{% endcontent-ref %}

## Gating a URL / Content

The simplest way to gate a static URL or content is to use BitBadges' built-in URL gating feature. This can be found in the rewards tab when creating a claim. Users will need to successfully complete the claim process to view the URL. This is perfect for:

* Private Discord invites
* Google Doc/Drive links
* File downloads
* Software downloads
* Exclusive website access
* Event registration links
* And more!

**Pro Tip**: For additional security, consider using one-time-use URLs, dynamic variables, or implementing additional verification on your destination website. The gated URL can also be a Sign In with BitBadges URL with eventual redirect to your service to provide seamless authentication.



<figure><img src="../.gitbook/assets/Screenshot 2025-03-16 at 3.49.12 PM.png" alt=""><figcaption></figcaption></figure>

## Gating a Discord, Telegram, Slack Channel

You can also configure your claim to auto implement utility for you with no-code. For example, assign a Discord role to users who successfully claim. This is a powerful tool because then you can create gated channels and offer further gated experiences however you see fit!

<figure><img src="../.gitbook/assets/image (202).png" alt=""><figcaption></figcaption></figure>

## Trigger a Zapier Zap -> 7000 No-Code Integrations

Configure your claim to send a post-success webhook to a Zapier Zap. This allows you to implement rewards from over 7000+ apps in no-code. This is great for services like newsletters, custom services, and much more! If you need a more programmatic solution, you can collect this same data via [Zapier](https://zapier.com/apps/bitbadges/integrations).

<figure><img src="../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

## Custom Forms, Webhooks, Plugins

Use the Forms plugin, custom webhooks, and custom plugins to collect user inputs (including attestations), social identifiers, and more. This allows you to maintain or create a list of users who you want to offer your gated utility too (e.g. send invites to the emails you collect).



<figure><img src="../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

## Gating a WordPress Site

Use the BitBadges WordPress plugin to create sites gated by Sign In with BitBadges. Specify your claim you want to check in the settings, and you instantly have a multi-chain site gated by any criteria you want.



<figure><img src="../.gitbook/assets/Screenshot 2025-03-16 at 3.55.10 PM.png" alt=""><figcaption></figcaption></figure>

## Sign In with BitBadges - Digital Services

Use Sign In with BitBadges to implement your own gated website or any digital service. Authenticate and check claim successes to make your website gated by anything you want.

<pre class="language-typescript"><code class="lang-typescript"><strong>// 1. Authenticate the address (Sign In with BitBadges is recommended but not mandatory)
</strong>// 2. Check claim success
const res = await BitBadgesApi.checkClaimSuccess(claimId, address);
</code></pre>

## Sign In with BitBadges QR Codes - In-Person Services

Use the QR code feature of Sign In with BitBadges to gate any in-person service. Users generate a QR code and present it at authentication time.



<figure><img src="../.gitbook/assets/Screenshot 2025-03-16 at 3.56.12 PM.png" alt=""><figcaption></figcaption></figure>


## File: ./overview/how-it-works/verifiable-secrets.md

# Verifiable Attestations

**Off-Chain Attestations and On-Chain Anchoring**

Besides traditional on-chain badges, BitBadges supports the storage of off-chain verifiable attestations. These can be any form of data that is secured by a signature, such as credentials or attestations. The flexibility to store data off-chain while still having the option to anchor it on-chain for verification purposes is often useful for use cases that have privacy and security requirements. Attestations are just signatures of one or more message using a crypto wallet.

BitBadges offers a centralized, easy to use solution for attestations with many neat features. The centralized part just comes from the fact that BitBadges stores the signatures for you. If you would like to self-host, you can for a decentralized experience.

Some of the neat features include:

-   **Integration into Authentication Flows:** Attestations can be used to prove certain criteria to authentication providers. If you can prove you meet the criteria via a attestation, you will be authenticated. This can be integrated into the Sign In with BitBadges flow, so for example, you can prove public ownership of a diploma badge whilst also verifying attestation data such as a users' GPA.
-   **Anchoring:** Anchoring credentials on-chain provides a transparent and verifiable record of issuance, enhancing the trustworthiness and integrity of the credential without compromising the holder's privacy. The blockchain can be used for proof of knowledge of a attestation at a certain time or to maintain data integrity.

**Issuance and Storage**

The credential issuance process begins when an issuer (for example, a university) signs a piece of private data (such as a student’s diploma) and transfers this signed data, along with the credential, to a recipient (the student). This action gives the holder concrete proof of their credential, which they can then present to any verifier. The system also ensures that verifiers receive cryptographic assurance of the data's authenticity.

A distinctive feature of BitBadges is the ability for issuers to **selectively disclose** information. This means they can prove claims (like a GPA above 3.0) without disclosing any additional personal information that's irrelevant to the verifier's needs.

For data integrity and verification purposes, credentials are signed and stored off-chain in the holder's BitBadges account. Issuers have the option to anchor these credentials on-chain to commit to the data publicly and verify its issuance time, although this step is optional and not always necessary.


## File: ./overview/launch-phases.md

# 🪙 Launch Phases

BitBadges plans to execute a two-phased launch:

### **Phase 1: Betanet**

Betanet is the initial phase of BitBadges upon launch. This is a phase where we plan to ship fast, gain feedback quickly, and iron out all bugs as quickly as possible in order to build the best product for you long term.

To allow us to do so, there will be no governance decisions, and all in-app credits will be purchasable via a faucet-like system (explained below).

### **Phase 2: Official Mainnet**

Once betanet is concluded and we feel ready, we will officially deploy a mainnet version of BitBadges. Everything will carry over.

In mainnet, we will look to decentralize further, operate under a governance model, and see out our vision as a fully decentralized and indestructible protocol. Time of this phase is TBD but most likely, this will be started when the betanet faucet runs out.

We will also look to migrate to being fully open-source where possible.

## **Credits ($BADGE vs $STAKE)**

$BADGE is the in-app compute credits system we use for blockchain transaction fees, such as creating or transferring badges. All transactions will require a fee of some number of credits.&#x20;

$STAKE is used by nodes to secure the network. BitBadges operates under a proof-of-stake consensus model using $STAKE. Once mainnet phase launches, we also plan for $STAKE to be used in governance decision votes.&#x20;

IMPORTANT: $BADGE and $STAKE are NOT to be speculated upon and are NOT financial assets. It is a system which is intended for purchase and usage as in-app compute credits, not trading, exchanging, etc.

## **$BADGE**

**Total Supply: 100,000,000**

**Inflation: None**

**Initial Airdrops**

We plan to airdrop the first 10,000,000 of the credits supply completely free of charge to select users. Please reach out to us on Discord if you or your community are interested in building with BitBadges and would like some free credits to get started.&#x20;

Airdrops Planned

* 10 $BADGE for first 100k users on the site (claimable any transaction page on site like the mint page)
* 100 $BADGE to developers who want to build on top of BitBadges (up to 5000 developers)

**Faucet: Remaining Supply**

The rest of the supply is simply up for purchase via the BitBadges site. BitBadges reserves the right to dynamically increase / decrease price according to demand. It will begin at $1 per credit.

## **$STAKE**

**Initial Supply: 100,000,000**

**Inflation: 7-20% (Set at 13%)**&#x20;

$STAKE will inflate at rate of 7-20% per year. Learn more about how this works [here](https://docs.cosmos.network/main/build/modules/mint). This serves as an incentive for nodes to put their stake to work and secure the network and earn more.

**Allocation**

Reach out to us in DIscord if you are interested in running a node. $STAKE will be distributed (while supplys last) to the first \~100 who complete a quick application process. This is to ensure the quality of node operators in our ecosystem.


## File: ./overview/learn/README.md

# 👨‍💻 Learn the Basics



## File: ./overview/learn/accounts.md

# Multi-Chain Accounts

### **How is BitBadges able to support addresses from different blockchains?**

To enable interoperability between different blockchains, BitBadges is signature compatible with all of its supported chains (Bitcoin, Ethereum, Solana, and Cosmos).

Signature compatibility means that users from any of the above blockchain ecosystems are able to sign BitBadges transactions, and we simply verify the signatures on our blockchain.

BitBadges is compatible with the wallets of each ecosystem. However, BitBadges is its own blockchain and does not pull any data from or is interoperable with any other blockchain. Everything is confined to the BitBadges blockchain.

<figure><img src="../../.gitbook/assets/image (34).png" alt=""><figcaption></figcaption></figure>

### **Why do I see multiple equivalent addresses?**

All addresses map to an equivalent one in a different ecosystem (see the image below). You may be used to seeing your address as an Ethereum address, but behind the scenes, your mapped BitBadges address may be used for record keeping.

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### **Which chains / wallets are supported?**

Currently, we support Ethereum, Cosmos, Solana, Bitcoin.

### Why is it per ecosystem and not per chain?

As you may have noticed, we do not differentiate between EVM chains, for example. All are treated the same with our architecture, so we just default to the emain chain of the ecosystem for display purposes (e.g. EVM for Ethereum).


## File: ./overview/learn/address-lists.md

# Address Lists

Address lists are a streamlined alternative to badges. Instead of dealing with the complexity of badges, you can create a simple list (public but off-chain). These can also be gated by claims, allowing you to gate spots on the list by any criteria imaginable.

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/learn/applications-points.md

# Applications (Points)

Applications allow you to create gamified points, quests, and tiers for your users. Behind the scenes, these just use claims with assigned weights for points, for example. Points can then be used as criteria for other gated utility, like a points-gated airdrop.

<figure><img src="../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/learn/attestations.md

# Attestations

Attestations are private by default credentials (e.g. signature of a specific claim like "Bob earned this diploma"). They enable individuals to prove claims about themselves (such as qualifications, achievements, or attributes) in a secure, tamper-evident, and privacy-preserving manner to any verifier.

These can be stored in your BItBadges account (or sent to the recipients) and selectively disclosed to whoever needs to verify them through claims or Sign In with BitBadges. Attestations are off-chain by default, but you can always anchor or prove existence of the attestation on-chain.

Attestations may come in different forms with varying properties, such as:

* Standard Signatures: Sign messages with your connected wallet address
* BBS+: Supports selectively disclosing only a subset of the N messages in the attestation. For example, disclose you are 21 without revealing your name.
* URLs: Attestations can even be a link to a URL as long as the verifier can verify it

<figure><img src="../../.gitbook/assets/image (6) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (7) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/learn/badge-concepts/README.md

# Badge Concepts



## File: ./overview/learn/badge-concepts/balances-types.md

# Balances Types

BitBadges offers different ways to store the badge balances and owners for your collection, each with their own pros and cons.

<figure><img src="../../../.gitbook/assets/image (40).png" alt=""><figcaption></figcaption></figure>

## Standard (On-Chain)

Standard balances are what you may be familiar with. All balances are stored on the blockchain, and users can transfer badges to each other by transacting with the blockchain. The total supply is controlled by on-chain transfers, approvals, and permissions.

This is the least scalable because it uses the most blockchain resources, but it is the most decentralized. Everything is facilitated on the blockchain and can access blockchain data with no trust involved (including $BADGE).

## Non-Public

We do give the option to make balances non-public. This can either mean you want to keep balances private through a self-implementation. Or, you may not need balances altogether. If either of these criteria match, you can select this balance type, and we will not display anything about balances on the user interface (everything is left up to you entirely).

## Off-Chain

Unlike conventional on-chain balances, off-chain balances leverage an alternative approach to balance storage. Core collection details are still stored on the blockchain, but balances are stored off-chain, on a typical server or through a file storage solution like IPFS. The current balance allocations are dynamically fetched from the URL designated for storage (URL is stored on-chain).

Transfers and approvals are not handled by the blockchain. Transfers may be implemented off-chain. This enables access to non blockchain native data, but it also means that blockchain data and logic can not be executed in a trustless manner (e.g. sending $BADGE along with an approval). Everything must occur off-chain.

#### Configurable URL and Permanent Storage

The URL fetching mechanism is customizable. URLs are stored on-chain and can be set to be updatable or non-updatable by the manager. The balances returned by the URL can also be configured be updatable or rely on permanent storage like IPFS, ensuring consistent and unchanging balance data. When URLs are non-updatable and use permanent storage, balances become immutable (aka soulbound or non-transferable), providing long-term stability.

#### Benefits

* **Significant Resource Reduction**: The architecture's off-chain nature results in a substantial reduction of resources used by your collection—potentially up to over 99%. This is primarily due to the absence of on-chain transfer transactions and balances. Only the collection needs to be created / updated on-chain, and future balance updates do not require blockchain transactions.
* **Non-Blockchain Data and Tools**: Balances can be customized using non-blockchain tools and data. While on-chain balances are restricted to on-chain data (smart contracts, etc.), off-chain balances can be customized with other data. For example, you can give badges to those who have paid subscriptions through a non-blockchain service (Google Pay, etc).
* **No-Cost Updates:** If the balances URL (stored on-chain) remains the same, balances can be updated by simply editing what is returned from the server. This means balances can be updated without interacting with the blockchain and paying transaction fees.
* **Enhanced User Experience**: Users are relieved from the need to interact directly with the blockchain and incur gas fees. This streamlined user experience enhances accessibility and usability. Badges are automatically populated into a user's portfolio without the user ever executing a blockchain transaction.
* **Discardability:** Because balances are indexed off-chain, past transfer activity that is no longer relevant and needed can be permanently discarded rather than permanently stored on the blockchain and bloating it.

#### Drawbacks

* **Scalability vs. Functionality Trade-off**: While off-chain balances offer scalability and user-centric benefits, they entail trade-offs in terms of functionality and decentralization. Mainly,\
  since there are no on-chain transfers, certain on-chain functionality (such as approvals, customizable transferability, transfers w/ $BADGE) is not supported. Everything is implemented off-chain in a custom manner.
* **Centralized Trust Factor**: The URL-driven approach introduces a centralized trust element, as the blockchain has no control over the data returned by the URL or the assignment of the balances. This can be mitigated if certain criteria is met (immutable and using permanent storage like IPFS).
* **Off-Chain Balance Indexing:** Because balance updates are facilitated and indexed off-chain, there is no on-chain verifiable ledger of transfer transactions. Off-chain indexing does not sacrifice any functionality, but the accuracy and availability may not be on par with on-chain indexing.
  * Timestamping: There is no decentralized, verifiable log of EXACTLY when each balance update occurs because they occur on a hosted server. Indexers will attempt to fetch and catch each update as fast as possible, if applicable, but there is bound to be delay.
  * Loss of Historical Data: Logs of past balances may be lost forever if all parties discard / lose the data and can not be reproduced. However, this could also be a good thing as seen in the benefits.

### Indexed vs Non-Indexed

Off-chain balances can either be indexed or non-indexed. Note we use on-demand and non-indexed interchangeably. The differences are as follows:

* Indexed balances have a total verifiable supply. Non-indexed does not.
* At any time, for indexed balances, all owners and their balances are known. With non-indexed, this is not tracked, and we fetch on-demand from the source every time.
* For indexed balances, a ledger of activity is tracked. For non-indexed, there is no ledger kept. You can only view the current balances at any given time.
* Indexed balances have a limit of unique owners (set by the indexer) for scalability reasons, whereas non-indexed has no such limit.

### Suitability of Off-Chain Balances

Consider adopting off-chain balances if your collection aligns with the following criteria:

1. **Non-Transferable / Soulbound**: If your collection's badges are intrinsically tied to specific users and are not intended for transfer, off-chain balances could be advantageous, especially if you make the balances frozen and immutable.
2. **Centralized Allocation Control**: In cases where a single entity should maintain complete control over badge allocation (concert tickets, diplomas, etc), the off-chain approach can be particularly beneficial.

This is because there is little added benefit to using a blockchain if such criteria is met. Sure, the blockchain might have better availability and verifiability than an off-chain solution (although, we have been using off-chain solutions for 20+ years successfully). However, other than that, the blockchain really provides little benefit, and fees can be expensive.

### Customizability and Advantages Over Standard Solutions

#### Custom Logic Implementation

Balances' updatable nature allows for the implementation of custom logic for what is returned by the URL. This empowers you to define and program your balance-fetching process to align with your collection's unique requirements. It also allows you to access and integrated with non-blockchain data and tools to customize your balances further.

For example, you can dynamically revoke and assign based on if users pay their subscription fees for a month all without ever interacting with the blockchain (since the URL won't change).

See [here](../../how-it-works/broken-reference/). Or, find a tool or tutorial for your use case on the [Ecosystem ](../../ecosystem/)page!

#### Advantages Over Standard Solutions

Compared to traditional client-server solutions, off-chain balances offer numerous advantages, including:

* **Simplified Badge Management**: Outsourcing badge creation, maintenance, and verification reduces your workload.
* **Seamless Integration**: Integration with the complete suite of BitBadges tools.
* **Enhanced Security and Availability**: While balances are off-chain, the collection's core creation and foundation remain on the blockchain where it benefits from security, immutability, and availability.
* **Unified Digital Identity Building**: Users can consolidate their digital identity to their single address, eliminating fragmentation across various websites.

In conclusion, off-chain balances present an intriguing avenue to enhance scalability, user experience, and badge management. While there are considerations and trade-offs, the decision to adopt this approach hinges on your collection's specific goals and priorities. For additional resources and guidance, consult the Ecosystem page to identify suitable tools and tutorials for your use case.


## File: ./overview/learn/badge-concepts/manager.md

# Manager

Each badge collection has a manager, which can execute admin permissions such as updating metadata, transferability, etc.

<figure><img src="../../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

**Manager Permissions**

The manager role can be granted various permissions, allowing for flexible administration of the collection. These permissions include, but are not limited to:

1. **Collection Deletion:** The ability to permanently remove the collection from the system.
2. **Collection Archiving:** Managers can archive a collection, making it read-only and rejecting all transactions until an unarchive action is performed.
3. **Core Collection Updates:** This includes modifying essential details such as metadata URLs, contract addresses, and the collection's standard.
4. **Off-chain Balance Management:** For collections using off-chain balance storage, managers can update these balances.
5. **Manager Role Transfer:** The ability to pass the manager role to another address.
6. **Badge Creation:** Managers can be given permission to mint additional badges within the collection.
7. **Transferability Updates:** This involves modifying the collection's approval settings, which determine how badges can be transferred. (For more details, see [transferability](transferability.md))
8. **Custom Permissions:** Depending on the collection's setup, there may be additional, collection-specific permissions available to the manager.

It's worth noting that the manager role can extend beyond on-chain functionalities. Various tools and platforms can offer custom off-chain utilities exclusive to the manager, further expanding the role's capabilities and responsibilities.

## Fine-Grained Customizability

One of the key features of the manager role in BitBadges is the ability to customize permissions at a granular level. This allows for precise control over the collection's management.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>Fine-Grained Permission Settings</p></figcaption></figure>

Permissions can be customized based on various factors, including:

* **Badge Specificity:** Which particular badges within the collection can be affected?
* **Time Constraints:** When can certain actions be performed?
* **Value Limitations:** What specific values or ranges are allowed for updates?
* **Conditional Triggers:** Under what circumstances can certain permissions be exercised?

This level of customization allows collection creators to implement complex management strategies tailored to their specific needs.

## Permission States

Each permission can exist in one of three states:

1. **Forbidden + Permanently Frozen:**
   * The permission is permanently disallowed.
   * This state cannot be changed, ensuring certain actions remain off-limits indefinitely.
2. **Permitted + Not Frozen:**
   * The permission is currently allowed.
   * This state can be changed to either of the other two states, offering flexibility in management.
3. **Permitted + Permanently Frozen:**
   * The permission is permanently allowed.
   * Like the first state, this cannot be changed, ensuring certain capabilities always remain available.

It's important to note that there is no "Forbidden + Not Frozen" state. This is because such a state could theoretically be updated to "Permitted" at any time and then immediately executed, effectively making it a "Permitted" state.

This system of states allows for both flexibility and security in managing collection permissions, enabling creators to set up governance structures that can evolve over time or remain fixed, depending on their needs.


## File: ./overview/learn/badge-concepts/standards.md

# Standards

Collections can optionally implement a specific type of collection or standard. Standards define the expected format of the collection and help others to know how to interpret the details of the collection.

Standards can define the expected values and format of everything about a collection, such as its expected metadata format or the expected genesis conditions. If you implement a standard, it is your responsibility to follow the rules defined by the standard.

Choose the most appropriate standard(s) for your desired use case. You may choose to mix and match more than one as long as they are compatible.

**Example**

```
standards: ["non-fungible", "attendance-event", "No User Ownership"]
```

## List of Standards

1. "No User Ownership" standard - If the standards contains the standard "No User Ownership", then, user ownership is deemed unimportant and all user balances are to not be displayed. This means nothing about transferability, approvals, activity, and so on is displayed. This standard is used by collections where only the badge metadata / permissions matter, such as an attestation to something. All badges are expected to not have any recipient.



## File: ./overview/learn/badge-concepts/time-dependent-ownership.md

# Time-Dependent Ownership

Typically, you may think of a balance in two parts: what you own and the amount you own (x10 of Badge IDs 1-199). BitBadges introduces a third part: ownership times.

For example, Bob owns x10 of Badge IDs 1-100 from January to March but x5 from March-December.

### Balance Components

1. **Badge IDs**: This refers to which badges in your possession.
2. **Badge Quantity / Amount**: This refers to how much of each badge you own.
3. **Ownership Times**: A time-based framework that governs the periods during which you possess specific badge quantities.

<figure><img src="../../../.gitbook/assets/image (5) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Example of Ownership Structure

Consider Bob's ownership structure as an illustrative example:

Bob initially owns x10 of Badge IDs 1-100 from January to March. Subsequently, his ownership transitions to x5 of Badge IDs 1-100 from March to December.

### Advantages of the Ownership System

This ownership system brings forth several compelling benefits:

#### Subscription Tokens

By leveraging this system, the transfer of tokens designated for subscriptions becomes seamless. Auto-expiring tokens can be transferred without necessitating the revocation of permissions or initiating blockchain transactions.

#### Token Unlocks

Numerous projects feature stock or token unlock schedules that primarily rely on trust, rather than code-enforced mechanisms. This ownership framework empowers users to define and implement token unlock schedules natively, enhancing security and accountability.

#### Lending Mechanism

The ownership times concept facilitates badge lending for specified durations without the need for escrow services. Users can temporarily transfer their badges while retaining the ability to reclaim them after the designated timeframe.

### Usage Examples

To elucidate the functioning of this ownership system, let's delve into practical scenarios.

**Starting Balance**: Bob owns x10 of Badge IDs 1-100 from January to March.

**Example 1**: Bob's Transfer to Alice

* Bob transfers x10 of Badge IDs 1-100 from January to February to Alice.
* Result: Bob's ownership persists as x10 of Badge IDs 1-100 from February to March, while Alice becomes the owner of x10 of Badge IDs 1-100 from January to February.

**Example 2**: Bob's Partial Transfer to Alice

* Bob transfers x5 of Badge IDs 1-100 from January to March to Alice.
* Result: Both Bob and Alice now possess x5 of Badge IDs 1-100 during the January to March period.

**Example 3**: Complex Transfer Scenario

* Bob transfers x10 of Badge IDs 1-50 from January to February to Alice.
* Result: Bob retains ownership of x10 of Badge IDs 1-50 from February to March, and additionally, x10 of Badge IDs 50-100 from January to March. Meanwhile, Alice owns x10 of Badge IDs 1-50 from January to February.

Incorporating time-based ownership into the conventional badge ownership paradigm introduces enhanced flexibility, security, and functionality, enabling various usage scenarios that would otherwise be challenging to achieve.


## File: ./overview/learn/badge-concepts/total-supplys.md

# Total Supplys

Each badge in a collection will have its own circulating supply. You can think of the "Mint" address having unlimited balances, and the circulating supply is determined by the approvals and permissions of transfers from minting set up by the collection manager.

Badges can be fungible, non-fungible, or anything in between. Each has its own supply. And with time-dependent balances, this supply may change over time automatically.

Badges cannot be "burned" once created. However, they can be transferred (if allowed) to addresses where no private key is known such as the Ethereum zero address.


## File: ./overview/learn/badge-concepts/transferability.md

# Transferability

The transferability defines the rules for transferring badges within the collection. Note this does not apply to address lists or any off-chain balances type ([see here](balances-types.md)), only standard on-chain balances.

### **Transferable vs Non-Transferable**

At its simplest, a collection can be thought of as transferable (badges can be transferred freely from one owner to another) or non-transferable (once a badge is owned, it is tied to that owner and never transferable).

### Problem

However, only specifying simply "transferable" vs "non-transferable" is very naive and not suitable for many use cases.&#x20;

For example, what if you need to be able to revoke? Freeze one's ability to transfer? Restrict who can transfer to who? Restrict when users can transfer? Restrict how many times a transfer can occur? Restrict the total amount of badges transferred? Or a combination of all of these?

We abstract everything to a clearly defined interface that accounts for all these factors on three different levels.

<figure><img src="../../../.gitbook/assets/image (157).png" alt=""><figcaption></figcaption></figure>

## Approval Levels

We define three levels of approved transfers: collection-wide, incoming, and outgoing.&#x20;

<figure><img src="../../../.gitbook/assets/image (32).png" alt=""><figcaption></figcaption></figure>

### **Collection Approvals**

The collection-wide approved transfers defines all possible combinations of transfers that are allowed to take place. **All transfers must be explicitly approved on the collection level.**  This is established upon creation and updated by the manager (according to the permissions set). This also is the only way to approve "transfers" from the "Mint" address as the "Mint" address has no user level approvals.

For example, the manager could define all badges to be transferable, non-transferable, revokable by the manager. Or, they can specify claims that must be passed in order to transfer (e.g. you must own this badge to interact with this collection or you must not own a scammer badge to interact with this collection). See all possibilities below.

The collection-wide approved transfers are unique because there is a forceful option which allows you to override and ignore the other two levels of approvals (incoming and outgoing). This is used for forcefully revoking badges or forcefully freezing badges. **If it does not override the incoming and outgoing levels of approvals, the transfer must also be approved on those levels as well.** This is what is used in the case of approving mints.

### **Outgoing Approvals**

The outgoing approvals are the approved transfers of the sender. By default, all transfers where the sender equals the transaction initiator are allowed, and all others are disallowed. The sender can optionally approve other addresses to transfer on their behalf. If you are familiar with other blockchain NFTs and tokens, this is similar.

The collection can define a default outgoing approved transfers for each user. This can then be updated by the user as they desire.

### **Incoming Approvals**

The incoming approvals are the approved transfers of the recipient. By default, all transfers where the recipient equals the transaction initiator are allowed, and all others are disallowed. The recipient can choose whether to block or allow incoming transfers via their incoming approved transfers. This is a new concept introduced by BitBadges.

The collection can define a default incoming approved transfers for each user. They can then be updated by the user as they desire. They can then be updated by the user as they desire.

Typically, this is left open-ended to allow all incoming transfers, but this can be customized for more advanced use cases.

### Transfer Validation Scenario

Let's delve into a transfer scenario to understand the process of approval validation:

#### Scenario: Bob transfers x5 of Badge IDs 1-10 to Alice for the times January to March&#x20;

1. **Collection-Level Approval Check**:
   * The initial step involves verifying if the transfer adheres to collection-level rules. For instance, if Badge ID 1 is found to be non-transferable overall via the collection, the transfer attempt would be deemed unsuccessful.
2. **Incoming Approval Check**:
   * If the transfer passes the collection-level check, the subsequent step involves assessing Alice's incoming approvals. This evaluation considers whether Alice has blocked Bob from sending her badges and whether she has opted in to the specific badge collection in question.
3. **Outgoing Approval Check**:
   * Upon Alice's incoming approval, the process moves on to Bob's approvals. It's necessary to ascertain whether Bob has provided his consent for the transfer to proceed. This step is particularly significant if the transfer was initiated by a party other than Bob himself.

This layered approach to approval ensures a thorough examination of the transfer's legitimacy and compliance with various levels of permissions. The hierarchical structure prevents unauthorized transfers and enhances transparency in the transfer process.

### Customization Options

At each level, we offer the following functionality for defining approved transfers. Mix and match any combinations:

* Who can transfer to who? And who can initiate the transaction?
* When can the transfer take place?
* Which badges can be sent? For how long ([see ownership times](time-dependent-ownership.md))? What amount?
* Max number of overall transfers? Max per sender? Max per recipient? Max per initiator?
* Max amount transferred? Max per sender? Max per recipient? Max per initiator?
* Predetermined transfers?
  * Transfer A must take place before Transfer B before Transfer C
* Incremented transfers?&#x20;
  * Start with specific badges and ownership times and increment them every transaction.
  * Ex: Transfer x1 of Badge ID 1, then x1 of Badge ID 2, and so on...
* Must own (or not own) specific badges to be approved
  * Ex: Must own a membership to transfer or must now own a scammer badge to transfer
* Require sender to be the initiator? Require sender to not be the initiator?
* Require recipient to be the initiator? Require recipient to not be the initiator?
* And more!

The best way to see all that is possible is to view the badge creation process.

### **Updatability**

We also support fine-grained updatability for all combinations of the above functionality through the manager permissions.

For example, the manager can permanently lock all combinations on a collection-level to make the transferability non-updatable. Or, they can lock it for a certain amount of time. Or, they can keep it updatable. One can even combine combinations, such as locking an approval for a specific badge for a specific time for specific users.


## File: ./overview/learn/badges.md

# Badges

Badges are on-chain, public tokens ownable and transferable by users from different addresses. These are handled on our own L1 blockchain and show up in your portfolio.

Badges offer many never-seen-before-features and ways of implementation like time-dependent balances, off-chain hybrid balances, and much more. Badge distribution can be gated by claims, allowing you to offer minting / approvals gated by any criteria imaginable. On the flip side, use ownership as criteria to gate any service imaginable.

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/learn/distribution.md

# BitBadges Claims

Claims are the backbone (or connectors) of pretty much all aspects of BitBadges. Create criteria checks from 7000+ applications, plugins, and services to gate anything from content to websites to badge distribution and more. Claims offer flexible implementation methods from no-code, in-site plugins to custom webhooks to a no-code Zapier integration connecting you to 7000+ apps and more.

1. Meet criteria - Owns badge? Is in Discord server? Provided secret attendance code?
2. Receive reward - Access to services? Receive badges?

What the criteria and / or rewards are all up to you!

Let BitBadges do the heavy lifting, enabling you to focus on offering your core utility. We offer tools to help on either end (badges, address lists, etc), but ultimately, you can check any criteria and deliver any reward you want!

Claims can be simply thought of as:

Claims have super flexible implementation as well. For example:

* Check criteria on-demand vs have users claim in-site vs auto-complete on behalf of users?
* Add any plugin you want from 7000+ no-code integrations
* Custom webhooks to connect to any service on either end
* No-code Zapier / Pipedream automation workflows on either criteria or rewards side

The best way we recommend to deep dive into what all is possible is just to experiment with the claim tester in the developer portal: [https://bitbadges.io/developer](https://bitbadges.io/developer). Or, explore the site.

For additional documentation, see here:

{% content-ref url="../claim-builder/" %}
[claim-builder](../claim-builder/)
{% endcontent-ref %}

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (5) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/learn/verification-tools.md

# Sign In with BitBadges

Gate any service (digital or in-person) with Sign In with BitBadges. All chains, one interface.

Gate your digital services with an industry standard OAuth 2..0 multi-chain authentication. This approach is a multi-chain replacement to "Sign In with Google". Or, leverage the QR code feature to create QR codes for gating in-person events. QR codes are exportable to any preferred format (email, Apple Wallet), so you do not need wallets at authentication time.

Additionally, use along with checking a claim to allow you to gate based on any criteria you want:

* Payment-gated website
* Badge-gated event
* Attestation-gated digital services
* Any combination of gated access!

We also are compatible with many frameworks and tools like Discourse, WordPress, Auth0, and more!

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

For developers interested in implementing these features, please refer to our detailed guide:

{% content-ref url="../../for-developers/authenticating-with-bitbadges/" %}
[authenticating-with-bitbadges](../../for-developers/authenticating-with-bitbadges/)
{% endcontent-ref %}


## File: ./overview/learn/wallets-and-sign-ins/README.md

# Wallets and Sign Ins



## File: ./overview/learn/wallets-and-sign-ins/approved-transactors.md

# Approved Transactors

**Approved Transactors**

In your account settings, BitBadges provides the option to approve other wallets to transact on-chain your behalf. Note this is different from the alternate sign ins on the prior page which approve other ways to access your BitBadges account (off-chain). This feature can be used to configure hot wallets, for example, that are easier to access and can sign on your behalf on the go.

Note: This feature is opt-in and not enabled by default.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**BitBadges Embedded Wallet**

While we allow approving any wallet / address, we offer a managed embedded wallet maintained by BitBadges. We will sign transactions / messages when requested, but the requester has to be signed in with the Embedded Wallet (embeddedWallet) scope enabled. This can be approved with an alternate sign-in method saved for your account, or check out the Sign In with BitBadges documentaion if you want to do this programmatically.

Note: The embedded wallet is its own address and needs to be treated as such. It needs to be registered, be funded, etc.

To sign transactions:

1. You must be signed in with permission to use the embedded wallet (the Embedded Wallet scope). You can configure alternate sign in methods (socials or other addresses) via the Sign In Methods tab. Ensure the Embedded Wallet scope is enabled.
2. The desired transaction message types must be approved in the account settings before transacting.
3. The wallet must have sufficient $BADGE credits.

Note this is opt-in and can be revoked at any time. This is provided as a way to trade off centralization / trust for enhanced user experience but is completely optional. Also note that the BitBadges embedded wallet is not the only option. We provide the functionality for you to approve any wallet.


## File: ./overview/learn/wallets-and-sign-ins/mobile-support.md

# Alternate Sign Ins / Mobile

If you want access to your BitBadges account on the go, consider adding approved sign-in methods in your account settings.&#x20; This allows you to access certain aspects of your account via Signing In with Discord, Google, etc, or an alternate approved method. Use at your own risk though as approving socials means account compromise on your socials -> account compromise on BitBadges. Only assign the scopes that you need. This can approve any off-chain action. 

For approving on-chain transactors, see the approved transactors page.

<figure><img src="../../../.gitbook/assets/image (158).png" alt=""><figcaption></figcaption></figure>

**Mobile Wallets**

Any mobile wallet is also supported. If you are using a mobile crypto wallet, please use best practices for that wallet. Some may require you to use their in-app browser, for example.

**Mobile App (PWA)**

While we do not have an official app on any app store, our web app is mobile friendly. It is also built as a PWA (progressive web app) which allows you to add it to your homescreen.&#x20;


## File: ./overview/learn/wallets-and-sign-ins/supported-wallets.md

# Supported Wallets

BitBadges is compatible with wallets from any of the supported chain's ecosystems.

**Ethereum** - 500+ via WalletConnect and compatible with any injected wallet

**Cosmos** - Keplr, Leap, Cosmostation

**Bitcoin** - Leather, Phantom

**Solana** - Phantom

**Privy** - We also support Privy wallets which help you map standard socials sign ins to an Ethereum wallet!

**Guest Accounts -** We also support browser-based, rotatable, temporary guest accounts.

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Note: Because we verify signatures on our own chain and do not pull data from any other chain, contract wallets like Coinbase Smart Wallet are not supported.


## File: ./overview/link-sharing.md

# 🤝 Brand Guidelines

Feel free to use BitBadges name and logo in your site as you see fit. If you have any questions or concerns about usage, please let us know. We are also happy to provide any other logos, images, or information you may need.

**Text Logo**

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Square Logo**

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>



## File: ./overview/official-links.md

# 🔗 Official Links and Resources

Below is a list of official links for socials and other platforms. Our preferred contact is Discord. This is not an exhaustive list. See the rest of the documentation for more information on specific subjects.

* [BitBadges App](https://bitbadges.io)
* [Explorer](https://explorer.bitbadges.io)

### Documentation

* [LLM .txt](../for-llms.txt) - Entire documentation dumped into one file

### Socials

* [Discord](https://discord.com/invite/TJMaEd9bar)
* [LinkedIn](https://linkedin.com/company/bitbadges)
* [Twitter](https://twitter.com/bitbadges_io)
* [Facebook](https://facebook.com/profile.php?id=100092259215026)
* [Instagram](https://instagram.com/bitbadges_official/)
* [Slack](https://bitbadges.slack.com/join/shared_invite/zt-1tws89arl-TMSK_4bdTLOLdyp177811Q#/shared-invite/email)
* [Reddit](https://www.reddit.com/r/BitBadges/)
* [Telegram](https://t.me/BitBadges)
* [GitHub](https://github.com/bitbadges)

### Integrations

* [Zapier](https://zapier.com/apps/bitbadges/integrations) ([Docs](broken-reference))
* [Chrome Extension](https://chromewebstore.google.com/detail/bitbadges-chrome-extensio/ocdlkggomnifibfadgaakkilojelgacj?authuser=0\&hl=en) ([Docs](ecosystem/chrome-extension.md))
* [MetaMask Snap Download](https://snaps.metamask.io/snap/npm/bitbadges-snap/) ([Docs](ecosystem/metamask-snap.md))

### API & SDK

* [NPM API / SDK Package](https://www.npmjs.com/package/bitbadgesjs-sdk) ([Docs](../for-developers/bitbadges-sdk/))
* [API Documentation](https://bitbadges.stoplight.io/docs/bitbadges) ([Docs](../for-developers/bitbadges-api/))
* [Quickstarter Demo](https://bitbadges.io/quickstart)

```bash
# Using npm
npm install bitbadgesjs-sdk

# Using pnpm
pnpm add bitbadgesjs-sdk

# Using bun
bun add bitbadgesjs-sdk
```

### Running a Node

* [Run a Node](https://docs.bitbadges.io/for-developers/bitbadges-blockchain/run-a-node)

Learn more about the team at [https://bitbadges.io/about](https://bitbadges.io/about).


## File: ./overview/staking-usdbadge.md

# Staking / Validators

The BitBadges blockchain is a [delegated proof-of-stake blockchain](https://101blockchains.com/proof-of-stake-vs-delegated-proof-of-stake/). Delegated Proof of Stake (DPoS) is a blockchain consensus mechanism where token holders elect a small group of trusted members (validators) to validate transactions and maintain the network. These validators stake their own stake and earn additional stake from maintaining the network.&#x20;

The delegated part is because token holders can delegate their stake to validators and split the earned, according to their delegation and commission charged by the validator. This enables token holders to contribute to the security of the network without running their own validator.

For the BitBadges blockchain, we use a separate denomination for staking (i.e. $BADGE credits are not used for staking). It will be the "ustake" denom behind the scenes ($STAKE). As explained in the [Launch Phases](launch-phases.md) docs, reach out to us in Discord if you plan to run a validating node and need $STAKE. This is free and only requires a quick application process.

If you want to become a validator by running a validator node, see [here](../for-developers/bitbadges-blockchain/run-a-node/).&#x20;

BitBadges is also a delegated PoS chain, so you can delegate $STAKE to an existing validator. This validator will split the amount earned from securing the network with you (they may charge a commission). Visit [https://bitbadges.io/stake](https://bitbadges.io/stake).&#x20;

Behind the scenes, this uses the [Cosmos SDK staking](https://docs.cosmos.network/main/modules/staking) module.&#x20;

## **Governance**

Initially, we do not plan to use a governance structure to allow us to ship fast and build a great prduct. Over time as we shift to becoming more decentralized, we will allow stakeholders to propose and vote on governance proposals, weighted via their amount. This will be via the [Cosmos SDK governance module](https://docs.cosmos.network/main/modules/gov). These governance proposals will allow holders to decide on the future of BitBadges.


## File: ./overview/testnet-mode.md

# 🧪 Testnet Mode

Testnet mode provides a separate environment for testing purposes. Simply turn on the switch (or go to [testnet.bitbadges.io](https://testnet.bitbadges.io)). It is isolated from the production environment of BitBadges and uses its own resources, such as a testnet blockchain, database, API, and more.

<pre><code><strong>Note: Third-party integrations (e.g. claim plugins) are the exact same.
</strong></code></pre>

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Important Notes

You should treat testnet as an entirely SEPARATE service. NOTHING will carry over from normal mode (not even profiles, badges, settings, anything). Consider this before determining whether testnet mode is the correct option for you.

### Differences

* Some features available in production may not be accessible in testnet:
  * Off-chain balances managed by BitBadges are not hosted externally (via CDN)
  * Buying $BADGE credits
  * Push notifications
  * And more
* Some restrictions may be more relaxed
  * No API keys required
  * Faucet may be more lenient
* Performance also may differ from the production environment

### Links

Frontend: [https://testnet.bitbadges.io](https://testnet.bitbadges.io)

Backend: [https://api.bitbadges.io/testnet](https://api.bitbadges.io/testnet) (append the normal routes to this base URL)

Testnet Node:

* RPC: [https://testnet.node.bitbadges.io/rpc](https://testnet.node.bitbadges.io/rpc)
* REST: [https://testnet.bitbadges.io/api](https://testnet.bitbadges.io/api)
* Direct Node Access: `http://138.197.10.8:YOUR_PORT`

### Feedback

If there is anything we can do to make development easier, let us know.


## File: ./overview/use-cases.md

# 🎨 Use Cases

Because you can check criteria for anything, there are infinitely many possible use cases for BitBadges! Below are some of our favorites. You can also browse featured items at [https://bitbadges.io/browse](https://bitbadges.io/browse).

* **Authentication / Tiered Services -** Most products' infrastructure simply consists of authentication + tiered services. These products can outsource their authentication (see [Authenticating with Badges](broken-reference)) and verify ownership through tiered services badges (family plan badge vs normal user badge, API key badge). Much cheaper, more secure, and less work!
* **Attendance Badges -** Mint an attendance badge as a souvenir or as proof you completed an action (e.g. "I Voted" badge).
* **Truth Badges -** Badges become the source of truth for scams, deep fakes, and more. For example, in a world of artificial intelligence, badges can be used to verify the root truth of some statement or thing.&#x20;
* **Memberships/Subscriptions/Access Tokens** - Badges can define expiration dates, so you can offer a limited time membership for anything from a gym membership to a Spotify subscription. Proof of ownership is easily done through our public API.
* **Premium Content** - Premium content can be offered only to badge holders.
* **Decentralized Verification** - Multiple verification services can give out verification badges, and you can choose which person/entity to get your verification ticks from. Or, verification can be more fine-grained and each entity / company can assign badges to their own registered employees / community.
* **Security and Safety -** Maybe a badge is assigned to every address who's private keys are compromised. Apps can then refuse service to such addresses.
* **Cross-Chain Protocols -** Implement a cross-chain follow, messaging, social media, etc protocols where every post, message, item is a badge being transferred / minted.&#x20;
* **Visual Block Explorers:** Query on-chain activity in a visual way with badges. For example, to see when a user's first blockchain transaction was, see which badge they own (OG 2015 User vs OG 2023 User, etc.)
* **Recognition of Achievement or Completion** - Job certifications, awards, athletic accomplishments, etc.
* **E-Learning** - Gamify the learning experience through learning badges
* **University Diplomas** - Universities can offer verifiable diplomas to students as a badge.
* **Publications** - Verify you are the author of a publication
* **Real Estate** - Custom encrypted title ownership, HOAs, and even MLS documents registered through the blockchain
* **Praise / Vouch Badges** - Praise, recommend, or vouch for something or someone/
* Literally anything!


## File: ./.github/workflows/for--llms.yml

```
name: Generate LLM Training Text

on:
    push:
        branches: [main, master]
    workflow_dispatch: # Allows manual triggering

jobs:
    generate-llm-text:
        runs-on: ubuntu-latest
        permissions:
            contents: write
        steps:
            - name: Checkout repository
              uses: actions/checkout@v3

            - name: Set up Python
              uses: actions/setup-python@v4
              with:
                  python-version: '3.10'

            - name: Install dependencies
              run: |
                  python -m pip install --upgrade pip

            - name: Create for-llms.txt file
              run: |
                  echo "# Gitbook Documentation Compilation" > for-llms.txt
                  echo "Generated on $(date)" >> for-llms.txt
                  echo "" >> for-llms.txt

                  # Find all markdown files
                  find . -type f -name "*.md" | sort | while read -r file; do
                    # Skip hidden directories and node_modules
                    if [[ "$file" != *"/.git/"* && "$file" != */node_modules/* && "$file" != */build/* && "$file" != */dist/* ]]; then
                      echo "Processing $file"
                      
                      # Add file path as header
                      echo -e "\n\n## File: $file\n" >> for-llms.txt
                      
                      # Add file content
                      cat "$file" >> for-llms.txt
                    fi
                  done

                  # Also find and process any other text-based documentation files
                  find . -type f -name "*.txt" -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" | sort | while read -r file; do
                    if [[ "$file" != *"/.git/"* && "$file" != */node_modules/* && "$file" != */build/* && "$file" != */dist/* && "$file" != *"for-llms.txt"* ]]; then
                      echo "Processing $file"
                      
                      # Add file path as header
                      echo -e "\n\n## File: $file\n" >> for-llms.txt
                      echo '```' >> for-llms.txt
                      
                      # Add file content
                      cat "$file" >> for-llms.txt
                      
                      echo '```' >> for-llms.txt
                    fi
                  done

            - name: Upload for-llms.txt as artifact
              uses: actions/upload-artifact@v4
              with:
                  name: llm-training-data
                  path: for-llms.txt

            - name: Commit and push for-llms.txt
              run: |
                  git config --local user.email "action@github.com"
                  git config --local user.name "GitHub Action"
                  git add for-llms.txt
                  git commit -m "Update for-llms.txt via GitHub Action" || echo "No changes to commit"
                  git push
```


## File: ./.vscode/settings.json

```
{
  "workbench.colorCustomizations": {
    "activityBar.background": "#2E2461",
    "titleBar.activeBackground": "#403287",
    "titleBar.activeForeground": "#FBFBFE"
  }
}```

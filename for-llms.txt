# Gitbook Documentation Compilation
Generated on Tue Feb  3 12:59:33 UTC 2026



## File: ./.gitbook/assets/README.md

BitBadges / [Exports](modules.md)


## File: ./.gitbook/assets/modules.md

[BitBadges](README.md) / Exports

# BitBadges

## Table of contents

### Enumerations

-   [DistributionMethod](enums/DistributionMethod.md)
-   [MetadataAddMethod](enums/MetadataAddMethod.md)
-   [SupportedChain](enums/SupportedChain.md)
-   [TransactionStatus](enums/TransactionStatus.md)

### Interfaces

-   [AccountDocs](interfaces/AccountDocs.md)
-   [AccountDocument](interfaces/AccountDocument.md)
-   [AccountMap](interfaces/AccountMap.md)
-   [AccountResponse](interfaces/AccountResponse.md)
-   [ActivityItem](interfaces/ActivityItem.md)
-   [Addresses](interfaces/Addresses.md)
-   [AnnouncementActivityItem](interfaces/AnnouncementActivityItem.md)
-   [Approval](interfaces/Approval.md)
-   [BadgeMetadata](interfaces/BadgeMetadata.md)
-   [BadgeMetadataMap](interfaces/BadgeMetadataMap.md)
-   [BadgeSupplyAndAmount](interfaces/BadgeSupplyAndAmount.md)
-   [BadgeUri](interfaces/BadgeUri.md)
-   [Balance](interfaces/Balance.md)
-   [BalanceObject](interfaces/BalanceObject.md)
-   [BalancesMap](interfaces/BalancesMap.md)
-   [BitBadgeCollection](interfaces/BitBadgeCollection.md)
-   [BitBadgeMintObject](interfaces/BitBadgeMintObject.md)
-   [BitBadgesUserInfo](interfaces/BitBadgesUserInfo.md)
-   [ClaimItem](interfaces/ClaimItem.md)
-   [ClaimItemWithTrees](interfaces/ClaimItemWithTrees.md)
-   [Claims](interfaces/Claims.md)
-   [CollectionDocs](interfaces/CollectionDocs.md)
-   [CollectionMap](interfaces/CollectionMap.md)
-   [CosmosAccountInformation](interfaces/CosmosAccountInformation.md)
-   [DbStatus](interfaces/DbStatus.md)
-   [Docs](interfaces/Docs.md)
-   [GetAccountResponse](interfaces/GetAccountResponse.md)
-   [GetBalanceResponse](interfaces/GetBalanceResponse.md)
-   [GetBalanceResponse](interfaces/GetBalanceResponse.md)
-   [GetCollectionResponse](interfaces/GetCollectionResponse.md)
-   [GetOwnersResponse](interfaces/GetOwnersResponse.md)
-   [GetPortfolioResponse](interfaces/GetPortfolioResponse.md)
-   [IdRange](interfaces/IdRange.md)
-   [IndexerStatus](interfaces/IndexerStatus.md)
-   [LatestBlockStatus](interfaces/LatestBlockStatus.md)
-   [MetadataDocs](interfaces/MetadataDocs.md)
-   [MetadataDocument](interfaces/MetadataDocument.md)
-   [PaginationInfo](interfaces/PaginationInfo.md)
-   [PasswordDocument](interfaces/PasswordDocument.md)
-   [PendingTransfer](interfaces/PendingTransfer.md)
-   [Proof](interfaces/Proof.md)
-   [SearchResponse](interfaces/SearchResponse.md)
-   [StoredBadgeCollection](interfaces/StoredBadgeCollection.md)
-   [SubassetSupply](interfaces/SubassetSupply.md)
-   [TransferActivityItem](interfaces/TransferActivityItem.md)
-   [TransferList](interfaces/TransferList.md)
-   [TransferListWithUnregisteredUsers](interfaces/TransferListWithUnregisteredUsers.md)
-   [Transfers](interfaces/Transfers.md)
-   [TransfersExtended](interfaces/TransfersExtended.md)
-   [UserBalance](interfaces/UserBalance.md)

### Type Aliases

-   [Permissions](modules.md#permissions)

### Variables

-   [AllAddressesTransferList](modules.md#alladdressestransferlist)
-   [CHAIN_DETAILS](modules.md#chain_details)
-   [CanCreateMoreBadgesDigit](modules.md#cancreatemorebadgesdigit)
-   [CanDeleteDigit](modules.md#candeletedigit)
-   [CanManagerBeTransferredDigit](modules.md#canmanagerbetransferreddigit)
-   [CanUpdateBytesDigit](modules.md#canupdatebytesdigit)
-   [CanUpdateDisallowedDigit](modules.md#canupdatedisalloweddigit)
-   [CanUpdateUrisDigit](modules.md#canupdateurisdigit)
-   [DefaultPlaceholderMetadata](modules.md#defaultplaceholdermetadata)
-   [ErrorMetadata](modules.md#errormetadata)
-   [GO_MAX_UINT_64](modules.md#go_max_uint_64)
-   [MAX_DATE_TIMESTAMP](modules.md#max_date_timestamp)
-   [METADATA_PAGE_LIMIT](modules.md#metadata_page_limit)
-   [MINT_ACCOUNT](modules.md#mint_account)
-   [NUM_PERMISSIONS](modules.md#num_permissions)

### Functions

-   [AddBalancesForIdRanges](modules.md#addbalancesforidranges)
-   [DeleteBalanceForIdRanges](modules.md#deletebalanceforidranges)
-   [GetAccountByNumberRoute](modules.md#getaccountbynumberroute)
-   [GetAccountRoute](modules.md#getaccountroute)
-   [GetAccountsRoute](modules.md#getaccountsroute)
-   [GetBalanceRoute](modules.md#getbalanceroute)
-   [GetBalanceInfoToInsertToStorage](modules.md#getbalanceinfotoinserttostorage)
-   [GetBalanceRoute](modules.md#getbalanceroute)
-   [GetBalancesForIdRanges](modules.md#getbalancesforidranges)
-   [GetCollectionRoute](modules.md#getcollectionroute)
-   [GetCollectionsRoute](modules.md#getcollectionsroute)
-   [GetIdRangeToInsert](modules.md#getidrangetoinsert)
-   [GetIdRangesToInsertToStorage](modules.md#getidrangestoinserttostorage)
-   [GetIdRangesWithOmitEmptyCaseHandled](modules.md#getidrangeswithomitemptycasehandled)
-   [GetIdxSpanForRange](modules.md#getidxspanforrange)
-   [GetIdxToInsertForNewId](modules.md#getidxtoinsertfornewid)
-   [GetMetadataRoute](modules.md#getmetadataroute)
-   [GetOwnersRoute](modules.md#getownersroute)
-   [GetPermissionNumberValue](modules.md#getpermissionnumbervalue)
-   [GetPermissions](modules.md#getpermissions)
-   [GetPortfolioRoute](modules.md#getportfolioroute)
-   [GetSearchRoute](modules.md#getsearchroute)
-   [GetStatusRoute](modules.md#getstatusroute)
-   [InsertRangeToIdRanges](modules.md#insertrangetoidranges)
-   [MergePrevOrNextIfPossible](modules.md#mergeprevornextifpossible)
-   [NormalizeIdRange](modules.md#normalizeidrange)
-   [RemoveIdsFromIdRange](modules.md#removeidsfromidrange)
-   [SafeAdd](modules.md#safeadd)
-   [SafeSubtract](modules.md#safesubtract)
-   [SearchBalances](modules.md#searchbalances)
-   [SearchIdRangesForId](modules.md#searchidrangesforid)
-   [SetBalanceForIdRanges](modules.md#setbalanceforidranges)
-   [SortIdRangesAndMergeIfNecessary](modules.md#sortidrangesandmergeifnecessary)
-   [SubtractBalancesForIdRanges](modules.md#subtractbalancesforidranges)
-   [UpdateBalancesForIdRanges](modules.md#updatebalancesforidranges)
-   [UpdatePermissions](modules.md#updatepermissions)
-   [ValidatePermissions](modules.md#validatepermissions)
-   [ValidatePermissionsUpdate](modules.md#validatepermissionsupdate)
-   [checkIfApproved](modules.md#checkifapproved)
-   [checkIfApprovedInTransferList](modules.md#checkifapprovedintransferlist)
-   [checkIfIdRangesOverlap](modules.md#checkifidrangesoverlap)
-   [convertToBitBadgesUserInfo](modules.md#converttobitbadgesuserinfo)
-   [convertToBitBadgesAddress](modules.md#converttocosmosaddress)
-   [createCollectionFromMsgNewCollection](modules.md#createcollectionfrommsgnewcollection)
-   [doesChainMatchName](modules.md#doeschainmatchname)
-   [filterTokenActivityForBadgeId](modules.md#filterbadgeactivityforbadgeid)
-   [getAbbreviatedAddress](modules.md#getabbreviatedaddress)
-   [getBadgeIdsToDisplayForPageNumber](modules.md#getbadgeidstodisplayforpagenumber)
-   [getBalanceAfterTransfer](modules.md#getbalanceaftertransfer)
-   [getBalanceAfterTransfers](modules.md#getbalanceaftertransfers)
-   [getBlankBalance](modules.md#getblankbalance)
-   [getChainForAddress](modules.md#getchainforaddress)
-   [getClaimsFromClaimItems](modules.md#getclaimsfromclaimitems)
-   [getIdRangesForAllBadgeIdsInCollection](modules.md#getidrangesforallbadgeidsincollection)
-   [getMatchingAddressesFromTransferList](modules.md#getmatchingaddressesfromtransferlist)
-   [getMaxBatchId](modules.md#getmaxbatchid)
-   [getMetadataForBadgeId](modules.md#getmetadataforbadgeid)
-   [getMetadataMapObjForBadgeId](modules.md#getmetadatamapobjforbadgeid)
-   [getNonTransferableDisallowedTransfers](modules.md#getnontransferabledisallowedtransfers)
-   [getSupplyByBadgeId](modules.md#getsupplybybadgeid)
-   [getTransferListForSelectOptions](modules.md#gettransferlistforselectoptions)
-   [getTransfersFromClaimItems](modules.md#gettransfersfromclaimitems)
-   [isAddressValid](modules.md#isaddressvalid)
-   [isTransferListFull](modules.md#istransferlistfull)
-   [populateFieldsOfOtherBadges](modules.md#populatefieldsofotherbadges)
-   [updateMetadataForBadgeIdsFromIndexerIfAbsent](modules.md#updatemetadataforbadgeidsfromindexerifabsent)
-   [updateMetadataMap](modules.md#updatemetadatamap)
-   [updateTransferListAccountNums](modules.md#updatetransferlistaccountnums)

## Type Aliases

### Permissions

∆¨ **Permissions**: `Object`

#### Type declaration

| Name                      | Type      |
| :------------------------ | :-------- |
| `CanCreateMoreBadges`     | `boolean` |
| `CanDelete`               | `boolean` |
| `CanManagerBeTransferred` | `boolean` |
| `CanUpdateBytes`          | `boolean` |
| `CanUpdateDisallowed`     | `boolean` |
| `CanUpdateUris`           | `boolean` |

#### Defined in

[permissions.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L3)

## Variables

### AllAddressesTransferList

‚Ä¢ `Const` **AllAddressesTransferList**: [`TransferList`](interfaces/TransferList.md)

#### Defined in

[badges.ts:109](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L109)

---

### CHAIN_DETAILS

‚Ä¢ `Const` **CHAIN_DETAILS**: `Object`

#### Type declaration

| Name            | Type     |
| :-------------- | :------- |
| `chainId`       | `number` |
| `cosmosChainId` | `string` |

#### Defined in

[constants.ts:9](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L9)

---

### CanCreateMoreBadgesDigit

‚Ä¢ `Const` **CanCreateMoreBadgesDigit**: `2`

#### Defined in

[permissions.ts:16](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L16)

---

### CanDeleteDigit

‚Ä¢ `Const` **CanDeleteDigit**: `6`

#### Defined in

[permissions.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L12)

---

### CanManagerBeTransferredDigit

‚Ä¢ `Const` **CanManagerBeTransferredDigit**: `4`

#### Defined in

[permissions.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L14)

---

### CanUpdateBytesDigit

‚Ä¢ `Const` **CanUpdateBytesDigit**: `5`

#### Defined in

[permissions.ts:13](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L13)

---

### CanUpdateDisallowedDigit

‚Ä¢ `Const` **CanUpdateDisallowedDigit**: `1`

#### Defined in

[permissions.ts:17](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L17)

---

### CanUpdateUrisDigit

‚Ä¢ `Const` **CanUpdateUrisDigit**: `3`

#### Defined in

[permissions.ts:15](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L15)

---

### DefaultPlaceholderMetadata

‚Ä¢ `Const` **DefaultPlaceholderMetadata**: [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[constants.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L14)

---

### ErrorMetadata

‚Ä¢ `Const` **ErrorMetadata**: [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[constants.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L20)

---

### GO_MAX_UINT_64

‚Ä¢ `Const` **GO_MAX_UINT_64**: `1000000000000000`

#### Defined in

[constants.ts:7](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L7)

---

### MAX_DATE_TIMESTAMP

‚Ä¢ `Const` **MAX_DATE_TIMESTAMP**: `number`

#### Defined in

[constants.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L5)

---

### METADATA_PAGE_LIMIT

‚Ä¢ `Const` **METADATA_PAGE_LIMIT**: `100`

#### Defined in

[constants.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L3)

---

### MINT_ACCOUNT

‚Ä¢ `Const` **MINT_ACCOUNT**: [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Defined in

[chains.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L5)

---

### NUM_PERMISSIONS

‚Ä¢ `Const` **NUM_PERMISSIONS**: `6`

#### Defined in

[permissions.ts:1](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L1)

## Functions

### AddBalancesForIdRanges

‚ñ∏ **AddBalancesForIdRanges**(`userBalanceInfo`, `ranges`, `balanceToAdd`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name              | Type                                       |
| :---------------- | :----------------------------------------- |
| `userBalanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |
| `ranges`          | [`IdRange`](interfaces/IdRange.md)[]       |
| `balanceToAdd`    | `number`                                   |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:116](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L116)

---

### DeleteBalanceForIdRanges

‚ñ∏ **DeleteBalanceForIdRanges**(`ranges`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name             | Type                                 |
| :--------------- | :----------------------------------- |
| `ranges`         | [`IdRange`](interfaces/IdRange.md)[] |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:142](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L142)

---

### GetAccountByNumberRoute

‚ñ∏ **GetAccountByNumberRoute**(`id`): `string`

#### Parameters

| Name | Type     |
| :--- | :------- |
| `id` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:8](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L8)

---

### GetAccountRoute

‚ñ∏ **GetAccountRoute**(`bech32address`): `string`

#### Parameters

| Name            | Type     |
| :-------------- | :------- |
| `bech32address` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:4](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L4)

---

### GetAccountsRoute

‚ñ∏ **GetAccountsRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L12)

---

### GetBalanceRoute

‚ñ∏ **GetBalanceRoute**(`collectionId`, `accountNumber`): `string`

#### Parameters

| Name            | Type     |
| :-------------- | :------- |
| `collectionId`  | `number` |
| `accountNumber` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:28](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L28)

---

### GetBalanceInfoToInsertToStorage

‚ñ∏ **GetBalanceInfoToInsertToStorage**(`balanceInfo`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name          | Type                                       |
| :------------ | :----------------------------------------- |
| `balanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:254](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L254)

---

### GetBalanceRoute

‚ñ∏ **GetBalanceRoute**(`bech32address`): `string`

#### Parameters

| Name            | Type     |
| :-------------- | :------- |
| `bech32address` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:16](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L16)

---

### GetBalancesForIdRanges

‚ñ∏ **GetBalancesForIdRanges**(`badgeIds`, `currentUserBalances`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name                  | Type                                 |
| :-------------------- | :----------------------------------- |
| `badgeIds`            | [`IdRange`](interfaces/IdRange.md)[] |
| `currentUserBalances` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L36)

---

### GetCollectionRoute

‚ñ∏ **GetCollectionRoute**(`collectionId`): `string`

#### Parameters

| Name           | Type     |
| :------------- | :------- |
| `collectionId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L20)

---

### GetCollectionsRoute

‚ñ∏ **GetCollectionsRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:24](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L24)

---

### GetIdRangeToInsert

‚ñ∏ **GetIdRangeToInsert**(`start`, `end`): `Object`

#### Parameters

| Name    | Type     |
| :------ | :------- |
| `start` | `number` |
| `end`   | `number` |

#### Returns

`Object`

| Name    | Type     |
| :------ | :------- |
| `end`   | `number` |
| `start` | `number` |

#### Defined in

[idRanges.ts:152](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L152)

---

### GetIdRangesToInsertToStorage

‚ñ∏ **GetIdRangesToInsertToStorage**(`idRanges`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name       | Type                                 |
| :--------- | :----------------------------------- |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:31](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L31)

---

### GetIdRangesWithOmitEmptyCaseHandled

‚ñ∏ **GetIdRangesWithOmitEmptyCaseHandled**(`ids`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name  | Type                                 |
| :---- | :----------------------------------- |
| `ids` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:144](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L144)

---

### GetIdxSpanForRange

‚ñ∏ **GetIdxSpanForRange**(`targetRange`, `targetIdRanges`): [[`IdRange`](interfaces/IdRange.md), `boolean`]

#### Parameters

| Name             | Type                                 |
| :--------------- | :----------------------------------- |
| `targetRange`    | [`IdRange`](interfaces/IdRange.md)   |
| `targetIdRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[[`IdRange`](interfaces/IdRange.md), `boolean`]

#### Defined in

[idRanges.ts:111](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L111)

---

### GetIdxToInsertForNewId

‚ñ∏ **GetIdxToInsertForNewId**(`id`, `targetIds`): `number`

#### Parameters

| Name        | Type                                 |
| :---------- | :----------------------------------- |
| `id`        | `number`                             |
| `targetIds` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

`number`

#### Defined in

[idRanges.ts:176](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L176)

---

### GetMetadataRoute

‚ñ∏ **GetMetadataRoute**(`collectionId`): `string`

#### Parameters

| Name           | Type     |
| :------------- | :------- |
| `collectionId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:40](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L40)

---

### GetOwnersRoute

‚ñ∏ **GetOwnersRoute**(`collectionId`, `badgeId`): `string`

#### Parameters

| Name           | Type     |
| :------------- | :------- |
| `collectionId` | `number` |
| `badgeId`      | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:32](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L32)

---

### GetPermissionNumberValue

‚ñ∏ **GetPermissionNumberValue**(`permissions`): `number`

#### Parameters

| Name          | Type                                    |
| :------------ | :-------------------------------------- |
| `permissions` | [`Permissions`](modules.md#permissions) |

#### Returns

`number`

#### Defined in

[permissions.ts:19](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L19)

---

### GetPermissions

‚ñ∏ **GetPermissions**(`permissions`): [`Permissions`](modules.md#permissions)

#### Parameters

| Name          | Type     |
| :------------ | :------- |
| `permissions` | `number` |

#### Returns

[`Permissions`](modules.md#permissions)

#### Defined in

[permissions.ts:118](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L118)

---

### GetPortfolioRoute

‚ñ∏ **GetPortfolioRoute**(`accountNumber`): `string`

#### Parameters

| Name            | Type     |
| :-------------- | :------- |
| `accountNumber` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L36)

---

### GetSearchRoute

‚ñ∏ **GetSearchRoute**(`query`): `string`

#### Parameters

| Name    | Type     |
| :------ | :------- |
| `query` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:44](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L44)

---

### GetStatusRoute

‚ñ∏ **GetStatusRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:48](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L48)

---

### InsertRangeToIdRanges

‚ñ∏ **InsertRangeToIdRanges**(`rangeToAdd`, `targetIds`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name         | Type                                 |
| :----------- | :----------------------------------- |
| `rangeToAdd` | [`IdRange`](interfaces/IdRange.md)   |
| `targetIds`  | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:274](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L274)

---

### MergePrevOrNextIfPossible

‚ñ∏ **MergePrevOrNextIfPossible**(`targetIds`, `insertedAtIdx`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name            | Type                                 |
| :-------------- | :----------------------------------- |
| `targetIds`     | [`IdRange`](interfaces/IdRange.md)[] |
| `insertedAtIdx` | `number`                             |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:218](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L218)

---

### NormalizeIdRange

‚ñ∏ **NormalizeIdRange**(`rangeToNormalize`): `Object`

#### Parameters

| Name               | Type                               |
| :----------------- | :--------------------------------- |
| `rangeToNormalize` | [`IdRange`](interfaces/IdRange.md) |

#### Returns

`Object`

| Name    | Type     |
| :------ | :------- |
| `end`   | `number` |
| `start` | `number` |

#### Defined in

[idRanges.ts:164](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L164)

---

### RemoveIdsFromIdRange

‚ñ∏ **RemoveIdsFromIdRange**(`rangeToRemove`, `rangeObject`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name            | Type                               |
| :-------------- | :--------------------------------- |
| `rangeToRemove` | [`IdRange`](interfaces/IdRange.md) |
| `rangeObject`   | [`IdRange`](interfaces/IdRange.md) |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:47](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L47)

---

### SafeAdd

‚ñ∏ **SafeAdd**(`left`, `right`): `number`

#### Parameters

| Name    | Type     |
| :------ | :------- |
| `left`  | `number` |
| `right` | `number` |

#### Returns

`number`

#### Defined in

[balances-gpt.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L5)

---

### SafeSubtract

‚ñ∏ **SafeSubtract**(`left`, `right`): `number`

#### Parameters

| Name    | Type     |
| :------ | :------- |
| `left`  | `number` |
| `right` | `number` |

#### Returns

`number`

#### Defined in

[balances-gpt.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L14)

---

### SearchBalances

‚ñ∏ **SearchBalances**(`targetAmount`, `balanceObjects`): (`number` \| `boolean`)[]

#### Parameters

| Name             | Type                                 |
| :--------------- | :----------------------------------- |
| `targetAmount`   | `number`                             |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

(`number` \| `boolean`)[]

#### Defined in

[balances-gpt.ts:224](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L224)

---

### SearchIdRangesForId

‚ñ∏ **SearchIdRangesForId**(`id`, `idRanges`): [`number`, `boolean`]

#### Parameters

| Name       | Type                                 |
| :--------- | :----------------------------------- |
| `id`       | `number`                             |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`number`, `boolean`]

#### Defined in

[idRanges.ts:92](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L92)

---

### SetBalanceForIdRanges

‚ñ∏ **SetBalanceForIdRanges**(`ranges`, `amount`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name             | Type                                 |
| :--------------- | :----------------------------------- |
| `ranges`         | [`IdRange`](interfaces/IdRange.md)[] |
| `amount`         | `number`                             |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:183](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L183)

---

### SortIdRangesAndMergeIfNecessary

‚ñ∏ **SortIdRangesAndMergeIfNecessary**(`idRanges`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name       | Type                                 |
| :--------- | :----------------------------------- |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L3)

---

### SubtractBalancesForIdRanges

‚ñ∏ **SubtractBalancesForIdRanges**(`userBalanceInfo`, `ranges`, `balanceToRemove`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name              | Type                                       |
| :---------------- | :----------------------------------------- |
| `userBalanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |
| `ranges`          | [`IdRange`](interfaces/IdRange.md)[]       |
| `balanceToRemove` | `number`                                   |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:129](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L129)

---

### UpdateBalancesForIdRanges

‚ñ∏ **UpdateBalancesForIdRanges**(`ranges`, `newAmount`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name             | Type                                 |
| :--------------- | :----------------------------------- |
| `ranges`         | [`IdRange`](interfaces/IdRange.md)[] |
| `newAmount`      | `number`                             |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:22](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L22)

---

### UpdatePermissions

‚ñ∏ **UpdatePermissions**(`currPermissions`, `permissionDigit`, `value`): `number`

#### Parameters

| Name              | Type      |
| :---------------- | :-------- |
| `currPermissions` | `number`  |
| `permissionDigit` | `number`  |
| `value`           | `boolean` |

#### Returns

`number`

#### Defined in

[permissions.ts:97](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L97)

---

### ValidatePermissions

‚ñ∏ **ValidatePermissions**(`permissions`): `void`

#### Parameters

| Name          | Type     |
| :------------ | :------- |
| `permissions` | `number` |

#### Returns

`void`

#### Defined in

[permissions.ts:53](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L53)

---

### ValidatePermissionsUpdate

‚ñ∏ **ValidatePermissionsUpdate**(`oldPermissions`, `newPermissions`): `void`

#### Parameters

| Name             | Type     |
| :--------------- | :------- |
| `oldPermissions` | `number` |
| `newPermissions` | `number` |

#### Returns

`void`

#### Defined in

[permissions.ts:60](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L60)

---

### checkIfApproved

‚ñ∏ **checkIfApproved**(`userBalance`, `accountNumber`, `balancesToCheck`): `boolean`

#### Parameters

| Name              | Type                                       |
| :---------------- | :----------------------------------------- |
| `userBalance`     | [`UserBalance`](interfaces/UserBalance.md) |
| `accountNumber`   | `number`                                   |
| `balancesToCheck` | [`Balance`](interfaces/Balance.md)[]       |

#### Returns

`boolean`

#### Defined in

[badges.ts:311](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L311)

---

### checkIfApprovedInTransferList

‚ñ∏ **checkIfApprovedInTransferList**(`addresses`, `connectedUser`, `managerAccountNumber`): `boolean`

#### Parameters

| Name                   | Type                                                   |
| :--------------------- | :----------------------------------------------------- |
| `addresses`            | [`Addresses`](interfaces/Addresses.md)                 |
| `connectedUser`        | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md) |
| `managerAccountNumber` | `number`                                               |

#### Returns

`boolean`

#### Defined in

[badges.ts:130](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L130)

---

### checkIfIdRangesOverlap

‚ñ∏ **checkIfIdRangesOverlap**(`idRanges`): `boolean`

#### Parameters

| Name       | Type                                 |
| :--------- | :----------------------------------- |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

`boolean`

#### Defined in

[idRanges.ts:301](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L301)

---

### convertToBitBadgesUserInfo

‚ñ∏ **convertToBitBadgesUserInfo**(`accountInfo`): [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Parameters

| Name          | Type                                               |
| :------------ | :------------------------------------------------- |
| `accountInfo` | [`AccountResponse`](interfaces/AccountResponse.md) |

#### Returns

[`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Defined in

[users.ts:4](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/users.ts#L4)

---

### convertToBitBadgesAddress

‚ñ∏ **convertToBitBadgesAddress**(`address`): `string`

#### Parameters

| Name      | Type     |
| :-------- | :------- |
| `address` | `string` |

#### Returns

`string`

#### Defined in

[chains.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L12)

---

### createCollectionFromMsgNewCollection

‚ñ∏ **createCollectionFromMsgNewCollection**(`msgNewCollection`, `collectionMetadata`, `individualBadgeMetadata`, `connectedUser`, `claimItems`, `existingCollection?`): [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)

#### Parameters

| Name                      | Type                                                       |
| :------------------------ | :--------------------------------------------------------- |
| `msgNewCollection`        | `MessageMsgNewCollection`                                  |
| `collectionMetadata`      | [`BadgeMetadata`](interfaces/BadgeMetadata.md)             |
| `individualBadgeMetadata` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)       |
| `connectedUser`           | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)     |
| `claimItems`              | [`ClaimItemWithTrees`](interfaces/ClaimItemWithTrees.md)[] |
| `existingCollection?`     | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)   |

#### Returns

[`BitBadgeCollection`](interfaces/BitBadgeCollection.md)

#### Defined in

[badges.ts:29](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L29)

---

### doesChainMatchName

‚ñ∏ **doesChainMatchName**(`chain`, `name?`): `boolean`

#### Parameters

| Name    | Type                                        |
| :------ | :------------------------------------------ |
| `chain` | [`SupportedChain`](enums/SupportedChain.md) |
| `name?` | `string`                                    |

#### Returns

`boolean`

#### Defined in

[chains.ts:87](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L87)

---

### filterTokenActivityForBadgeId

‚ñ∏ **filterTokenActivityForBadgeId**(`badgeId`, `activity`): [`TransferActivityItem`](interfaces/TransferActivityItem.md)[]

#### Parameters

| Name       | Type                                                           |
| :--------- | :------------------------------------------------------------- |
| `badgeId`  | `number`                                                       |
| `activity` | [`TransferActivityItem`](interfaces/TransferActivityItem.md)[] |

#### Returns

[`TransferActivityItem`](interfaces/TransferActivityItem.md)[]

#### Defined in

[badges.ts:10](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L10)

---

### getAbbreviatedAddress

‚ñ∏ **getAbbreviatedAddress**(`address`): `string`

#### Parameters

| Name      | Type     |
| :-------- | :------- |
| `address` | `string` |

#### Returns

`string`

#### Defined in

[chains.ts:46](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L46)

---

### getBadgeIdsToDisplayForPageNumber

‚ñ∏ **getBadgeIdsToDisplayForPageNumber**(`collections?`, `startIdxNum`, `pageSize`): { `badgeIds`: `number`[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) }[]

#### Parameters

| Name          | Type                                                                                                                            | Default value |
| :------------ | :------------------------------------------------------------------------------------------------------------------------------ | :------------ |
| `collections` | { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) }[] | `[]`          |
| `startIdxNum` | `number`                                                                                                                        | `undefined`   |
| `pageSize`    | `number`                                                                                                                        | `undefined`   |

#### Returns

{ `badgeIds`: `number`[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) }[]

#### Defined in

[badges.ts:197](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L197)

---

### getBalanceAfterTransfer

‚ñ∏ **getBalanceAfterTransfer**(`balance`, `startSubbadgeId`, `endSubbadgeId`, `amountToTransfer`, `numRecipients`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name               | Type                                       |
| :----------------- | :----------------------------------------- |
| `balance`          | [`UserBalance`](interfaces/UserBalance.md) |
| `startSubbadgeId`  | `number`                                   |
| `endSubbadgeId`    | `number`                                   |
| `amountToTransfer` | `number`                                   |
| `numRecipients`    | `number`                                   |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L14)

---

### getBalanceAfterTransfers

‚ñ∏ **getBalanceAfterTransfers**(`balance`, `transfers`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name        | Type                                                     |
| :---------- | :------------------------------------------------------- |
| `balance`   | [`UserBalance`](interfaces/UserBalance.md)               |
| `transfers` | [`TransfersExtended`](interfaces/TransfersExtended.md)[] |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:21](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L21)

---

### getBlankBalance

‚ñ∏ **getBlankBalance**(): [`UserBalance`](interfaces/UserBalance.md)

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L5)

---

### getChainForAddress

‚ñ∏ **getChainForAddress**(`address`): `SupportedChain`

#### Parameters

| Name      | Type     |
| :-------- | :------- |
| `address` | `string` |

#### Returns

`SupportedChain`

#### Defined in

[chains.ts:26](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L26)

---

### getClaimsFromClaimItems

‚ñ∏ **getClaimsFromClaimItems**(`balance`, `claimItems`): `Object`

#### Parameters

| Name         | Type                                                       |
| :----------- | :--------------------------------------------------------- |
| `balance`    | [`UserBalance`](interfaces/UserBalance.md)                 |
| `claimItems` | [`ClaimItemWithTrees`](interfaces/ClaimItemWithTrees.md)[] |

#### Returns

`Object`

| Name                   | Type                               |
| :--------------------- | :--------------------------------- |
| `claims`               | [`Claims`](interfaces/Claims.md)[] |
| `undistributedBalance` | `any`                              |

#### Defined in

[claims.ts:63](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/claims.ts#L63)

---

### getIdRangesForAllBadgeIdsInCollection

‚ñ∏ **getIdRangesForAllBadgeIdsInCollection**(`collection`): `any`

#### Parameters

| Name         | Type                                                     |
| :----------- | :------------------------------------------------------- |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`any`

#### Defined in

[badges.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L20)

---

### getMatchingAddressesFromTransferList

‚ñ∏ **getMatchingAddressesFromTransferList**(`list`, `toAddresses`, `chain`, `managerAccountNumber`): `any`[]

#### Parameters

| Name                   | Type                                                     |
| :--------------------- | :------------------------------------------------------- |
| `list`                 | [`TransferList`](interfaces/TransferList.md)[]           |
| `toAddresses`          | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)[] |
| `chain`                | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)   |
| `managerAccountNumber` | `number`                                                 |

#### Returns

`any`[]

#### Defined in

[badges.ts:153](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L153)

---

### getMaxBatchId

‚ñ∏ **getMaxBatchId**(`collection`): `number`

#### Parameters

| Name         | Type                                                     |
| :----------- | :------------------------------------------------------- |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`number`

#### Defined in

[badges.ts:245](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L245)

---

### getMetadataForBadgeId

‚ñ∏ **getMetadataForBadgeId**(`badgeId`, `metadataMap`): `undefined` \| [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Parameters

| Name          | Type                                                 |
| :------------ | :--------------------------------------------------- |
| `badgeId`     | `number`                                             |
| `metadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |

#### Returns

`undefined` \| [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[badges.ts:183](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L183)

---

### getMetadataMapObjForBadgeId

‚ñ∏ **getMetadataMapObjForBadgeId**(`badgeId`, `metadataMap`): `undefined` \| { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `metadata`: [`BadgeMetadata`](interfaces/BadgeMetadata.md) ; `uri`: `string` }

#### Parameters

| Name          | Type                                                 |
| :------------ | :--------------------------------------------------- |
| `badgeId`     | `number`                                             |
| `metadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |

#### Returns

`undefined` \| { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `metadata`: [`BadgeMetadata`](interfaces/BadgeMetadata.md) ; `uri`: `string` }

#### Defined in

[badges.ts:170](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L170)

---

### getNonTransferableDisallowedTransfers

‚ñ∏ **getNonTransferableDisallowedTransfers**(): `any`[]

#### Returns

`any`[]

#### Defined in

[badges.ts:105](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L105)

---

### getSupplyByBadgeId

‚ñ∏ **getSupplyByBadgeId**(`badgeId`, `balances`): `number`

#### Parameters

| Name       | Type                                 |
| :--------- | :----------------------------------- |
| `badgeId`  | `number`                             |
| `balances` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

`number`

#### Defined in

[balances.ts:48](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L48)

---

### getTransferListForSelectOptions

‚ñ∏ **getTransferListForSelectOptions**(`isFromList`, `unregistered`, `users`, `all`, `none`, `everyoneExcept`): `undefined` \| [`TransferListWithUnregisteredUsers`](interfaces/TransferListWithUnregisteredUsers.md)

#### Parameters

| Name             | Type                                                     |
| :--------------- | :------------------------------------------------------- |
| `isFromList`     | `boolean`                                                |
| `unregistered`   | `string`[]                                               |
| `users`          | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)[] |
| `all`            | `boolean`                                                |
| `none`           | `boolean`                                                |
| `everyoneExcept` | `boolean`                                                |

#### Returns

`undefined` \| [`TransferListWithUnregisteredUsers`](interfaces/TransferListWithUnregisteredUsers.md)

#### Defined in

[transferLists.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L36)

---

### getTransfersFromClaimItems

‚ñ∏ **getTransfersFromClaimItems**(`claimItems`, `accounts`): [`TransfersExtended`](interfaces/TransfersExtended.md)[]

#### Parameters

| Name         | Type                                     |
| :----------- | :--------------------------------------- |
| `claimItems` | [`ClaimItem`](interfaces/ClaimItem.md)[] |
| `accounts`   | [`AccountMap`](interfaces/AccountMap.md) |

#### Returns

[`TransfersExtended`](interfaces/TransfersExtended.md)[]

#### Defined in

[claims.ts:6](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/claims.ts#L6)

---

### isAddressValid

‚ñ∏ **isAddressValid**(`address`, `chain?`): `boolean`

#### Parameters

| Name      | Type     |
| :-------- | :------- |
| `address` | `string` |
| `chain?`  | `string` |

#### Returns

`boolean`

#### Defined in

[chains.ts:55](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L55)

---

### isTransferListFull

‚ñ∏ **isTransferListFull**(`transfersList`): `boolean`

#### Parameters

| Name            | Type                                           |
| :-------------- | :--------------------------------------------- |
| `transfersList` | [`TransferList`](interfaces/TransferList.md)[] |

#### Returns

`boolean`

#### Defined in

[transferLists.ts:27](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L27)

---

### populateFieldsOfOtherBadges

‚ñ∏ **populateFieldsOfOtherBadges**(`individualBadgeMetadata`, `badgeIds`, `key`, `value`, `metadataToSet?`): [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Parameters

| Name                      | Type                                                 |
| :------------------------ | :--------------------------------------------------- |
| `individualBadgeMetadata` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `badgeIds`                | [`IdRange`](interfaces/IdRange.md)[]                 |
| `key`                     | `string`                                             |
| `value`                   | `any`                                                |
| `metadataToSet?`          | [`BadgeMetadata`](interfaces/BadgeMetadata.md)       |

#### Returns

[`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Defined in

[metadata.ts:61](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/metadata.ts#L61)

---

### updateMetadataForBadgeIdsFromIndexerIfAbsent

‚ñ∏ **updateMetadataForBadgeIdsFromIndexerIfAbsent**(`badgeIdsToDisplay`, `collection`): `number`[]

#### Parameters

| Name                | Type                                                     |
| :------------------ | :------------------------------------------------------- |
| `badgeIdsToDisplay` | `number`[]                                               |
| `collection`        | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`number`[]

#### Defined in

[badges.ts:264](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L264)

---

### updateMetadataMap

‚ñ∏ **updateMetadataMap**(`currMetadataMap`, `metadata`, `badgeIds`, `uri`): [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Parameters

| Name              | Type                                                 |
| :---------------- | :--------------------------------------------------- |
| `currMetadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `metadata`        | [`BadgeMetadata`](interfaces/BadgeMetadata.md)       |
| `badgeIds`        | [`IdRange`](interfaces/IdRange.md)                   |
| `uri`             | `string`                                             |

#### Returns

[`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Defined in

[metadata.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/metadata.ts#L5)

---

### updateTransferListAccountNums

‚ñ∏ **updateTransferListAccountNums**(`accountNumber`, `remove`, `transferListAddresses`): [`Addresses`](interfaces/Addresses.md)

#### Parameters

| Name                    | Type                                   |
| :---------------------- | :------------------------------------- |
| `accountNumber`         | `number`                               |
| `remove`                | `boolean`                              |
| `transferListAddresses` | [`Addresses`](interfaces/Addresses.md) |

#### Returns

[`Addresses`](interfaces/Addresses.md)

#### Defined in

[transferLists.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L5)


## File: ./.gitbook/includes/untitled.md

---
title: Untitled
---

{% file src="../assets/badge_logo.png" %}


## File: ./README.md

---
description: >-
    Here, you will find documentation about BitBadges, how it works, how to
    interact, and how to contribute!
---

# üëã BitBadges Overview

## üöÄ The Next-Generation Token Standard

BitBadges has built a brand new tokenization standard exclusively as a Cosmos SDK module, designed specifically for RWAs (Real World Assets), compliance, payments, and custom transferability requirements.

Unlike existing standards (`x/bank`, `x/tokenfactory`, `x/nft`, ICS20, ERC20, ERC-3643), our `x/badges` module provides native support for compliance checks on every transfer (even IBC transfers and in liquidity pools), custom transferability / compliance rules, issuer-level control, and enterprise-grade tokenization features‚Äîall out of the box with no code or smart contracts required, just a module! All plug-and-play and infinitely customizable.

Our revolutionary token standard goes far beyond ERC-20, ERC-721, and other existing standards with features like time-dependent ownership, fine-grained transferability controls, IBC compatibility, connecting to 7000+ apps, connecting to EVM, IBC, CosmWASM, and more.

Our theses are:

1. The next wave of tokenization needs a next-generation standard. Existing ones are not enough and built on outdated technology.
2. Compliance / transferability is not just a matter of a simple whitelist/blacklist or transferable vs soulbound. It is a complex series of moving parts (time-gating, ownerships, approvals, who can send to who?, initiated by who?, revokable? freezable?, and so on). To truly make compliance work on-chain, you need to handle all these moving parts automatically, not with a manually updated whitelist/blacklist. And, this belongs on the token standard level.
3. The standardized, reusable, no-code approach wins over per use-case smart contracts over time.

<figure><img src=".gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

## ‚ùì Why BitBadges?

BitBadges is simply tokenization-as-a-service. Create anything from subscriptions and memberships to tradable NFTs, credentials, and access tokens - all with the most advanced token standard ever built.

Traditional token standards are limited, inflexible, and locked to single blockchain ecosystems. BitBadges fixes this with a 100x improvement that supports:

-   **No Code, No Smart Contracts, No Audits** - Everything works out-of-the-box with no code. One reusable module.
-   **Compliance Checked Every Transfer, Swap, IBC Transfer** - Build complex transferability systems checked everywhere. No backdoors. Compliance checked every swap.
-   **Drop-In 1000x Upgrade -** We are a superset of existing standards. One line of code change for 1000x unlock in features.
-   **Supports Any IBC (ICS20) Currency -** We've designed it in a way such that it is seamlessly compatible with any ICS20 currency paired for payments, swaps, liquidity, or anything else.
-   **IBC Compatibility** - One interface, one token experience for all blockchain ecosystems via IBC.
-   **Time-Dependent Ownership** - Create subscriptions, time-locked tokens, and expiring credentials with time-dependent logic and approvals.
-   **Advanced Transferability / Compliance** - Fine-grained controls over who can transfer what, when, and how on any level.
-   **Three Transferability Levels** - Customize transferability on the collection, sender,and recipient levels.
-   **Connect to 7000+ Apps** - Connect to 7000+ apps and integrations with seamless on/off-chain criteria checks
-   **Connect to Cosmos via IBC** - Connect to Cosmos and beyond via IBC and use the BitBadges token standard on any Cosmos chain
-   **Extend with CosmWASM or EVM Contracts** - Extend the BitBadges token standard with CosmWASM or EVM contracts or any other custom environment
-   **Customizable Permissions** - Flexible manager controls for collections

## ü§î Motive for building BitBadges?

The answer is simple. We believe in the potential of blockchains and interoperability, but this potential cannot be realized with the current infrastructure and token standards in place today.

## ‚ö†Ô∏è Problems with Existing Standards

Existing tokenization standards (ERC-20, ERC-721, CW-20, ICS-20, etc.) are **flawed from the ground up**:

-   **Too Simple** - Basic mint/transfer/burn functionality lacks the flexibility needed for 90% of real-world applications. The industry has been stuck with these limited standards for 10+ years due to technical debt.
-   **Vulnerable by Default** - Smart contract approach introduces new attack vectors with each token contract. Each deployment is a potential vulnerability.
-   **Complex & Expensive** - Requires extensive technical knowledge to implement, deploy, and maintain contracts.
-   **Low Interoperability** - Tokens are siloed to single ecosystems, forcing companies to split their userbase across chains.
-   **Fragmented Standards** - Many competing standards with incompatible twists create confusion and fragmentation.

**The whole tokenization approach needs a complete overhaul.**

## üí° Our Design Philosophy

BitBadges addresses these fundamental issues through core design decisions:

-   **Universality** - One standard powerful enough for any use case: NFTs, fungible tokens, subscriptions, credentials, RWAs, compliance, or anything you can imagine. One standard to rule them all.
-   **No-Code Module Approach** - Built as a Cosmos SDK module, not smart contracts. 99% of users will never need to write code, regardless of complexity. Promotes reusability and battle-tested security.
-   **Ever-Evolving** - Purpose-built for next-generation tokenization. We're not stuck in the past like ERC-20/721. New features are added continuously with no technical debt accrual.
-   **IBC-First** - Cosmos-native with IBC at the core. Custom wrappable to ICS-20/721, supports IBC denominations for payments/swaps/liquidity, and enables one-signature multi-hop IBC transfers.


## File: ./SUMMARY.md

# Table of contents

## Overview

* [üëã BitBadges Overview](README.md)
* [üé® Use Cases](overview/use-cases.md)
* [ü™ô BADGE](overview/badge.md)
* [üîó Official Links and Resources](overview/official-links.md)
* [ü§ù Brand Guidelines](overview/link-sharing.md)

## üèóÔ∏è Token Standard

* [üìö Overview](x-badges/README.md)
* [üéì Learn](learn/README.md)
  * [Explore!](learn/pre-readings.md)
  * [Manager / Permissions](learn/permissions.md)
  * [Balances](token-standard/learn/balance-system.md)
  * [Transferability / Approvals](learn/transferability.md)
  * [Approval Criteria](token-standard/learn/approval-criteria/README.md)
    * [Address Checks](token-standard/learn/approval-criteria/address-checks.md)
    * [Approval Trackers](token-standard/learn/approval-criteria/approval-trackers.md)
    * [Auto-Deletion Options](token-standard/learn/approval-criteria/auto-deletion-options.md)
    * [Token Ownership](token-standard/learn/approval-criteria/badge-ownership.md)
    * [Dynamic Store Challenges](token-standard/learn/approval-criteria/dynamic-store-challenges.md)
    * [ETH Signature Challenges](token-standard/learn/approval-criteria/eth-signature-challenges.md)
    * [Max Number of Transfers](token-standard/learn/approval-criteria/max-number-of-transfers.md)
    * [Merkle Challenges](token-standard/learn/approval-criteria/merkle-challenges.md)
    * [Override User Level Approvals](token-standard/learn/approval-criteria/overrides.md)
    * [Predetermined Balances](token-standard/learn/approval-criteria/predetermined-balances.md)
    * [Requires](token-standard/learn/approval-criteria/requires.md)
    * [Tallied Approval Amounts](token-standard/learn/approval-criteria/tallied-approval-amounts.md)
    * [Coin Transfers](token-standard/learn/approval-criteria/usdbadge-transfers.md)
    * [User Royalties](token-standard/learn/approval-criteria/user-royalties.md)
  * [Minting and Circulating Supply](learn/minting-and-circulating-supply.md)
  * [Auto-Scan vs. Prioritized Approvals](learn/auto-scan-and-prioritized-approvals.md)
  * [Alias Compatibility](learn/alias-compatibility.md)
  * [IBC Backed Minting](learn/ibc-backed-minting.md)
  * [Cosmos Coin Wrapper Paths](learn/cosmos-coin-wrapper-paths.md)
  * [Collection Configuration](token-standard/learn/collection-setup-fields.md)
  * [Address Lists](token-standard/learn/address-lists.md)
  * [UintRanges](token-standard/learn/uintrange.md)
* [üì® Messages](x-badges/messages/README.md)
  * [MsgCreateAddressLists](x-badges/messages/msg-create-address-lists.md)
  * [MsgCreateCollection](x-badges/messages/msg-create-collection.md)
  * [MsgCreateDynamicStore](x-badges/messages/msg-create-dynamic-store.md)
  * [MsgDeleteCollection](x-badges/messages/msg-delete-collection.md)
  * [MsgDeleteDynamicStore](x-badges/messages/msg-delete-dynamic-store.md)
  * [MsgDeleteIncomingApproval](x-badges/messages/msg-delete-incoming-approval.md)
  * [MsgDeleteOutgoingApproval](x-badges/messages/msg-delete-outgoing-approval.md)
  * [MsgPurgeApprovals](x-badges/messages/msg-purge-approvals.md)
  * [MsgSetTokenMetadata](token-standard/messages/msgsettokenmetadata.md)
  * [MsgSetCollectionApprovals](x-badges/messages/msg-set-collection-approvals.md)
  * [MsgSetCollectionMetadata](x-badges/messages/msg-set-collection-metadata.md)
  * [MsgSetCustomData](x-badges/messages/msg-set-custom-data.md)
  * [MsgSetDynamicStoreValue](x-badges/messages/msg-set-dynamic-store-value.md)
  * [MsgSetIncomingApproval](x-badges/messages/msg-set-incoming-approval.md)
  * [MsgSetIsArchived](x-badges/messages/msg-set-is-archived.md)
  * [MsgSetManager](x-badges/messages/msg-set-manager.md)
  * [MsgSetOutgoingApproval](x-badges/messages/msg-set-outgoing-approval.md)
  * [MsgSetStandards](x-badges/messages/msg-set-standards.md)
  * [MsgSetValidTokenIds](x-badges/messages/msg-set-valid-token-ids.md)
  * [MsgTransferTokens](x-badges/messages/msg-transfer-tokens.md)
  * [MsgUniversalUpdateCollection](x-badges/messages/msg-universal-update-collection.md)
  * [MsgUpdateCollection](x-badges/messages/msg-update-collection.md)
  * [MsgUpdateDynamicStore](x-badges/messages/msg-update-dynamic-store.md)
  * [MsgUpdateUserApprovals](x-badges/messages/msg-update-user-approvals.md)
* [üîç Queries](x-badges/queries/README.md)
  * [Node API](https://lcd.bitbadges.io/)
  * [GetAddressList](x-badges/queries/get-address-list.md)
  * [GetApprovalTracker](x-badges/queries/get-approval-tracker.md)
  * [GetBalance](x-badges/queries/get-balance.md)
  * [GetChallengeTracker](x-badges/queries/get-challenge-tracker.md)
  * [GetCollection](x-badges/queries/get-collection.md)
  * [GetDynamicStore](x-badges/queries/get-dynamic-store.md)
  * [GetDynamicStoreValue](x-badges/queries/get-dynamic-store-value.md)
  * [GetETHSignatureTracker](x-badges/queries/get-eth-signature-tracker.md)
  * [Params](x-badges/queries/params.md)
* [üí° Examples and Snippets](x-badges/examples/README.md)
  * [Base Collection Details](x-badges/examples/base-collection-details.md)
  * [Building Your Collection Approvals](x-badges/examples/building-collection-approvals.md)
  * [Building Your Collection Permissions](x-badges/examples/building-collection-permissions.md)
  * [Building User-Level Approvals](x-badges/examples/building-user-approvals.md)
  * [Building User-Level Permissions](x-badges/examples/building-user-permissions.md)
  * [Cosmos Coin Wrapper Tutorial](x-badges/examples/cosmos-coin-wrapper-example.md)
  * [Defining and Locking Circulating Supply](x-badges/examples/defining-circulating-supply.md)
  * [Empty Approval Criteria Template](x-badges/examples/empty-approval-criteria.md)
  * [Mint All Tokens to Self - Tutorial](x-badges/examples/mint-all-to-self-tutorial.md)
  * [Approvals](token-standard/examples/approvals/README.md)
    * [Admin Override Approval](x-badges/examples/approvals/admin-override-approval.md)
    * [Burnable Approval](x-badges/examples/approvals/burnable-approval.md)
    * [Cosmos Unwrapper Approval](x-badges/examples/approvals/cosmos-unwrapper-approval.md)
    * [Cosmos Wrapper Approval](x-badges/examples/approvals/cosmos-wrapper-approval.md)
    * [Transferable Approval](x-badges/examples/approvals/transferable-approval.md)
  * [Message Transfer Examples](x-badges/examples/msg-transfer/README.md)
    * [Simple Token Transfer](x-badges/examples/msg-transfer/simple-badge-transfer.md)
    * [Transfer with Precalculation](x-badges/examples/msg-transfer/transfer-with-precalculation.md)
  * [Permission Examples](x-badges/examples/permissions/README.md)
    * [Freezing Mint Transferability](x-badges/examples/permissions/freezing-mint-transferability.md)
    * [Locking Specific Approval ID](x-badges/examples/permissions/locking-specific-approval-id.md)
    * [Locking Specific Token IDs](x-badges/examples/permissions/locking-specific-token-ids.md)
    * [Locking Valid Token IDs](x-badges/examples/permissions/locking-valid-token-ids.md)
  * [Transaction Examples](x-badges/examples/txs/README.md)
    * [MsgCreateCollection Examples](x-badges/examples/txs/msgcreatecollection/README.md)
      * [Quest Token Collection Example](x-badges/examples/txs/msgcreatecollection/quest-badge-collection.md)
      * [Tradable Collection Example](x-badges/examples/txs/msgcreatecollection/tradable-nft-collection.md)
    * [MsgUpdateUserApprovals Examples](x-badges/examples/txs/msgupdate-user-approvals/README.md)
      * [Updating Outgoing Approvals](x-badges/examples/txs/msgupdate-user-approvals/updating-outgoing-approvals.md)
* [‚õìÔ∏è Integrating The Module?](token-standard/integrating-the-module/README.md)
  * [Supporting Multiple Standards](token-standard/integrating-the-module/support-multiple-standards.md)
  * [Custom Extension Hooks](token-standard/integrating-the-module/custom-extension-hooks.md)
* [‚ùì FAQ](overview/faq.md)
* [üêô Source Code](https://github.com/BitBadges/bitbadgeschain/tree/master/x/badges)
* [‚úâÔ∏è Proto Type Definitions](https://github.com/BitBadges/bitbadgeschain/tree/master/proto/badges)

## ‚å®Ô∏è For Developers

* [üî® Getting Started](for-developers/getting-started.md)
* [üìö BitBadges API](for-developers/bitbadges-api/README.md)
  * [Getting Started](for-developers/bitbadges-api/api.md)
  * [Estimating Swaps](for-developers/bitbadges-api/estimating-swaps.md)
  * [Standard API Reference](https://bitbadges.stoplight.io/docs/bitbadges)
  * [Blockchain API Reference](https://lcd.bitbadges.io/)
  * [Typed SDK Types](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html)
  * [Create, Generate, and Sign Txs](for-developers/bitbadges-blockchain/create-and-broadcast-txs/README.md)
  * [Upgrading an API Key Tier](for-developers/bitbadges-api/upgrading-an-api-key-tier.md)
  * [Concepts](for-developers/bitbadges-api/concepts/README.md)
    * [Refresh / Claim Completion Queue](for-developers/bitbadges-api/concepts/refresh-queue.md)
    * [Limits / Restrictions](for-developers/bitbadges-api/concepts/limits-restrictions.md)
    * [Managing Views](for-developers/bitbadges-api/concepts/managing-views.md)
  * [Sign In with BitBadges (OAuth)](for-developers/sign-in-with-bitbadges/README.md)
    * [Overview](for-developers/sign-in-with-bitbadges/overview.md)
    * [Templates and Frameworks](for-developers/sign-in-with-bitbadges/templates-and-frameworks/README.md)
      * [WordPress](for-developers/sign-in-with-bitbadges/templates-and-frameworks/wordpress.md)
      * [Auth0](for-developers/sign-in-with-bitbadges/templates-and-frameworks/auth0.md)
      * [ExpressJS](for-developers/sign-in-with-bitbadges/templates-and-frameworks/expressjs.md)
      * [Discourse](for-developers/sign-in-with-bitbadges/templates-and-frameworks/discourse.md)
      * [Supabase](for-developers/sign-in-with-bitbadges/templates-and-frameworks/supabase.md)
      * [Others](for-developers/sign-in-with-bitbadges/templates-and-frameworks/others.md)
    * [Setting Up an App](for-developers/sign-in-with-bitbadges/setting-up-an-app.md)
    * [Authorization URL](for-developers/sign-in-with-bitbadges/authorization-url/README.md)
      * [Configuration](for-developers/sign-in-with-bitbadges/authorization-url/configuration.md)
      * [Generating the URL](for-developers/sign-in-with-bitbadges/authorization-url/generating-the-url.md)
    * [Redirect Callback](for-developers/sign-in-with-bitbadges/approaches/redirected-callback.md)
    * [Verification](for-developers/sign-in-with-bitbadges/verification/README.md)
      * [Verification Flow](for-developers/sign-in-with-bitbadges/verification/verification-flow.md)
      * [Access Tokens](for-developers/sign-in-with-bitbadges/verification/access-tokens.md)
      * [Security Considerations](for-developers/sign-in-with-bitbadges/verification/security-considerations.md)
    * [Blockin Docs](https://blockin.gitbook.io/blockin)
* [‚öíÔ∏è BitBadges JS / SDK](for-developers/bitbadges-sdk/README.md)
  * [Overview](for-developers/bitbadges-sdk/overview.md)
  * [SDK Types](for-developers/bitbadges-sdk/sdk-types.md)
  * [Common Snippets](for-developers/bitbadges-sdk/common-snippets/README.md)
    * [Address Conversions](for-developers/bitbadges-sdk/common-snippets/address-conversions.md)
    * [NumberType Conversions](for-developers/bitbadges-sdk/common-snippets/numbertype-conversions.md)
    * [Uint Ranges](for-developers/bitbadges-sdk/common-snippets/uint-ranges.md)
    * [Balances](for-developers/bitbadges-sdk/common-snippets/balances.md)
    * [Transfers](for-developers/bitbadges-sdk/common-snippets/transfers-w-increments.md)
    * [Address Lists](for-developers/bitbadges-sdk/common-snippets/address-lists.md)
    * [Token Metadata](for-developers/bitbadges-sdk/common-snippets/badge-metadata.md)
    * [Approvals / Transferability](for-developers/bitbadges-sdk/common-snippets/get-unhandled-approvals.md)
* [‚õìÔ∏è BitBadges Blockchain](for-developers/bitbadges-blockchain/README.md)
  * [Overview](for-developers/bitbadges-blockchain/overview.md)
  * [BitBadges Explorer](https://explorer.bitbadges.io/)
  * [Registry Details](https://github.com/cosmos/chain-registry/tree/master/bitbadges)
  * [Supported IBC Connections](https://github.com/cosmos/chain-registry/tree/master/_IBC)
  * [Supported Denoms](for-developers/bitbadges-blockchain/supported-denoms.md)
  * [Create a WASM Contract](for-developers/bitbadges-blockchain/create-a-wasm-contract.md)
  * [Run a Mainnet Node](for-developers/bitbadges-blockchain/run-a-mainnet-node.md)
  * [Create, Generate, and Sign Txs](for-developers/bitbadges-blockchain/create-and-broadcast-txs/README.md)
    * [Transaction Context](for-developers/bitbadges-blockchain/create-and-broadcast-txs/transaction-context.md)
    * [Generate Msg Contents](for-developers/bitbadges-blockchain/create-and-broadcast-txs/generate-msg-contents.md)
    * [Signing - Cosmos](for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-cosmos.md)
    * [Broadcast to a Node](for-developers/bitbadges-blockchain/create-and-broadcast-txs/broadcast-to-a-node.md)
    * [Sign + Broadcast - bitbadges.io](for-developers/bitbadges-blockchain/create-and-broadcast-txs/sign-+-broadcast-bitbadges.io.md)
  * [Testnet Mode](for-developers/bitbadges-blockchain/testnet-mode.md)
* [üéÅ BitBadges Claims](overview/claim-builder/README.md)
  * [Overview](for-developers/claim-builder/overview.md)
  * [Concepts](for-developers/claim-builder/concepts/README.md)
    * [Standard vs On-Demand](for-developers/claim-builder/concepts/standard-vs-on-demand.md)
    * [Completion Methods](for-developers/claim-builder/completion-methods.md)
    * [Gating On-Chain Approvals](for-developers/claim-builder/concepts/gating-badge-distribution.md)
    * [Claim Numbers](for-developers/claim-builder/concepts/claim-numbers.md)
    * [Success Logic](for-developers/claim-builder/success-logic.md)
    * [Signed In vs Select Address](for-developers/claim-builder/concepts/signed-in-vs-select-address.md)
    * [Universal Approach - Claim Codes](for-developers/claim-builder/concepts/universal-approach-claim-codes.md)
    * [Identify By Socials / Emails?](for-developers/claim-builder/concepts/identify-by-socials-emails.md)
  * [Checking Custom Criteria](for-developers/claim-builder/checking-custom-criteria.md)
  * [Implementing Custom Utility](for-developers/claim-builder/implementing-custom-utility.md)
  * [Leveraging AI](for-developers/claim-builder/leveraging-ai.md)
  * [BitBadges API & Claims](for-developers/claim-builder/bitbadges-api-claims/README.md)
    * [Verifying Claim Attempts w/ the API](for-developers/claim-builder/bitbadges-api-claims/verifying-claim-attempts-w-the-api.md)
    * [Fetching Claims](for-developers/claim-builder/bitbadges-api-claims/fetching-claims.md)
    * [Auto-Complete Claims w/ BitBadges API](for-developers/claim-builder/bitbadges-api-claims/auto-complete-claims-w-bitbadges-api.md)
  * [Dynamic Stores](for-developers/claim-builder/dynamic-stores/README.md)
    * [Overview](for-developers/claim-builder/dynamic-stores/overview.md)
    * [Adding Data](for-developers/claim-builder/dynamic-stores/adding-data.md)
  * [Custom Plugins / Webhooks](for-developers/claim-builder/plugins/README.md)
    * [Overview](for-developers/claim-builder/plugins/overview.md)
    * [Pre-Built Webhook Plugins](for-developers/claim-builder/plugins/creating-a-custom-plugin/alternatives.md)
    * [Creating a Custom Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/README.md)
      * [Implement Your Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/README.md)
        * [Getting Started](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/getting-started.md)
        * [Hook Types and Simulations](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/hook-types-and-simulations.md)
        * [Design Considerations](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/design-considerations.md)
        * [Parameters](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/parameters.md)
        * [Custom Inputs](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/user-inputs.md)
        * [API Handler](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/api-handler.md)
      * [Managing Your Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/managing-your-plugin.md)
      * [Testing Your Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/testing-your-plugin.md)
    * [Configuration Tools](for-developers/claim-builder/plugins/configuration-tools.md)
  * [Integrate with Zapier](for-developers/claim-builder/auto-completing-claims/automate-w-zapier/README.md)
    * [Overview](for-developers/claim-builder/auto-completing-claims/automate-w-zapier/overview.md)
    * [Dynamic Store Zaps](for-developers/claim-builder/automate-w-zapier/dynamic-store-zaps.md)
    * [Automatic Claim Tutorial](for-developers/claim-builder/auto-completing-claims/automate-w-zapier/automatic-claim-tutorial.md)
    * [Post-Success Zaps](for-developers/claim-builder/automate-w-zapier/post-success-zaps.md)
    * [Leveraging Zapier AI Actions / MCP](for-developers/claim-builder/automate-w-zapier/leveraging-zapier-ai-actions-mcp.md)
    * [Automate Any Part of the Process](for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/README.md)
      * [Google Forms](for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/google-forms.md)
  * [Integrate with Pipedream](for-developers/claim-builder/integrate-with-pipedream/README.md)
    * [Overview](for-developers/claim-builder/integrate-with-pipedream/overview.md)
    * [Leveraging Pipedream MCP](for-developers/claim-builder/integrate-with-pipedream/leveraging-pipedream-mcp.md)
    * [Build Custom Plugins](for-developers/claim-builder/integrate-with-pipedream/build-custom-plugins.md)
    * [Workflow Actions](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/README.md)
      * [Complete Claim](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/complete-claim.md)
      * [Get Claim Attempt Status](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-attempt-status.md)
      * [Get Claim Code by Idx](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-code-by-idx.md)
      * [Add User to Dynamic Store](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/add-user-to-dynamic-store.md)
    * [Workflow Triggers](for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/README.md)
      * [Poll Claim Attempts](for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/poll-claim-attempts.md)
    * [End to End Example](for-developers/claim-builder/integrate-with-pipedream/end-to-end-example.md)
  * [In-Site Plugins](for-developers/claim-builder/bitbadges-created-plugins/README.md)
    * [Plugins Directory](https://bitbadges.io/plugin-directory)
    * [Ownership Requirements](for-developers/claim-builder/bitbadges-created-plugins/ownership-requirements.md)
  * [Tutorials](for-developers/claim-builder/other-tutorials/README.md)
    * [In-Site Guides](for-developers/claim-builder/other-tutorials/in-site-guides.md)
    * [Get Integration User IDs](for-developers/claim-builder/other-tutorials/get-integration-user-ids/README.md)
      * [Get Discord User ID](for-developers/claim-builder/other-tutorials/get-integration-user-ids/get-discord-user-id.md)
      * [Get Discord Server ID](for-developers/claim-builder/other-tutorials/get-integration-user-ids/discord.md)
      * [X / Twitch / GitHub IDs](for-developers/claim-builder/other-tutorials/get-integration-user-ids/x-twitch-github-ids.md)
    * [Add Telegram Bot to Channel](for-developers/claim-builder/other-tutorials/add-telegram-bot-to-channel.md)

## Other Modules

* [üìö Overview](other-modules/README.md)
* [üíß x/gamm](other-modules/x-gamm/README.md)
  * [Overview](x-gamm/README.md)
  * [Introduction](x-gamm/introduction.md)
  * [Messages](x-gamm/messages/README.md)
    * [MsgCreateBalancerPool](x-gamm/messages/msg-create-balancer-pool.md)
    * [MsgExitPool](x-gamm/messages/msg-exit-pool.md)
    * [MsgJoinPool](x-gamm/messages/msg-join-pool.md)
    * [MsgSwapExactAmountIn](x-gamm/messages/msg-swap-exact-amount-in.md)
    * [MsgSwapExactAmountInWithIBCTransfer](x-gamm/messages/msg-swap-exact-amount-in-with-ibc-transfer.md)
* [üîó x/custom-ibc-hooks](other-modules/x-custom-ibc-hooks/README.md)
  * [Overview](x-custom-ibc-hooks/README.md)
  * [Introduction](x-custom-ibc-hooks/overview.md)
* [üö¶ x/ibc-rate-limit](other-modules/x-ibc-rate-limit/README.md)
  * [Overview](x-ibc-rate-limit/README.md)
  * [Introduction](x-ibc-rate-limit/overview.md)
* [üë• x/managersplitter](other-modules/x-managersplitter/README.md)
  * [Overview](x-managersplitter/README.md)
  * [Introduction](x-managersplitter/overview.md)
  * [Messages](x-managersplitter/messages/README.md)
    * [MsgCreateManagerSplitter](x-managersplitter/messages/msg-create-manager-splitter.md)
    * [MsgDeleteManagerSplitter](x-managersplitter/messages/msg-delete-manager-splitter.md)
    * [MsgExecuteUniversalUpdateCollection](x-managersplitter/messages/msg-execute-universal-update-collection.md)
    * [MsgUpdateManagerSplitter](x-managersplitter/messages/msg-update-manager-splitter.md)


## File: ./_docs/development-guide.md

# Documentation Development Guide

A concise guide for writing GitBook markdown documentation for BitBadges.

## Core Principles

### 1. Be Concise

**Bad:**

```markdown
In this section, we will be discussing the various aspects and components that make up the transfer validation process, which is a critical part of how the system ensures that all transfers are properly validated before they are executed.
```

**Good:**

```markdown
Transfers must pass validation before execution. The system checks balances, collection approvals, and user-level approvals.
```

### 2. Code Snippets Everywhere

Every section should include at least one code snippet, example, or graphic.

````markdown
## Creating a Collection

Use `MsgCreateCollection` to create a new badge collection:

```typescript
const msg = {
    typeUrl: '/bitbadges.badges.MsgCreateCollection',
    value: {
        creator: 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls',
        collectionId: '1',
        badges: [],
    },
};
```
````

````

### 3. Developer-First, Zero Assumptions

Use technical jargon freely, but explain concepts as if the reader has no prior knowledge.

```markdown
## UintRanges

UintRanges represent token ID ranges using string-based uint64 values. Use them for batch operations:

```typescript
const tokenIds: UintRange[] = [
  { start: '1', end: '100' },
  { start: '200', end: '300' },
];
````

**Why strings?** JavaScript's `Number.MAX_SAFE_INTEGER` is `2^53 - 1`, but uint64 supports up to `2^64 - 1`. Strings prevent precision loss.

````

## GitBook Markdown Syntax

### Frontmatter

**Do not include descriptions in frontmatter.** GitBook automatically generates descriptions from page titles and content.

```markdown
---
# No description field needed
---
````

### Content References

Link to related docs using GitBook's content reference syntax:

```markdown
{% content-ref url="../path/to/file.md" %}
[Link Text](../path/to/file.md)
{% endcontent-ref %}
```

### Images

Use GitBook's figure syntax with captions:

```markdown
<figure>
  <img src="../.gitbook/assets/image.png" alt="Description">
  <figcaption>Caption explaining the image</figcaption>
</figure>
```

### Code Blocks

Always specify language for syntax highlighting:

```typescript
// TypeScript example
const collection = { id: '1' };
```

```json
// JSON example
{
    "collectionId": "1",
    "badges": []
}
```

```bash
# Shell commands
bitbadgeschaind query badges collection 1
```

## Structure Guidelines

### Headers

**Avoid H1 headings:** GitBook automatically applies the page title as an H1. Start with H2 (`##`) or lower:

```markdown
# ‚ùå Don't use H1 - GitBook adds this automatically

## ‚úÖ Start with H2
```

Use descriptive headers. Prefer action-oriented titles:

```markdown
## Creating Collections

## Building Approvals

## Querying Balances
```

Not:

```markdown
## Collection Creation

## About Approvals

## Balance Information
```

### Nested Section READMEs

For parent pages with nested children, leave the README minimal or blank. GitBook automatically generates a table of contents:

```markdown
---
description: >-
    Brief description of the section
---

<!-- GitBook automatically shows child pages here -->
```

**Don't manually list child pages** - GitBook does this automatically from SUMMARY.md.

### Sections

Keep sections focused. If a section exceeds 300 words, split it:

```markdown
## Collection Configuration

### Base Fields

[Content here]

### Metadata

[Content here]

### Permissions

[Content here]
```

### Lists

Use lists for multiple items, steps, or options:

````markdown
## Transfer Validation Steps

1. **Balance Check**: Verify sender has sufficient tokens
2. **Collection Approval**: At least one approval must pass
3. **User Approvals**: Sender/recipient approvals must pass

```typescript
const validateTransfer = (transfer: Transfer) => {
    checkBalance(transfer);
    checkCollectionApprovals(transfer);
    checkUserApprovals(transfer);
};
```
````

````

## Code Examples

### Real Examples Only

Always use working, tested code:

```typescript
// ‚úÖ Good - Real, working example
const msg = {
  typeUrl: '/bitbadges.badges.MsgCreateCollection',
  value: {
    creator: 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls',
    collectionId: '1',
    badges: [],
  },
};

// ‚ùå Bad - Placeholder
const msg = {
  typeUrl: '...',
  value: {
    creator: 'YOUR_ADDRESS',
    // ...
  },
};
````

### Context Matters

Provide enough context for the example to be useful:

```typescript
import { MsgCreateCollection } from 'bitbadgesjs-sdk';

// Create a collection with 100 token IDs
const collection = {
    // ...
    validTokenIds: [{ start: '1', end: '100' }],
    manager: 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls',
};

const msg = MsgCreateCollection(collection);
```

### Common Patterns

Extract common patterns into reusable examples:

```typescript
// Use throughout documentation
const manager = 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls';
```

## Tables

Use tables for structured data:

```markdown
| Field           | Type        | Description                  |
| --------------- | ----------- | ---------------------------- |
| `collectionId`  | string      | Unique collection identifier |
| `validTokenIds` | UintRange[] | Valid token ID ranges        |
| `manager`       | string      | Manager address              |
```

## Cross-References

Link to related concepts liberally within the content, but avoid "Next Steps" sections at the end:

```markdown
## Collection Approvals

Collection approvals define transferability rules. See [User Approvals](./user-approvals.md) for sender/recipient-level controls.

For approval criteria details, see [Approval Criteria](../concepts/approval-criteria/).
```

**Don't add "Next Steps" sections:** Avoid adding a "Next Steps" section with links at the end of pages. Instead, embed relevant links naturally within the content where they're contextually relevant.

## Writing Style

### Active Voice

```markdown
‚úÖ The system validates transfers automatically.
‚ùå Transfers are validated automatically by the system.
```

### Direct Statements

```markdown
‚úÖ Use `MsgTransfer` to transfer tokens.
‚ùå You can use `MsgTransfer` if you want to transfer tokens.
```

### Technical Terms

Define terms on first use, then use freely:

```markdown
## Mint Address

The **Mint address** is a reserved address representing the collection's minting source. It has unlimited balances.

Transfers from the Mint address create new tokens. The Mint address cannot receive tokens.
```

### Avoid Redundant Explanations

Don't repeat information that's already explained in the text. If you've stated something, don't create a separate "Key properties" or "Summary" list that repeats it:

```markdown
# ‚ùå Bad - Redundant

The **Mint address** is a reserved address representing the collection's minting source. It has unlimited balances, and any transfer from the Mint address creates tokens.

**Key properties:**

-   Unlimited balances
-   Transfers from Mint = token creation
-   Cannot receive tokens

# ‚úÖ Good - No redundancy

The **Mint address** is a reserved address representing the collection's minting source. It has unlimited balances, and any transfer from the Mint address creates tokens. The Mint address cannot receive tokens.
```

**Exception:** Summary lists are acceptable if they consolidate information from multiple sections or provide a quick reference after a long explanation.

## Common Patterns

### Concept Explanation

````markdown
## Collection Fields

Collection fields are set directly as simple values.

```typescript
const collectionMetadata = {
    uri: 'ipfs://...',
    customData: '',
};
```
````

This sets the collection metadata directly.

````

### API Documentation

```markdown
## Query Collection

Query a collection by ID:

```bash
bitbadgeschaind query badges collection 1
````

**Response:**

```json
{
    "collection": {
        "collectionId": "1",
        "validTokenIds": [{ "start": "1", "end": "100" }]
    }
}
```

````

### Tutorial Format

```markdown
## Creating Your First Collection

1. **Set valid token IDs:**
```typescript
const validTokenIds = [{ start: '1', end: '100' }];
````

2. **Configure manager:**

```typescript
const manager = 'YOUR_ADDRESS';
```

3. **Create the collection:**

```typescript
const msg = MsgCreateCollection({ validTokenIds, manager: 'bb1...' });
```

````

## Checklist

Before publishing, verify:

- [ ] Every section has at least one code snippet/example/graphic
- [ ] All code examples are real and tested
- [ ] Frontmatter includes description
- [ ] Related docs are cross-referenced
- [ ] Technical terms are defined on first use
- [ ] No fluff or unnecessary words
- [ ] Headers are action-oriented
- [ ] Code blocks specify language
- [ ] Images have alt text and captions

## BitBadges-Specific Conventions

### CLI Command

Always use `bitbadgeschaind` (not `bitbadgesd`):

```bash
# ‚úÖ Correct
bitbadgeschaind query badges collection 1
bitbadgeschaind tx badges create-collection '[tx-json]' --from key

# ‚ùå Incorrect
bitbadgesd query badges collection 1
```

### Address Format

BitBadges addresses use the `bb1` prefix:

```typescript
// ‚úÖ Correct
const address = 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls';
const manager = 'bb1uqxan5ch2ulhkjrgmre90rr923932w38gwez5d';

// ‚ùå Incorrect
const address = 'cosmos1...'; // Wrong prefix
const address = '0x...'; // Ethereum format
```

**Reserved addresses:**
- `"Mint"` - Special reserved address for minting (not a `bb1` address)

### SDK Package

Use `bitbadgesjs-sdk` (not `@bitbadges/bitbadgesjs`):

```typescript
// ‚úÖ Correct
import { BitBadgesAPI, BigIntify, Balance } from 'bitbadgesjs-sdk';

// ‚ùå Incorrect
import { BitBadgesAPI } from '@bitbadges/bitbadgesjs';
```

### Number Types

Use string-based uint64 values to prevent precision loss:

```typescript
// ‚úÖ Correct - Strings for large numbers
const tokenIds = [{ start: '1', end: '18446744073709551615' }];
const amount = '1000000000000';

// ‚ùå Incorrect - Numbers lose precision
const tokenIds = [{ start: 1, end: 18446744073709551615 }]; // Precision loss!
```

Convert with SDK functions:
- `BigIntify` - Convert to `bigint`
- `Numberify` - Convert to `number`
- `Stringify` - Keep as `string`

### Denomination

Base denomination is `ubadge` (display: `BADGE`):

```typescript
// ‚úÖ Correct
const coin = { denom: 'ubadge', amount: '1000000000' };

// ‚ùå Incorrect
const coin = { denom: 'badge', amount: '1000000000' };
```

### Module Name

The Cosmos SDK module is `x/badges`:

```typescript
// ‚úÖ Correct
typeUrl: '/bitbadges.badges.MsgCreateCollection'

// ‚ùå Incorrect
typeUrl: '/bitbadges.tokenization.MsgCreateCollection'
```

### Reserved Address List IDs

Use reserved IDs for common patterns:

```typescript
// ‚úÖ Correct
toListId: 'All' // All addresses including Mint
toListId: 'Mint' // Only Mint address
toListId: 'None' // No addresses
toListId: 'AllWithoutMint:bb1abc...' // All except specified
toListId: 'bb1abc...:bb1def...' // Inline whitelist

// ‚ùå Incorrect
toListId: 'all' // Case-sensitive
toListId: 'ALL' // Case-sensitive
```

### API Endpoints

```typescript
// API base URL
const apiUrl = 'https://api.bitbadges.io/';

// LCD (Light Client Daemon) endpoint
const lcdUrl = 'https://lcd.bitbadges.io/';
```

## Quick Reference

### GitBook Syntax

```markdown
{% content-ref url="path" %}
[Text](path)
{% endcontent-ref %}

<figure>
  <img src="path" alt="alt">
  <figcaption>Caption</figcaption>
</figure>
````

### Common Code Patterns

```typescript
// Time range
const FullTimeRanges = [{ start: '1', end: '18446744073709551615' }];

// Token ID range
const tokenIds = [{ start: '1', end: '100' }];

// Address
const address = 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls';
```


## File: ./badge-standard/examples/approvals/README.md

# Approvals



## File: ./for-developers/bitbadges-api/README.md

# üìö Indexer / API



## File: ./for-developers/bitbadges-api/api.md

# Getting Started

## Getting Started - API Keys

By default, select routes are available publicly in a rate limited manner with no API key. However, API keys allow you access to all routes with higher limits.

1. Sign in on and create an API key by going to [https://bitbadges.io/developer](https://bitbadges.io/developer) -> API Keys tab.
2. Start sending requests to the base URL of [https://api.bitbadges.io/](https://api.bitbadges.io/) with the HTTP header x-api-key. All routes require an API key.
3. For higher tiers / paid plans, visit [https://bitbadges.io/pricing](https://bitbadges.io/pricing). To actually upgrade, see the Upgrading an API Key Tier demo.

<figure><img src="../../.gitbook/assets/image (189).png" alt=""><figcaption></figcaption></figure>

## Number Types

Note: Numbers are stringified in responses to avoid precision loss. You will have to convert them to your desired type (preferably bigint). The SDK does this for you if you use it.

## References

* [OpenAPI Spec](https://raw.githubusercontent.com/bitbadges/bitbadgesjs/main/packages/bitbadgesjs-sdk/openapi-hosted/openapi.json)

In this documentation, we often use the SDK format for explanation purposes. Please convert the corresponding function name to vanilla HTTP if you are not using the SDK from the documentation above.

```typescript
await BitBadgesApi.routeFn(...)
```

```
POST https://api.bitbadges.io/api/v0/routeFn
```

## Testnet Mode

A testnet version of the API is available with the base URL [https://api.bitbadges.io/testnet](https://api.bitbadges.io/testnet). Everything else is the same, just add the /testnet before all paths.

Note that this testnet API is an entirely separate service from normal API. Nothing carries over. It commmunicates with the frontend with testnet mode turned on and uses the testnet BitBadges blockchain.

## Using the API SDK (Recommended)

If you are using JavaScript / TypeScript, consider using the typed API SDK for convenience. This will give you typed routes, provide quality checks, and also auto-convert all responses to your desired number type (bigint, Number, etc).

```typescript
import { BigIntify, BitBadgesAPI } from 'bitbadgesjs-sdk';

export type DesiredNumberType = bigint;
export const ConvertFunction = BigIntify;

//BACKEND_URL for main API is https://api.bitbadges.io
//Make sure process.env.BITBADGES_API_KEY is set with a valid API key.

const BitBadgesApi = new BitBadgesAPI({
    apiKey: '...',
    //converts responses to your desired number type (bigint, Number, etc)
    convertFunction: ConvertFunction //Can also do Numberify, Stringify, etc
    apiUrl: '...' //defaults to official one if empty
});

//See https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html for documentation
//Some might require authentication. Some might be CORS only from the official site.
await BitBadgesApi.getAccounts(...);
await BitBadgesApi.getCollections(...);
await BitBadgesApi.simulateTx(...);
```

## Using BitBadges JS/SDK

Check out the BitBadges JS/SDK for implementing further functionality beyond just API requests / responses, such as manipulating balances, handling approvals, checking permissions, etc.

{% content-ref url="../bitbadges-sdk/" %}
[bitbadges-sdk](../bitbadges-sdk/)
{% endcontent-ref %}

## API Authorization

For most applications, you should be fine without needing to access private user authenticated information. However if you do, check out Sign In with BitBadges. This follows a standard OAuth 2.0 flow. Use the scopes to gain access to authenticated routes. Refer to the API reference to see what scopes are needed where.

{% content-ref url="../sign-in-with-bitbadges/" %}
[sign-in-with-bitbadges](../sign-in-with-bitbadges/)
{% endcontent-ref %}

## Bookmarking

Throughout the API, we use a bookmark technique. For the first request, you will not need to specify a bookmark (e.g. ""), and it will fetch the first page. Within the response, it will return a **bookmark** and **hasMore**. **hasMore** defines whether there are more pages to be fetched. To fetch the next page, you will specify the returned bookmark from the previous request to the next request. This process can be repeated until all are loaded.


## File: ./for-developers/bitbadges-api/concepts/README.md

# Concepts



## File: ./for-developers/bitbadges-api/concepts/limits-restrictions.md

# API Limits & Restrictions

The following limits are in place to ensure API stability and performance. If these limits are too restrictive for your use case, please contact us.

## Request Limits

-   **Rate Limit**: 10,000 requests per day per API key
-   **Global Rate Limit**: Enforced to prevent infinite loops
-   **Refresh Rate**: Operations can only be refreshed once per hour

## Data Limits

-   **Batch Size**: Maximum 250 items per request for:
    -   Metadata URIs
    -   Account lookups
    -   Collection fetches
-   **IPFS Storage**: Maximum 100MB total uploads per address
-   **Collection Size**: Limited functionality for collections exceeding JavaScript's `Number.MAX_SAFE_INTEGER`

## Timeouts & Retries

This applies to any external fetches, including metadata URIs and other external sources like custom success hooks.

-   **URI Fetch Timeout**: 10 seconds maximum for direct source URI fetches
-   **Retry Policy**: For failed fetches, exponential backoff:
    ```
    Delay = 1 hour √ó 2^(number of attempts)
    ```

Note: These limits may change over time. Please refer to our latest documentation for current values.


## File: ./for-developers/bitbadges-api/concepts/managing-views.md

# Managing Views

Throughout the BitBadges API, we use a bookmark-based pagination system for efficient data retrieval. This system is particularly useful when dealing with large datasets that need to be fetched in smaller chunks.

Some endpoints like the get accounts or get collections will use a generic viewsToFetch and views object which can maintain multiple paginated views. Some endpoints will request the bookmark directly. Refer to the documentation for each endpoint to see how it handles pagination.

### How Bookmark Pagination Works

1. **First Request**: For your initial request, use an empty bookmark string (`""`).

```typescript
const firstRequest = {
    viewType: 'owners',
    viewId: 'owners',
    bookmark: '', // Empty for first page
};
```

2. **Response Structure**: Each paginated response includes:
    - The requested data
    - A `bookmark` string for the next page
    - A `hasMore` boolean indicating if more data exists

```typescript
{
    data: [...],
    views: {
        'owners': {
            ids: [...],
            pagination: {
                bookmark: 'abc123...', // Use this for next request
                hasMore: true
            }
        }
    }
}
```

3. **Subsequent Requests**: To fetch the next page, use the bookmark from the previous response:

```typescript
const nextRequest = {
    viewType: 'owners',
    viewId: 'owners',
    bookmark: 'abc123...', // Bookmark from previous response
};
```

4. **Completion**: Continue this process until `hasMore` is `false`.

## Understanding the Views Object

```
Note: This is planning to be deprecated in favor of more confined view routes.
Please use those instead. They are much less confusing.
```

The views object is a central concept in the BitBadges API, used to manage paginated data across different interfaces (BitBadgesCollection, BitBadgesUserInfo, etc). It follows this structure:

```typescript
views: {
    [viewId: string]: {
        ids: string[];          // Array of document IDs
        pagination: {
            bookmark: string;    // Bookmark for next page
            hasMore: boolean;    // Whether more data exists
        };
        type: string;           // The view type
    } | undefined;
}
```

### Key Components

1. **viewId**: A unique identifier for the view
2. **ids**: Array of document IDs that correspond to full documents in the response
3. **pagination**: Contains the bookmark and hasMore flag
4. **type**: Indicates the type of view (e.g., 'owners', 'activity', etc.)

### Document ID Mapping

Documents in the response are referenced by their `_docId` field. To access the full document, you map the IDs from the view to the corresponding array in the response. For example, the activity view documents are stored in the `activity` array, and the view IDs are stored in the `views.activity.ids` array.

```typescript
// Example of accessing activity documents from a view
getActivityView(viewId: string) {
    return (this.views[viewId]?.ids.map((x) => {
        return this.activity.find((y) => y._docId === x);
    }) ?? []);
}
```

### Common View Types

Different interfaces support different view types. See the corresponding documentation for each interface to see what views are supported.

#### Collections Interface

-   `owners`: List of owners
-   `activity`: Transfer activity
-   `approvalTrackers`: Approval tracking documents

See all at [CollectionViewKey](https://bitbadges.github.io/bitbadgesjs/types/CollectionViewKey.html)

#### Account Interface

-   `transferActivity`: User's transfer history
-   `tokensCollected`: Tokens owned by the user
-   `createdTokens`: Collections created by the user
-   `managingTokens`: Collections being managed

See all at [AccountViewKey](https://bitbadges.github.io/bitbadgesjs/types/AccountViewKey.html)

## Helper Functions

The BitBadges SDK provides several helper functions for managing views:

```typescript
// Check if more pages exist
const hasMore = collection.viewHasMore('owners');

// Get bookmark for next page
const nextBookmark = collection.getViewBookmark('owners');

// Fetch next page of data
await collection.fetchNextForView(BitBadgesApi, 'owners', 'owners');

// Get all documents for a view
const ownersView = collection.getOwnersView('owners');
```

## Best Practices

1. **Consistent ViewIds**: Use consistent viewIds when paginating through the same dataset
2. **Error Handling**: Always check for undefined views before accessing
3. **Document Mapping**: Use helper functions when available for mapping IDs to documents
4. **Pagination State**: Track both bookmark and hasMore status for proper pagination
5. **Response Merging**: Remember that each response is confined to its request - use helper functions or manually merge data as needed


## File: ./for-developers/bitbadges-api/concepts/refresh-queue.md

# Refresh / Claim Completion Queue

The API / indexer makes use of a load-balanced refresh queue system whenever we need to fetch anything from a source URI (metadata, off-chain balances, etc). Because this is a queue-based system, certain metadata may take awhile to fully load and populate. Once we fetch the metadata, we cache it and return the fetched values until it is refreshed again.

**When do we trigger refreshes?**

Refreshes are triggered automatically when certain things occur on-chain, such as a collection is created / URI is changed. You can also manually trigger refreshes (note there are cooldown limits in place to prevent spam) to refresh the cached values via the refresh endpoints.

**What happens if the fetch fails?**

See [Restrictions / Limits](limits-restrictions.md). We implement an exponential retry system.

**Checking Status**

If you are having issues, you can check the BitBadges collection page on site -> Actions -> Refresh for statuses. Or, if you need a programmatic solution, you can use following route to see its status and see if it has any error docs.

```typescript
await BitBadgesApi.getRefreshStatus()
```


## File: ./for-developers/bitbadges-api/estimating-swaps.md

# Estimating Swaps

The swap estimation endpoint allows you to estimate the output amount and required messages for a token swap before executing it. Routing includes both native swaps (our gamm module) and routing through Skip:Go across IBC chains like Osmosis.

## Endpoint

```
POST https://api.bitbadges.io/api/v0/api/{version}/swaps/estimate
```

```typescript
export interface iEstimateSwapPayload {
  /** The token in to swap. Format: "amount:X,denom:Y" */
  tokenIn: string;
  /** Optional chain ID for the token in. Defaults to "bitbadges-1" if not provided. */
  tokenInChainId?: string;
  /** The token out denom to swap to. */
  tokenOutDenom: string;
  /** Optional chain ID for the token out. Defaults to "bitbadges-1" if not provided. */
  tokenOutChainId?: string;
  /**
   * Mapping of chain IDs to addresses.
   * Only supports "bitbadges-1" (bech32 bb prefixed address for Cosmos-based chains and "1" (EVM-based chains with a standard 0x address)
   *
   * We will generate any other chain addresses from these addresses.
   */
  chainIdsToAddresses: Record<string, string>;
  /**
   * Optional mapping of chain IDs to affiliate fee recipients.
   * Structure: { [chainId]: { affiliates: Array<{ address: string; basis_points_fee: string }> } }
   */
  chainIdsToAffiliates?: Record<string, { affiliates: Array<{ address: string; basis_points_fee: string }> }>;
  /** Slippage tolerance as a percentage (0-100). Can be a string or number. */
  slippageTolerancePercent: string | number;
  /** Forcefully recheck compliance and avoid cache (5 minutes) */
  forcefulRecheckCompliance?: boolean;
}
```

```typescript
export interface iEstimateSwapSuccessResponse {
  /** Whether the swap estimation was successful. */
  success: boolean;
  /** Detailed estimation information for the swap. */
  estimate: {
    /** The estimated amount of tokens that will be received (token out). */
    tokenOutAmount: string;
    /** The amount of tokens being swapped in (token in). */
    tokenInAmount: string;
    /**
     * Messages for multi-chain routing.
     * Contains either a multi-chain message (for Cosmos chains) or an EVM transaction (for EVM chains).
     * These messages are used to execute the swap across different chains if needed.
     */
    skipGoMsgs: SkipGoMessage[];
    /**
     * The path the asset takes through different chains and operations to complete the swap.
     * Each step in the path indicates the denom, chain ID, and how the asset moves (genesis, swap, or transfer).
     */
    assetPath: {
      denom: string;
      chainId: string;
      how: 'genesis' | 'swap' | 'transfer';
    }[];
    /** Whether an actual swap operation occurs (true) or if it's just a transfer. */
    doesSwap: boolean;
    /** Warning flag indicating if the liquidity pool has low liquidity, which may affect swap execution. */
    lowLiquidityWarning?: boolean;
    /** Warning flag indicating if compliance checks did not pass for this swap. This means swap is likely to fail on BitBadges pool swap with compliance checks. */
    complianceNotPassedWarning?: boolean;
    /** Detailed error message if compliance checks failed. */
    complianceErrorMessage?: string;
    /** Estimated time in seconds for the swap to complete (if available). */
    estimatedTime?: number;
    /** Fallback asset if swap is not possible. */
    fallbackAsset?: { denom: string; chainId: string; };
  };
}
```

## Skip Go Compatibility

We attempt to mirror Skip:Go support as much as possible. And, we plan to eventually get fully integrated directly. However, there are a couple of minor differences and we do not claim full compatibility yet:

* **Limited Skip Support**: Skip doesn't support our routing yet, so their API, engines, explorers, and client might not support the full feature set
* **Message Format**: The `skipGoMsgs` returned attempt to follow the format from the [Skip API](https://docs.skip.build/go/api-reference/prod/fungible/post-v2fungiblemsgs)
* **Cosmos Only**: This route will only recommend Cosmos swaps. For other chains outside of Cosmos liek ETH and SOL, these are not supported yet.

## Example

```typescript
const response = await BitBadgesApi.estimateSwap({
// ...
});

console.log(response.estimate.tokenOutAmount);
console.log(response.estimate.skipGoMsgs);

// Use the msgs to get user signatures and execute the swap
```


## File: ./for-developers/bitbadges-api/indexer.md

# Indexer

If you want to run your own indexer and API, check out the source code at [https://github.com/bitbadges/bitbadges-indexer](https://github.com/bitbadges/bitbadges-indexer).

The indexer is split into two main parts: the poller and the API. The poller fetches the latest block from a connected node every second and updates the MongoDB database accordingly. The API is an Express.js API that makes the indexed data queryable to users.

Although you can query other blockchain nodes, it is strongly recommended that you run your own node and query that. HTTP requests can reach >100 per second.

### Running from Scratch

1. Install and setup CouchDB
2. Setup a valid .env file. See environment.d.ts below for the expected format of the .env file.&#x20;
3. Use **npm run setup** to setup the CouchDB databases. Note that you can run **npm run setup with-delete** to restart all indexer databases from scratch.
4. Use **npm run indexer-dev** to start in development mode.
5. Use **npm run build** and **npm run indexer** to start in production mode.

### Running with Docker

See [https://github.com/bitbadges/bitbadges-docker](https://github.com/bitbadges/bitbadges-docker).

### Customization Options (.env file)

Below are the supported customization options. Some may be applicable. Some may not.

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadges-indexer/blob/master/environment.d.ts" %}



## File: ./for-developers/bitbadges-api/upgrading-an-api-key-tier.md

# Upgrading an API Key Tier

1. Sign in and create your API key in the [developer portal -> API Keys tab](https://bitbadges.io/developer).

<figure><img src="../../.gitbook/assets/image (97) (1).png" alt=""><figcaption></figcaption></figure>

2. Once you've created it and copied it somewhere safe, select "Update Tier".

<figure><img src="../../.gitbook/assets/image (98) (1).png" alt=""><figcaption></figcaption></figure>

3. This will take you to the billing page. Select your desired tier. Note that if you have a coupon code, it will typically only apply to a specific tier.

<figure><img src="../../.gitbook/assets/image (99) (1).png" alt=""><figcaption></figcaption></figure>

4. Lastly, complete the form, selecting your newly created API key. Enter your email, enter promo code (if applicable), and complete the rest of the form.

<figure><img src="../../.gitbook/assets/image (101) (1).png" alt=""><figcaption></figcaption></figure>

5. Once that form is submitted, you're ready to start building! See the [BitBadges API documentation](https://docs.bitbadges.io) for more information on how to use the BitBadges API. The new tier may take 5-10 minutes to register, so please allow some time for the changes to take effect.


## File: ./for-developers/bitbadges-blockchain/README.md

# ‚õìÔ∏è BitBadges Blockchain



## File: ./for-developers/bitbadges-blockchain/create-a-wasm-contract.md

# Create a WASM Contract

BitBadges support CosmWASM smart contracts to allow you to extend the token interface for custom functionality as desired. If you do need to extend the interface with unsupported functionality but you think it would be a good fit to be added natively, please let us know. Our end goal is that no smart contracts are ever needed, and everything is supported natively!

We refer you to official CosmWASM and Rust documentation for more information. This tutorial will only focus on BItBadges specific information.

{% embed url="https://cosmwasm.cosmos.network/" %}

```go.mod
github.com/CosmWasm/wasmd v0.52.0
```

**Permissioned Uploads**

```
BitBadges implements CosmWASM in a permissioned manner.
```

Instantiating and officially deploying a contract does require a review process and governance approval. Reach out for more information.

Requirements:

* No avoidance of the protocol fee. Any token transfers that take place must use MsgTransferTokens, or if you need to implement transfer functionality directly in the contract, the protocol fee must be obeyed.
* We encourage audits and a peer review process before officailly deploying.
* You must also showcase a working testnet implementation as well (testnet is permissionless)

Generally speaking, even though this is a permissioned implementation, we want the contract layer to be as permissionless as possible. We just have to enforce that our business model (protocol fee) is obeyed.

**High-Level Development Overview**

```rust
const msgExecuteContract: MsgExecuteContractCompat = {
    sender: 'bb1uqxan5ch2ulhkjrgmre90rr923932w38gwez5d',
    contract:
        'bb14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sc8kg9e',
    msg: '{"myCustomMsg1": {"collectionId": "1"}}',
    funds: '1ubadge',
};
```

* Each contract has a Cosmos bech32 contract address (e.g. bb14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sc8kg9e).
* 3-Step Process: Upload / Store Code, Instantiate, Execute
  * Instantiating requires governance proposal (see below)
* Contracts can call into the core x/badges module as submessages (delayed until directly after the contract)
  * When calling into x/badges, msg.Creator will ALWAYS be the contract address. You may need to come up with creative workarounds or creative solutions in certain situations.
* The main execution part of every contract is ExecuteMsg. Think of this like the API definition for your contract. You can have multiple message types with different logic.

```rust
//contract.rs
use bitbadges_cosmwasm::{
  transfer_tokens_msg
};

#[entry_point]
pub fn execute(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response<BitBadgesMsg>, StdError> {
    match msg {
        ExecuteMsg::CustomMsg1 { collection_id, transfers } => {
          let msg = transfer_tokens_msg(collection_id, transfers);
          Ok(Response::new().add_submessage(SubMsg::reply_always(msg, BADGES_REPLY_ID)))
        }
        ExecuteMsg::CustomMsg2 { collection_id, transfers } => {
          let msg = transfer_tokens_msg(collection_id, transfers);
          Ok(Response::new().add_submessage(SubMsg::reply_always(msg, BADGES_REPLY_ID)))
        }
        // Add other messages here as needed
    }
}
```

### **Create a Contract Tutorial**

1. Clone the BitBadges Cosmwasm repository

```
git clone https://github.com/BitBadges/bitbadges-cosmwasm-bindings.git
cd bitbadges-cosmwasm-bindings
```

This repository exports all the custom bindings via `packages/bitbadges-cosmwasm`. You should typically NOT edit the exported types. These are already pregenerated exactly as defined on-chain for you to use.

2. Create your contract

You will be dealing with the `contracts` folder. This is where you implement your contract logic. The `contracts` folder is automatically configured to import from the local `packages/bitbadges-cosmwasm.` We have provided an example and boilerplate for you.

Tools at your disposal:

```rust
// All BitBadges type bindings
use bitbadges_cosmwasm::{
  Transfer, Balance, ....
};
```

<pre class="language-rust"><code class="lang-rust">// BitBadges *_msg() functions
// This is how you call into x/badges by adding Ok(Response::new().add_message(msg))
use bitbadges_cosmwasm::{
  transfer_tokens_msg, delete_collection_msg, BitBadgesMsg
}

<strong>pub fn execute_my_msg(
</strong>    collection_id: String,
    transfers: Vec&#x3C;Transfer>,
) -> StdResult&#x3C;Response&#x3C;BitBadgesMsg>> {
    let msg = transfer_tokens_msg(
        collection_id,
        transfers,
    );

    Ok(Response::new().add_message(msg))
}

#[entry_point]
pub fn execute(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: ExecuteMsg,
) -> Result&#x3C;Response&#x3C;BitBadgesMsg>, StdError> {
    match msg {
        ExecuteMsg::MyCustomMsg { collection_id, transfers } => {
          execute_my_msg(collection_id, transfers)
        }
        // Add other messages here as needed
    }
}
</code></pre>

3. Build and Optimize

You may have to edit the script for you file names and paths. Consider also using an optimizer like [https://github.com/CosmWasm/rust-optimizer](https://github.com/CosmWasm/rust-optimizer).

```bash
cargo build
source ./build.sh # outputs a .wasm
gzip youcontractname.wasm # outputs a .wasm.gz
```

```bash
# build.sh
RUSTFLAGS='-C link-arg=-s' cargo wasm
cp ../../target/wasm32-unknown-unknown/release/YOUR_CONTRACT_NAME.wasm .
```

4. Uploading Your Contract

Go to [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast) and select MsgStoreCode. Upload your .wasm.gz file. Submit the transaction.

For testnet uploads, use testnet.bitbadges.io

<figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

5. Instantiate your Contract

A notification from Step 4 should pop up with your code ID, assuming the transaction was successful.

Refresh the page or clear all Msgs and start a new transaction. Now, select MsgInstantiateContractCompat. Set a label (name for your contract) and enter the code ID from step 3. Submit the transaction.

If you want to instantiate it with funds. the **funds** property will be in the format "1badge".

A notification should pop up with your contract's address. Store this somewhere.

```
Note: This is only applicable to testnet.

For mainnet, instantiation requires a governance proposal. Reach out to us to start this process.
```

6. Interact with the Contract

Once deployed, you need to to let your users interact with it. Use our custom x/wasmx MsgExecuteContractCompat to do so. This is a wrapper around the core x/wasm MsgExecuteContract with support for BitBadges signing. This is the same as broadcasting any other transaction, so we refer you to Creating, Signing, and Broadcasting Txs for a tutorial.

Couple common misunderstandings:

* Note msg is an encoded stringified JSON. Be mindful of single vs double quotes and escaped characters.
*   Note camelCase vs snake\_case. Contracts typically auto-format with camelCase via

    ```rust
    #[serde(rename_all = "camelCase")]
    ```
* Parsing may not be smart enough to identify empty values like empty arrays. You may have to manually specify empty strings, arrays for compatibility.

**Examples**

```typescript
const msgExecuteContract: MsgExecuteContractCompat = {
    sender: 'bb1uqxan5ch2ulhkjrgmre90rr923932w38gwez5d', //enter sender adress here
    contract: 'bb14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sc8kg9e', //
    msg: '{"deleteCollectionMsg": {"collectionId": "1"}}',
    funds: '1badge',
};
```


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/README.md

# Create, Generate, and Sign Txs

There are multiple ways you can create, generate, and sign transactions.&#x20;

-   CLI: Directly interact with the blockchain node's CLI in a terminal
-   Directly via Cosmos SDK practices like Keplr signing
-   Via our SDK

We recommend generating, signing, and broadcasting your transactions with the [BitBadges SDK](../../bitbadges-sdk/). The SDK provides easy-to-use TypeScript functions to construct transactions of all types and broadcast them to a blockchain node.


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/broadcast-to-a-node.md

# Broadcast to a Node

### **Simulating**

A good practice to have is to simulate the transaction before you actually broadcast and update the **fee** from the transaction context with up to date values. You can leave all signature fields empty because simulations do not check any signatures. In our signing examples (previous pages), simply set simulate = true.

```typescript
// https://api.bitbadges.io/api/v0/simulate
const res = await BitBadgesApi.simulateTx(txBody); //Returned from signing steps
```

This will return the gas used and success statuses on a dry run of the transaction.

```typescript
export interface SimulateTxRouteSuccessResponse<T extends NumberType> {
    gas_info: {
        gas_used: string;
        gas_wanted: string;
    };
    result: {
        data: string;
        log: string;
        events: {
            type: string;
            attributes: {
                key: string;
                value: string;
                index: boolean;
            }[];
        }[];
        msg_responses: any[];
    };
}
```

### **Broadcasting**

You can replace the URL below with any valid BitBadges blockchain node.

```typescript
// https://api.bitbadges.io/api/v0/broadcast
const res = await BitBadgesApi.broadcastTx(txBody); //Returned from signing steps
```

The response code should be 0 for a successful transaction.

```typescript
export interface BroadcastTxRouteSuccessResponse<T extends NumberType> {
    tx_response: {
        code: number;
        codespace: string;
        data: string;
        events: {
            type: string;
            attributes: {
                key: string;
                value: string;
                index: boolean;
            }[];
        }[];
        gas_wanted: string;
        gas_used: string;
        height: string;
        info: string;
        logs: {
            events: {
                type: string;
                attributes: {
                    key: string;
                    value: string;
                    index: boolean;
                }[];
            }[];
        }[];
        raw_log: string;
        timestamp: string;
        tx: object | null;
        txhash: string;
    };
}
```

### Polling

Once you have the tx hash from above, you can poll a node until the transaction is confirmed like below. Note this is a blockchain REST API\_URL, not the BitBadges API. Use [https://lcd.bitbadges.io](https://lcd.bitbadges.io) for the BitBadges maintained node.

```typescript
const txHash = res.data.tx_response.txhash;
const code = res.data.tx_response.code;
if (code !== undefined && code !== 0) {
    throw new Error(
        `Error broadcasting transaction: Code ${code}: ${JSON.stringify(
            res.data.tx_response,
            null,
            2
        )}`
    );
}

let fetched = false;
while (!fetched) {
    try {
        const res = await axios.get(
            `${process.env.API_URL}/cosmos/tx/v1beta1/txs/${txHash}`
        );
        fetched = true;

        return res;
    } catch (e) {
        // wait 1 sec
        console.log('Waiting 1 sec to fetch tx');
        await new Promise((resolve) => setTimeout(resolve, 1000));
    }
}

return res;
```

There are also other polling methods: websockets + parsing txs as they come through, the Cosmos SDK provides various endpoints / approaches, redirecting to explorers.


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/generate-msg-contents.md

# Generate Msg Contents

### **Building the Msgs**

You can build out the transaction from the exported Proto type definitions from our SDK. This allows you to create transactions with multiple Msg types in one tx. See [here](https://github.com/BitBadges/bitbadgesjs/tree/main/packages/bitbadgesjs-sdk/src/proto) for all proto Msg definitions.

```typescript
import { proto } from 'bitbadgesjs-sdk';

//proto.cosmos.module for standard Cosmos
//proto.badges for BitBadges x/badges
const MsgDeleteCollection = proto.badges.MsgDeleteCollection;
const MsgCreateCollection = proto.badges.MsgCreateCollection;
const MsgUpdateCollection = proto.badges.MsgUpdateCollection;
const MsgTransferTokens = proto.badges.MsgTransferTokens;

const protoMsgs = [
    new MsgDeleteCollection({ collectionId: '1', creator: 'bb...' }),
    //Add more here (executed in order)
];
```

### Building the Transaction

```typescript
import { TxContext, createTransactionPayload } from 'bitbadgesjs-sdk';

const txContext: TxContext = { ... } //See prior page

const txnPayload = createTransactionPayload(txContext, protoMsgs);
```

The outputted payload will be in the following format.

```typescript
export interface TransactionPayload {
    legacyAmino: {
        body: TxBody;
        authInfo: AuthInfo;
        signBytes: string;
    };
    signDirect: {
        body: TxBody;
        authInfo: AuthInfo;
        signBytes: string;
    };
    txnString: string;
    txnJson: Record<string, any>;
}
```


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/sign-+-broadcast-bitbadges.io.md

# Sign + Broadcast - bitbadges.io

For development, you may just want an interface to handle all of this for you. See if [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast) fits your needs. You can simply copy / paste the transaction context, and our interface will handle all the signing / behind the scenes.

This is to be used as a developer tool and not a user-facing solution.

<figure><img src="../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-cosmos.md

# Signing - Cosmos

#### Signing with Keplr

```ts
const signTxn = async (
    context: TxContext,
    payload: TransactionPayload,
    protoMsgs: any[],
    simulate: boolean
) => {
    const { sender } = context;
    await window.keplr?.enable(chainId);

    let signatures = [new Uint8Array(Buffer.from('0x', 'hex'))];
    if (!simulate) {
        const signResponse = await window?.keplr?.signDirect(
            chainId,
            sender.address,
            {
                bodyBytes: payload.signDirect.body.toBinary(),
                authInfoBytes: payload.signDirect.authInfo.toBinary(),
                chainId: chainId,
                accountNumber: new Long(sender.accountNumber),
            },
            {
                preferNoSetFee: true,
            }
        );

        if (!signResponse) {
            throw new Error('No signature returned from Keplr');
        }

        signatures = [
            new Uint8Array(
                Buffer.from(signResponse.signature.signature, 'base64')
            ),
        ];
    }

    const hexSig = Buffer.from(signatures[0]).toString('hex');

    const txBody = createTxBroadcastBody(context, protoMsgs, hexSig);
    return txBody;
};
```


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/transaction-context.md

# Transaction Context

For the signer, you will need their address, sequence, and account number. This can be done via our API like below or you can query directly via a blockchain node.

```typescript
// https://api.bitbadges.io/api/v0/user?address=bb1...
const res = await BitBadgesApi.getAccount({ address: '...' });
const account = res.account;
const { accountNumber, sequence, publicKey } = account;
if (Number(accountNumber) <= 0) {
    // TODO: They are unregistered. Send them dust to register.
}
```

For Cosmos-based wallets, you will need the public key. This may be available in the account response if the user has already interacted with BitBadges, but if this is first time, you can fetch it like below.

```typescript
const getPublicKey = async () => {
    const account = await window?.keplr?.getKey('bitbadges-1');
    if (!account) return '';
    return Buffer.from(account.pubKey).toString('base64');
};
```

Then, generate the context.

```typescript
//Pre-Reqs: Ensure users are registered (i.e. have a valid account number) or else this will fail
const txContext = {
    testnet: false,
    sender: {
        //Must be in native format ('bb1..')
        address: account.address,
        sequence: account.sequence,
        accountNumber: account.accountNumber,
        //Public key is only needed for Cosmos native signatures. Leave "" if not.
        publicKey: account.publicKey,
    },
    //TODO: adjust accordingly
    fee: {
        amount: `0`,
        denom: 'ubadge',
        gas: `400000`,
    },
    memo: '',
};
```

**Fee Generation**

Oftentimes, transactions will not require fees depending on network congestion.

We leave this up to you to implement. You can get the gas used from simulating the transaction (see later in this tutorial). For our frontend, we currently use a base gas price of 0.025 per unit.

```typescript
const baseGasPrice = 0.025;
const feeInUbadge = BigIntify(Math.round(Number(gasUsed) * baseGasPrice));
```


## File: ./for-developers/bitbadges-blockchain/overview.md

# Overview

BitBadges offers an L1 delegated proof-of-stake blockchain built with [Cosmos SDK](https://docs.cosmos.network/main). The blockchain is able to attain instant transaction finality using Tendermint and uses Cosmos-based 'bb' prefixed bech32 addresses and Cosmos signatures for all user interactions.

The source code can be found at [https://github.com/bitbadges/bitbadgeschain](https://github.com/bitbadges/bitbadgeschain).&#x20;

BitBadges defines its official metadata, IBC connections, and more in the Cosmos chain registry at  [https://github.com/cosmos/chain-registry](https://github.com/cosmos/chain-registry).

Other Links

[https://explorer.bitbadges.io](https://explorer.bitbadges.io/)

[https://rpc.bitbadges.io](https://rpc.bitbadges.io)

[https://lcd.bitbadges.io](https://lcd.bitbadges.io)



## File: ./for-developers/bitbadges-blockchain/run-a-mainnet-node.md

# Run a Mainnet Node

Running a node is the same as any other Cosmos SDK chain. If you encounter any issues during the setup process, you can also refer to other Cosmos SDK node documentation, such as "[Cosmos SDK - Running a Node](https://docs.cosmos.network/main/user/run-node/run-node)" or "[Cosmos Tutorials - Run in Production documentation](https://tutorials.cosmos.network/tutorials/9-path-to-prod/1-overview.html)."&#x20;

Below are some links to get you started. If you are unfamiliar with setup, I'd recommend following a guide and/or asking for help in the #validators channel of our Discord. We have plenty of great validators maintaining the network, and many have detailed guides to help you get started. LLMs are also a good resource and can help you get set up.

Note that as a validator, you are responsible for the security of the network. Take necessary precautions for uptime and security in order to avoid slashing or losing staked funds.

**Discord**

Our main communication method is via Discord:

* \#validators channel is a great resource for help. Ping @trevormil to give you the Validator role.
* \#announcements and #chain-upgrades are where we announce the latest plans to upgrade. We use the x/upgrade module from Cosmos SDK. We recommend Cosmovisor for handling upgrades.

**Guides + Setup w/ Snapshots**

* [https://docs.provewithryd.xyz/mainnet/bitbadges/network-overview](https://docs.provewithryd.xyz/mainnet/bitbadges/network-overview)
* [https://nodestake.org/bitbadges](https://nodestake.org/bitbadges)
* Note that most validators have their own guides. Choose whichever one works best for you.

**Releases / Instructions**

* [https://github.com/BitBadges/bitbadgeschain/releases](https://github.com/BitBadges/bitbadgeschain/releases)

**Genesis File**

* [https://github.com/BitBadges/bitbadgeschain/blob/master/genesis-711316.json](https://github.com/BitBadges/bitbadgeschain/blob/master/genesis-711316.json) (Note this is post 711316 hard fork)

**Explorer**

* [https://explorer.bitbadges.io/BitBadges%20Mainnet/staking](https://explorer.bitbadges.io/BitBadges%20Mainnet/staking)

**BitBadges RPC**

* https://rpc.bitbadges.io

**Running a Relayer?**

* See the official IBC connections in the Cosmos chain registry that we support.

**Configuration**

Most node parameters are flexible and you can set up according to your preferences. Here are some that should be the same as the rest of the network.&#x20;

* chain\_id: bitbadges-1
* timeout\_commit: 2s


## File: ./for-developers/bitbadges-blockchain/supported-denoms.md

# Supported Denoms

BitBadges implements an allowlist for supported denominations that you can use within the token standard on its chain.

```typescript
export const MAINNET_COINS_REGISTRY: Record<string, CoinDetails> = {
  ubadge: {
    skipGoSupported: true,
    label: 'BADGE',
    symbol: 'BADGE',
    decimals: '9',
    baseDenom: 'ubadge',
    image: 'https://github.com/cosmos/chain-registry/blob/master/bitbadges/images/badge_logo.png?raw=true'
  },
  'badges:49:chaosnet': {
    skipGoSupported: false,
    label: 'CHAOS',
    symbol: 'CHAOS',
    decimals: '9',
    baseDenom: 'badges:49:chaosnet',
    image: 'https://bitbadges.io/_next/image?url=https%3A%2F%2Fbitbadges-ipfs.infura-ipfs.io%2Fipfs%2FQmdRQUvQBo6p24RQ7AS7RD6srqyUjoHJ5Cjs4p22zie9bQ&w=1920&q=75'
  },
  'ibc/F082B65C88E4B6D5EF1DB243CDA1D331D002759E938A0F5CD3FFDC5D53B3E349': {
    skipGoSupported: true,
    label: 'USDC',
    symbol: 'USDC',
    decimals: '6',
    baseDenom: 'ibc/F082B65C88E4B6D5EF1DB243CDA1D331D002759E938A0F5CD3FFDC5D53B3E349',
    image: 'https://github.com/cosmos/chain-registry/blob/master/noble/images/USDCoin.png?raw=true'
  },
  'ibc/A4DB47A9D3CF9A068D454513891B526702455D3EF08FB9EB558C561F9DC2B701': {
    skipGoSupported: true,
    label: 'ATOM',
    symbol: 'ATOM',
    decimals: '6',
    baseDenom: 'ibc/A4DB47A9D3CF9A068D454513891B526702455D3EF08FB9EB558C561F9DC2B701',
    image: 'https://github.com/cosmos/chain-registry/blob/master/cosmoshub/images/atom.png?raw=true'
  },
  'ibc/ED07A3391A112B175915CD8FAF43A2DA8E4790EDE12566649D0C2F97716B8518': {
    skipGoSupported: true,
    label: 'OSMO',
    symbol: 'OSMO',
    decimals: '6',
    baseDenom: 'ibc/ED07A3391A112B175915CD8FAF43A2DA8E4790EDE12566649D0C2F97716B8518',
    image: 'https://github.com/cosmos/chain-registry/blob/master/osmosis/images/osmo.png?raw=true'
  }
};
```


## File: ./for-developers/bitbadges-blockchain/testnet-mode.md

# Testnet Mode

Testnet mode provides a separate environment for testing purposes. Simply turn on the switch (or go to [testnet.bitbadges.io](https://testnet.bitbadges.io)). It is isolated from the production environment of BitBadges and uses its own resources, such as a testnet blockchain, database, API, and more.

<pre><code><strong>Note: Third-party integrations (e.g. claim plugins) are the exact same. 
</strong></code></pre>

<figure><img src="../../.gitbook/assets/image (129) (1).png" alt=""><figcaption></figcaption></figure>

### Important Notes

You should treat testnet as an entirely SEPARATE service. NOTHING will carry over from normal mode (not even profiles, badges, settings, anything). Consider this before determining whether testnet mode is the correct option for you.

### Differences

* Some features available in production may not be accessible in testnet:
  * Off-chain balances managed by BitBadges are not hosted externally (via CDN)
  * Buying BADGE credits
  * Push notifications
  * And more
* Some restrictions may be more relaxed
  * No API keys required
  * Faucet may be more lenient
* Performance also may differ from the production environment

### Links

Frontend: [https://testnet.bitbadges.io](https://testnet.bitbadges.io)

Backend: [https://api.bitbadges.io/testnet](https://api.bitbadges.io/testnet) (append the normal routes to this base URL)

Testnet Node:

* RPC: [https://rpc-testnet.bitbadges.io](https://rpc-testnet.bitbadges.io)
* REST: [https://lcd-testnet.bitbadges.io](https://lcd-testnet.bitbadges.io)

### Feedback

If there is anything we can do to make development easier, let us know.


## File: ./for-developers/bitbadges-sdk/README.md

# ‚öí BitBadges SDK



## File: ./for-developers/bitbadges-sdk/common-snippets/README.md

# Common Snippets

In this section, we provide common snippets and examples for the SDK. Some of these were auto-generated with AI, so please let us know if there are issues.


## File: ./for-developers/bitbadges-sdk/common-snippets/address-conversions.md

# Address Conversions

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> Address Utils

> **Note:** As of v23, BitBadges only supports Cosmos-based 'bb' prefixed bech32 addresses. The `convertToBitBadgesAddress()` function is now essentially a pass-through validation function - it validates that the input is a valid bb-prefixed address and returns it unchanged. It is still exported for compatibility but is redundant since both input and output are bb-prefixed addresses. You can also use the `isAddressValid()` function to check if an address is a valid BitBadges address.

```ts
import { convertToBitBadgesAddress } from 'bitbadgesjs-sdk';

let address = convertToBitBadgesAddress(
    'bb1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw'
    // Previously: '0x....'
);
if (!!address) {
    // address is valid
}
```


## File: ./for-developers/bitbadges-sdk/common-snippets/address-lists.md

# Address Lists

AddressLists are the base type for lists. The BitBadgesAddressList class you see returned from the API extends this. Learn more about lists in the core concepts.

```typescript
const list = new AddressList({
  addresses: ['bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh'],
  whitelist: true,
  customData: '',
  uri: '',
  createdBy: 'bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh',
  listId: 'abc123',
})

const isInList = list.checkAddress('bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh') // true
const invertedList = list.toInverted()
const isInListNow = invertedList.checkAddress('bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh') // false

list.remove('bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh')
const isEmpty = list.isEmpty()


const MintList = AddressList.Reserved('Mint')
const All = AddressList.AllAddresses();
```


## File: ./for-developers/bitbadges-sdk/common-snippets/badge-metadata.md

# Token Metadata

#### Tutorial: Managing Token Metadata in TypeScript

**1. Introduction to `TokenMetadataDetails`**

The `TokenMetadataDetails` type captures comprehensive details about the metadata of a token. It contains fields such as token IDs (ranges), associated metadata, a URI, and custom data. This is what is used via the **cachedTokenMetadata** field from collection responses.

**2. Removing Metadata for Specific Token IDs**

To delete metadata associated with specific token IDs:

```typescript
const currentMetadata: TokenMetadataDetails<bigint>[] = [...]; // your current metadata array

const tokenIdsToRemove = UintRangeArray.From([
  { start: 5n, end: 10n }
];

const updatedMetadata = removeTokenMetadata(currentMetadata, tokenIdsToRemove);
console.log(updatedMetadata); // This will show metadata without the removed token IDs.
```

**3. Updating Metadata for Tokens**

If you wish to update specific token metadata in the token metadata details:

```typescript
const currentMetadata: TokenMetadataDetails<bigint>[] = [...]; // your current metadata array

const metadataToUpdate: TokenMetadataDetails<bigint> = new TokenMetadataDetails<bigint>({
  tokenIds: [{ start: 7n, end: 7n }],
  metadata: { /* your metadata details here */ },
  uri: "http://new-metadata-url.com", //Or 'Placeholder' or something else
  customData: "Some custom information",
});

const newMetadataArray = updateTokenMetadata(currentMetadata, metadataToUpdate);
console.log(newMetadataArray); // This will show the array with the updated metadata.
```

**4. Fetch Metadata Details for a Specific Token ID**

To retrieve metadata details for a particular token ID:

```typescript
const tokenIdToFetch = 12n;

const tokenMetadataDetails = getMetadataDetailsForTokenId(tokenIdToFetch, currentMetadata);
console.log(tokenMetadataDetails); // This will display the metadata details for the specified token ID.
```

**5. Fetch Only the Metadata for a Specific Token ID**

To only retrieve the metadata (without the surrounding details) for a particular token ID:

```typescript
const tokenIdToFetch = 15n;

const tokenMetadata = getMetadataForTokenId(tokenIdToFetch, currentMetadata);
console.log(tokenMetadata); // This will show only the metadata for the given token ID.
```

**Conclusion**

These functions provide a robust toolkit for managing token metadata. Whether you're updating, fetching, or deleting metadata associated with tokens, you have a systematic and structured approach available.


## File: ./for-developers/bitbadges-sdk/common-snippets/balances.md

# Balances

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> Balances

### Tutorial: Using the TypeScript SDK for Balance Operations

**1. Define the Balance**

Here's how you create a balance using the provided `Balance` interface:

<pre class="language-typescript"><code class="lang-typescript"><strong>const userBalance = BalanceArray.From([{
</strong>  "amount": 5n, // example amount using the BigInt type
  "tokenIds": [{ start: 1n, end: 5n }],
  "ownershipTimes": [{ start: 1628770800000n, end: 1628857200000n }] // example timestamps using BigInt
}])
</code></pre>

Note: The `UintRange` type is assumed to be an object with `start` and `end` properties of type `bigint`. Adjust as necessary based on the actual definition.

**2. Add Balance**

To add a balance to an array of existing balances:

```typescript
const balanceToAdd = {
    amount: 3n,
    tokenIds: [{ start: 6n, end: 8n }],
    ownershipTimes: [{ start: 1628860800000n, end: 1628947200000n }],
};
userBalance.addBalances([balanceToAdd]);
```

This will add `balanceToAdd` to the list of existing balances.

**3. Subtract Balance**

To subtract a balance from an array of existing balances:

```typescript
const balanceToRemove = {
    amount: 2n,
    tokenIds: [{ start: 2n, end: 3n }],
    ownershipTimes: [{ start: 1628784400000n, end: 1628870800000n }],
};
userBalance.subtractBalances([balanceToRemove], false); //second param is to allow underflow (negatives)
```

**Conclusion**

This SDK provides a clear and structured way to manage and operate on balances. With the `addBalance` and `subtractBalance` functions, you can effortlessly update and maintain balances in your application.\
\
Given the new functions you've shared, I'll provide a tutorial snippet for each of them.

### Tutorial: Retrieving Balances Based on Token ID and Time

**1. Get Balance for a Specific ID and Time**

If you need to retrieve the balance for a specific token ID and a specific ownership time, you can use the `getBalanceForIdAndTime` function:

```typescript
const tokenIdToLookup = 3n;
const timeToLookup = 1628784400000n; // example timestamp using BigInt
const specificBalance = balances.getBalanceForIdAndTime(
    tokenIdToLookup,
    timeToLookup
);

console.log(specificBalance); // This will show the balance for the specified token ID and time, if found.
```

**2. Get Balances for a Specific Token ID**

To get all balances associated with a specific token ID:

```typescript
const tokenIdToLookup = 4n;
const balances = balances.getBalancesForId(tokenIdToLookup);

console.log(balances); // This will display all the balances for the given token ID.
```

**3. Get Balances for a Specific Time**

If you need to retrieve all balances for a specific ownership time:

```typescript
const timeToLookup = 1628784400000n;
const timeSpecificBalances = balances.getBalancesForTime(timeToLookup);

console.log(timeSpecificBalances); // This will show all the balances that have the specified ownership time.
```

Alright, given the new function `getBalancesForIds` which retrieves balances for a range of token IDs and a range of times, let's create a tutorial snippet for it:

4. **Get Balances for Specific Ranges of Token IDs and Times**

If you need to retrieve balances for a range of token IDs and a range of ownership times, you can utilize the `getBalancesForIds` function:

```typescript
// Define the range of token IDs and times you want to look up
const idRangesToLookup = [
    { start: 1n, end: 3n },
    { start: 5n, end: 7n },
];

const timeRangesToLookup = [
    { start: 1628770800000n, end: 1628857200000n }, // example timestamp range using BigInt
    { start: 1628943600000n, end: 1629030000000n }, // another timestamp range
];

// Retrieve the balances
const specificBalances = balances.getBalancesForIds(
    idRangesToLookup,
    timeRangesToLookup
);
console.log(specificBalances); // This will show the balances that fall within the specified token ID ranges and time ranges.
```

**Conclusion**

The provided functions in this SDK make it easy to retrieve specific balances based on different criteria, such as token ID and ownership time. Utilize these functions to access and display relevant data as per your application's requirements.


## File: ./for-developers/bitbadges-sdk/common-snippets/get-unhandled-approvals.md

# Approvals / Transferability

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> Approvals / Transferability

You can use the following functions to get the approval combinations that have unhandled. If unhandled, they are disapproved.

```typescript
export function getUnhandledCollectionApprovals(
  collectionApprovals: CollectionApprovalWithDetails<bigint>[],
  ignoreTrackerIds?: boolean
  doNotMerge?: boolean
)
```

```typescript
export function getUnhandledUserOutgoingApprovals(
  approvals: UserOutgoingApprovalWithDetails<bigint>[],
  userAddress: string,
  doNotMerge?: boolean
)
```

```typescript
export function getUnhandledUserIncomingApprovals(
  approvals: UserIncomingApprovalWithDetails<bigint>[],
  userAddress: string,
  doNotMerge?: boolean
)
```

Use the following functions to add the default user approvals to an existing set of approvals. For incoming, this will be: if unhandled, approve only if to == initiatedBy. For outgoing, vice versa.

```typescript
export function appendSelfInitiatedOutgoingApproval(currApprovals: UserOutgoingApprovalWithDetails<bigint>[], userAddress: string): UserOutgoingApprovalWithDetails<bigint>[]
```

```typescript
export function appendSelfInitiatedIncomingApproval(currApprovals: UserIncomingApprovalWithDetails<bigint>[], userAddress: string): UserIncomingApprovalWithDetails<bigint>[] 
```


## File: ./for-developers/bitbadges-sdk/common-snippets/numbertype-conversions.md

# NumberType Conversions

A problem with creating a JavaScript SDK for a Cosmos SDK based blockchain is that JavaScript's number primitive cannot natively handle numbers > Number.MAX\_SAFE\_INTEGER, but the blockchain allows amounts greater than that.

To combat this, we have made all TypeScript types in the SDK generic via a NumberType interface.

```typescript
export type NumberType = bigint | number | string | boolean;
```

Types that you will find in the SDK that are number-based will all be generically typed, so that you can use any of the above NumberTypes, according to your preferences.

It is recommended that you use bigint and/or stringified because these can represent all possible numbers and do not lose precision. Also, note that for almost all SDK functions, we only take bigints.

For example, the following will represent a TokenMetadata type where all numbers are stringified (i.e. "100" or "123").

```typescript
const stringifiedMetadata: TokenMetadata<string> = new TokenMetadata({ uri: ... });
```

**Converting Between NumberTypes**

To convert between different number types, all types come with a converter function (**.convert()**). This allows you to convert all the stringified numbers to another format (such as JS number or JS bigint). To convert, you can simply do the following:

```typescript
import { BigIntify, TokenMetadata, JSPrimitiveNumberType, NumberType, convertTokenMetadata } from "bitbadgesjs-sdk";

const stringifiedMetadata: TokenMetadata<string> = new TokenMetadata({ uri: ... });
const bigIntifiedMetadata = stringifiedTokenMetadata.convert(BigIntify);
```

We export the following types and converter functions for your convenience.

```typescript
export type NumberType = bigint | number | string | boolean;
export type JSPrimitiveNumberType = string | number | boolean;

export const BigIntify = (item: NumberType) => numberify(item, StringNumberStorageOptions.BigInt) as bigint;
export const Stringify = (item: NumberType) => numberify(item, StringNumberStorageOptions.String) as string;
export const Numberify = (item: NumberType) => numberify(item, StringNumberStorageOptions.Number) as number;
export const NumberifyIfPossible = (item: NumberType) => numberify(item, StringNumberStorageOptions.NumberIfPossible) as number | string;
```

**Example Application**

In our API, JS bigints cannot be natively sent over HTTP. So, we use the following execution flow:

1. Before sending to the client, stringify everything before sending over HTTP
2. The client can use the converter functions to coonvert all types to their preferred method


## File: ./for-developers/bitbadges-sdk/common-snippets/transfers-w-increments.md

# Transfers

The `TransferWithIncrements` type provides a convenient method for handling batch transfers, especially when you need to distribute tokens sequentially or when tokens have varying ownership times. By combining this with the `getBalancesAfterTransfers` function, you can effortlessly manage and update balances in your application.

```typescript
import {
    BalanceArray,
    TransferWithIncrements,
    getAllTokenIdsToBeTransferred,
    getAllBalancesToBeTransferred,
} from '../packages/bitbadgesjs-sdk';

const startingBalances = BalanceArray.From([
    {
        amount: 100n,
        tokenIds: [{ start: 1n, end: 100n }],
        ownershipTimes: [{ start: 1628770800000n, end: 1628857200000n }],
    },
]);

const batchTransfer = new TransferWithIncrements<bigint>({
    from: 'Mint', // replace with your address

    balances: startingBalances,

    toAddresses: [], // this will be empty because we're using `toAddressesLength`
    toAddressesLength: 100n,

    incrementTokenIdsBy: 1n,
    incrementOwnershipTimesBy: 86400000n, // assuming this is 1 day in milliseconds in BigInt form
});

const allTokenIds = getAllTokenIdsToBeTransferred([batchTransfer]); // returns [{ start: 1n, end: 100n }]
const allBalancesToBeTransferred = getAllBalancesToBeTransferred([
    batchTransfer,
]); // returns [{ amount: 100n, tokenIds: [{ start: 1n, end: 100n }], ownershipTimes: [{ start: 1628770800000n, end: 1628857200000n }] }
```


## File: ./for-developers/bitbadges-sdk/common-snippets/uint-ranges.md

# Uint Ranges

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> UintRanges



#### Tutorial: Managing and Querying Unsigned Integer Ranges

**1. Introduction to `UintRange`**

The `UintRange` interface captures a range of unsigned integers using a start and end property. This is handy when representing intervals or spans of values.

**2. Sorting and Merging Ranges**

To sort a list of ranges and merge adjacent or overlapping ones:

```typescript
const ranges = UintRangeArray.From([
  { start: 10n, end: 20n },
  { start: 5n, end: 12n },
  { start: 21n, end: 25n }
]);
ranges.sortAndMerge();

console.log(ranges); // Expected: [{ start: 5n, end: 25n }]
```

**3. Searching Within Ranges**

To search for a specific ID within a list of ranges and return its index and a boolean indicating if it was found:

```typescript
const idToSearch = 15n;
const [index, isFound] = ragnes.search(idToSearch)
console.log(`Index: ${index}, Found: ${isFound}`);
```

**4. Inverting Ranges**

To invert a list of ranges between a minimum and maximum ID:

<pre class="language-typescript"><code class="lang-typescript"><strong>ranges.invert(1n, 30n);
</strong>console.log(invertedRanges); // This would show the gaps between the given ranges within the specified bounds.
</code></pre>

**5. Removing One Range From Another**

To remove one range from another and also get the removed part:

```typescript
const rangesToRemove = [{ start: 10n, end: 20n }];

ranges.remove(rangesToRemove);
console.log("Remaining:", ranges);

const [inCurrButNotOther, overlaps, inOtherButNotCurr] = ranges.getOverlapDetails(rangesToRemove)
```

**6. Checking for Overlaps**

To determine if there are overlaps within a list of ranges:

```typescript
const overlaps = ranges.overlaps([{ ...}]);
console.log(`Ranges Overlap: ${overlappingCheck}`);
```

**Conclusion**

The functions provided offer a comprehensive toolkit for managing and querying unsigned integer ranges. Whether you're checking for overlaps, inverting ranges, or removing specific integers from a range, you now have the tools to do it efficiently and systematically.



```typescript
import { GO_MAX_UINT_64, UintRange, UintRangeArray } from 'bitbadgesjs-sdk'

//Singular range functions
const range = new UintRange<bigint>({ start: 1n, end: 10n })
const size = range.size() //10n
const fullRange = UintRange.FullRange() // 1n - GO_MAX_UINT_64
const isFull = fullRange.isFull()
const inverted = range.invert() // 11n - GO_MAX_UINT_64
const overlaps = range.overlaps(inverted) // false
const doesFiveExist = range.search(5n) // true
const overlapDetails = range.getOverlapDetails(fullRange) // [[], [{ start: 1n, end: 10n }], [{ start: 11n, end: GO_MAX_UINT_64 }]]
const overlappingRanges = range.getOverlaps(fullRange) // [{ start: 1n, end: 10n }]

const rangeArr = UintRangeArray.From<bigint>([{ start: 1n, end: 10n }, { start: 11n, end: 20n }])
const rangeArrSize = rangeArr.size() // 20n
const rangeArrFull = UintRangeArray.FullRanges() // 1n - GO_MAX_UINT_64
const rangeArrIsFull = rangeArrFull.isFull()
const rangeArrInverted = rangeArr.toInverted({ start: 1n, end: GO_MAX_UINT_64 }) // 21n - GO_MAX_UINT_64

const unsortedArr = UintRangeArray.From<bigint>([{ start: 11n, end: 20n }, { start: 1n, end: 15n }])
const hasOverlaps = unsortedArr.hasOverlaps() // true
unsortedArr.sortAndMerge() // [{ start: 1n, end: 20n }]

const sortedArr = unsortedArr.clone()
const [inCurrButNotOther, overlaps, inOtherButNotCurr] = sortedArr.getOverlapDetails(unsortedArr) // [[], [{ start: 1n, end: 20n }], []]

sortedArr.remove({ start: 1n, end: 10n }) // [{ start: 11n, end: 20n }]

const [idx, found] = sortedArr.search(11n) // [0n, true]
const exists = sortedArr.searchIfExists(11n) // true
const index = sortedArr.searchIndex(11n) // 0n
```


## File: ./for-developers/bitbadges-sdk/overview.md

# Overview

The BitBadges SDK is a bundle of TypeScript libraries that provide all the tools and functions needed for you to build your own frontend or interact with the BitBadges API, blockchain, and indexer.

GitHub: [https://github.com/bitbadges/bitbadgesjs](https://github.com/bitbadges/bitbadgesjs)

Full Documentation: [https://bitbadges.github.io/bitbadgesjs/](https://bitbadges.github.io/bitbadgesjs/)

```
npm install bitbadgesjs-sdk
```

This library provides miscellaneous functionality to help you interact with BitBadges, such as types, API routes, managing metadata requests, logic with ID ranges and balances, etc.


## File: ./for-developers/bitbadges-sdk/sdk-types.md

# SDK Types

### Custom Types

All types used in the SDK are exported via two ways.&#x20;

**Classes**

The first is via a JavaScript class. These will always begin with a capital letter. This class will always have the core functions below. Other specific functions may also be implemented.

```typescript
export declare class CustomTypeClass<T extends CustomType<T>> implements CustomType<T> {
    toJson(): JsonObject;
    toJsonString(): string;
    equals<U extends CustomType<U>>(other: CustomType<U> | null | undefined, normalizeNumberTypes?: boolean | undefined): boolean;
    clone(): T;
    getNumberFieldNames(): string[]; //Used behind the scenes
    convert<U extends NumberType>(_convertFunction?: (val: NumberType) => U): CustomType<any>;
}
```

The .convert() function is especially useful when dealing with different NumberTypes (bigint -> string).

```typescript
import { Balance, Numberify } 

const balance = new Balance<bigint>({
    amount: 1n,
    tokenIds: [{ start: 1n, end: 100n }],
    ownershipTimes: [{ start: 1n, end: 100n }]
})
const convertedBalance = balance.convert(Numberify); //1, 100 instead of 1n, 100n
```

**Interfaces**

The second is a JavaScript interface. This is the same as the class version minus all functions (just the core JSON object).

```typescript
export interface iBalance<T extends NumberType> {
    amount: T;
    tokenIds: iUintRange<T>[];
    ownershipTimes: iUintRange<T>[];
}
```

**Which one to use?**

Many functions support both; however, you may have to convert between them occasionally for compatibility. We recommend using the classes, but we recognize that many developers prefer the interfaces.&#x20;

### Typed Arrays

Some types also have a typed array exported as well. Similar to a Uint8Array in Javascript, these have all the features of traditional arrays. Thus, you can use .find, .map, .filter(), etc. Plus, additional functions will be available on them (e.g. array.addBalances for the BalanceArray type).&#x20;

```typescript
//Option 1
const balances = new BalanceArray()
balances.push(...)

//Option 2
const balances = BalanceArray.From([{ ... })

balances.addBalances([{ ... }]); //adds balances in-place
```

### **Proto Types**

The blockchain behind the scenes uses the Protocol Buffer type language. Within the SDK, we auto-generate all these proto types for you, but these are typically not the ones you should use in development (only when broadcasting transactions (see [here](../bitbadges-blockchain/create-and-broadcast-txs/))).&#x20;

Some might have duplicates between the two types.

```typescript
import { Balance } from "bitbadgesjs-sdk/dist/proto/balances";
import { Balance } from "bitbadgesjs-sdk";
```

The Proto types are exported via the following

```typescript
import { proto } from "bitbadgesjs-sdk";
const MsgCreateProtocol = proto.protocols.MsgCreateProtocol;
```

If you ever end up with something like the following, this is also the proto definition. We recommend using the proto.abc.xyz method to avoid confusion.

```typescript
import { MsgUpdateCollection } from "bitbadgesjs-sdk/dist/proto/badges";
```


## File: ./for-developers/claim-builder/auto-completing-claims/automate-w-zapier/README.md

# Integrate with Zapier



## File: ./for-developers/claim-builder/auto-completing-claims/automate-w-zapier/automatic-claim-tutorial.md

# Automatic Claim Tutorial

### Overview

The other option is to trigger claims automatically with Zapier. You will configure the Zap to automatically complete the claim for the user upon a custom trigger. For example, upon purchasing an item, auto-send them a purchased item token.

To do this, you **MUST** get the users' crypto addresses somehow before the action is executed. This can be beforehand or somehow obtained during the duration of the Zap. We leave this up to you. If you cannot obtain users' addresses, this approach will not work.

We want to note that functionality is slightly different for tokens with on-chain balances as opposed to off-chain claims.

* On-Chain: The check and complete claim action will **RESERVE** the right for the user to complete the claim. However, it does not actually automatically trigger anything on the blockchain. This is because such a transaction requires a signature from the recipient. Thus, the user still has to go to the BitBadges site and complete the claim process, although the reservation process is automatic.
* Off-Chain Claims: For off-chain claim types, there is no reservation process. The claims are automatically completed.

You will use the BitBadges API Zapier plugin with the Complete Claim action to perform the final claim completion. This approach takes special configuration explained in the tutorial below to ensure the claim process is correct and only executable by the Zap. See the tutorial for more information.

<figure><img src="../../../../.gitbook/assets/image (146) (1).png" alt=""><figcaption></figcaption></figure>

### Create the Claim

The first step is to create the claim via the Bitbadges site; however, note that the configuration of the claim must be correct to ensure correct behavior of the claim process and allow Zapier to communicate. Select the Zapier approach when creating, and it should guide you through the process.

Note: Many in-site plugins may become incompatible due to the user not completing in-site. However, you gain access to any custom trigger from 7000+ apps on Zapier.

<figure><img src="../../../../.gitbook/assets/image (368).png" alt=""><figcaption></figcaption></figure>

## Tutorial

Example walkthrough of a custom Zap. Customize to your use case.

Step 1: Create and setup your Zap on [https://zapier.com/](https://zapier.com/). The site will walk you through it all.

Step 2: Select and configure your trigger. Triggers are the action that initiate the automation flow. In this cases, this is a new Udemy course being completed. We leave the selection of the trigger up to you. This will depend on your intended use case.

<figure><img src="../../../../.gitbook/assets/image (147) (1).png" alt=""><figcaption></figcaption></figure>

Step 3: Configure the Complete Claim by BitBadges integration. The password and other config parameters will be constant and obtained when creating the claim. However, the address may be fetched from prior integrations or manually provided. This is up to you.

<figure><img src="../../../../.gitbook/assets/image (280).png" alt=""><figcaption></figcaption></figure>

You can get the claim information from the form when you are creating the claim.

Step 4: Simulate / Test

You may use the simulation feature to test that your claim communicates and will pass without actually executing the action.

Note that behind the scenes, this is just a simulation (does not actually complete the claim) if sent manually from the test step. The claim will actually be completed for successful Zaps once live.

Step 5: Track Progress

For most use cases, just submitting the claim is typically adequate. However, you can also track it with the other BitBadges action in Zapier (Get Claim Attempt Status). You will pass the ID received from the submission to this. Note that we use a queue system so it may take some time to officially process.

And, it is as easy as that!


## File: ./for-developers/claim-builder/auto-completing-claims/automate-w-zapier/overview.md

# Overview

Zapier BitBadges Integration: [https://zapier.com/apps/bitbadges/integrations](https://zapier.com/apps/bitbadges/integrations)

**What is Zapier?**

Zapier is an online automation tool that connects your favorite apps, such as Gmail, Slack, Mailchimp, and more than 2,000 others. You can automate repetitive tasks with workflows known as Zaps. A Zap connects two or more apps to automate part of your business or personal tasks. A Zap is created using a trigger and one or more actions. A trigger is an event in an app that starts the Zap. After a trigger occurs, Zapier automatically completes an action‚Äîor series of actions‚Äîin another app. This seamless connection between apps enables complex tasks to be completed automatically, saving time and improving productivity.

See all supported apps here: [https://zapier.com/apps](https://zapier.com/apps).

<figure><img src="../../../../.gitbook/assets/image (245).png" alt=""><figcaption></figcaption></figure>

**How does Zapier x BitBadges work?**

Couple ways:

* Claims can be auto-completed from Zapier
* Post-success Zaps can implement utility or rewards
* Dynamic stores can be implemented with automatic updates of the list
* Claim infomration like codes can be automatically distributed to users

<figure><img src="../../../../.gitbook/assets/image (369).png" alt=""><figcaption></figcaption></figure>

When automating claims with Zapier, you will follow the approach of upon doing something (custom trigger), perform an action (claim a token, distribute a code, add to dynamic store).

<figure><img src="../../../../.gitbook/assets/image (147) (1).png" alt=""><figcaption></figcaption></figure>

## **Error Handling**

You should also account for the fact that Zaps can partially execute. For example, if you have a Zap with 10 plugins and it fails on the 8th plugin, the Zap will not be considered a success but 8/10 plugins would be executed already. There is no rollback feature.

Similarly, if you are triggering a Zap during a claim's execution, there is no guarantee that the overall claim is successful because other plugins might fail.

## Triggers

The custom trigger step is left up to you to implement from any of the 7000+ app integrations.

## **Actions**

With the claim or action step of the automated flow, you have a couple options depending on your use case.

{% content-ref url="../../automate-w-zapier/distribute-claim-information-tutorial/" %}
[distribute-claim-information-tutorial](../../automate-w-zapier/distribute-claim-information-tutorial/)
{% endcontent-ref %}

{% content-ref url="automatic-claim-tutorial.md" %}
[automatic-claim-tutorial.md](automatic-claim-tutorial.md)
{% endcontent-ref %}


## File: ./for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/README.md

# Automate Any Part of the Process

You can also get creative and customize other parts of the claim too, like the distribution of secret information like codes.

<figure><img src="../../../../.gitbook/assets/image (369).png" alt=""><figcaption></figcaption></figure>

You can send the claim code, for example, via the Email by Zapier Plugin or Gmail plugin, and once the user receives the email, they can log on to the BitBadges site and select their address to receive the tokens for when claiming.

<figure><img src="../../../../.gitbook/assets/image (315).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/google-forms.md

# Google Forms

## Setting Up a Claim with Google Forms Zapier

The easiest way is to simply create a Zap using the Google Forms and BitBadges integrations. See the link below for a full tutorial.

<figure><img src="../../../../.gitbook/assets/image (318).png" alt=""><figcaption></figcaption></figure>

{% content-ref url="./" %}
[.](./)
{% endcontent-ref %}

## Setting Up a Claim with Google Forms Script Editor

This guide will walk you through setting up a Google Form to generate unique claim codes using a seed code from the BitBadges Codes plugin.

### Prerequisites

* A Google account
* Access to Google Forms
* A claim with the BitBadges Codes plugin

### Steps

#### 1. Create a Google Form

* Go to Google Forms.
* Create a new form or open an existing one. Customize as needed.

#### 2. Open the Script Editor

* In your Google Form, click on the three dots in the upper right corner.
* Select Script editor.

<figure><img src="../../../../.gitbook/assets/image (311).png" alt=""><figcaption></figcaption></figure>

#### 3. Add the Script

1\. Delete any existing code in the script editor.

2\. Copy and paste the following code into the script editor.\


```javascript
var SEED_CODE = 'ENTER_SEED_CODE_HERE';

function onFormSubmit(e) {
  var form = FormApp.getActiveForm();
  var submissionNumber = getSubmissionNumber();
  var code = generateCodeFromSeed(SEED_CODE, submissionNumber);
  setCustomConfirmation(form, code);
}

function generateCodeFromSeed(seedCode, submissionNumber) {
  var data = seedCode + '-' + submissionNumber;
  var hash = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, data);
  var hexHash = hash.map(function(byte) {
    var hex = (byte & 0xFF).toString(16);
    return (hex.length === 1 ? '0' : '') + hex;
  }).join('');
  return hexHash + '-' + submissionNumber;
}

function getSubmissionNumber() {
  var form = FormApp.getActiveForm();
  return form.getResponses().length;
}

function setCustomConfirmation(form, code) {
  var confirmationMessage = "Thank you for completing the survey. Your unique code is: " + code + '. Provide this in the form on BitBadges when claiming.'
  form.setConfirmationMessage(confirmationMessage);
}
```

3\. Replace 'ENTER\_SEED\_CODE\_HERE' with your actual seed code. To get your seed code, use the Codes plugin on BitBadges:

* Click on the Distribute button which opens up the modal.
* Select Batch.
* Copy the seed code.

<figure><img src="../../../../.gitbook/assets/image (312).png" alt=""><figcaption></figcaption></figure>

#### 4. Set Up the Trigger

* In the script editor, click on the clock icon to open the Triggers page.
* Click on + Add Trigger.
* Set the following options:
  * Choose which function to run: onFormSubmit
  * Choose which deployment should run: Head
  * Select event source: From form
  * Select event type: On form submit

<figure><img src="../../../../.gitbook/assets/image (313).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/image (310).png" alt="" width="554"><figcaption></figcaption></figure>

#### 5. Save and Close

Save your script by clicking on the disk icon or pressing Ctrl + S. Close the script editor.

#### 6. Test Your Form

Submit a response to your form.

* Check the confirmation message to see your unique code.
* Note that the forms are assigned based on number of responses (including any test submissions). If you want to reset from scratch, you can delete all saved responses in your form.



**Add-Ons**

Consider adding functionality to the script like sending the code via emails, protecting against multiple submissions, etc. We leave thi sup to you and your needs.



## File: ./for-developers/claim-builder/automate-w-zapier/dynamic-store-zaps.md

# Dynamic Store Zaps

We refer you [here](../dynamic-stores/adding-data.md) for more information.&#x20;

Zaps to add users to a dynamic store may be the most common use case for the BitBadges Zapier integration, notably because they can operate without crypto addresses in favor of emails. You can simply just use the Zap to parse email or user ID or username -> add to the store and let BitBadges handle the rest of the crypto-native stuff.

<figure><img src="../../../.gitbook/assets/image (348).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/automate-w-zapier/leveraging-zapier-ai-actions-mcp.md

# Leveraging Zapier AI Actions / MCP

Leverage Zapier AI actions to build cool use cases with BitBadges x AI. This is applciable ot both the criteria and rewards side.

{% content-ref url="../leveraging-ai.md" %}
[leveraging-ai.md](../leveraging-ai.md)
{% endcontent-ref %}

<figure><img src="../../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/automate-w-zapier/post-success-zaps.md

# Post-Success Zaps

Post-success Zaps are a great way to implement custom utility from over 7000+ apps upon claim successes.

There are two options:

1. Use Webhooks by Zapier plugin and catch a POST request + Post-Success Zap plugin in your claim. This is recommended as it is much more feature complete and allows you to get social identifiers like emails, apps, etc.
2. Use the Claim Success trigger provided by BitBadges x Zapier Integration



For this tutorial, we will showcase Option 1 (recommended):

1. Setup your Zap (in the Zapier interface) with Webhooks by Zapier and catch a POST request

<figure><img src="../../../.gitbook/assets/image (377).png" alt=""><figcaption></figcaption></figure>

2. Configure your Post-Success Zapier Webhook plugin in the BitBadges site. Add the webhook URL it gives you from Step 1. For Zapier, the validation secret is not as important, but you can additionally add a step to check it within the Zap. The JSON preview it shows you will give you all the available fields you can use.

<figure><img src="../../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

3. Use the Send Test Request in the BitBadges site to complete the test / simulation step in your Zap.

<figure><img src="../../../.gitbook/assets/image (378).png" alt=""><figcaption></figcaption></figure>

4. Configure your action with any app and dynamically replace values where needed. For example, if your action is an outbound send email, you will need to parse the email from the webhook and automatically populate the recipient address for the email.

<figure><img src="../../../.gitbook/assets/image (379).png" alt=""><figcaption></figcaption></figure>

5. Setup the rest of your Zap, create the claim, and you are good to go!


## File: ./for-developers/claim-builder/bitbadges-api-claims/README.md

# BitBadges API & Claims



## File: ./for-developers/claim-builder/bitbadges-api-claims/auto-complete-claims-w-bitbadges-api.md

# Auto-Complete Claims w/ BitBadges API

Note: This is a more advanced option that is incompatible with in-site plugins. Before going through the entire process, consider whether you can implement your use case with a plugin-only approach.

Typically, we recommend making a custom webhook / plugin over this. Get creative! Use existing plugins, Zapier, create custom plugins, etc as an alternative to needing a complete auto-complete implementation.

<figure><img src="../../../.gitbook/assets/image (27) (1).png" alt=""><figcaption></figcaption></figure>

### Auto-Completion

You can use the BitBadges SDK to auto-complete claims for users.

```typescript
const res = await BitBadgesApi.completeClaim(claimId, address, { ... });
console.log(res.claimAttemptId);

//Sleep 2 seconds to wait for it to be processed in the queue

const res = await BitBadgesApi.getClaimAttemptStatus(res.claimAttemptId);
console.log(res); // { success: true }
```

When creating on the BitBadges site, go to the API Code tab, and you should see code snippets customized to your claim.

<figure><img src="../../../.gitbook/assets/image (292).png" alt=""><figcaption></figcaption></figure>

Couple notes with auto-completing claims:

* If your claim is setup to require proof of sign in, proof of other socials sign ins (Sign In with Discord, etc), you must have the proper session authentication handled.
* Otherwise, you can setup your claim to be open to anyone but restricted by non-session criteria. For example, do not require proof of address but all claimees must present a valid password (potentially only known by you or the code which is expected to claim).

**Simulating**

You can also simulate the claim (which is instant and not put into the queue). There are also options within this request to simulate specific plugins only for further fine-grained testing (\_specificInstanceIds). The complete claim route automatically simulates and returns instantly if simulation fails. If simulation passes, it is put into the queue.

The body is the same as the completeClaim route. See below.

```typescript
const res = await BitBadgesApi.simulateClaim(claimId, address, { ...body });
```

**Custom Body**

Custom plugins may also require custom body inputs from the user. If you are using a custom plugin not created by you, refer to that plugin's documentation or contact the creator for more input on the custom body schema.

You will need to pass \_expectedVersion. This is the version number of the claim that you expect to complete. If there is a version mismatch at claim time, the claim will fail. This is to avoid instances where the claim creator maliciously changes criteria / actions without you knowing. You can specify -1 for don't check, but this is not recommended.

The custom body (if needed) should be in the following format

```typescript
{
    _expectedVersion: '0', //version of the claim (obtained from fetching the claim)
    [instanceId: string]: { ...pluginBody }
}
```

For example,

```typescript
{
    _expectedVersion: '0', //version of the claim 
    [`abc123`]: { //password plugin w/ instance ID = "abc123"
        password: "abc123"
    },
    [`codes1234`]: { //codes plugin w/ instance ID = "codes1234"
        code: "supersecretcode"
    },
}
```

**Customization**

The rest is left up to you. You decide when to trigger this code. It could be when a user signs in, you can auto-trigger based on certain criteria, or anything else you want.


## File: ./for-developers/claim-builder/bitbadges-api-claims/fetching-claims.md

# Fetching Claims

More documentation is available via the API routes for fetching claims.

Go to the JSON tab of the claim details in-site to see an example one. Note that fetchPrivateParams: true is necessary to get certain private information. You must have permissions to view private parameters.

```typescript
// GET https://api.bitbadges.io/api/v0/claim/claimId?...
const claimsRes = await BitBadgesApi.getClaim({ 
    claimId, 
    fetchPrivateParams: false, 
    fetchAllClaimedUsers: true, 
    privateStatesToFetch: [instanceId],
});
```

<figure><img src="../../../.gitbook/assets/image (74) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/bitbadges-api-claims/verifying-claim-attempts-w-the-api.md

# Verifying Claim Attempts w/ the API

IMPORTANT: Verifying claim attempts are two-fold:

* Authentication: Authenticate the user (can be done with Sign In with BitBadges or however)
* Verifying Claim Attempt: Lookup the claim attempt via the BitBadges API and cross-check the user has satisfied the criteria

Note: You may opt to simply receive a post-success webhook which would take the API verification step out of it.

```typescript
// Pre-Req: Set up your claim at https://bitbadges.io/create
// Pre-Req: User is authenticated

// 1. By address (if you already have it)
// GET https://api.bitbadges.io/api/v0/claims/success/{claimId}/{address}
// successCount will be 1 for on-demand claims and the number of completions for standard
const res = await BitBadgesApi.checkClaimSuccess(claimId, address);
if (res.successCount >= 1) { doSomething(); }

// 2. By attempt ID 
// GET https://api.bitbadges.io/api/v0/claims/status/{claimAttemptId}
const res = await BitBadgesApi.getClaimAttemptStatus(claimAttemptId);
if (res.success) { doSomething() }

// You may also browse all claim-based API routes in the reference like a fetch all claim
// attempts for a user, but the above two are typically what you are looking for.
```

**Claim Attempt IDs vs By Address**

If you already have the user address, you can simply use option 1.

If you want to verify by claim attempt ID, you can use option 2. Claim attempt IDs can be obtained if you are completing the claim on behalf of the user (e.g. via Zapier or the API), or you can set up a custom webhook to receive it.

Note: If you are receiving a post-success webhook, you already know the claim has gone through by the nature of it, so you do not need to verify it.

This will also allow you to map a user address / claim attempt to another social that you may identify your users by. For example, if you authenticate with email, you can request us to verify the user email, receive the email, and use the (ID, email) pair instead of an address.

<figure><img src="../../../.gitbook/assets/image (31) (1).png" alt=""><figcaption></figcaption></figure>

Use one of the plugins pictured below or a custom plugin to do so when setting up your claim.

<figure><img src="../../../.gitbook/assets/image (33).png" alt=""><figcaption></figcaption></figure>

**More Advanced Ways**

Note: You may also implement other ways of verifying claim attempts such as parsing state directly, storing data yourself from webhooks, etc. You can also trust the post-success webook to only be fired upon success. For these, we refer you to the corresponding documentation such as the API. The process is flexible, but the above should be all you need.


## File: ./for-developers/claim-builder/bitbadges-created-plugins/README.md

# BitBadges Created Plugins

##


## File: ./for-developers/claim-builder/bitbadges-created-plugins/ownership-requirements.md

# Ownership Requirements

Below we explain more about the ownership requirements field and schema. This is used in certain plugins for checking token / list ownership.

```typescript
const ownershipRequirements = {
    $and: [
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 1n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 0n, end: 0n },
                },
            ],
        },
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 2n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 0n, end: 0n },
                },
            ],
        },
    ],
};

const popupParams = {
    ...ownershipRequirements,
};
```

#### **Asset Ownership Requirements**

The **assetOwnershipRequirements** uses an $and, $or, and base case schema to allow you to implement custom logical requirements. For $and requirements, all criteria in the array must be satisfied. For $or, one of the criteria in the array needs tobe satisfied. You can implement the "not" case by saying owns x0 of a token.

```typescript
assetOwnershipRequirements: {
    $or: [
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 1n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 0n, end: 0n },
                },
            ],
        },
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 2n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 1n, end: 1n },
                },
            ],
        },
    ];
}
```

**Options**

As an alternative to $or, we also support specifying **options.numMatchesForVerification** which sets a threshold for how many assets in the current group the criteria needs to pass for. For example, below requires 1 / 1000 tokens to be owned out of the IDs 1-1000.

```typescript
assetOwnershipRequirements: {
  assets: [
    {
      chain: 'BitBadges',
      collectionId: 1n,
      assetIds: [{ start: 1n, end: 1000n }],
      ownershipTimes: UintRangeArray.FullRanges(),
      mustOwnAmounts: { start: 1n, end: 1n }
    }
  ],
  options: { numMatchesForVerification: 1n }
}
```

**BitBadges Token Collections**

For BitBadges assets, we expect the chain = ' BitBadges', all collection IDs to be numeric, and all assetIds to be UintRanges. Querying a user owns a token at a specific time is also supported via ownership times.

```typescript
{
  chain: 'BitBadges',
  collectionId: 1n,
  assetIds: [{ start: 1n, end: 1000n }],
  ownershipTimes: UintRangeArray.FullRanges(),
  mustOwnAmounts: { start: 0n, end: 0n }
}
```

#### **Ownership Times** <a href="#ownership-times" id="ownership-times"></a>

```
ownershipTimes: []
```

The default when ownership times is empty or missing is to verify at the current time. If this is the case, we dynamically add the current time as \[{ start: currTime, end: currTime }].

```typescript
ownershipTimes: UintRangeArray.FullRanges();
```

For assets that support ownership times like BitBadges tokens, you can specify custom times to check.


## File: ./for-developers/claim-builder/checking-custom-criteria.md

# Checking Custom Criteria

If the in-site plugins are not enough on the criteria side, consider one of the following:

## Dynamic Stores

Dynamic stores can be created in the developer portal. They are simply a list of users stored by BitBadges, managed by you. You attach it to a claim and gate the claim to users in the list.

Stores are nice because they are not tied to a specific claim, and you do not have to deal with addresses if not needed. They are serverless.

You can:

1. Update users manually in-site
2. Update programmatically via the API
3. Update via Zapier - Triggers from 7000+ apps -> add to dynamic store

{% content-ref url="dynamic-stores/" %}
[dynamic-stores](dynamic-stores/)
{% endcontent-ref %}

<figure><img src="../../.gitbook/assets/image (26) (1).png" alt=""><figcaption></figcaption></figure>

## Custom Webhooks / Plugins

Configure your claim with custom webhooks. Use the "Check Your Own Criteria" plugin. Alternatively, you can use the Forms / Collect Inputs plugin to instead let us store the requests for you, and you can fetch the details in-site / export to CSV format.

Note: The in-site webhook plugins are streamlined alternatives to building your own custom plugins which are a little more feature-rich and reusable.

Be mindful though that if you are checking criteria, you should have verification BEFORE the claim is completed. Post-success hooks cannot affect the outcome.

{% content-ref url="plugins/" %}
[plugins](plugins/)
{% endcontent-ref %}

<figure><img src="../../.gitbook/assets/image (25) (1).png" alt=""><figcaption></figcaption></figure>

## Auto-Completion

You could also initiate the completion of claims on behalf of users with the API or via Zapier. This is advanced and a custom plugin / webhook is oftnetimes a better alternative.


## File: ./for-developers/claim-builder/completion-methods.md

# Completion Methods

With BitBadges claims, you will have a couple ways of completing claims. Note on-demand do not have a completion "action", so this is only applicable to standard claims.

**Option 1: Directly In-Site (Recommended)**

Users can claim directly on the corresponding page directly in the BitBadges site. We envision this is to be used for almost all cases. Custom logic can be implemented through custom plugins or webhooks or other means.

<figure><img src="../../.gitbook/assets/image (84) (1).png" alt=""><figcaption></figcaption></figure>

**Option 2: Auto-Claim by Zapier**

You can can extend BitBadges Claims with our custom Zapier integration that allows you to connect claims with over 7000+ apps. See all supported apps here: [https://zapier.com/apps](https://zapier.com/apps).

For example, make a purchase on Shopify -> get allocated a token or complete a course on Udemy -> get a completion token. The "airdrop" is a claim completion.

<figure><img src="../../.gitbook/assets/image (147) (1).png" alt=""><figcaption></figcaption></figure>

Note: Zapier can also be used to automate other parts of the claim, like specific plugins or implementing post-claim rewards.

**Option 3: Auto-Claim by API**

You can implement a hybrid approach on your own using the BitBadges API and connect it behind the scenes. This allows you full flexibility over the claiming process.

```typescript
const res = await BitBadgesApi.completeClaim(claimId, address, { ... });
```

**Get Creative!**

A common theme you may see when implementing claims is to get creative and think outside the box. There are a ton of integrations and features already implemented. Even if your use case doesn't exactly match the implementation, you can get creative and implement workarounds.

For example,

* Give out claim codes / passwords to those who meet the criteria on your end rather than needing a direct integration.
* Many apps and services are email based rather than username based. Consider using the Email plugin universally.

## Claiming on Behalf of Others

With each claim, there is only one address (the claiming address). There is no initiator and recipient like with standard approvals. If you want to initiate a claim on behalf of others, you have to get a little creative.

**Password (Secrets) Approach**

The typical approach (used for Zapier and other examples) is to disable all user authentication (Signed In to BitBadges) but gate the claim with a password or other secret information. This allows you (who has knowledge of the password) to complete claims.

Because the authentication check is disabled, you can specify any claiming address. However, note that this disables the authentication check for everyone. You must gate the claim in other ways (like the password).

<figure><img src="../../.gitbook/assets/image (360).png" alt=""><figcaption></figcaption></figure>

**OAuth - Complete Claim Scope**

Or, you could also be authorized to complete claims on behalf of the user via the BitBadges API, but this is only used in some cases. You will need separate authorizations from every claiming user. See Sign In with BitBadges for how to implement.


## File: ./for-developers/claim-builder/concepts/README.md

# Concepts



## File: ./for-developers/claim-builder/concepts/claim-numbers.md

# Claim Numbers

By default, we use an incrementing claim number system for standard claims. For example, claim #1, then claim #2, etc.

However, certain implementations may custom assign claim numbers, which can be used to implement custom logic, such as distributing specific tokens.

Only one plugin is allowed to assign claim numbers which is determined by the **assignMethod** of the claim. If the assignMethod === a plugin's unique instance ID, we allow it to assign claim numbers.

<figure><img src="../../../.gitbook/assets/image (359).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/gating-badge-distribution.md

# Gating On-Chain Approvals

In the BitBadges site, we allow using claims to gate approvals, such as mints. For example, gate mints to those who have joined a Discord (checked via a claim).

It is important to note the hybrid apporach here. Claims are checked off-chain. BitBadges becomes the centralized oracle distributing unique claim codes to be used on-chain eventually. Thus, think of claims gating approvals as gating the "right to initiate the transfer" rather than automatically initiating it. It is a two-step process.

On-chain, these are the leaves of [Merkle challenge](../../../token-standard/learn/approval-criteria/merkle-challenges.md) in the approval criteria and are one-time use only to prevent replay attacks. These are not the same codes as the Codes plugin, if en


## File: ./for-developers/claim-builder/concepts/identify-by-socials-emails.md

# Identify By Socials / Emails?

Do you identify your users by emails or a supported social username?

Select one of the webhook plugins (or forms for serverless) when setting up your claim. This will set you up to be able to track and maintain a map of (attempt ID / address) -> user socials or emails, enabling you to continue identifying your users how you already do!

Note: Verifying claim attempts are two-fold: 1) authenticate the user and 2) verify the claim. In this instance, step 1 would be authenticating the user email / social on your end if needed.

{% content-ref url="../plugins/creating-a-custom-plugin/alternatives.md" %}
[alternatives.md](../plugins/creating-a-custom-plugin/alternatives.md)
{% endcontent-ref %}

<figure><img src="../../../.gitbook/assets/image (25) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/signed-in-vs-select-address.md

# Signed In vs Select Address

To require the user to be signed in, select the Signed In to BitBadges plugin. If not selected, we allow any address to be manually entered without address verification or sign in requirements. However, disabling "Signed In with BitBadges" allows any user to claim on another's behalf. Make sure this is intended and all other criteria properly gates the claim.

By not including a sign-in requirement, this makes the user experience better (no signatures). This is also helpful on mobile or other places where users may not have access to their wallets. However, this can be mitigated with approved sign-ins or other approaches like embedded wallets, but those require prior setup.

**Auto-Completing Claims**

If you are planning to auto complete claims behind the scenes via the API or via Zapier, note that you have two approaches.

1. OAuth Sign In with BitBadges - The Signed In requirement will pass if you have the Complete Claims ("completeClaims") scope.
2. Disable + Gate In Another Way - For example, our Zapier flow does not check user sign in but gates with a password that only Zapier knows.

<figure><img src="../../../.gitbook/assets/image (371).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/standard-vs-on-demand.md

# Standard vs On-Demand

Claims, at their core, are just criteria checks, but there are two ways we can check this criteria. The first is standard claims which require a "complete claim" process or action:

* Criteria is checked at completion time
* Claim numbers are assigned
* Can maintain statefulness
* Ledger of users who have claimed

<figure><img src="../../../.gitbook/assets/image (77) (1).png" alt=""><figcaption></figcaption></figure>

The second is on-demand (sometimes described as non-indexed). These are a special type of claim that has unique properties. Notably, they are autonomous, self-contained, can be fetched on-demand, stateless, does not require any user inputs, sessions, and can function with just a user address / creator parameters.

The critieria is not indexed anywhere but rather calculated on-demand.

* No indexing
* No claim numbers
* No verifiable list of users who have claimed
* Limited in feature set because you need to be able to check criteria at any time, so you cannot use authenticated sessions or other apporaches
* Calculated in real-time
* No success webhooks

For example, checking a minimum balance of BADGE is safe to use on-demand because we always know a user's balance at any given time wihtout user interaction and just their address. Another common on-demand check is token ownership as shown below.

<figure><img src="../../../.gitbook/assets/image (78).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/universal-approach-claim-codes.md

# Universal Approach - Claim Codes

We want to highlight that claim codes are a universal approach that can be used with any application / criteria. For example,

-   Give codes to finishers of a race
-   Give codes to attendees of an event
-   Give codes to those who sign in to your website
-   Distribute codes via email, SMS, etc
-   And so on. You distribute according to your needs!

No need for a custom integration or to identify the user by an identifier. Simply identify them with a code.

Use the Codes plugin to set the codes for your claim. We recommend auto-generating them for sufficient randomness, but you may also custom create them.

**Generate Codes from Seed Snippet**

Auto-generated codes are calculated from a seed code, rather than needing to store all N codes. Note indexes are zero-based (code #1 = idx 0).

```typescript
import CryptoJS from 'crypto-js';
const { SHA256 } = CryptoJS;
export const generateCodesFromSeed = (
    seedCode: string,
    numCodes: number
): string[] => {
    let currCode = seedCode;
    const codes = [];
    for (let i = 0; i < numCodes; i++) {
        currCode = SHA256(`${seedCode}-${i}`).toString();
        codes.push(`${currCode}-${i}`);
    }
    return codes;
};
```

**Generate Codes from Seed API Endpoint**

Or, outsource the generation to our [API Route](https://bitbadges.stoplight.io/docs/bitbadges/abee9e7fa5f8d-get-code-codes-plugin)

## **Save for Later Links**

You may also consider using a save for later link. See example below.

[https://bitbadges.io/saveforlater?value=38d3fe58dffea3f7a675b587bc9239e0360047b7482d245f6770deb589aef869](https://bitbadges.io/saveforlater?value=38d3fe58dffea3f7a675b587bc9239e0360047b7482d245f6770deb589aef869)

## **Zapier**

The get code via idx from seedCode route is also available in Zapier opening up some cool possibilities like auto-distribution.

{% content-ref url="../automate-w-zapier/distribute-claim-information-tutorial/" %}
[distribute-claim-information-tutorial](../automate-w-zapier/distribute-claim-information-tutorial/)
{% endcontent-ref %}


## File: ./for-developers/claim-builder/dynamic-stores/README.md

# Dynamic Stores



## File: ./for-developers/claim-builder/dynamic-stores/adding-data.md

# Adding Data

**Method 1: UI**

You can directly manage your store in the interface.

**Method 2: API**

```typescript
await BitBadgesApi.performStoreAction(...)
await BitBadgesApi.performBatchStoreAction(...)
```

If you want to use the BitBadges API to send hooks / POST requests to, you can do so manually. We refer you to the interface in the developer portal for getting the exact route / body you might need.

<figure><img src="../../../.gitbook/assets/image (346).png" alt=""><figcaption></figcaption></figure>

**Method 3: Zapier**

Use the BitBadges Zapier integration to automate workflows for you. Zapier connects to over 7000+ integrations. In this case, your trigger will be the app you want to integrate nad the action will be BitBadges Add User to Dynamic Store.

Typically, you will want to field map data from your trigger (e.g. Eventbrite attendee email) into the BitBadges Store Action step. For documentation on how to do this, see Zapiers documentation.

* [Field Mapping](https://help.zapier.com/hc/en-us/articles/31709122224653-Enter-data-in-Zap-fields#01JC4MFMXXJXSS7GBAYZP32XKZ)
* [Send Data Between Steps By Mapping Fields](https://help.zapier.com/hc/en-us/articles/8496343026701-Send-data-between-steps-by-mapping-fields)

You may notice that we have a few different identifier fields (email, address, id, username). Leave the ones you don't need blank. Which field you populate should correspond to the store type you have created.

<figure><img src="../../../.gitbook/assets/image (349).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (347).png" alt=""><figcaption></figcaption></figure>

You can also use the Zapier approach to check criteria as well. For example,

1. Setup a Google Form that users can enter their email (or parse the Gmail from the metadata).
2. Setup a Zap to trigger upon Google Forms responses.
3. Check if existing Mailchimp subscriber using email provided via the Mailchimp integration plugin.
4. Add email to dynamic store if subscribed (note: we only allow claims for verified emails)

If setting up an in-site claim, you can redirect the users to the form via the URL Click plugin, Custom Instructions Plugin, or just in the description as well.


## File: ./for-developers/claim-builder/dynamic-stores/overview.md

# Overview

#### What are Dynamic Stores?

A flexible storage system on BitBadges' side for maintaining lists of:

* Email addresses
* User Crypto addresses
* User IDs / usernames names from platforms like Discord, etc

These can be thought of as a separate store for maintaining a list of users. You then "attach" stores to a claim and gate the claim by checking if a user is in the store. You control it. We store it. Update it:

* Manually in-site in the developer portal
* Automatically w/ API calls

```typescript
await BitBadgesApi.performStoreAction(...)
await BitBadgesApi.performBatchStoreAction(...)
```

* Automatically w/ Zapier - Listen to 7000+ apps and add users to store in no-code

To get started, go to the Developer Portal. This will walk you through the process of creating, attaching, and adding data to the store.

Once your store is created, you can add users / data to it. Note that we add via a queue-based approach, so the data may take a couple moments to populate.

**Attach to a Claim**

The interface should walk you through the process of attaching it to a claim:

1. Directly in claim builder, you should see your stores in the templates section
2. In the stores tab, click Create Claim for a one-click create a claim which is auto-configured
3. Add the corresponding plugin (email for email stores) and add the store in the parameters select

**Store ID and Store Secret**

When creating your store, you will get a store ID and secret. These are to be provided by the API / Zapier when managing data. You can also manage the store without the secret if you are signed in with the owner address.

#### Core Advantages

**1. Reusability**

* Not tied to specific plugins or claims
* Can be shared across multiple verification processes

**2. Dynamic Management**

* Real-time updates on the go (dynamic instead of static)
* For example, as users check in to an event, you can dynamically add them to the store which would then make the plugin pass for those users dynamically

**3. Outsourced Storage**

* As opposed to a traditional plugin where you maintain a validation endpoint and potentially store data, this is outsourced to us.
* The roles are flipped. We handle the storage and validation, and you just send update hooks as they come in.

**4. Not Address Dependent**

* All accounting for claims and other BitBadges services is done primarily with crypto addresses. For example, to complete a claim, you need to specify a claiming address. However, many apps and services do not have such a link from user ID on the app -> crypto address.
  * This approach allows you to not need to worry about addresses and only the app identifiers / emails. BitBadges handles the rest.

<figure><img src="../../../.gitbook/assets/image (395).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (341).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (396).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/implementing-custom-utility.md

# Implementing Custom Utility

Need to perform some additional action upon the user claiming successfully?

## **Preconfigured Plugins**

The easiest and most typical approach is to just do this with preconfigured plugins. No code required. Many use cases are already implemented for you and will auto execute for you if configured. For example, the Send BitBadges Notification plugin or Assign Discord Role.

<figure><img src="../../.gitbook/assets/image (362).png" alt=""><figcaption></figcaption></figure>

## **Integrations**

Some integrations may check claims automatically for you. For example, create a WordPress gated site by just entering the claim ID to check in the settings.

## **In-Site Rewards - URLs / Content**

When creating rewards on the claim builder page, you can also link gated content / URLs to only be visible to users upon successfully claiming.

You may want additional authentication depending on your tolerance level. You can even consider this in-site URL to initially be a Sign In with BitBadges URL here with eventual redirect support to your destination URL. Authentication becomes streamlined this way.

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Use the BitBadges API

To lookup claim state or recent claim attempts by address or other claim information, use the BitBadges API to query this data. Then, implement your logic as you see fit.

{% content-ref url="bitbadges-api-claims/verifying-claim-attempts-w-the-api.md" %}
[verifying-claim-attempts-w-the-api.md](bitbadges-api-claims/verifying-claim-attempts-w-the-api.md)
{% endcontent-ref %}

## Use Post-Success Zaps

If you want to automate this process, consider using Zapier to auto-execute logic upon claim successes per user.

For example, new claim -> add to Mailchimp list or add to Google Sheets.

<figure><img src="../../.gitbook/assets/image (392).png" alt=""><figcaption></figcaption></figure>

{% content-ref url="automate-w-zapier/post-success-zaps.md" %}
[post-success-zaps.md](automate-w-zapier/post-success-zaps.md)
{% endcontent-ref %}

## **Use Post-Success Webhooks / Plugins / Serverless Request Bin**

<figure><img src="../../.gitbook/assets/image (24) (1).png" alt=""><figcaption></figcaption></figure>

Set up a custom success webhook or plugin (post-success) and receive the configured information (plus any custom user inputs or configured user socials you want to receive) via the payload. By the nature of it being a post-success webhook, you do not even need to verify the claim attempt was successful.

Or, the Collect User Inputs (request bin) plugin is a serverless alternative! Instead of needing your own handler, we store the requests for you. You access them in-site or via the API.

<figure><img src="../../.gitbook/assets/image (25) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/integrate-with-pipedream/README.md

# Integrate with Pipedream



## File: ./for-developers/claim-builder/integrate-with-pipedream/build-custom-plugins.md

# Build Custom Plugins

Building custom plugins with Pipedream could streamline a lot of the development process for you. This is a unique feature that Zapier doesn't offer because you can execute custom code from their SDK rather than just automated workflows that are setup.

Below, we provide an overview in how to do so. For further implementation guides, see the official Pipedream docs and the Custom Plugins docs. All principles of creating and setting up your custom BitBadges plugin apply. This will just streamline the authentication and logic handling on your end.&#x20;

{% content-ref url="../plugins/" %}
[plugins](../plugins/)
{% endcontent-ref %}

Note when building custom plugins, it is typically not recommended to trust full on automation workflows since these are asynchronous and may not handle the claim plugin logic quick enough. Please use direct API calls or code executed directly, or if you do trigger a full automation workflow, return a quick 200 OK and expect logic to be processed asynchronously (e.g. post-claim rewards).

[https://pipedream.com/docs](https://pipedream.com/docs)

**Pipedream SDK**

If you only need your own authentication and not end users, you can simply set this up with the standard SDK code.&#x20;

```javascript
import { axios } from "@pipedream/platform"
export default defineComponent({
  props: {
    slack: {
      type: "app",
      app: "slack",
    }
  },
  async run({steps, $}) {
    return await axios($, {
      url: `https://slack.com/api/users.profile.get`,
      headers: {
        Authorization: `Bearer ${this.slack.$auth.oauth_access_token}`,
      },
    })
  },
})
```

**Pipedream Connect**

Pipedream Connect allows you to actually obtain the access tokens for your users and directly execute API requests on their behalf all programmatically. This takes all of the authentication setup out for you. This is great for seamlessly building third-party custom plugins. Simply setup Pipedream Connect in your app, and then, you have SDK access to 1000s of API integrations at your fingertips. We refer you to their docs for setting this up.

Note that there are two flows for authenticating users:

* Manually triggered by your frontend - If you already have a frontend, you may consider just handling it all there.
* [Connect links](https://pipedream.com/docs/connect/connect-link) - You redirect the user to a Pipedream connect URL and Pipedream handles it for you. This could be useful if you want to make a headless plugin without a custom frontend.

Your frontend URL or connect URL can be configured in the tutorial / user input redirect URI when building your custom plugin. Then, once you have the authentication, you can handle your logic in the plugin handler as you see fit.&#x20;

Or, alternatives including adding custom instructions or developing a configuration tool.

<figure><img src="../../../.gitbook/assets/image (384).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/integrate-with-pipedream/end-to-end-example.md

# End to End Example

This will walk you through an entire end-to-end auto-completion flow for Pipedream. This will assume you need the whole stack of per-user authorizatioon and auto-completing claims. If you do not, you can remove some of these steps and adapt for your use case.

Note: This is not the only way to implement. It is just a guided tutorial.

With user authentication, you will need your users to go through the Pipedream Connect authorize flow somehow. Each user will be identified by an `external_user_id` that you set, and once they authorize, you can specify to use that user's authorization details in the automation workflow. Their authorization details are stored under that user ID within your Connect app.

See docs here: [https://pipedream.com/docs/connect](https://pipedream.com/docs/connect). When creating a project, you can also get a step by step tutorial through the Connect tab.

<figure><img src="../../../.gitbook/assets/image (50) (1).png" alt=""><figcaption></figcaption></figure>

We leave this step open ended up to you. For the sake of the tutorial, we are going to assume that the claim is to be auto-completed upon user authorization. We will also use the Pipedream SDK Connect Link feature to outsource the frontend code, but Pipedream also is flexible for more custom flows.

You will need to create a **token** (short-lived) which can be used to create a Connect Link (see [https://pipedream.com/docs/connect/connect-link](https://pipedream.com/docs/connect/connect-link)). Note the `external_user_id`you use for this user. This is done server-side.

This is also open-ended. For this tutorial, we are going to use a proxy handler endpoint to generate the Connect Link to not need frontend code at all.

If you want to have a headless no frontend plugin, you can consider adding the Custom Instructions plugin in a claim with a link to a proxy handler endpoint. Because tokens are short-lived and generated dynamically, this should be a proxy one that generates the Connect URL and redirects users there (User -> Proxy Handler -> Generate Connect Link -> Redirect to Connect Link).

Let's say our proxy handler endpoint is hosted on `https://my-proxy-handler.com/generate-connect-link`. You will redirect your users to this endpoint to initiate the Connect Link flow. Consider adding this in the claim description or custom instructions plugin or however you want to expose it to your users.

The proxy handler endpoint is as follows:

```typescript
import express from 'express';
import { serverConnectTokenCreate } from '@pipedream/sdk/server';

const app = express();
const PORT = process.env.PORT || 3000;

// Configuration for Pipedream
const PIPEDREAM_CONFIG = {
    clientId: process.env.PIPEDREAM_CLIENT_ID,
    clientSecret: process.env.PIPEDREAM_CLIENT_SECRET,
    appSlug: process.env.PIPEDREAM_APP_SLUG, // Your app's slug from Pipedream
};

// Proxy handler endpoint
app.get('/generate-connect-link', async (req, res) => {
    try {
        //TODO: Get the user ID from query params or however you want to identify the user
        const externalUserId = req.query.userId;

        if (!externalUserId) {
            return res.status(400).json({ error: 'Missing userId parameter' });
        }

        // Generate the short-lived token
        const { token, expires_at } = await serverConnectTokenCreate({
            external_user_id: externalUserId,
            credentials: {
                clientId: PIPEDREAM_CONFIG.clientId,
                clientSecret: PIPEDREAM_CONFIG.clientSecret,
            },
        });

        // Success / error handler URIs
        const successRedirectUrl =
            'https://my-success-redirect-url.com/auth-callback';
        const errorRedirectUrl =
            'https://my-error-redirect-url.com/error-callback';

        // Construct the Connect Link URL
        const connectUrl = `https://pipedream.com/_static/connect.html?token=${token}&connectLink=true&app=${PIPEDREAM_CONFIG.appSlug}&success_redirect_url=${successRedirectUrl}&error_redirect_url=${errorRedirectUrl}`;

        // Redirect the user to the Pipedream Connect flow
        res.redirect(connectUrl);
    } catch (error) {
        console.error('Error generating Connect link:', error);
        res.status(500).json({
            error: 'Failed to generate Connect link',
            details: error.message,
        });
    }
});

// Optional: Callback endpoint for after authorization
app.get('/auth-callback', (req, res) => {
    res.send('Authorization successful! You can close this window.');

    //TODO: Trigger the workflow here if you want to auto-complete the claim automatically (see below)
});

app.get('/error-callback', (req, res) => {
    res.send('Authorization failed!');
});

// Start the server
app.listen(PORT, () => {
    console.log(`Proxy handler running on port ${PORT}`);
});
```

The final Pipedream Connect URL the user will be redirected to is:

```
https://pipedream.com/_static/connect.html?token={token}&connectLink=true&app={appSlug}&success_redirect_url={successRedirectUrl}&error_redirect_url={errorRedirectUrl}
```

Once the user has completed the authorization, you can now use that `external_user_id`to perform authenticated requests. If you want to do this in a headless way, you can use the success callback URL to automatically do it upon completion.

<figure><img src="../../../.gitbook/assets/image (51).png" alt=""><figcaption></figcaption></figure>

For this tutorial, we will auto-complete a claim with their no-code workflow interface ([https://pipedream.com/docs/connect/workflows](https://pipedream.com/docs/connect/workflows)). Follow along here for implementation details. Alternatively, you can directly execute code too without a workflow using their SDK or also fetch the user's authorization credentials and use them in your own code. We recommend the interface for ease of use and testing.

Below, we will explain at a high level and will skip over some lower level details.

1. Create a workflow in the Pipedream site with a HTTP POST webhook trigger.
2. Configure authorization for the webhook. This can be done in a couple ways.
   1. Use Pipedream OAuth
   2. Check for a secret hardcoded value (add a step after) to make sure you are the origin of the request
   3. No authentication - if you do not add authentication, the only thing saving the endpoint from unwanted requests is the knowledge of the endpoint itself. It is important to not leak it if this is your approach
3. When adding your custom actions, select to use the end user's authentication. See the Pipedream docs for testing this. You will probably need to generate a test account and specify the external user ID in the headers.
   1. Ex: For adding a Slack action with the user's authentication, add another step with Slack and select the little switch icon to use user authentication.
4. We recommend using the API request w/ code (NodeJS) feature. You customize your criteria checks here. You may setup custom parameters parsed from the trigger per claim or static hardcoded props. We leave this open-ended up to you. The only requirement is that if a user that does not meet the criteria, this step should throw an error / fail.

<figure><img src="../../../.gitbook/assets/image (52) (1).png" alt=""><figcaption></figcaption></figure>

5. Lastly, set up the BitBadges action step as the final action in the workflow. We refer you to the workflow actions for the options here. Typically, you will auto-complete claims if you have the user's crypto address. If not, it may involve setting up and adding a dynamic store. Make sure to test or simulate before actually claiming for real. Also, ensure you are dynamically adding the user info from prior steps and not hardcoding it.

<figure><img src="../../../.gitbook/assets/image (53).png" alt=""><figcaption></figcaption></figure>

6. The workflow setup is now complete. The workflow will be triggered upon the HTTP request. It will then use the provided `external_user_id`and execute the claim criteria checks from your configured apps and finally, it will complete a BitBadges claim or add to a dynamic store as the final action properly gating the claim.

You can then invoke the workflow per unique `external_user_id`as shown here with the SDK. Or, you can also trigger via HTTP.

```typescript
import { createBackendClient, HTTPAuthType } from "@pipedream/sdk/server";

// These secrets should be saved securely and passed to your environment
const pd = createBackendClient({
  environment: "development", // change to production if running for a test production account, or in production
  credentials: {
    clientId: "{oauth_client_id}",
    clientSecret: "{oauth_client_secret}",
  },
  projectId: "{your_project_id}"
});

await pd.invokeWorkflowForExternalUser(
  "{your_endpoint_url}", // pass the endpoint ID or full URL here
  "{your_external_user_id}" // The end user's ID in your system
  {
    method: "POST",
    body: {
      message: "Hello World"
    }
  },
  HTTPAuthType.OAuth // Will automatically send the Authorization header with a fresh token
)
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/leveraging-pipedream-mcp.md

# Leveraging Pipedream MCP

Pipedream Connect / MCP is super powerful as you can connect BitBadges to 3000+ integrations on the criteria and the rewards side.  We refer youy here for more information!

{% content-ref url="../leveraging-ai.md" %}
[leveraging-ai.md](../leveraging-ai.md)
{% endcontent-ref %}



## File: ./for-developers/claim-builder/integrate-with-pipedream/overview.md

# Overview

Similar to Zapier, Pipedream allows you to build automation workflows. We recommend checking out what is possible via Zapier first. Everything there can be done with Pipedream as well. Pipedream may have less connected apps, but it is more extendible and developer friendly.

**Custom Plugins**

Because Pipedream allows more customization on your level (in addition to just automation workflows), you can use their SDK to implement custom plugins seamlessly. This streamlines the development process and helps you connect to 1000s of applications seamlessly!

{% content-ref url="build-custom-plugins.md" %}
[build-custom-plugins.md](build-custom-plugins.md)
{% endcontent-ref %}

**Automation Workflows**

Automation workflows with Pipedream and BitBadges allow you to auto-complete claims, auto-add users to dynamic stores, implement post-claim logic, and more

Get started by creating a workflow with the BitBadges configuration. Then, you can copy/paste the code provided from the actions / triggers in the subpages of this section to programmatically interact with the BitBadges API. We refer you to the Zapier flows documentation for the high-level concepts and designs.

{% embed url="https://pipedream.com/apps/bitbadges" %}

{% content-ref url="../auto-completing-claims/automate-w-zapier/" %}
[automate-w-zapier](../auto-completing-claims/automate-w-zapier/)
{% endcontent-ref %}

{% content-ref url="workflow-actions/" %}
[workflow-actions](workflow-actions/)
{% endcontent-ref %}

{% content-ref url="workflow-triggers/" %}
[workflow-triggers](workflow-triggers/)
{% endcontent-ref %}

For the inputs, there are two ways of configuring. You may nee dto slightly adapt the templates to fit your desired flow.

Props - You set it manually via the props

```typescript
export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    },
    claimInfo: {
      type: "string",
      "label":  "Claim Information",
      optional: false, // Use optional: false instead of required: true
    },
...
```

Dynamic - Parse from the trigger / another step (steps.trigger.event)

```typescript
export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      const response = await axios($, {
        method: 'POST',
        url: `https://api.bitbadges.io/api/v0/claims/status/${steps.trigger.event.claimAttemptId}`,
 ...
```

<figure><img src="../../../.gitbook/assets/image (54).png" alt=""><figcaption></figcaption></figure>



## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/README.md

# Workflow Actions



## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/add-user-to-dynamic-store.md

# Add User to Dynamic Store

```typescript
import { axios } from "@pipedream/platform"

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      await axios($, {
        method: 'POST',
        url: `https://api.bitbadges.io/api/v0/storeActions/add/${steps.trigger.event.dynamicDataId}/${steps.trigger.event.dataSecret}`,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'x-api-key': this.bitbadges.$auth.api_key
        },
        data: {
          "address": steps.trigger.event.address,
          "id": steps.trigger.event.id,
          "email": steps.trigger.event.email,
          "username": steps.trigger.event.username
        }
      })

      return { success: true }
    } catch (error) {
      $.export('error', error)
      throw error
    }
  },
})
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/complete-claim.md

# Complete Claim

To complete a claim, enter this code in your workflow with [the BitBadges integration](https://pipedream.com/apps/bitbadges) and adapt as needed.

The **claimInfo** is in the format: ${claimId}-${passwordPluginInstanceId}-${password}. You can setup the password plugin manually or select the Automation Workflow completion method -> Copy.

This is the approach we use for automation workflows. We remove any sign in requirements, but anyone claim must specify the secret password (only known to Pipedream / Zapier).

```
62f59244fc1003e331f183c4b3907f87-ecdb0ed0513716af3124899f6e7b5da70eb85c4399dafe2bf970236b34940da9-30892aa1bb0f84b19ecf244958c9cd4676400e13a24791e7512bc88efa217c89
```

<figure><img src="../../../../.gitbook/assets/image (55) (1).png" alt=""><figcaption></figcaption></figure>

```typescript
import { axios } from "@pipedream/platform";

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    },
    claimInfo: {
      type: "string", // Claim details passed as a string in the format "claimId-passwordPluginId-password"
    },
    address: {
      type: "string", // Address of the user
    },
    isSimulation: {
      type: "boolean", // Boolean to determine if this is a simulated run
      default: false,
    },
  },
  async run({ steps, $ }) {
    const details = this.claimInfo.split("-");
    if (details.length !== 3) {
      throw new Error("Invalid claim details parsed");
    }

    const claimId = details[0];
    const passwordPluginId = details[1];
    const password = details[2];

    const endpoint = `https://api.bitbadges.io/api/v0/claims/${
      this.isSimulation ? "simulate" : "complete"
    }/${claimId}/${this.address}`;

    const data = {
      _expectedVersion: -1, 
      [`${passwordPluginId}`]: {
        password: password,
      },
    };

    try {
      const response = await axios($, {
        method: "post",
        url: endpoint,
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
          "x-api-key": `${this.bitbadges.$auth.api_key}`,
        },
        data,
      });

      const result = response;

      // Note: This means a successful trigger (add to queue), not a claim completion
      // You can use the claimAttemptId to poll
      return {
        success: true,
        claimAttemptId: result.claimAttemptId || "",
        currentTimestamp: Date.now()
      };
    } catch (error) {
      throw new Error(`Failed to complete claim: ${error.message}`);
    }
  },
});
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-attempt-status.md

# Get Claim Attempt Status

```typescript
import { axios } from "@pipedream/platform"

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      const response = await axios($, {
        method: 'POST',
        url: `https://api.bitbadges.io/api/v0/claims/status/${steps.trigger.event.claimAttemptId}`,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'x-api-key': this.bitbadges.$auth.api_key
        },
        data: {}
      })

      return {
        success: response.success,
        error: response.error
      }
    } catch (error) {
      $.export('error', error)
      throw error
    }
  },
})
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-code-by-idx.md

# Get Claim Code by Idx

```typescript
import { axios } from "@pipedream/platform"

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      const codeIdx = this.sub_by_one 
        ? steps.trigger.event.code_idx - 1 
        : steps.trigger.event.code_idx;

      const response = await axios($, {
        method: 'POST',
        url: 'https://api.bitbadges.io/api/v0/codes',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'x-api-key': this.bitbadges.$auth.api_key
        },
        data: {
          'seedCode': steps.trigger.event.seed_code,
          'idx': codeIdx
        }
      })

      return response;
    } catch (error) {
      $.export('error', error)
      throw error
    }
  },
})
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/README.md

# Workflow Triggers



## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/poll-claim-attempts.md

# Poll Claim Attempts

For polling claim attempts, we recommend that you jsut set up a custom success webhook with the HTTP trigger on Pipedream. This can be directly configured into your workflow by just adding the POST endpoint URL it gives you.

<figure><img src="../../../../.gitbook/assets/image (385).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/image (386).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/leveraging-ai.md

# Leveraging AI

A great way to implement both criteria and utility is through AI models and agents. This will follow along with the plugins / webhooks that we already have in place!

**Reward Side**

On the reward side, simply set up a post-success claim, receive any user identifiers or inputs needed, and trigger your actions. This can be custom webhooks to any model or service of your choice (Pipedream Connect / MCP, Zapier MCP, anything!), and we also have an in-site plugin for you to use the Zapier AI Actions / MCP service!

<figure><img src="../../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (10) (1).png" alt=""><figcaption></figcaption></figure>

**Criteria Side**

On the criteria side, this is recommended to follow the dynamic stores approach. While you can check and trigger AI models during execution time, we typically recommend against this due to long wait times and poor UX. If you pre-add a user to a dynamic store, the claim process is good UX for the user.

{% content-ref url="dynamic-stores/" %}
[dynamic-stores](dynamic-stores/)
{% endcontent-ref %}

This is left open-ended. You could leverage Zapier AI Actions / MCP and the BitBadges integration to do this automatically.

<figure><img src="../../.gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

```typescript
import fetch from 'node-fetch';

const ZAPIER_API_KEY = 'ADD_YOURS';

const options = { method: 'GET', headers: { 'x-api-key': ZAPIER_API_KEY } };

const fetchActions = async () => {
  const response = await fetch('https://actions.zapier.com/api/v2/ai-actions/', options);
  const data = await response.json();
  return data;
};

const executeAction = async (actionId: string, email: string) => {
  const options = {
    method: 'POST',
    headers: { 'x-api-key': ZAPIER_API_KEY, 'Content-Type': 'application/json' },
    body: `{"instructions":"Add ${email} to the store" ,"params":{}}`
  };

  await fetch(`https://actions.zapier.com/api/v2/ai-actions/${actionId}/execute/`, options)
    .then((response) => response.json())
    .then((response) => console.log(response));
};
```


## File: ./for-developers/claim-builder/other-tutorials/README.md

# Other



## File: ./for-developers/claim-builder/other-tutorials/add-telegram-bot-to-channel.md

# Add Telegram Bot to Channel

This guide will walk you through the process of adding the BitBadges bot (@bitbadges\_bot) to your Telegram channel. By integrating this bot, you can enhance your channel with BitBadges functionality.

### Prerequisites

* You must be an admin of the Telegram channel where you want to add the bot.
* You need to have the Telegram app installed on your device.

### Steps to Add the BitBadges Bot

#### 1. Find the BitBadges Bot

1. Open your Telegram app.
2. In the search bar at the top, type "@bitbadges\_bot".
3. Tap on the BitBadges bot in the search results.

#### 2. Start a Chat with the Bot

1. Tap on the "Start" button to initiate a conversation with the bot.
2. The bot may send you a welcome message with instructions.

#### 3. Add the Bot to Your Channel

1. Go to your Telegram channel.
2. Tap on the channel name at the top to open the channel info.
3. Scroll down and tap on "Administrators".
4. Tap on "Add Administrator".
5. Search for "@bitbadges\_bot" and select it from the results.
6. Review the bot's permissions. Ensure it has the necessary permissions to function properly in your channel.
7. Tap "Done" to add the bot as an administrator.

####


## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/README.md

# Get Integration User IDs



## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/discord.md

# Get Discord Server ID

To get your discord server ID, this can be done by right clicking on the  server -> Copy Server ID,

<figure><img src="../../../../.gitbook/assets/image (233).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/get-discord-user-id.md

# Get Discord User ID

<figure><img src="../../../../.gitbook/assets/image (132).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/x-twitch-github-ids.md

# X / Twitch / GitHub IDs

X / Twitter - [https://www.wikihow.com/Find-Your-User-ID-on-Twitter#:\~:text=Visit%20a%20site%20like%20What's,as%20you%20know%20their%20username.](https://www.wikihow.com/Find-Your-User-ID-on-Twitter)

GitHub  - [https://caius.github.io/github\_id/](https://caius.github.io/github\_id/)

Twitch - [https://www.streamweasels.com/tools/convert-twitch-username-to-user-id/](https://www.wikihow.com/Find-Your-User-ID-on-Twitter)


## File: ./for-developers/claim-builder/other-tutorials/in-site-guides.md

# In-Site Guides

The best way to get started with a tutorial is to use the Claim Tester in-site, and simply browse the guides section or experiment by adding plugins. The guides section will have a ton of common patterns and show you how to implement ideas that may or may not be supported natively. Find a similar use case to yours and apply the same steps. Even if there is nothing similar, most of the same principes to apply to almost all integrations.

If you need to see the resulting claim JSON (for advanced implementations), you can also see this in-site under the JSON tab of the claim details.

<figure><img src="../../../.gitbook/assets/image (63) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/overview.md

# Overview

> üí° **Note:** This documentation is intended to provide developer documentation for more advanced use cases. Most of the time, you can directly do everything in-site. Or if you need custom functionality, it is oftentimes a better approach to just self-implement the functionality you need rather than deal with the complexities of connecting with claims. LLMs, especially with MCP, are great for implementing all of this stuff. We just provide claims as an out of the box tool in-site.

BitBadges claims are designed to be a comprehensive tool directly within the site or via the API for you to custom gate your utility. Claims can be simply thought of as: **Meet criteria? -> Offer utility / rewards.** The implementation process aims to be super flexible, allowing you maximum customization.

<figure><img src="../../.gitbook/assets/image (23) (1).png" alt=""><figcaption></figcaption></figure>

### **How do claims work? What are plugins?**

Claims are made up of one or more plugins executed in order. By default, all must pass, but this can be customized. Out of the box, we offer plenty of built-in plugins and features with no code required and directly claimable by users in the site. Or, you can extend its functionality with helper tools, custom plugins, Zapier, our API, and more!

### **Get Creative**

While we do offer a ton of functionality directly in-site, your desired functionality may not be directly supported. Before considering custom implementations, get creative!

* Can you implement everything with a token and then check token ownership?
* Use claim codes or a password which can be used as a universal approach (no need for a specific app integration)
* Can your users be identified by email? Addresses? Use those plugins or dynamic stores
* Does Zapier support your approach? They have 7000+ apps and integrations natively. Pipedream?

### **How to create / manage claims?**

Claims are created and managed in the developer portal.

### **What is possible in-site?**

Most of the time, you can directly do everything without a line of code. Get creative and experiment!

* Gate URLs / Content to those who claim with the Rewards tab
* Use the Discord Role Assigner plugin to create gated channels
* And much more

### **Can claims connect to other BitBadges services?**

Claims are the universal connector. You can not only check criteria from any BitBadges service (token ownership, >100 points) but also use claims on the reward side (gate mints, award points).

<figure><img src="../../.gitbook/assets/image (393).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/README.md

# Plugins



## File: ./for-developers/claim-builder/plugins/configuration-tools.md

# Configuration Tools

Configuration tools are a helper layer abstracted over the core plugin implementations. Instead of creating new, individual plugins for each use case, you can often reuse existing ones. Configuration tools help the user configure the parameters of existing plugins.

For example,&#x20;

-   Google Calendar can be implemented by configuring the Email plugin with the attendee emails
-   Auto-configure approved user addresses with the Address Restrictions plugin
-   Or any application can be implemented by issuing claim codes with the Codes plugin.

```
Note: This is a more advanced option and is not a great user experience.
This should only be used in select cases.

Please create custom plugins for better UX.
```

Prompt the user to add the copy / paste the stringified JSON to the Configuration Tools tab on the claim builder.

<figure><img src="../../../.gitbook/assets/image (387).png" alt=""><figcaption></figcaption></figure>

```json
{
    "pluginId": "codes",
    "version": "0",
    "publicParams": { "numCodes": 1 },
    "privateParams": { "codes": ["code123"] }
}
```


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/README.md

# Creating a Custom Plugin



## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/alternatives.md

# Pre-Built Webhook Plugins

Configure prebuilt webhook plugins in the claim builder without needing to create an entirely new custom plugin. Just enter the endpoint and configure what you want to receive.If you do not want to actually set up a full handler, you can also use the Forms plugin which allows you to store and view the requests in-site (serverless).

<figure><img src="../../../../.gitbook/assets/image (24) (1).png" alt=""><figcaption></figcaption></figure>

**Note**: These plugins only support a simple POST request and expect a 200 OK response. If you require more custom logic or reusability, a custom plugin is necessary.

### Configuration

* **POST Routes**: Customizable routes for your needs.
* **User Details**: Optionally select to receive user details, like their address, custom inputs, or connected socials (only identifying information and no authentication tokens or details)
* **Validation Secret**: Customize a validation secret to confirm requests are from BitBadges. This is what is entered in the form.
* **Expected Response:** 200 OK within 10 seconds
  * For non-critical logic, consider returning 200 early and asynchronously process.
  * Stateless

### Forms Plugin - Serverless

The forms plugin is a serverless alternative. This is titled "Collect User Inputs" in the site.

Think of this like a request storage bin. We store the requests that would've been sent to the webhooks for you. You can then view them in-site or fetch them from the API when needed.

```typescript
// Pre: Get the attempt ID. If you do not have it already, see the API reference endpoints

// GET /api/v0/requestBin/attemptData/{claimId}/{claimAttemptId}
const res = await BitBadgesApi.getAttemptDataFromRequestBin("claim123", "attempt123", { ... });
console.log(res);
// { bitbadgesAddress, email, claimAttemptId } 
```

<figure><img src="../../../../.gitbook/assets/image (16) (1).png" alt=""><figcaption></figcaption></figure>

### Implementation - Handlers

The request/response flow mirrors that of custom plugins, with the `pluginSecret` replaced by the inputted validation secret. For detailed implementation guidance, refer to the respective documentation. The configuration is done in-site via the claim builder.

1. Setup your plugin handler (see plugin documentation for more information)
2. Create your claim and configure the webhook as one of the plugins, specifying your endpoint
3. Test it out to make sure it is working


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/README.md

# Implement Your Plugin

###


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/api-handler.md

# API Handler

The outgoing request (from BitBadges to your plugin) will be made up of the custom body inputs (passed from your frontend), the claim parameters, plus some contextual information about the claim and the claiming user.

-   **Plugin Secret:** A plugin secret value that you can use to verify BitBadges as the origin of the call. This is secret only to you and can be obtained via the developer portal when creating your plugin.
-   **Claiming Address:** The **bitbadgesAddress** of the user who is attempting to claim (bb-prefixed Cosmos address).
    -   Note the claiming address may not be verified (signed in) dependeing on the configuration (the user must have the Signed In to BitBadges plugin). If you need to make sure that the user is signed in, use the **isAddressSignedIn** field. This will be true if the claiming user is signed in as the claiming address. All other socials you can assume have been verified / signed in.
-   **Claim Information**: Lastly, we also pass the **claimId,** as well as the claim's **createdAt** and **lastUpdated** timestamps. These can be used, for example, to implement version control systems on your end.
-   **Claim Attempt ID:** The claim attempt ID is the ID of the attempt, and you can use it to track the status of the claim (whether it eventually fails or succeeds).
-   **Attempt Status:** The attempt status (attemptStatus) will be 'executing' during the execution of the claim. If you subscribe to success status webhooks (in the configuration), we will also send a second request (with same body and headers) and \_attemptStatus='success'. This can be used to trigger post-claim logic that needs to wait until completion.
-   **Simulation (Dry Run) Flag:** The **\_isSimulation** flag tells you whether this is a known dry run.

For POST, PUT, and DELETE requests, we pass the values over the body. For GET, we pass them over the GET params. You are responsible for making sure the endpoint is accessible (e.g. no CORS errors, etc.). Make sure it is the desired type as well (i.e. GET vs POST vs DELETE vs PUT).

```typescript
const payload = {
    ...customBody, //if applicable
    ...allConfiguredParams, //if applicable

    // Context info

    email: 'bob@abc.com', //If pass email is configured
    discord: { id: '...', username: '...', discriminator: '...' }, //If configured
    twitch: { id: '...', username: '...' }, //If configured
    twitter: { id: '...', username: '...' }, //If configured
    github: { id: '...', username: '...' }, //If configured
    google: { id: '...', username: '...' }, //If configured
    pluginSecret: pluginDoc.pluginSecret,
    claimId: context.claimId,
    claimAttemptId: context.claimAttemptId,
    bitbadgesAddress: context.bitbadgesAddress, //If pass address is configured
    _attemptStatus: context._attemptStatus,
    lastUpdated: context.lastUpdated,
    createdAt: context.createdAt,
    version: context.version,
};
```

### **Identifying the Claiming User**

If you need to identify the claiming user, we pass their address + other requested socials to your endpoint. The socials will all be verified and signed in on our side. The address will be authorized if your plugin specifies the require sign in? option or the claim creator requires sign in.

Although that may not be enough if you identify your users in another way, or you may just not want to fully trust BitBadges. You can also simply check via a secret authorization code. Give them the authorization code on your end while authenticated. Have them enter it as a custom user input in-site. Then, verify it on your end.

### **Responses**

All responses expect a 200 success OK status code within 10 seconds for a successful attempt. For any of the below, do not assume that a 200 OK response means a successful claim and a successful set of the new state. Think of this as a hypothetical state transition IF the claim is eventually successful.

Note: Ensure the returned JSON object keys do not contain any "." characters because that may mess up the state handler. For example, emails should be bob@abc\[dot]com rather than bob@abc.com.

**Stateless Preset**

The stateless preset is simple. If we receive the 200, the plugin is successful. Nothing else is checked via the response. Everything is handled on your end (if you have state).

<figure><img src="../../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1)   (1).png" alt=""><figcaption></figcaption></figure>

**Claim Token Preset**

This preset expects a { claimToken} in the response. The claim token is a one-time use only claim code. Issuing claim tokens is left up to you.

<figure><img src="../../../../../.gitbook/assets/image (141) (1).png" alt=""><figcaption></figcaption></figure>

**Claim Numbers Preset**

This preset expects a { claimNumber } in the response. The claim number is the claim number that will be assigned if the claim number is successful. Claim numbers are 0-based, so claimNumber === 0 is the first claim, and so on.

IMPORTANT: Only one plugin can control claim number assignment. If you select this approach, claims that use this plugin will not be compatible with any other plugin that uses the claim number preset.

### **Success Hook Responses**

For success hooks (\_attemptStatus=success), we also expect a 200 OK within 10 seconds. If you need to do asynchronous processing, return 200 OK early and process as you desire.

Otherwise, for failed attempts, we will retry later with an exponential backoff policy.

### **Error Responses**

If your plugin fails, we will save the error for debugging / monitor purposes. It may be displayed to the claiming user and / or claim cretor, so make errors informative but do not reveal sensitive information.

Please follow the { message } interface for returned JSON error responses.

### Example Plugin Handler

<pre class="language-typescript"><code class="lang-typescript"><strong>//TODO: Fill in missing information
</strong>const handlePlugin = async (req: NextApiRequest, res: NextApiResponse) => {
  try {
    //Step 1: Handle the request payload from the plugin
    const body = req.body; //We assume the plugin sends the payload in the body of the request (change this for GET)
    const { claimId, pluginSecret, bitbadgesAddress, lastUpdated, createdAt } = body;
    const { ...otherCustomProvidedInputs } = body;
    
    //Handle anything specific to dry runs _isSimulation

    //Step 2: Verify BitBadges as origin by checking plugin secret is correct
    const YOUR_PLUGIN_SECRET = '';
    if (pluginSecret !== YOUR_PLUGIN_SECRET) {
      return res.status(401).json({ message: 'Invalid plugin secret' });
    }

    //Step 3: Implement your custom logic here. Consider checking the plugin's creation / last updated time to implement version control.
    //TODO: 

    //Step 4: Return the response to the plugin based on your configured state function preset
    // const claimTokenRes = { claimToken: '...'  }
    // const statelessRes = {};
    return res.status(200).json({});
  } catch (err) {
    console.log(err);
    return res.status(401).json({ message: `${err}` });
  }
};

export default handlePlugin;
</code></pre>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/design-considerations.md

# Design Considerations

### Your Plugin Status !== Claim Success Status

For processing hooks, note that your plugin may succeed, but this does not mean the overall claim will succeed. Other plugins may fail, or other stuff may go wrong.

If you receive a post-success hook, you can be sure the claim has succeeded. Or, you can use the attempt ID to verify it on your end as well,

### Asynchronous Processing

Claims are processed in an asynchronous manner. For processing hooks, your plugin may succeed, but the claim may not complete until a later time.

Best practices:

* If using state management on BitBadges end for custom plugins, design your plugin to avoid race conditions. For example, do not return the same one-time use claim token to multiple attempts. Most plugins are stateless (on BitBadges end) though and do not have to worry about this. It should always be eventually oconsistent.
* Do not depend on the BitBadges claim state like number of claims completed. It may not be up to date or real-tie at the time of your plugin's execution. Your custom parameters are okay to depend on.

This is not really applicable to post-success hooks.

### State Management

An important aspect to consider is how you will handle state (if applicable). The golden rule here is that a successful response from your plugin DOES NOT mean the overall claim attempt was successful. Other plugins might fail. Or vice versa, your plugin may fail, but the claim succeeds. We only update state on our end if your plugin passed and was in the success path (we short-circuit OR requirements).

You have a couple options:

* Use the preset response patterns to customize how BitBadges controls state for your plugin on our end. This is eventually consistent meaning that you return an intent from your handler, and we update only upon successful claim (and in the success path).
  * A typical flow is to associate certain state with unique claim tokens and let BitBadges handle the claim tokens being marked as USED vs UNUSED.
* Manage state on your end, but be mindful of the way BitBadges processes claims.

### Reusing for On-Demand Claims

To be used with on-demand claims, the plugin must meet specific requirements and have specific properties:

* Stateless - No per-attempt state
* No User Inputs - The plugin should be able to function at any time without any custom user inputs. Note this also includes socials or connected sessions.
* Only Needs Context - The plugin should be able to function with just the contextual information passed. The context mainly includes the plugin information, claim information, and the claimee's address.

Typically, these are only possible with crypto-native plugins. For example,

* Check >1 ETH in account from address
* Check POAP ownership
* Check token ownership

Parameters are okay because they are hardcoded and not changed (e.g. set min ETH to 1).

### **Authentication / Sensitive Values**

As a design decision, we do NOT want to handle your authentication or sensitive values. Treat BitBadges as a middleman. Authentication should either be fully managed by BitBadges (identifers passed to you like email, usernames) or fully managed by you from start to finish. This applies to both the creator and the end claiming user.

If you need to make authenticated requests on behalf of the user (beyond just receving identification information), you will need to implement authentication on your end. You may let the claim creator store sensitive information in the private parameters of the plugin.

Consider a workaround such as storing any information yourself, mapping it to a token or code, giving that code to the user / creator, and having them enter it in the flow. You then use the token / code to lookup the information in your handler.

This approach follows the same flow as OAuth authorization codes, except with a custom claim code. You should follow all the same best practices (expiring tokens, PKCE for preventing authorization code interception attacks, and more).

<figure><img src="../../../../../.gitbook/assets/image (120) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/getting-started.md

# Getting Started

To create, publish, and maintain your plugin, go to [https://bitbadges.io/developer](https://bitbadges.io/developer) and use the Plugins tab. This should walk you through the whole process of configuration and submitting it to be used on the BitBadges site. If you are confused at any point, refer back to this documentation.

For testing purposes, you can setup using Pipedream's request bin ([https://pipedream.com/requestbin](https://pipedream.com/requestbin)) and just monitor incoming requests that way.

<figure><img src="../../../../../.gitbook/assets/image (104) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/hook-types-and-simulations.md

# Hook Types and Simulations

### Timing of Hooks

BitBadges can send the request at two different times (during processing hooks and success hooks after successful claim). Certain settings in the creation form can be set to customize how or if we send these. You may choose to receive or ignore them.

-   Processing hooks (\_attemptStatus = "executing") are checked during the execution of the claim, and the results could influence whether the claim succeeds or not.
-   Post-Success hooks (\_attemptStatus = "success") are only sent after the claim is successful and cannot affect the outcome of the claim. Typically used for post-claim actions or success logic. If a 200 OK is not received, we will use exponential backoff to retry until successful.

<figure><img src="../../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Simulations

```
NOTE: Catching simulations is important.

You do not want to execute success logic on a dry run.
```

We allow users to simulate claims as a dry run before they actually submit for real. The BitBadges site will always simulate once before submitting, but you should not depend on every claim attempt having a prior simulation.

The scope of the dry run is left up to you, but we recommend as a rule of thumb is that if the user successfully simulates, they are expected to always pass at execution time.

To determine whether you are receiving a simulation hook or a "for real" hook, you can use the \_isSimulation flag that is passed. The claimAttemptId will also be empty / blank, but the rest of the payload should remain the same.

You can select to not receive simulation hooks at all in the usage settings when creating your plugin in the developer portal.


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/parameters.md

# Parameters

Each plugin can configure the expected schema of parameters inputted by the claim creator and the end user. These will all be available in the payload of your handler in addition to contextual information like address, attempt ID, etc.

```json
{
    ...context,
    ...publicParams, // Public to the end users
    ...privateParams, // Private to BitBadges and the claim creator
    ...userInputs
}
```

Parameters will be passed to your backend handler in the payload.

<figure><img src="../../../../../.gitbook/assets/image (336).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/user-inputs.md

# Custom Inputs

### Handling User / Creator Inputs

If your plugin requires inputs from the claiming user or claim creator, you can do this in the BitBadges site (recommended) or via a window.postMessage from a custom frontend / tool. All inputs will be passed along to your handler via the payload. If none are provided, we assume there is nothing needed to be passed.

<figure><img src="../../../../../.gitbook/assets/image (338).png" alt=""><figcaption></figcaption></figure>

Note to be compatible with Zapier (and possibly API auto-claiming) or on-demand claims, user inputs are typically not allowed (because the user is not manually initiating anything).

**Option 1: Completely In-Site**

When creating the plugin, configure the expected schemas. We will prompt the users / creators to enter such information in-site via a form. All outsourced to BitBadges.

<figure><img src="../../../../../.gitbook/assets/image (294).png" alt=""><figcaption></figcaption></figure>

**Option 2: Custom Frontend**

Consider creating your own frontend that the user will be redirected to via the redirect URL.You will need to combine approaches. This typically follows a code approach. For example, handle secure stuff on your end -> grant an authorization / claim code -> have user add it directly in the site -> use the code for whatever.

**Supported Schema Types**

Primitives: String, Number, Boolean

Date: UNIX millisecond timestamp

URL: Stringified URL

### Identifying the Claiming User

You can also select to automatically pass supported identifying details about the user (e.g. crypto addresses, Discord, X, GitHub, etc). Note no access tokens or auth details are passed along so private, authorized requests are not possible with this information.

We will authenticate the user on our end where needed, and you can use their identifying information to execute queries (e.g. public GitHub contributions). The only one that may not be verified in some cases is the claiming address. This depends on the configuration (the user must have the Signed In to BitBadges plugin). If you need to make sure that the user is signed in, check the **isAddressSignedIn** field. This will be true if the claiming user is signed in as the claiming address.

<figure><img src="../../../../../.gitbook/assets/image (388).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../../.gitbook/assets/image (389).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/managing-your-plugin.md

# Managing Your Plugin

### Updating Your Plugin / Version Control

Management of your plugin is done through the developer portal. You may configure different versions of your plugin. New claims will always use the latest **finalized** version. Existing claims will remain on the version they were created with. Unfinalized versions can ONLY be used by you in the claim tester.

We leave updates and version control management up to you. It is your responsibility to keep claims compatible and functioning. If you need to implement a breaking change, you can also consider using the createdAt, lastUpdated, or version fields passed via the context to implement version control and handle it on your end. Or, you can also create a new plugin.

## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/testing-your-plugin.md

# Testing Your Plugin

There are two approaches to testing your plugin.

**Local Development**

Use your favorite tool to simulate requests to your handler such as the one below. Replace with your corresponding details.

```bash
curl -X POST https://yourhandler.com  -H 'Content-Type: application/json' -d '{
  "pluginSecret": "068145b0058668ac5b880e23ca2556e4207efe8066227f4eb3466a6b0d16daa4",
  "claimId": "abcxyz123",
  "claimAttemptId": "...",
  "lastUpdated": 1800000000000,
  "createdAt": 1800000000000,
  "version": "0",
  "_attemptStatus": "executing",
  ...USER_ID_DETAILS, //whatever is configured
  ...YOUR_INPUTS
}'
```

**Test Requests**

In the creation / update interface, there will be a Send Test Request button which will send a formatted request from your browser. This uses mocked data, and should only be used for testing purposes.

<figure><img src="../../../../.gitbook/assets/image (320).png" alt=""><figcaption></figcaption></figure>

**Claim Tester**

The easiest way to test your plugin integration with BitBadges is with the Claim Tester tab in the developer portal. This is the only place you will be able to test unfinalized versions of your plugin.

<figure><img src="../../../../.gitbook/assets/image (124).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/overview.md

# Overview

Plugins / webhooks are simply HTTP requests.

1. Configure your plugin / webhook in the BitBadges site
2. Set up your handler at the specified URL / method. Use the payload to implement your logic. The payload includes context about the attempt plus can include the user address, email, social usernames, custom inputs, and more.
   1. Check the pluginSecret to verify BitBadges as the origin of the request if this is important
3. Return the expected response that was configured (e.g. 200 OK)

<figure><img src="../../../.gitbook/assets/image (28) (1).png" alt=""><figcaption></figcaption></figure>

```typescript
const handlePlugin = async (req: NextApiRequest, res: NextApiResponse) => {
  //Step 1: Handle the request payload from the plugin
  const body = req.body; //For POST
  const { _isSimulation, claimId, pluginSecret, bitbadgesAddress, lastUpdated, createdAt } = body;
  const { ...otherCustomProvidedInputs } = body;
  
  //Step 1.5: Catch simulations if applicable. Don't run success logic on a dry run
  // if (_isSimulation) return doDryRunStuffOnly();
  
  //Step 2: Verify BitBadges as origin by checking plugin secret is correct
  const YOUR_PLUGIN_SECRET = '';
  if (pluginSecret !== YOUR_PLUGIN_SECRET) {
    return res.status(401).json({ message: 'Invalid plugin secret' });
  }
  
  //Step 3: Implement your custom logic here. Consider checking the plugin's creation / last updated time to implement version control.
  
  //Step 4: Return expected responses
  return res.status(200).json({});
};

export default handlePlugin;
```

We have designed plugins in a way to allow you maximum customization by letting you handle as much of the plugin logic as possible. This is a design decision as we believe the core logic of the distribution process should be decentralized and community-driven (not centralized on BitBadges servers).

**Potential Parties**

* Claim Creator - Entity creating the claim that uses the plugin
* Claiming User - End user attempting to claim
* Plugin Creator - Entity creating the plugin

**Timing of Requests**

Plugins can either be:

* Success hooks: Only sent after the claim succeeds. Typically for post-claim logic or rewards
* Processing hooks: Sent during execution and can affect the overall outcome of the claim depending on the response.

We also allow users to simulate (dry run) their claim attempts. Plugins are expected to handle these as necessary. These are all configurable in the creation process in-site.

**Parts of the Plugin**

* Backend Handler (Your API) - All plugins have a backend handler that we expect a 200 OK response from, along with other details depending on the configuration, at claim time.
* Claim Creator Input Handlers (Public / Private Parameters) - The creator will need to configure public and private parameter, if applicable. This can be done in-site or outsourced to a configuration tool.
* User Input Handlers (Custom Input Body) - The user may also need to enter inputs for the claim attempt. This can also be done in-site or outsourced to your own custom frontend.

<figure><img src="../../../.gitbook/assets/image (120) (1).png" alt=""><figcaption></figcaption></figure>

**State Management**

If there is any core state required to be used, this must be managed on BitBadges side to avoid race conditions. To workaround this, the plugin will pass along expected updates IF the claim is passed (e.g. mark this one time use claim token as USED IF the claim is successful).

The golden rule here is that a successful response from your plugin DOES NOT mean the overall claim attempt was successful. Other plugins might fail. The other way around is also true. If your plugin fails, the overall claim may still be successful (e.g. 1 out of 10 plugins must pass but yours fails).

**Published Plugins**

Plugins are private and only usable by the creator and approved users by default, but you can publish them as well. Published plugins will be displayable in the directory (after a review process) and selectable by anyone creating a claim.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Plugin IDs vs Instance IDs**

Plugin IDs are constant and specific to a specific plugin type. For example, the password pluginId is "password".

Instance IDs are a unique identifier for a specific plugin in your claim. This is to handle duplicates. For example, you may have two password plugins, one with instance Id "abc" and one with "def". This is just used as a unique identifier and can really be anything. If you only have one instance of a specific type, you can name it the same as the pluginId as well.


## File: ./for-developers/claim-builder/success-logic.md

# Success Logic

Certain claims may make use of the **satsifyMethod** property to implement dynamic logic. This option is currently only available behind the scenes. Frontend defaults to all are required (satisfyMethod = undefined). By default, all plugins must pass without any custom success logic specified.

<figure><img src="../../.gitbook/assets/image (361).png" alt=""><figcaption></figcaption></figure>

This works in the following ways:

* By default, if  **satisfyMethod** is falsy (undefined), ALL plugins are required in order for the overall claim to succeed.
* The "numUses" plugin or those critical to assigning claim numbers are required and cannot be optional
* Claimees are allowed to select which plugins they want to execute / be applied. Behind the scene this uses the **\_specificInstanceIds** property on the simulate / complete API claim request.
* For stateful plugins, we ONLY update the state for the plugins in the success path (we will short circuit where necessary).
  * For example, if there is a requirement group with 2 out of 8 plugins needing success and the first two pass, we will not even check or apply state for the other six.

```typescript
export interface iSatisfyMethod {
  type: 'AND' | 'OR' | 'NOT';
  /** Conditions can either be the instance ID of the plugin to check success for or another satisfyMethod object. */
  conditions: Array<string | iSatisfyMethod>;
  options?: {
    /** Only applicable to OR logic. Implements M of N logic. */
    minNumSatisfied?: number;
  };
}
```



## File: ./for-developers/concepts/README.md

# üë• Concepts

This section covers core BitBadges concepts that developers need to understand when building with the platform.

## Account System

BitBadges uses Cosmos-based accounts with 'bb' prefixed bech32 addresses. All users interact with tokens and services using Cosmos-compatible wallets and Cosmos signatures.


## File: ./for-developers/concepts/address-mappings-lists.md

# üìß Address Lists (Lists)

[AddressLists](https://bitbadges.github.io/bitbadgesjs/interfaces/iAddressList.html) are a powerful feature with range logic similar to UintRanges. They allow us to specify a list of addresses, identified by a listId.

```typescript
export interface AddressList {
    listId: string;

    addresses: string[];
    whitelist: boolean;

    uri: string;
    customData: string;
}
```

### Inverting (Whitelist vs Blacklist)

These are invertible meaning we can create a list that includes all addresses EXCEPT some specified addresses (whitelist = false). Or, we can create a list that includes ONLY some specified addresses (whitelist = true). More commonly, this is thought of as a blacklist or whitelist.

**IMPORTANT:** When you invert, the inversion by default includes the "Mint" address. This is important when handling the **fromList** of approvals. You do not want to accidentally approve users to transfer from the "Mint" address.

### **Storage**

**On-Chain:** AddressLists are **permanent and not updatable** once created, if stored on-chain. These can be created using [MsgCreateAddressLists](../create-and-broadcast-txs/cosmos-sdk-msgs/).

They can be used to define transferability on-chain. For example, list "xyz" can only transfer to list "abc" initiated by the reserved "Manager" list.

The same address list is not unique to a collection on-chain and can be used for defining transferability by any collection.

**Off-Chain:** Address lists can also be created off-chain through our indexer / API. These are updatable and deletable, along with additional options. However, this is a centralized solution and doesn't use the blockchain. Everything is simply stored on our centralized servers

### **Reserved Address List IDs**

There are a couple IDs for AddressLists that are reserved for efficient shorthand methods. To enable this, "\_" and ":" and "!" are not allowed anywhere in a standard ID.

-   If prefixed with "!", it denotes to invert the address list (e.g. "!id123" inverts the "id123" address list)
-   Any valid Cosmos (bech32) address is reserved as the list that ONLY includes that specific address.
-   "Mint" specifies the "Mint" address only.
-   "AllWithoutAddress1" denotes all valid user addresses excluding Address1 (e.g. "AllWithoutMint")
-   "AllWithoutAddress1:Address2:Address3" denotes all valid user addresses excluding Address 1,2,and3 (e.g. "AllWithoutMint:bb123...:bb456...")
-   "All" or "AllWithMint" denotes all valid user addresses as well as the "Mint" address

See below for the function for generating them.

### Custom IDs

Reserved address lists are provided for convenience, so you don't actually have to create an AddressList on-chain first. However, long list IDs are very inefficient, especially if used multiple times (e.g. "AllWithoutMint:bb123...:bb456...").&#x20;

For efficiency, consider creating a list with a unique short ID and reference the list that way. You can create a list which is all addresses except Mint, bb123..., bb456... and identified by the ID "abc". Instead of repeating the long "AllWithoutMint:bb123...:bb456..." wherever the ID is needed, you can simply repeat "abc" which saves a lot of resources.

### Examples

This is the list which includes all addresses except "bb123...." and "bb456...."

```typescript
{
  "listId": "abcdef",
  "addresses": ["bb123...", "bb456...."],
  "whitelist": false,
  ...
}
```

<pre class="language-typescript"><code class="lang-typescript"><a data-footnote-ref href="#user-content-fn-1">function</a> getReservedList(
  addressListId: string,
  allowAliases?: boolean,
): AddressList {
  let inverted = false
  let addressList: AddressList | undefined = undefined

  if (addressListId[0] === '!') {
    inverted = true
    addressListId = addressListId.slice(1)
  }

  if (addressListId === 'Mint') {
    addressList = {
      listId: 'Mint',
      addresses: ['Mint'],
      whitelist: true,
      uri: '',
      customData: '',
      createdBy: '',
    }
  } else if (addressListId.startsWith('AllWithout')) {
    addressList = {
      listId: addressListId,
      addresses: [],
      whitelist: false,
      uri: '',
      customData: '',
      createdBy: '',
    }

    const addresses = addressListId.slice(10).split(':')

    for (let address of addresses) {
      addressList.addresses.push(address)
    }
  } else if (addressListId === 'AllWithMint' || addressListId === 'All') {
    addressList = {
      listId: addressListId,
      addresses: [],
      whitelist: false,
      uri: '',
      customData: '',
      createdBy: '',
    }
  } else if (addressListId === 'None') {
    addressList = {
      listId: 'None',
      addresses: [],
      whitelist: true,
      uri: '',
      customData: '',
      createdBy: '',
    }
  } else {
    //split by :
    const addressesToCheck = addressListId.split(':')
    let allAreValid = true
    //For tracker IDs, we allow aliasses(aka non valid addresses)
    if (!allowAliases) {
      for (let address of addressesToCheck) {
        if (address != 'Mint' &#x26;&#x26; !convertToBitBadgesAddress(address)) {
          allAreValid = false
        }
      }
    }

    if (allAreValid) {
      addressList = {
        listId: addressListId,
        addresses: addressesToCheck,
        whitelist: true,
        uri: '',
        customData: '',
        createdBy: '',
      }
    }
  }

  if (inverted &#x26;&#x26; addressList) {
    addressList.whitelist = !addressList.whitelist
  }

  if (!addressList) {
    throw new Error(`Invalid address list ID: ${addressListId}`)
  }

  return addressList
}
</code></pre>

[^1]:


## File: ./for-developers/concepts/balances.md

# üìä Balances

For an overview, first read [Balances / Transfers](../../overview/how-it-works/time-dependent-ownership.md).

```typescript
export interface Balance<T extends NumberType> {
  amount: T;
  tokenIds: UintRange<T>[]
  ownershipTimes: UintRange<T>[]
}
```

**Interpreting Balances**

When interpreting balances, there are certain rules to keep in mind. If we have multiple ranges of token IDs and ownership times defined within a single Balance structure, it means that we own all possible combinations.&#x20;

```
for (balance of balances) {
    for (tokenIdRange of balance.tokenIds) {
        for (ownershipTimeRange of balanace.ownershipTimes) {
            //User owns x(balance.amount) of (tokenIdRange) for the times (ownershipTimeRange)
        }
    }
}
```

For example, lets say we have a balance of&#x20;

<pre class="language-json"><code class="lang-json"><strong>{ 
</strong>    amount: 1, 
    tokenIds: [{ start: 1, end: 10}, {start: 20, end: 30}], 
    ownershipTimes: [{start: 20, end: 50}, {start: 100, end: 200}] 
}
</code></pre>

This can be expanded and thought of as owning:

* x1 of IDs 1-10 from times 20-50&#x20;
* x1 of IDs 1-10 from times 100-200
* x1 of IDs 20-30 from times 20-50
* x1 of IDs 20-30 from times 100-200

If we wanted to subtract the first set of balances (x1 of IDs 1-10 from times 20-50), we would then need to represent it as two separate balances:&#x20;

```
{ 
    amount: 1, 
    tokenIds: [{ start: 1, end: 10}, {start: 20, end: 30}], 
    ownershipTimes: [{start: 100, end: 200}] 
}
```

```
{ 
    amount: 1, 
    tokenIds: [{start: 20, end: 30}], 
    ownershipTimes: [{start: 20, end: 50}}] 
}
```

**Duplicates**

If you specify duplicate token IDs in balances such as:

```
{ 
    amount: 1, 
    tokenIds: [{ start: 1, end: 10}, {start: 1, end: 10}], 
    ownershipTimes: [{start: 100, end: 200}] 
}
```

This is equivalent and will be treated as:

```
{ 
    amount: 2, 
    tokenIds: [{ start: 1, end: 10}], 
    ownershipTimes: [{start: 100, end: 200}] 
}
```


## File: ./for-developers/concepts/chain-details.md

# ‚úè Chain Details

Cosmos Chain ID (Mainnet) - bitbadges-1

Cosmos Chain ID (Testnet) - bitbadges-2

[Cosmos SDK Coin Denom](https://docs.cosmos.network/main/modules/bank) - "ubadge" (1 BADGE = 1 \* 10^9 ubadge)


## File: ./for-developers/concepts/uint-ranges.md

# üî¢ Uint Ranges

<pre class="language-typescript"><code class="lang-typescript"><strong>export interface UintRange&#x3C;T extends NumberType> {
</strong>  start: T;
  end: T;
}
</code></pre>

A core type behind the scenes in BitBadges is the [UintRange](https://bitbadges.github.io/bitbadgesjs/interfaces/iUintRange.html) type, which simply defines a range of numbers from some start value to some end value, inclusive. This allows us to apply powerful range logic.

These are typically used for representing token IDs and time ranges. For example, transferring tokens will require an UintRange\<number>\[] of tokenIds to be specified. If you say to transfer \[{ start: 1, end: 10}, {start: 20, end: 50}], it will transfer the token IDs 1-10 and 20-50.

**Restricted Values**

If used for token IDs or times, we only allow the start and end to be within the range of 1 to Go's math.MaxUint64 or 18446744073709551615 (**so no zero value and no value greater than that**).

To represent a "full" or "complete" range, use \[{ start: 1, end: 18446744073709551615 }]. If we invert a range, we get all the values from 1 to 18446744073709551615 that are not in the current range.

```json
"transferTimes": [
  {
    "start": "1",
    "end": "18446744073709551615"
  }
]
```


## File: ./for-developers/create-and-broadcast-txs/cosmos-sdk-msgs/msgcreateaddressmappings.md

# MsgCreateAddressLists

To create an on-chain AddressList, you can use the MsgCreateAddressLists. See [here](../../core-concepts/address-lists-lists.md) to learn more about AddressLists.

Reminder: on-chain address lists are immutable, permanent. and non-deletable.

```typescript
export interface MsgCreateAddressLists {
  creator: string;
  addressLists: AddressList[];
}
```

```typescript
export interface AddressList {
  listId: string;

  addresses: string[];
  whitelist: boolean;

  uri: string; 
  customData: string;
}
```



**Combining with MsgCreateCollection or MsgUpdateCollection**

Oftentimes, you want to create a new AddressList, so it can be used in a MsgCreateCollection or MsgUpdateCollection (for example, defining transferability using a new, custom list ID).

Before an AddressList can be used, it needs to be defined on-chain. The two Msgs can be easily combined in the same transaction (as Cosmos transactions support multiple Msgs). See [here](../../bitbadges-sdk/common-snippets/creating-signing-and-broadcasting-txs.md) for an example of how to do it with the SDK. Just make sure MsgCreateAddressLists is executed first and precedes when it is actually used.

```typescript
const msgs: MessageGenerated[] = [];
msgs.push(...bootstrapLists().map(x => createProtoMsg(x))); //MsgCreateAddressLists
msgs.push(...bootstrapCollections().map(x => createProtoMsg(x))) //MsgCreateCollections

//Note how MsgCreateAddressLists is first in the array
const txn = createTransactionPayload(txContext, msgs);
```



## File: ./for-developers/getting-started.md

# üî® Getting Started

BitBadges is proud to offer no-code / low-code flows for all our major services. Simply navigate to the Create tab in-site, and get started creating tokens, claims, address lists, explore listings, applications, and more!

<figure><img src="../.gitbook/assets/image (4) (1).png" alt=""><figcaption></figcaption></figure>

> **Need help?** Join our Discord for support from the BitBadges team and community developers.
>
> **Need BADGE?** Contact us on Discord - get subsidized credits for developers during chaosnet!
>
> **No-Code / In-Site Solutions** Check out the [Create tab](https://bitbadges.io/create) or the [developer portal](https://bitbadges.io/developer) first to see what all is possible. Most of the time, you can just do everything with no code directly in-site! No need for any direct integration. Let us handle everything!
>
> Get creative. You can gate URLs, Discords, and integrate with many of your favorite tools without a single line of code!

## Explore First, Read Later

We strongly recommend, if you have not already, to explore the claim tester and other creation options in-site. Many of your questions should be answered by the interface and is much easier to understand than a bunch of long text here in this documentation. Just go explore and experiment first.

Most of your setup and management (and oftentimes all) will be done directly in-site via the developer portal or Create tab. Get started at [https://bitbadges.io/create](https://bitbadges.io/create).

## Quick Start - Tokens

{% content-ref url="../x-badges/" %}
[x-badges](../x-badges/)
{% endcontent-ref %}

## Quick Start - Claims

{% content-ref url="../overview/claim-builder/" %}
[claim-builder](../overview/claim-builder/)
{% endcontent-ref %}

## Quick Start - API

{% content-ref url="bitbadges-api/" %}
[bitbadges-api](bitbadges-api/)
{% endcontent-ref %}

{% content-ref url="bitbadges-sdk/" %}
[bitbadges-sdk](bitbadges-sdk/)
{% endcontent-ref %}

```bash
npm i bitbadgesjs-sdk
```

```ts
import { BitBadgesAPI } from 'bitbadgesjs-sdk';

const api = new BitBadgesAPI({
  ...
});

await BitBadgesAPI.getCollection(...);
```

## Developing with AI

Below, we provide some resources that may be helpful for developing with AI. If there is anything else we can do to make development easier, let us know!

[https://github.com/BitBadges/bitbadges-quickstarter-ai](https://github.com/BitBadges/bitbadges-quickstarter-ai)

[https://docs.bitbadges.io/\~gitbook/mcp](https://docs.bitbadges.io/~gitbook/mcp) - GitBook Provided MCP with searchDocumentation tool

[Cosmos Msg Proto Definitions](https://github.com/BitBadges/bitbadgeschain/tree/master/proto)

[BitBadges API OpenAPI Spec](https://raw.githubusercontent.com/bitbadges/bitbadgesjs/main/packages/bitbadgesjs-sdk/openapi-hosted/openapi.json)

[Full Documentation .txt](../for-llms.txt)

[Full SDK Reference](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html) - [Full Types Reference](https://github.com/BitBadges/bitbadgesjs/blob/main/packages/bitbadgesjs-sdk/type-map/typedoc-output.json)


## File: ./for-developers/sign-in-with-bitbadges/README.md

# Sign In with BitBadges (OAuth)



## File: ./for-developers/sign-in-with-bitbadges/approaches/redirected-callback.md

# Redirect Callback

The standard OAuth callback approach is used for immediate authentication. To enable callbacks, the parameters must have a redirect URI set that matches your app's configured one. With the callback, the user will never even see the code. Everything is handled behind the scenes immediately.

**How do callbacks work?**

A high-level overview is:

1. Users navigate to the custom SIWBB URL for your authentication request.
2. The user will be walked through the authentication process. Upon completion, an authorization code is transmitted to the redirect URI via the query parameters `code` and `state`.
3. The redirect URI can then fetch the details from the API using the transmitted code with knowledge of the configured app's client secret.

**Generating the URL**

The important part here is to correctly specify a valid **redirectUri** letting us know that you expect to receive the details immeditately.

{% content-ref url="../authorization-url/" %}
[authorization-url](../authorization-url/)
{% endcontent-ref %}

**Implementation - Backend**

```typescript
// GET /api/callback?code=...&state=...
const callbackHandler = async (req: NextApiRequest, res: NextApiResponse) => {
    //Parse the code and state from the query parameters
    const code = req.query.code;
    const state = req.query.state as string;

    //TODO: Fetch authentication details (see Verification page)
    //      const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({ code, ... });
    //TODO: Any application specific requirements

    //Learn more in the verification steps
};
```

At your redirect URI, you will need to set up a handler to handle the code / state that is passed. The code and state will be passed in via the HTTP query parameters. This follows typical OAuth2 flow. We refer you to OAuth tutorials for more details.

To ensure the security of the data exchange process, consider the following practices:

* Validate the `state` parameter according to your requirements (if applicable)
* Use HTTPS to protect the data in transit, ensuring that all communications between your server and the client are encrypted.


## File: ./for-developers/sign-in-with-bitbadges/authorization-url/README.md

# Authorization URL



## File: ./for-developers/sign-in-with-bitbadges/authorization-url/configuration.md

# Configuration

BitBadges authentication uses an OAuth URL with custom parameters: `https://bitbadges.io/siwbb/authorize?client_id=...`.

Users will visit this URL to authenticate and receive an authorization code. This code will be passed behind the scenes for digital flows via the redirect or it will be the actual QR code for in-person / delayed flows.

By default, Sign In with BitBadges will handle authentication for the user (in other words, checking address ownership). You can additionally:

-   Specify the `scope` to request additional BitBadges API permissions for the user (e.g. 'completeClaims,readClaimAlerts')
-   Specify a `claimId` to display a specific claim to the user (for display purposes, you will need to verify the claim successes on your end). Claims open up any criteria like token ownership checks, payments, anything

## Parameter Interface

```typescript
interface CodeGenQueryParams {
    client_id: string; // Required: Your app's client ID
    redirect_uri?: string; // Required for instant auth. Not needed for QR code auth.
    state?: string; // Optional: Additional data passed to redirect
    scope?: string; // Optional: Comma-separated BitBadges API permission scopes (e.g. 'completeClaims,readClaimAlerts')

    // Claim UI Options (optional)
    claimId?: string; // ID of required claim
    hideIfAlreadyClaimed?: boolean; // Hide if already claimed
    expectVerifySuccess?: boolean;

    // Expect attestation presentations
    expectAttestations?: boolean;
}
```

## Key Features

### 1. App Configuration

-   Create OAuth apps at [bitbadges.io/developer](https://bitbadges.io/developer)
-   `client_id` is mandatory (obtained from app registration)
-   `redirect_uri` required for instant auth, optional for delayed auth
-   If `redirect_uri` is blank, QR code is generated and stored in user's account
-   See OAuth tutorials for more details

### 2. Scopes

-   This is only needed for authorized BitBadges API access. By default, you will verify address ownership with no scopes.
-   Format: `scope: 'completeClaims,readClaimAlerts'`
-   View all available scopes at [bitbadges.io/auth/linkgen](https://bitbadges.io/auth/linkgen)

### 3. Claims

-   Specify required claim to be satisfied with `claimId`
-   Create the claim in the developer portal. See claim docs for more details.
-   Claims are not a part of the core authentication process. You need to verify them separately server-side to ensure the user has met the criteria.


## File: ./for-developers/sign-in-with-bitbadges/authorization-url/generating-the-url.md

# Generating the URL

The base URL is [https://bitbadges.io/siwbb/authorize](https://bitbadges.io/siwbb/authorize), with parameters appended to it.

For instance:

```vbnet
https://bitbadges.io/siwbb/authorize?client_id=...
```

This URL structure adheres to the following interface:

* **Base URL**: [https://bitbadges.io/siwbb/authorize](https://bitbadges.io/siwbb/authorize)
* **Parameters**: Custom parameters specific to your implementation.

You can use [https://bitbadges.io/auth/linkgen](https://bitbadges.io/auth/linkgen) or the code below to generate the URL or click Create SIWBB URL directly from your app in the developer portal (recommended).

<figure><img src="../../../.gitbook/assets/image (86) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (357).png" alt=""><figcaption></figcaption></figure>

**Snippets**

<pre class="language-typescript"><code class="lang-typescript"><strong>import { generateBitBadgesAuthUrl, CodeGenQueryParams } from 'bitbadgesjs-sdk';
</strong>
const popupParams: CodeGenQueryParams {
    ...
} // See Authentication URL page

<strong>const authUrl = generateBitBadgesAuthUrl(popupParams);
</strong></code></pre>

```ts
export const generateBitBadgesAuthUrl = (params: CodeGenQueryParams) => {
    let url = `https://bitbadges.io/siwbb/authorize?`;
    for (const [key, value] of Object.entries(params)) {
        if (value) {
            if (typeof value === 'object') {
                const valueString = JSON.stringify(value);
                const encodedValue = encodeURIComponent(valueString);
                url = url.concat(`${key}=${encodedValue}&`);
            } else {
                url = url.concat(`${key}=${value}&`);
            }
        }
    }
    return url;
};
```


## File: ./for-developers/sign-in-with-bitbadges/overview.md

# Overview

Sign In with BitBadges (SIWBB) is a Cosmos/BitBadges authentication solution. It replaces traditional "Sign In with X" buttons and can be configured to handle the following all in one flow:

-   Cosmos/BitBadges authentication
-   Token ownership verification
-   Integration with 7000+ supported apps and plugins
-   BitBadges API scope authorizations

#### Use Alternatives If Possible

NOTE: This is mainly intended for OAuth authorization for the BitBadges API. If you don't need this, then we recommend you use other Web3 services out there for Web3 authentication now like WalletConnect, MagicAuth, etc.&#x20;

Combining authentication + criteria checks (claim successes, token ownership) is a powerful combination with the BitBadges API. Simply 1) authenticate and 2) check criteria using our API.

```typescript
// Pre-req: Create claim in BitBadges site
// 1. Authenticate your user (using your existing setup)
// 2. Verify claim success
const res = await BitBadgesApi.checkClaimSuccess(claimId, address);
```

#### OAuth Endpoints

-   **Authorization:** `https://bitbadges.io/siwbb/authorize?your_params`
-   **Token:** `https://api.bitbadges.io/api/v0/siwbb/token`
-   **Revoke:** `https://api.bitbadges.io/api/v0/siwbb/token/revoke`

[**Demo**](https://bitbadges.io/siwbb/authorize?client_id=example-client-id&redirect_uri=https://example.com&)

## Implementation Flow

1. **Authentication- BitBadges Side**
    - User accesses BitBadges URL (direct or popup)
    - Proves address ownership and other criteria (tokens, etc.)
    - Receives authorization code from BitBadges (QR or behind the scenes via redirect)
2. **Integration- Your App Side**
    - Receive authentication response
    - Check criteria on your end
    - Implements security measures (prevent replay attacks, etc.)
    - Focus on your core utility


## File: ./for-developers/sign-in-with-bitbadges/setting-up-an-app.md

# Setting Up an App

### App Registration

* Register at [https://btibadges.io/developer](https://btibadges.io/developer) -> OAuth Apps
* Take note of your client ID / secret

### Key Components

#### 1. Client ID

* Unique identifier for your app
* Assigned upon registration

#### 2. Client Secret

* Cryptographic key for API authentication
* Keep confidential; never expose in client-side code. Treat like a password.
* Required to fetch user authentication details

#### 3. Redirect URIs

* Endpoints where users are redirected after authentication
* Must be pre-registered and use HTTPS
* Not needed for delayed/QR code authentication. Only for immediate digital redirects.

### Security Notes

* Treat client secret as securely as a password
* Ensure exact match between registered and used redirect URIs (if applicable)
* Use HTTPS for all redirects for security reasons


## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/README.md

# Templates and Frameworks



## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/auth0.md

# Auth0

### **Social Connection Integration**

When adding a Social Connection, you will see BitBadges as a preconfigured option. This has everything setup for you. You will simply need to specify your client ID and client secret. You will also have to configure your redirect URI to match your Auth0 application's domain. This typically ends with /callback (for example, [https://dev-pgv803tz4ztg35oi.us.auth0.com/login/callback](https://dev-pgv803tz4ztg35oi.us.auth0.com/login/callback)).

### [https://marketplace.auth0.com/integrations/bitbadges](https://marketplace.auth0.com/integrations/bitbadges)

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (299).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Custom

You can also customize the connection further by creating a custom connection. This allows you to add parameters beyond the standard flow. You callback will be the same as above.

<figure><img src="../../../.gitbook/assets/image (136) (1).png" alt=""><figcaption></figcaption></figure>

**Authorization URL:** https://bitbadges.io/siwbb/authorize

**Token URL:** https://api.bitbadges.io/api/v0/siwbb/token

**Scopes:** None (All you typically need is the user crypto address) - Although, you can add as needed

**Fields:** Get your API key, client ID, and client secret at https://bitbadgesio/developer.

**Fetch Profile Script**:

```javascript
function fetchUserProfile(accessToken, ctx, cb) {
    request.post(
        {
            url: 'https://api.bitbadges.io/api/v0/auth/status',
            headers: {
                'Content-Type': 'application/json',
                // TODO: Replace
                'x-api-key': 'ENTER_API_KEY_HERE',
                Authorization: 'Bearer ' + accessToken,
            },
        },
        (err, resp, body) => {
            if (err) {
                return cb(err);
            }
            if (resp.statusCode !== 200) {
                return cb(new Error(body));
            }
            let bodyParsed;
            try {
                bodyParsed = JSON.parse(body);
            } catch (jsonError) {
                return cb(
                    new Error('Failed JSON parsing for user profile response.')
                );
            }

            const account = bodyParsed;

            const profile = {
                address: account.address,
                chain: account.chain,
                id: account.bitbadgesAddress,
                name: account.address,
            };
            return cb(null, profile);
        }
    );
}
```

**Custom Headers:**

Make sure you enter your API key in the custom headers an d replace it in the fetch script.

```
{
    "x-api-key": "YOUR_API_KEY"
}
```


## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/discourse.md

# Discourse

For Discourse, we do not have a dedicated plugin, but SIWBB is OAuth2 compatible and integrated with other providers. So, you can reuse existing plugins as needed.

**Auth0 Plugin**

Set up SIWBB with Auth0 here:

{% content-ref url="auth0.md" %}
[auth0.md](auth0.md)
{% endcontent-ref %}

Then, integrate with Discourse here:

{% embed url="https://meta.discourse.org/t/configure-sign-up-and-log-in-with-auth0-using-the-oauth2-basic-plugin/64633" %}

**OAuth2 Plugin**

{% embed url="https://meta.discourse.org/t/discourse-oauth2-basic/33879" %}


## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/expressjs.md

# ExpressJS

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadges-passportjs-example/blob/main/index.ts" %}


## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/others.md

# Others

Many of your favorite frameworks already support Auth0, and you can simply use Sign In with BitBadges through that.

* Auth.js (Next Auth) - [https://authjs.dev/getting-started/providers/auth0](https://authjs.dev/getting-started/providers/auth0)
* Amazon Cognito - [https://auth0.com/docs/customize/integrations/aws/amazon-cognito#configure-amazon-web-services](https://auth0.com/docs/customize/integrations/aws/amazon-cognito#configure-amazon-web-services)
* Supabase - [https://supabase.com/partners/integrations/auth0](https://supabase.com/partners/integrations/auth0)

If you have any suggestions for unsupported integrations as well, let us know! And again, note that you are not locked into Sign In with BitBadges. You can use any Web3 authentication provider and then check BitBadges claim successes to gate anything.


## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/supabase.md

# Supabase

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadges-supabase-demo" %}

This repository is a basic example for getting started with Supabase and Sign in with BitBadges. It is meant to be a starting point and is not production ready.

This example:

* Uses the Next.js x Supabase template
* Uses traditional Supabase authentication and once signed in, you can additionally Sign In with BitBadges. This effectively creates a username <-> address mapping that you can use.

<figure><img src="../../../.gitbook/assets/image (398).png" alt=""><figcaption></figcaption></figure>

Anything else is left as an exercise for you.

* Gating the entire site rather than using traditional authentication
* Gating specific pages / implementing your utility
* Linking claims

Note: Supabase is flexible. You may choose to implement it via Express, Auth0, or another way as well. This is just a reference to help you get started.

**Setup**

1. Setup Supabase as explained via their documentation
2. Add your BitBadges API key, client ID, and client secret to your .env
3. Execute the SQL in supabase/migrations folder to setup the tables. This can be done via the SQL Editor in the dashboard.


## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/wordpress.md

# WordPress

Gate your WordPress site with BitBadges! Authenticate with Sign In with BitBadges and check any claim criteria, allowing you to create gated websites for anything.

Directory Link: [https://wordpress.org/plugins/sign-in-with-bitbadges/](https://wordpress.org/plugins/sign-in-with-bitbadges/)

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadges-wp-plugin" %}

<figure><img src="../../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

This plugin allows users to gate their WordPress site with BitBadges ‚Äì claims, payments, NFT badges, and more!

\== Description ==

This plugin allows users to gate their site with BitBadges - claims, payments, NFT badges, and more!

**Important Note:** This plugin ONLY handles authentication with BitBadges - it does not restrict access to your site by itself. For restricting access, we recommend using this plugin in conjunction with:

* [Force Login](https://wordpress.org/plugins/wp-force-login/) - Forces users to log in to view your site
* [Restrict Content](https://wordpress.org/plugins/restrict-content/) - Restrict content to logged-in users
* [Members](https://wordpress.org/plugins/members/) - Advanced user roles and permissions
* Or other plugins that restrict access to your site

\== Installation ==

1. Download the plugin files and upload them to your `/wp-content/plugins/` directory
2. Activate the plugin through the 'Plugins' menu in WordPress
3. Go to Settings > BitBadges SIWBB to configure the plugin

\== Configuration ==

1. Create a new application (OAuth App) in the [BitBadges Developer Portal](https://bitbadges.io/developer)
2. Set your redirect URI to: `https://your-wordpress-site.com/wp-login.php?action=bitbadges-callback`
3. Copy your Client ID and Client Secret
4. Go to your WordPress admin panel > Settings > BitBadges SIWBB
5. Enter your Client ID and Client Secret
6. (Optional) Configure a claim ID to gate access and other additional settings
7. Save the settings

\== Features ==

* Adds a "Sign in with BitBadges" button to the WordPress login form
* Creates WordPress users automatically when they first sign in with BitBadges
* Secure OAuth 2.0 implementation with state verification
* Simple admin interface for configuration
* Optional exclusive BitBadges authentication mode (disable normal WordPress login)
* Claim-gated access support
* Emergency admin access URL for exclusive mode
* Customizable claim visibility on authorization page

\== Security ==

* CSRF protection using state parameter
* Secure storage of client credentials
* WordPress nonce verification
* Input sanitization
* Proper error handling
* Secure admin access fallback
* Claim verification

\== User Experience ==

* Clean, centered login button design
* Shortened wallet addresses for better readability
* Clear separation between traditional and BitBadges login
* Visible claim requirements before authentication
* Seamless first-time user setup

\== Requirements ==

* WordPress 5.0 or higher
* PHP 7.0 or higher
* HTTPS enabled on your site (required for secure OAuth)

\== Support ==

For support or feature requests, please visit the [BitBadges website](https://bitbadges.io) or create an issue in the GitHub repository.

\== License ==

This plugin is licensed under the GPL v2 or later.\
License URI: https://www.gnu.org/licenses/gpl-2.0.html

\== Changelog ==

\= 1.0.0 =

* Initial release with basic OAuth functionality
* Added exclusive authentication mode
* Added claim-gating support
* Added emergency admin access
* Improved user display names
* Enhanced UI/UX for login button
* Added claim visibility options


## File: ./for-developers/sign-in-with-bitbadges/verification/README.md

# Verification



## File: ./for-developers/sign-in-with-bitbadges/verification/access-tokens.md

# Access Tokens

With access tokens, you can start sending requests to authenticated endpoints with your access token specified in the Authorization header as "Bearer YOUR\_ACCESS\_TOKEN".

If you did not request any specific scopes, you will still have access to the health check endpoint to ensure the user has not revoked authorization.

<figure><img src="../../../.gitbook/assets/image (269).png" alt=""><figcaption></figcaption></figure>

If you are using the SDK, you can instead do this which handles the header setting:

```typescript
BitBadgesApi.setAccessToken(token);
BitBadgesApi.unsetAccessToken();
```

Access tokens by default expire in 1 day, and refresh tokens expire in 60 days. Note that they may also become invalid as the user revokes access to them as well.

**Health Checks**

To check that you are signed in, use the following route. This will return signedIn: false if not authenticated, access token is expired, or authorization has been revoked.

Note: This can even be used when no scopes are requested.

```typescript
// POST /api/v0/auth/status {}
const res = await BitBadgesApi.checkIfSignedIn({})
// 200 { signedIn: boolean, scopes: [...], ... }
console.log(res.signedIn)
```

**Refreshing**

```typescript
const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({
    refresh_token
    grant_type: 'refresh_token',
    client_secret: '...',
    client_id: '...',
    redirect_uri: '...' //only needed if redirected
});

const { access_token, access_token_expires_at, refresh_token, refresh_token_expires_at } = res;
```

Using the refresh token obtained previously, you can exchange for a new access token and refresh token (with expiration reset) on a rolling basis. This step can be repeated indefinitely.

**Revoking Access**

Once you are done with the access token, you should revoke your access to it via the following. This can also be done by the user via the Connections -> Authorizations tab in-site. This can be done by either the user or the app.

```typescript
// POST https://api.bitbadges.io/api/v0/siwbb/token/revoke
await BitBadgesApi.revokeOauthAuthorization({ token });
```


## File: ./for-developers/sign-in-with-bitbadges/verification/security-considerations.md

# Security Considerations

This flow is OAuth 2.0 compatible, so we refer you to the official spec and other OAuth 2.0 resources for security considerations with the protocol itself (replay attacks, man in the middle, etc).

You may also be prone to flash criteria checks, such as flash ownership checks. For example, Bob signs in, transfers a token to Alice, and Alice signs in with the same token. Both are authenticated with the same token which may not be the intended behavior. This can apply to any criteria not just tokens. Ensure your claim criteria, attestations, etc protect against such cases.


## File: ./for-developers/sign-in-with-bitbadges/verification/verification-flow.md

# Verification Flow

From the prior pages, you should now have the authorization **code** (32 byte hex) for the user.&#x20;

```typescript
// 32 byte hex string
async function myHandler(req: NextApiRequest, res: NextApiResponse) {
    const code = req.query.code as string;
}
```

You can now exchange the code and valid app configuration details. Be sure to keep the client secret secret. The response will contain all authentication details, including a **verificationResponse**.

**Exchanging the Code**

The next step is to exchange the code for authentication details. This is done via the exchange endpoint. This follows typical OAuth2 flow. You can also specify options to check the issued at time of code generation. Typically for in-person, you may need to disable the issued at time check of 10 minutes.

[API Reference](https://bitbadges.stoplight.io/docs/bitbadges) -> Exchange SIWBB Code

```typescript
// 32 byte hex string
async function myHandler(req: NextApiRequest, res: NextApiResponse) {
    const code = req.query.code as string;

    const options = {
        issuedAtTimeWindowMs: 1000 * 60 * 10, // 10 minutes (set to 0 to disable)
    };

    // POST https://api.bitbadges.io/api/v0/siwbb/token
    const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({
        code,
        options,
        grant_type: 'authorization_code',
        client_secret: '...',
        client_id: '...',
        redirect_uri: '...', //only needed for digital immediate flow
    });

    const { address, chain, verificationResponse } = res;
    if (!verificationResponse.success) {
        console.log(verificationResponse.errorMessage);
        throw new Error('Not authenticated');
    }
    
    //Verify claims or anything else you need to do here
}
```

**Access Tokens / Session Management**

We return access tokens and refresh tokens for you to perform session management. The expiration times can help you implement sessions for your users, and you can health check the user hasn't revoked through the API. Code exchanges can only be performed once per unique code which is checked on our end.

```typescript
// 32 byte hex string
async function myHandler(req: NextApiRequest, res: NextApiResponse) {
    const code = req.query.code as string;

    // POST https://api.bitbadges.io/api/v0/siwbb/token
    const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({ ... });

    const { access_token, access_token_expires_at, refresh_token, refresh_token_expires_at } = res;
    // TODO: You can use these tokens for session management and authorized API access
}
```

Note this is not the only way of implementing sessions. You may implement custom approaches on your own like checking IDs, stamping hands, using claim numbers, etc.

{% content-ref url="api-access-tokens.md" %}
[api-access-tokens.md](api-access-tokens.md)
{% endcontent-ref %}

**Verifying Other "Attached" Criteria**

For any other criteria like claim verification or attestations, you must check this additionally server-side. Do not trust that if you added `claimId` in the URL params that it is automatically verified.

```typescript
async function myHandler(req: NextApiRequest, res: NextApiResponse) {
    const code = req.query.code as string;

    // Exchange code from above

    const { address, chain, verificationResponse } = res;

    // ...

    // After verifying the address, you can now check other criteria with knowledge that the user is the owner of the address
    // const claimAttemptsByAddress = await BitBadgesApi.getClaimAttempts(claimId, { address });
    // const ownershipRequirementsRes = await BitBadgesApi.verifyOwnershipRequirements(...);
}
```

**Putting It Together**

```typescript
import { BitBadgesApi } from 'bitbadgesjs-sdk';

// 32 byte hex string
async function myHandler(req: NextApiRequest, res: NextApiResponse) {
    const code = req.query.code as string;

    const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({
        code,
        options,
        grant_type: 'authorization_code',
        client_secret: '...',
        client_id: '...',
        redirect_uri: '...', //only needed if immediate
    });

    const { address, chain, verificationResponse } = res;
    if (!verificationResponse.success) {
        console.log(verificationResponse.errorMessage);
        throw new Error('Not authenticated');
    }

    const {
        access_token,
        access_token_expires_at,
        refresh_token,
        refresh_token_expires_at,
    } = res;
    // TODO: You can use these tokens for session management and authorized API access

    // After verifying the address, you can now check other criteria with knowledge that the user is the owner of the address
    // const claimsRes = await BitBadgesApi.getClaims({ ... });

    //TODO: Handle other checks and logic here
    // - Prevent replay attacks by checking timestamps or nonces
    // - Need to cache anything for later use?
    // - If verifying with assets, is the asset transferable and prone to flash ownership attacks (e.g. one use per asset, etc)?
    // - Other criteria needed for signing in? (e.g. whitelist / blacklist of addresses signing in)
    // - Verify claim criteria

    //TODO: If receiving attestations, are the contents valid?
    //For example:
    // - Verify the contents of the attestation messages are correct
    // - Verify the creator is who you expect
    // - Verify the metadata is correct
    // - Verify the on-chain anchors / update history are correct
    // - Verify the update history is correct
}
```

## **IMPORTANT: What is verified natively vs not?**

Does check :white\_check\_mark:

* Proof of address ownership via their authenticated BitBadges account
* Anything specified in the verify challenge options
* Issued at time of code generation is not too long ago if **options.isssuedAtTimeWindowMs** is specified. Defaults to 10 minutes.
* One exchange per authorization code -> access / refresh token

Does not check natively :x:

* Additional app-specific criteria needed for signing in (claims, ownership requirements, attestations)
* Does not natively prevent against flash ownership attacks, replay attacks, or man-in-the-middle attacks other than what OAuth2 protects against



## File: ./learn/README.md

# üéì Learn



## File: ./learn/alias-compatibility.md

# Alias Compatibility

In many instances, you may see BitBadges provide alias denomination support for compatibility with existing Cosmos SDK interfaces like `sdk.Coin`. This enables seamless integration with liquidity pools, multi-standard environments, and other systems that expect standard Cosmos coin formats (denom, amount).

Note that the environment must support aliases for this to work.

## Alias Denomination Format

BitBadges uses the format `badgeslp:COLLECTION_ID:denom` for alias denominations:

-   **Format**: `badgeslp:COLLECTION_ID:denom`
-   **Example**: `5 badgeslp:73:utoken`
    -   Collection ID: `73`
    -   Base denomination: `utoken` (from the collection's `aliasPaths` array)
    -   Amount: `5`

## How It Works

The alias denomination converts an integer amount to `Balances[]` using the collection's `aliasPaths` field, which defines the conversion rate.

### Conversion Process

1. **Parse the alias**: Extract collection ID and denom from `badgeslp:COLLECTION_ID:denom`
2. **Find alias path**: Look up the matching `AliasPath` in the collection's `aliasPaths` array by denom
3. **Convert amount**: Use the path's `conversion` field to convert the integer amount to `Balances[]`. The conversion rate is: `conversion.sideA.amount` alias units = `conversion.sideB[]` tokens. For example, if `sideA.amount = "1"` and `sideB = [{ amount: 1n, ... }]`, then `1 badgeslp:73:utoken = 1 token` (1:1 conversion)
4. **Execute transfer**: Process the transfer using the converted `Balances[]` via `MsgTransferTokens`

### Important Notes

-   **No wrapping involved**: This is not a wrapping/unwrapping process. The conversion is simply an alias for the full `Balances[]` field.
-   **Conversion rate defined**: The conversion rate is defined in the collection's `aliasPaths` field, specifically in the `conversion.sideA.amount` and `conversion.sideB[]` fields of each path.
-   **Auto-scan mode**: Implementations that support alias denominations almost always operate in **auto-scan mode** (no prioritized approvals required).

## Use Cases

### Liquidity Pool Environments

Alias denominations enable BitBadges tokens to participate in liquidity pools that expect standard `sdk.Coin` formats:

```typescript
// Example: Adding liquidity to a pool
const coins = [
    {
        denom: 'badgeslp:73:utoken',
        amount: '1000000', // Converts to Balances[] via aliasPaths behind the scenes
    },
    {
        denom: 'uatom',
        amount: '500000',
    },
];
```

### Multi-Standard Support

In environments where you need to support multiple token standards, alias denominations provide a unified interface:

```typescript
// Works seamlessly with standard Cosmos SDK coins
const transfer = {
    from: 'bb1...',
    to: 'bb1...',
    amount: [
        {
            denom: 'badgeslp:73:utoken', // BitBadges token (alias)
            amount: '1000',
        },
        {
            denom: 'uatom', // Standard Cosmos SDK coin
            amount: '500',
        },
    ],
};
```

## Configuration

The conversion is defined in the collection's `aliasPaths` field:

```typescript
const collection: MsgCreateCollection = {
    // ... other fields
    aliasPathsToAdd: [
        {
            denom: 'utoken',
            conversion: {
                sideA: {
                    amount: '1', // Required: amount of alias unit
                },
                sideB: [
                    {
                        amount: 1n,
                        tokenIds: [{ start: 1n, end: 100n }],
                        ownershipTimes: [
                            { start: 1n, end: 18446744073709551615n },
                        ],
                    },
                ],
            },
            symbol: 'BASETOKEN',
            denomUnits: [
                {
                    decimals: 6n,
                    symbol: 'TOKEN',
                    isDefaultDisplay: true,
                },
            ],
            metadata: { uri: '', customData: '' }, // Optional PathMetadata
        },
    ],
};
```

**Metadata**: Alias paths use the standard metadata structure with `uri` (e.g., `ipfs://Qm...`) pointing to hosted JSON containing `{ name, image, description }`. The image is the primary use case. The on-chain `symbol` field is typically used for identification, not the metadata name.

In this example:

-   `1 badgeslp:COLLECTION_ID:utoken` converts to `1` token with IDs `1-100` and full ownership times
-   The conversion rate is `1:1` (1 alias unit = 1 token) because `conversion.sideA.amount = "1"` and `conversion.sideB[0].amount = 1n`
-   The conversion structure uses `ConversionWithoutDenom` because the denom is stored separately at the path level

## Permission Control

Adding new alias paths to a collection is controlled by the `canAddMoreAliasPaths` permission. This permission allows you to control when managers can add new alias paths.

### Default Behavior

-   **Empty/Nil Permissions**: When `canAddMoreAliasPaths` is empty or nil, adding paths is **allowed** (neutral state)
-   **Migration**: Collections migrated from v21 will have empty permissions, meaning adding paths is allowed by default

### Permission Structure

The permission uses the `ActionPermission` type with time-based controls:

```typescript
const collectionPermissions: CollectionPermissions<bigint> = {
    canAddMoreAliasPaths: [
        {
            permanentlyPermittedTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
            permanentlyForbiddenTimes: [],
        },
    ],
};
```

### Usage Examples

**Allow adding paths at all times:**

```typescript
const collectionPermissions: CollectionPermissions<bigint> = {
    canAddMoreAliasPaths: [], // Empty = allowed by default
};
```

**Lock adding paths forever:**

```typescript
const collectionPermissions: CollectionPermissions<bigint> = {
    canAddMoreAliasPaths: [
        {
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
        },
    ],
};
```

**Allow adding paths only during specific period:**

```typescript
const collectionPermissions: CollectionPermissions<bigint> = {
    canAddMoreAliasPaths: [
        {
            permanentlyPermittedTimes: [
                { start: 1704067200000n, end: 1735689600000n },
            ],
            permanentlyForbiddenTimes: [],
        },
    ],
};
```

### Permission Check

When using `MsgUniversalUpdateCollection` to add alias paths via `aliasPathsToAdd`, the system checks the `canAddMoreAliasPaths` permission before processing the paths. If the permission check fails, the transaction will be rejected with an appropriate error message.

**Note**: The permission is checked before paths are added, but the permission itself can be updated at the end of the transaction (if `updateCollectionPermissions` is set to `true`).

## Benefits

-   **Drop-In Replacement**: Upgrade existing systems to support BitBadges tokens with simply changing a line of code
-   **Seamless Integration**: Works with existing Cosmos SDK interfaces and tools
-   **Liquidity Pool Compatibility**: Enables participation in AMM pools and DeFi protocols
-   **Multi-Standard Support**: Unified interface for different token types
-   **No Wrapping Overhead**: Direct alias conversion without minting/burning


## File: ./learn/auto-scan-and-prioritized-approvals.md

The transfer approval system operates in two modes: **auto-scan** (default) and **prioritized approvals**. When a transfer is submitted without explicitly prioritizing specific approvals, the system operates in **auto-scan mode** and automatically searches through available approvals to find a match.

However, **not all approvals are safe for auto-scanning**. In auto-scan mode, unsafe approvals are ignored to prevent unexpected behavior. If a transfer needs to be prioritized, it MUST always be prioritized with proper versioning specified to prevent malicious approval changes after submission.

This is important to consider when designing your systems. For example, auto-scan environments like liquidity pools should account for this.

**Why:** Prioritization ensures users know exactly which approval they're using and its side effects (e.g., coin transfers, predetermined balances, version control to prevent malicious approval changes after submission).

## Auto-Scan Mode (Default)

```typescript
const msg: MsgTransferTokens = {
    creator: 'bb1initiator...',
    collectionId: '1',
    transfers: [
        {
            from: 'bb1sender...',
            toAddresses: ['bb1recipient...'],
            balances: [
                {
                    amount: '1',
                    tokenIds: [{ start: '1', end: '1' }],
                    ownershipTimes: [
                        { start: '1', end: '18446744073709551615' },
                    ],
                },
            ],
            // No prioritizedApprovals specified - uses auto-scan
            // System automatically finds matching approval
        },
    ],
};
```

## Prioritized Approvals Mode

```typescript
import { MsgTransferTokens } from 'bitbadgesjs-sdk';

const msg: MsgTransferTokens = {
    creator: 'bb1initiator...',
    collectionId: '1',
    transfers: [
        {
            from: 'bb1sender...',
            toAddresses: ['bb1recipient...'],
            balances: [
                {
                    amount: 1n,
                    tokenIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: [
                        {
                            start: 1n,
                            end: 18446744073709551615n,
                        },
                    ],
                },
            ],
            prioritizedApprovals: [
                {
                    approvalId: 'abc123',
                    approvalLevel: 'collection',
                    approverAddress: '', // Empty for collection, address for user approvals
                    version: 2n, // Must specify exact version
                },
            ],
            onlyCheckPrioritizedCollectionApprovals: true,
        },
    ],
};
```

### Safety Check Logic

An approval is considered **safe for auto-scan mode** if:

1. **Must prioritize flag is false** - `mustPrioritize` is not `true`
2. **No coin transfers** - `approvalCriteria.coinTransfers` is nil or empty
3. **No predetermined balances** - `approvalCriteria.predeterminedBalances` is nil or empty / not used
4. **No merkle challenges** - `approvalCriteria.merkleChallenges` is nil or empty
5. **No ETH signature challenges** - `approvalCriteria.ethSignatureChallenges` is nil or empty
6. **Not special context** - certain special protocol contexts require prioritized approvals (ex: IBC backed minting, Cosmos wrapping)

### Complete Function Reference

The complete implementation of the auto-scannable check:

```go
func CollectionApprovalIsAutoScannable(approvalCriteria *ApprovalCriteria) bool {
	if approvalCriteria == nil {
		return true
	}

	if approvalCriteria.MustPrioritize {
		return false
	}

	if approvalCriteria.CoinTransfers != nil && len(approvalCriteria.CoinTransfers) > 0 {
		return false
	}

	if approvalCriteria.PredeterminedBalances != nil && !PredeterminedBalancesIsBasicallyNil(approvalCriteria.PredeterminedBalances) {
		return false
	}

	if approvalCriteria.MerkleChallenges != nil && len(approvalCriteria.MerkleChallenges) > 0 {
		return false
	}

	if approvalCriteria.EthSignatureChallenges != nil && len(approvalCriteria.EthSignatureChallenges) > 0 {
		return false
	}

	return true
}
```

```typescript
// ‚úÖ Auto-scannable approval
const approval: CollectionApproval<bigint> = {
    approvalId: 'simple-transfer',
    fromListId: 'Mint',
    toListId: 'All',
    initiatedByListId: 'All',
    transferTimes: [{ start: 1n, end: 18446744073709551615n }],
    tokenIds: [{ start: 1n, end: 18446744073709551615n }],
    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
    version: 0n,
    approvalCriteria: {
        // Only read-only checks - safe for auto-scan
        mustOwnTokens: [
            {
                tokenIds: [{ start: 1n, end: 1n }],
                ownershipTimes: [
                    {
                        start: 1n,
                        end: 18446744073709551615n,
                    },
                ],
            },
        ],
        // ... other criteria
    },
};

// ‚ùå NOT auto-scannable - has coin transfers
const approvalWithSideEffects: CollectionApproval<bigint> = {
    approvalId: 'paid-transfer',
    fromListId: '!Mint',
    toListId: 'All',
    initiatedByListId: 'All',
    transferTimes: [{ start: 1n, end: 18446744073709551615n }],
    tokenIds: [{ start: 1n, end: 18446744073709551615n }],
    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
    version: 0n,
    approvalCriteria: {
        coinTransfers: [
            {
                to: 'bb1...',
                coins: [{ denom: 'ubadge', amount: 1000000n }],
            },
        ],
        // ... other criteria
    },
};
```

### Safe Criteria for Auto-Scan

Read-only criteria are safe and won't prevent auto-scanning:

-   `mustOwnTokens`, address checks
-   `requireToEqualsInitiatedBy`, etc.
-   `overridesFromOutgoingApprovals`, `overridesToIncomingApprovals`
-   `autoDeletionOptions`

### Versioning Control

Versioning ensures users know the exact approval they're using before submitting, preventing race conditions. Every time you update an approval, the version will increment automatically.

```typescript
// Approval version increments on each update
const approval: CollectionApproval<bigint> = {
    approvalId: 'my-approval',
    fromListId: '!Mint',
    toListId: 'All',
    initiatedByListId: 'All',
    transferTimes: [{ start: 1n, end: 18446744073709551615n }],
    tokenIds: [{ start: 1n, end: 18446744073709551615n }],
    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
    version: 0n, // Initial version
    // ... other fields
};

// After update, version becomes '1'

// Transfer must specify version '1' to use updated approval
// If mismatched version, transfer will fail / ignore that approval
import { MsgTransferTokens } from 'bitbadgesjs-sdk';

const msg: MsgTransferTokens = {
    creator: 'bb1initiator...',
    collectionId: '1',
    transfers: [
        {
            from: 'bb1sender...',
            toAddresses: ['bb1recipient...'],
            balances: [
                {
                    amount: 1n,
                    tokenIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: [
                        {
                            start: 1n,
                            end: 18446744073709551615n,
                        },
                    ],
                },
            ],
            prioritizedApprovals: [
                {
                    approvalId: 'my-approval',
                    approvalLevel: 'collection',
                    approverAddress: '',
                    version: 1n, // Must match current version
                },
            ],
        },
    ],
};
```

### Only Check Prioritized Approvals

You can restrict the system to only check prioritized approvals. If true, we will only check the prioritized approvals provided and fail if none match (i.e. do not check any non-prioritized approvals).

If false, we will check the prioritized approvals first and then scan through the rest of the approvals in auto-scan mode.

```typescript
const msg: MsgTransferTokens = {
    // ... other fields
    transfers: [
        {
            // ... other fields
            prioritizedApprovals: [
                {
                    approvalId: 'abc123',
                    approvalLevel: 'collection',
                    approverAddress: '',
                    version: '0',
                },
            ],
            onlyCheckPrioritizedCollectionApprovals: true, // Only check prioritized, fail if none match
            onlyCheckPrioritizedIncomingApprovals: true,
            onlyCheckPrioritizedOutgoingApprovals: true,
        },
    ],
};
```

## Must Prioritize Flag

The `mustPrioritize` flag explicitly requires an approval to be prioritized. This is an easy way to prevent auto-scanning of approvals that you do not want to be auto-scanned.

```typescript
const approval: CollectionApproval<bigint> = {
    approvalCriteria: {
        mustPrioritize: true, // Cannot be auto-scanned
        // ... other criteria
    },
};
```

**Recommended to use `mustPrioritize: true` when:**

-   Forceful transfers (overrides user approvals)
-   Stateful approvals (increment trackers)
-   Sensitive operations requiring explicit control

## Selective Prioritization

Prioritization is not only used for non auto-scannable approvals. It can also be used to selectively prioritize approvals over others or match to a single approval for a specific transfer context.

## User-Level Auto Approval Flags

All user-level auto approval flags are auto-scannable by default. These flags have no disallowed criteria, so they don't need to be prioritized.

```typescript
// User enables auto-approval flags
const userBalanceStore: UserBalanceStore<bigint> = {
    balances: [],
    outgoingApprovals: [],
    incomingApprovals: [],
    autoApproveSelfInitiatedOutgoingTransfers: true,
    autoApproveSelfInitiatedIncomingTransfers: true,
    autoApproveAllIncomingTransfers: true,
    userPermissions: {
        // ... permission fields
    },
    // ... other fields
};
```

## Examples

### Collection-Level Transferability

Oftentimes, you may want to make collection-level approvals fully transferable with certain approval criteria restrictions like `mustOwnTokens`. This is fine and compatible with liquidity pools and other auto-scan environments. Handle accordingly in your design.

```typescript
// ‚úÖ Auto-scannable - fully transferable with read-only restrictions
const collectionApproval: CollectionApproval<bigint> = {
    fromListId: '!Mint',
    toListId: 'All',
    initiatedByListId: 'All',
    transferTimes: [{ start: 1n, end: 18446744073709551615n }],
    tokenIds: [{ start: 1n, end: 18446744073709551615n }],
    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
    approvalId: 'transferable-approval',
    version: 0n,
    approvalCriteria: {
        // Read-only checks - safe for auto-scan
        mustOwnTokens: [
            {
                tokenIds: [{ start: 1n, end: 1n }],
                ownershipTimes: [
                    {
                        start: 1n,
                        end: 18446744073709551615n,
                    },
                ],
            },
        ],
        // ... other criteria
    },
};
```

**Compatible with:** Liquidity pools, automated trading, and other auto-scan environments.

However, if you introduce `coinTransfers` or other disallowed logic, the approval becomes incompatible with auto-scan mode:

```typescript
// ‚ùå NOT auto-scannable - has coin transfers
const collectionApproval: CollectionApproval<bigint> = {
    fromListId: '!Mint',
    toListId: 'All',
    initiatedByListId: 'All',
    transferTimes: [{ start: 1n, end: 18446744073709551615n }],
    tokenIds: [{ start: 1n, end: 18446744073709551615n }],
    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
    approvalId: 'paid-approval',
    version: 0n,
    approvalCriteria: {
        coinTransfers: [
            {
                to: 'bb1...',
                coins: [{ denom: 'ubadge', amount: 1000000n }],
            },
        ],
        // ... other criteria
    },
};
```

**Not compatible with:** Auto-scan environments. Transfers must be prioritized.

### Auto-Scan Compatible Transfer

```typescript
import { MsgTransferTokens } from 'bitbadgesjs-sdk';

// Simple transfer - no side effects
const msg: MsgTransferTokens = {
    creator: 'bb1initiator...',
    collectionId: '1',
    transfers: [
        {
            from: 'bb1sender...',
            toAddresses: ['bb1recipient...'],
            balances: [
                {
                    amount: 1n,
                    tokenIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: [
                        {
                            start: 1n,
                            end: 18446744073709551615n,
                        },
                    ],
                },
            ],
            // No prioritizedApprovals - system auto-scans
        },
    ],
};
```

### Prioritized Transfer with Coin Transfers

```typescript
// Transfer with payment side effects - MUST prioritize
const msg: MsgTransferTokens = {
    creator: 'bb1initiator...',
    collectionId: '1',
    transfers: [
        {
            from: 'bb1sender...',
            toAddresses: ['bb1recipient...'],
            balances: [
                {
                    amount: '1',
                    tokenIds: [{ start: '1', end: '1' }],
                    ownershipTimes: [
                        { start: '1', end: '18446744073709551615' },
                    ],
                },
            ],
            prioritizedApprovals: [
                {
                    approvalId: 'reward-approval',
                    approvalLevel: 'collection',
                    approverAddress: '',
                    version: '1', // Must match current version
                },
            ],
        },
    ],
};
```

### Multiple Prioritized Approvals

```typescript
// Transfer using multiple approvals
const msg: MsgTransferTokens = {
    creator: 'bb1initiator...',
    collectionId: '1',
    transfers: [
        {
            from: 'bb1sender...',
            toAddresses: ['bb1recipient...'],
            balances: [
                {
                    amount: '1',
                    tokenIds: [{ start: '1', end: '1' }],
                    ownershipTimes: [
                        { start: '1', end: '18446744073709551615' },
                    ],
                },
            ],
            prioritizedApprovals: [
                {
                    approvalId: 'collection-approval',
                    approvalLevel: 'collection',
                    approverAddress: '',
                    version: '2',
                },
                {
                    approvalId: 'outgoing-approval',
                    approvalLevel: 'outgoing',
                    approverAddress: 'bb1sender...',
                    version: '0',
                },
            ],
        },
    ],
};
```

See [Transferability](./transferability.md) for detailed documentation.


## File: ./learn/cosmos-coin-wrapper-paths.md

# Cosmos Coin Wrapper Paths

Cosmos Wrapper Paths enable wrapping between BitBadges tokens and native Cosmos SDK coin (x/bank) asset types, making tokens IBC-compatible. These paths automatically mint and burn tokens when transferring to/from specific wrapper addresses.

This is used to generate a 1:1 compatible mapping between our standard tokens and native Cosmos SDK coins. Note that this does not use an existing IBC denom, but rather creates a custom generated denomination.

Use cases could include:

-   Using our standard tokens for time-dependent logic but eventually making them native Cosmos SDK coins
-   Compatibility with existing Cosmos services and chains like Osmosis, Juno, etc.

> **Important**: Since wrapper addresses are uncontrollable (no private keys), approval design requires careful consideration. You must override the wrapper address's user-level approvals where necessary using collection approvals to ensure wrapping/unwrapping functions properly. Additionally, collection approvals used for wrapper path operations must have `allowSpecialWrapping: true` set in their `approvalCriteria`. See [Special Address Flags](../token-standard/learn/approval-criteria/special-address-flags.md) for details.

## Core Concept

Wrapper paths create special addresses that convert our standard tokens to native Cosmos SDK coins:

-   **Wrapping**: Send our standard tokens to wrapper address ‚Üí receive native coins (tokens are burned, x/bank coins are minted)
-   **Unwrapping**: Send native coins to wrapper address ‚Üí receive our standard tokens (x/bank coins are burned, tokens are minted)

```typescript
// Collection with wrapper path
const collection: MsgCreateCollection = {
    creator: 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls',
    collectionId: '0', // 0 for new collection
    validTokenIds: [{ start: 1n, end: 100n }],
    cosmosCoinWrapperPathsToAdd: [
        {
            denom: 'utoken',
            conversion: {
                sideA: {
                    amount: '1', // Required: amount of wrapped coin
                },
                sideB: [
                    {
                        amount: 1n,
                        tokenIds: [{ start: 1n, end: 100n }],
                        ownershipTimes: [
                            { start: 1n, end: 18446744073709551615n },
                        ],
                    },
                ],
            },
            symbol: 'TOKEN',
            denomUnits: [
                {
                    decimals: 6n,
                    symbol: 'TOKEN',
                    isDefaultDisplay: true,
                },
            ],
            allowOverrideWithAnyValidToken: false,
            metadata: { uri: '', customData: '' }, // Optional metadata
        },
    ],
    aliasPathsToAdd: [
        {
            denom: 'utoken-alias',
            conversion: {
                sideA: {
                    amount: '1', // Required: amount of wrapped coin
                },
                sideB: [
                    {
                        amount: 1n,
                        tokenIds: [{ start: 1n, end: 100n }],
                        ownershipTimes: [
                            { start: 1n, end: 18446744073709551615n },
                        ],
                    },
                ],
            },
            symbol: 'ALIAS',
            denomUnits: [
                {
                    decimals: 6n,
                    symbol: 'ALIAS',
                    isDefaultDisplay: true,
                },
            ],
            metadata: { uri: '', customData: '' }, // Optional metadata
        },
    ],
    // ... other fields
};
```

## Wrapper Paths vs Alias Paths

The system now distinguishes between two separate path types:

### Cosmos Coin Wrapper Paths

Used for actual wrapping/unwrapping with minting and burning:

-   **Purpose**: Convert tokens to native Cosmos SDK coins and vice versa
-   **Behavior**: Tokens are burned when wrapping, coins are minted. Coins are burned when unwrapping, tokens are minted
-   **Use case**: IBC transfers, converting tokens to native coins for Cosmos ecosystem compatibility
-   **Storage**: Stored in `cosmosCoinWrapperPaths` array
-   **Features**: Includes `address` field (wrapper address) and `allowOverrideWithAnyValidToken` option

```typescript
{
    denom: 'utoken',
            conversion: {
                sideA: {
                    amount: '1', // Required: amount of wrapped coin
                },
        sideB: [
            {
                amount: 1n,
                tokenIds: [{ start: 1n, end: 100n }],
                ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
            },
        ],
    },
    symbol: 'TOKEN',
    denomUnits: [
        {
            decimals: 6n,
            symbol: 'TOKEN',
            isDefaultDisplay: true,
        },
    ],
    allowOverrideWithAnyValidToken: false,
    metadata: { uri: '', customData: '' }, // Optional PathMetadata
}
```

### Alias Paths

Used for compatibility with existing Cosmos SDK interfaces without actual wrapping:

-   **Purpose**: Alias denomination support (e.g., `badgeslp:COLLECTION_ID:denom`)
-   **Behavior**: No minting/burning occurs, only an alias for information purposes
-   **Use case**: Compatibility with liquidity pools, DeFi protocols that expect `sdk.Coin` format
-   **Storage**: Stored in `aliasPaths` array (separate from wrapper paths)
-   **See**: [Alias Compatibility](alias-compatibility.md) for details
-   **Note**: Does not include `address` or `allowOverrideWithAnyValidToken` fields

```typescript
{
    denom: 'utoken',
            conversion: {
                sideA: {
                    amount: '1', // Required: amount of alias unit
                },
        sideB: [
            {
                amount: 1n,
                tokenIds: [{ start: 1n, end: 100n }],
                ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
            },
        ],
    },
    symbol: 'TOKEN',
    denomUnits: [
        {
            decimals: 6n,
            symbol: 'TOKEN',
            isDefaultDisplay: true,
        },
    ],
    metadata: { uri: '', customData: '' }, // Optional PathMetadata
}
```

## Wrapper Address Generation

Wrapper addresses are auto-generated based on the denom:

```typescript
import { generateAliasAddressForDenom } from 'bitbadgesjs-sdk';

const denom = 'utoken';
const wrapperAddress = generateAliasAddressForDenom(denom);
console.log('Wrapper Address:', wrapperAddress);
```

**Note:** The address is generated from the custom denom, not the full `badges:collectionId:denom` format.

## Conversion Structure

Wrapper paths and alias paths use a structured conversion format to define the relationship between wrapped/alias units and badge tokens:

### ConversionWithoutDenom

Used by wrapper paths and alias paths (denom stored separately):

```typescript
{
    conversion: {
        sideA: {
            amount: '1', // Required: amount of wrapped/alias coin (Uint type)
        },
        sideB: [
            // Balances[] that define which tokens participate
            {
                amount: 1n,
                tokenIds: [{ start: 1n, end: 100n }],
                ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
            },
        ],
    },
}
```

**Key Points:**

-   `sideA.amount`: The amount of wrapped/alias coin units (required, must be specified)
-   `sideB`: Array of `Balance` objects that define the tokens involved in the conversion
-   The denom is stored at the path level, not in the conversion (hence "WithoutDenom")
-   Conversion rate: `sideA.amount` wrapped/alias units = `sideB[]` tokens

**Example:**

-   If `sideA.amount = "1"` and `sideB = [{ amount: 1n, tokenIds: [...], ... }]`
-   Then: `1 wrapped coin = 1 token` (1:1 conversion)

**Example with different rate:**

-   If `sideA.amount = "100"` and `sideB = [{ amount: 1n, tokenIds: [...], ... }]`
-   Then: `100 wrapped coins = 1 token` (100:1 conversion)

## Configuration Fields

### Denom

The base denomination for the wrapped coin. The full Cosmos denomination will be `badges:collectionId:denom`. Note that `badges:` is different from the `badgeslp:` format used for aliases elsewhere.

```typescript
{
    denom: 'utoken', // Base denom
    // Full denom: badges:1:utoken
}
```

### Conversion

Defines the conversion rate between wrapped coins and tokens using a structured conversion format:

```typescript
{
    conversion: {
        sideA: {
            amount: '1', // Required: amount of wrapped coin
        },
        sideB: [
            {
                amount: 1n, // Token amount
                tokenIds: [{ start: 1n, end: 100n }], // Token IDs that can wrap
                ownershipTimes: [{ start: 1n, end: 18446744073709551615n }], // Ownership times
            },
        ],
    },
}
```

**Conversion rate:** `conversion.sideA.amount wrapped coin = conversion.sideB[] tokens`

**Key Points:**

-   `sideA.amount` is required and must be specified (cannot be "0" or nil)
-   `sideB` contains the `Balances[]` that define which tokens participate in wrapping
-   The denom is stored separately at the path level (not in the conversion)

### Denomination Units

Multiple denomination units allow different display formats:

```typescript
{
    denomUnits: [
        {
            decimals: 3n, // 3 decimal places
            symbol: 'mtoken', // Milli-token
            isDefaultDisplay: false,
            metadata: { uri: '', customData: '' }, // Optional PathMetadata
        },
        {
            decimals: 6n, // 6 decimal places
            symbol: 'TOKEN', // Full token
            isDefaultDisplay: true, // Shown by default
            metadata: { uri: '', customData: '' }, // Optional PathMetadata
        },
    ],
}
```

**System:**

-   `utoken` = base unit (0 decimals)
-   `mtoken` = 1,000 `utoken` (3 decimals)
-   `TOKEN` = 1,000,000 `utoken` (6 decimals, default display)

**Note:** Each `DenomUnit` now includes an optional `metadata` field of type `PathMetadata` for additional information.

### Allow Override With Any Valid Token

When `true`, allows the wrapper to accept any SINGLE valid token ID from the collection's `validTokenIds` range:

```typescript
{
    denom: 'utoken',
    conversion: {
        sideA: {
            amount: '1',
        },
        sideB: [
            {
                amount: 1n,
                tokenIds: [{ start: 1n, end: 1n }], // Overridden during transfer
                ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
            },
        ],
    },
    allowOverrideWithAnyValidToken: true, // Accept any valid token ID
}
```

**How it works:**

1. User transfers token ID 5 to wrapper
2. System validates token ID 5 is in `validTokenIds`
3. System temporarily overrides `conversion.sideB[].tokenIds` with `[{ start: 5n, end: 5n }]` ignoring the values set in the `sideB` array
4. Conversion proceeds with token ID 5

## {id} Placeholder Support

You can use `{id}` in the denom to dynamically replace it with the actual token ID:

```typescript
{
    denom: 'utoken{id}', // Dynamic denom
    symbol: 'TOKEN:{id}',
    conversion: {
        sideA: {
            amount: '1',
        },
        sideB: [
            {
                amount: 1n,
                tokenIds: [{ start: 1n, end: 1n }],
                ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
            },
        ],
    },
    allowOverrideWithAnyValidToken: true,
}
```

**Example:** Transferring token ID 5 results in denom `utoken5`.

### Metadata

Both wrapper paths and alias paths support optional metadata using the standard metadata structure:

```typescript
{
    metadata: {
        uri: 'ipfs://Qm...', // Optional URI to hosted JSON metadata
        customData: '{"key": "value"}', // Optional custom JSON data
    },
}
```

The hosted JSON at the URI typically contains `{ name, image, description }`, though the image is the primary use case. The on-chain `symbol` field is used for identification, not the metadata name.

**Note:** Metadata is optional. It's also available on `DenomUnit` objects for additional per-unit metadata.

## Transferability Requirements

Wrapper addresses are subject to the same transferability requirements as any other address. You can user-gate, rate-limit, or apply custom logic:

```typescript
// Example: Rate-limited wrapping
const collectionApprovals = [
    {
        fromListId: 'AllWithoutMint',
        toListId: wrapperAddress,
        initiatedByListId: 'All',
        transferTimes: [{ start: 1n, end: 18446744073709551615n }],
        tokenIds: [{ start: 1n, end: 100n }],
        ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
        approvalId: 'wrap-approval',
        version: 0n,
        approvalCriteria: {
            allowSpecialWrapping: true, // Required for wrapper path operations
            maxNumTransfers: {
                perInitiatedByAddressMaxNumTransfers: 10n, // 10 wraps per day
                // ... reset time intervals
            },
        },
    },
    {
        fromListId: wrapperAddress,
        toListId: 'All',
        initiatedByListId: 'All',
        transferTimes: [{ start: 1n, end: 18446744073709551615n }],
        tokenIds: [{ start: 1n, end: 100n }],
        ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
        approvalId: 'unwrap-approval',
        version: 0n,
        approvalCriteria: {
            allowSpecialWrapping: true, // Required for wrapper path operations
            // Override wrapper's incoming approvals
            overridesToIncomingApprovals: true,
        },
    },
];
```

## Conversion Process

### Token to Coin (Wrapping)

1. User transfers tokens to wrapper address
2. System processes denom (replaces `{id}` if present, validates override if enabled)
3. System burns tokens from user's balance
4. System mints equivalent native coins
5. Coins credited to user's account

```typescript
// Wrapping tokens
// ‚ö†Ô∏è IMPORTANT: Wrapping/unwrapping requires prioritized approvals (not compatible with auto-scan mode)
const wrapTokens: MsgTransferTokens = {
    creator: 'bb1user...',
    collectionId: '1',
    transfers: [
        {
            from: 'bb1user...',
            toAddresses: [wrapperAddress],
            balances: [
                {
                    amount: 10n,
                    tokenIds: [{ start: 1n, end: 100n }],
                    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
                },
            ],
            prioritizedApprovals: [
                {
                    approvalId: 'wrap-approval',
                    approvalLevel: 'collection',
                    approverAddress: '',
                    version: 0n,
                },
            ],
            onlyCheckPrioritizedCollectionApprovals: true,
        },
    ],
};

// Result: User receives 10 badges:1:utoken coins (based on conversion.sideA.amount = 1)
// 10 badge tokens are burned (based on conversion.sideB balances)
```

### Coin to Token (Unwrapping)

Unwrapping still uses `MsgTransferTokens`. You initiate a transfer on behalf of the wrapper address:

1. User initiates `MsgTransferTokens` with wrapper address as `from`
2. System processes denom (replaces `{id}` if present, validates override if enabled)
3. System burns native coins from wrapper address
4. System mints equivalent tokens
5. Tokens credited to user's balance

```typescript
// Unwrapping coins
// ‚ö†Ô∏è IMPORTANT: Wrapping/unwrapping requires prioritized approvals (not compatible with auto-scan mode)
// You initiate a transfer on behalf of the wrapper address
const unwrapCoins: MsgTransferTokens = {
    creator: 'bb1user...',
    collectionId: '1',
    transfers: [
        {
            from: wrapperAddress, // Transfer from wrapper address
            toAddresses: ['bb1user...'], // To user
            balances: [
                {
                    amount: 10n,
                    tokenIds: [{ start: 1n, end: 100n }],
                    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
                },
            ],
            prioritizedApprovals: [
                {
                    approvalId: 'unwrap-approval',
                    approvalLevel: 'collection',
                    approverAddress: '',
                    version: 0n,
                },
            ],
            onlyCheckPrioritizedCollectionApprovals: true,
        },
    ],
};

// Result: User receives 10 badge tokens (based on conversion.sideB balances)
// 10 badges:1:utoken coins are burned from wrapper address (based on conversion.sideA.amount = 1)
```

## Use Cases

### IBC Transfers

Enable cross-chain transfers of wrapped tokens:

```typescript
// Wrap tokens for IBC transfer
// ‚ö†Ô∏è IMPORTANT: Requires prioritized approvals
// The conversion rate is defined in the wrapper path's conversion field
const wrapForIBC: MsgTransferTokens = {
    creator: 'bb1user...',
    collectionId: '1',
    transfers: [
        {
            from: 'bb1user...',
            toAddresses: [wrapperAddress],
            balances: [
                {
                    amount: 100n,
                    tokenIds: [{ start: 1n, end: 100n }],
                    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
                },
            ],
            prioritizedApprovals: [
                {
                    approvalId: 'wrap-approval',
                    approvalLevel: 'collection',
                    approverAddress: '',
                    version: 0n,
                },
            ],
            onlyCheckPrioritizedCollectionApprovals: true,
        },
    ],
};

// Transfer wrapped coins via IBC
const ibcTransfer = {
    sourcePort: 'transfer',
    sourceChannel: 'channel-0',
    token: {
        denom: 'badges:1:utoken',
        amount: '100',
    },
    sender: 'bb1user...',
    receiver: 'cosmos1...',
};
```

### DeFi Integration

Use wrapped tokens in Cosmos DeFi protocols:

```typescript
// Add wrapped tokens to liquidity pool
const addLiquidity = {
    poolId: '1',
    sender: 'bb1user...',
    tokenInMaxs: [
        {
            denom: 'badges:1:utoken',
            amount: '1000000',
        },
        {
            denom: 'uatom',
            amount: '500000',
        },
    ],
};
```

## Permission Control

Adding new cosmos coin wrapper paths to a collection is controlled by the `canAddMoreCosmosCoinWrapperPaths` permission. This permission allows you to control when managers can add new wrapper paths.

### Default Behavior

-   **Empty/Nil Permissions**: When `canAddMoreCosmosCoinWrapperPaths` is empty or nil, adding paths is **allowed** (neutral state)
-   **Migration**: Collections migrated from v21 will have empty permissions, meaning adding paths is allowed by default

### Permission Structure

The permission uses the `ActionPermission` type with time-based controls:

```typescript
const collectionPermissions: CollectionPermissions<bigint> = {
    canAddMoreCosmosCoinWrapperPaths: [
        {
            permanentlyPermittedTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
            permanentlyForbiddenTimes: [],
        },
    ],
};
```

### Usage Examples

**Allow adding paths at all times:**

```typescript
const collectionPermissions: CollectionPermissions<bigint> = {
    canAddMoreCosmosCoinWrapperPaths: [], // Empty = allowed by default
};
```

**Lock adding paths forever:**

```typescript
const collectionPermissions: CollectionPermissions<bigint> = {
    canAddMoreCosmosCoinWrapperPaths: [
        {
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
        },
    ],
};
```

**Allow adding paths only during specific period:**

```typescript
const collectionPermissions: CollectionPermissions<bigint> = {
    canAddMoreCosmosCoinWrapperPaths: [
        {
            permanentlyPermittedTimes: [
                { start: 1704067200000n, end: 1735689600000n },
            ],
            permanentlyForbiddenTimes: [],
        },
    ],
};
```

### Permission Check

When using `MsgUniversalUpdateCollection` to add wrapper paths via `cosmosCoinWrapperPathsToAdd`, the system checks the `canAddMoreCosmosCoinWrapperPaths` permission before processing the paths. If the permission check fails, the transaction will be rejected with an appropriate error message.

**Note**: The permission is checked before paths are added, but the permission itself can be updated at the end of the transaction (if `updateCollectionPermissions` is set to `true`).

## Differences from IBC Backed Paths

| Feature           | Wrapper Path                 | IBC Backed Path                        |
| ----------------- | ---------------------------- | -------------------------------------- |
| **Minting**       | Minting/burning of new denom | No minting/burning (uses existing IBC) |
| **Denom Source**  | Generated denom              | Existing IBC denom                     |
| **Configuration** | Can add paths, no edits      | Collection invariant                   |
| **Mint Address**  | Enabled                      | Disabled                               |


## File: ./learn/ibc-backed-minting.md

# IBC Backed Minting Invariants

IBC Backed Paths enable bidirectional conversion between our standard and IBC coins (standard Cosmos SDK coins). This creates a special address that acts as an intermediary, allowing tokens created with our standard to be "backed" by IBC-denominated tokens for seamless interoperability with the broader Cosmos ecosystem.

This can be very useful for use cases like reverse-wrapping IBC (ICS20) tokens with added compliance.

## Core Concept

An IBC Backed Path creates a special address that converts our standard tokens to and from IBC coins:

-   **Back tokens**: Send our standard tokens to the special address ‚Üí receive IBC coins
-   **Unback tokens**: Send IBC coins to the special address ‚Üí receive our standard tokens

```typescript
// Collection with IBC backed path
const collection: MsgCreateCollection = {
    creator: 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls',
    collectionId: '0', // 0 for new collection
    validTokenIds: [{ start: 1n, end: 1n }],
    invariants: {
        cosmosCoinBackedPath: {
            // address: auto-generated from conversion.sideA.denom
            conversion: {
                sideA: {
                    amount: '1000000', // IBC coin amount (from old ibcAmount)
                    denom: 'ibc/1234567890ABCDEF', // IBC denomination (from old ibcDenom)
                },
                sideB: [
                    {
                        amount: 1n,
                        tokenIds: [{ start: 1n, end: 1n }],
                        ownershipTimes: [
                            { start: 1n, end: 18446744073709551615n },
                        ],
                    },
                ],
            },
        },
        noCustomOwnershipTimes: false,
        maxSupplyPerId: '0',
        noForcefulPostMintTransfers: false,
        disablePoolCreation: false,
    },
    // ... other fields (collectionPermissions, manager, etc.)
};
```

## Special Address

Each IBC backed path has a **special address** automatically generated from the IBC denomination in `conversion.sideA.denom`:

```typescript
import { generateAliasAddressForIBCDenom } from 'bitbadgesjs-sdk';

const ibcDenom = 'ibc/1234567890ABCDEF';
const specialAddress = generateAliasAddressForIBCDenom(ibcDenom);
console.log('Special Address:', specialAddress);
```

**Properties:**

-   Deterministically derived from the IBC denom using a hash function
-   Acts as the intermediary for all conversions
-   Marked as a reserved protocol address
-   Holds the IBC coins that back the badge tokens

## Conversion Mechanism

The conversion uses a structured `Conversion` format that combines the IBC denom and amount into `sideA`, with badge tokens in `sideB`. You can't fractionalize it, but if you make the denominations as small as possible, you can get as fine-grained as you want.

```
conversion.sideA (amount + denom) = conversion.sideB[] (x/badges)
```

**Example:**

```typescript
// Configuration
const backedPath = {
    conversion: {
        sideA: {
            amount: '1000000', // IBC coin amount (from old ibcAmount)
            denom: 'ibc/1234567890ABCDEF', // IBC denomination (from old ibcDenom)
        },
        sideB: [
            {
                amount: 1n,
                tokenIds: [{ start: 1n, end: 1n }],
                ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
            },
        ],
    },
};
```

**Conversion Structure:**

-   **`Conversion`** (with denom): Used by backed paths because the denom is part of the conversion
-   **`sideA`**: Contains both `amount` and `denom` (from old `ibcAmount` and `ibcDenom` fields)
-   **`sideB`**: Array of `Balance` objects that define the badge tokens (from old `balances` field)
-   **Conversion rate**: `conversion.sideA.amount` of `conversion.sideA.denom` = `conversion.sideB[]` tokens

## Configuration

IBC backed paths are configured as **collection invariants**, meaning:

-   Set only during collection creation
-   Cannot be modified after creation
-   Only **one** backed path allowed per collection

```typescript
const collection: MsgCreateCollection = {
    creator: 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls',
    collectionId: '0', // 0 for new collection
    validTokenIds: [{ start: 1n, end: 100n }],
    invariants: {
        cosmosCoinBackedPath: {
            conversion: {
                sideA: {
                    amount: '1000000', // IBC coin amount
                    denom: 'ibc/1234567890ABCDEF', // IBC denomination
                },
                sideB: [
                    {
                        amount: 1n,
                        tokenIds: [{ start: 1n, end: 100n }],
                        ownershipTimes: [
                            { start: 1n, end: 18446744073709551615n },
                        ],
                    },
                ],
            },
        },
        noCustomOwnershipTimes: false,
        maxSupplyPerId: '0',
        noForcefulPostMintTransfers: false,
        disablePoolCreation: false,
    },
    collectionPermissions: {
        // ... permission fields
    },
    manager: 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls',
    // ... other collection fields
};
```

## Mint Address Restrictions

When an IBC backed path is configured:

-   Transfers **from** the Mint address (mints) are never allowed
-   All mints must be done through the IBC backed path
-   Collection approvals cannot include the Mint address in `fromListId`

This prevents minting tokens that would bypass the backing mechanism and cause desyncs.

If you want a more hybrid approach or more customization, don't use the invariant and rather implement it with custom transferability logic instead.

```typescript
// ‚ùå Invalid - Cannot use Mint address with IBC backed path
const invalidApproval = {
    fromListId: 'Mint', // Not allowed when cosmosCoinBackedPath is set
    toListId: 'All',
    // ...
};

// ‚úÖ Valid - Must use special address for minting
const validApproval = {
    fromListId: specialAddress, // Use the IBC backed path address
    toListId: 'All',
    // ...
};
```

## Transferability Requirements

The special address is subject to the same transferability requirements as any other address. You can user-gate, rate-limit, or apply any approval logic.

**Important:** Collection approvals used for IBC backed path operations must have `allowBackedMinting: true` set in their `approvalCriteria`. See [Special Address Flags](../token-standard/learn/approval-criteria/special-address-flags.md) for details.

```typescript
// Example: Rate-limited backing
const collectionApprovals = [
    {
        fromListId: specialAddress,
        toListId: 'All',
        initiatedByListId: 'All',
        transferTimes: [{ start: 1n, end: 18446744073709551615n }],
        tokenIds: [{ start: 1n, end: 100n }],
        ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
        approvalId: 'backing-approval',
        version: 0n,
        approvalCriteria: {
            allowBackedMinting: true, // Required for IBC backed path operations
            maxNumTransfers: {
                perInitiatedByAddressMaxNumTransfers: 10n, // 10 backs per day
                // ... reset time intervals
            },
        },
    },
];
```

## Technical Implementation

### Address Detection

The system automatically detects transfers involving the special address:

-   Checks if `to` address matches the backed path address (backing)
-   Checks if `from` address matches the backed path address (unbacking)
-   Triggers the appropriate conversion logic

**Important:** Detection happens in `MsgTransferTokens` implementation. Using the bank module alone won't work because it doesn't know about IBC backed paths. To trigger a minting or unminting, you simply wire up a `MsgTransferTokens` message to the special address. Approvals of the special address are handled behind the scenes by the system. Note: The approval must be prioritized as this is a special context / environment. We also verify that the initiator is equal to the recipient / sender. There is no doing this on behalf of another user.

## Example: Backing Tokens

```typescript
// User sends badge tokens to special address
// ‚ö†Ô∏è IMPORTANT: IBC backed path operations require prioritized approvals (not compatible with auto-scan mode)
// The initiator must equal the sender/recipient - no doing this on behalf of another user
const backTokens: MsgTransferTokens = {
    creator: 'bb1user...', // Must equal from address
    collectionId: '1',
    transfers: [
        {
            from: 'bb1user...', // Must equal creator
            toAddresses: [specialAddress], // Special IBC backed path address
            balances: [
                {
                    amount: 5n,
                    tokenIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
                },
            ],
            prioritizedApprovals: [
                {
                    approvalId: 'backing-approval',
                    approvalLevel: 'collection',
                    approverAddress: '',
                    version: 0n,
                },
            ],
            onlyCheckPrioritizedCollectionApprovals: true,
        },
    ],
};

// Result: User receives corresponding IBC coins automatically based on the conversion rate
```

## Example: Unbacking Tokens

Approvals are actually handled behind the scenes by the system for the special address. You do not need to do anything special here besides having sufficient balances to unback the tokens.

```typescript
// User initiates transfer on behalf of special address to receive tokens
// ‚ö†Ô∏è IMPORTANT: IBC backed path operations require prioritized approvals (not compatible with auto-scan mode)
// The initiator must equal the recipient - no doing this on behalf of another user
const unbackTokens: MsgTransferTokens = {
    creator: 'bb1user...', // Must equal toAddress
    collectionId: '1',
    transfers: [
        {
            from: specialAddress, // Transfer from special IBC backed path address
            toAddresses: ['bb1user...'], // Must equal creator
            balances: [
                {
                    amount: 5n,
                    tokenIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
                },
            ],
            prioritizedApprovals: [
                {
                    approvalId: 'unbacking-approval',
                    approvalLevel: 'collection',
                    approverAddress: '',
                    version: 0n,
                },
            ],
            onlyCheckPrioritizedCollectionApprovals: true,
        },
    ],
};

// Result: User receives 5 badge tokens
// Corresponding IBC coins are deducted from special address
```

## Differences from Wrapper Paths

| Feature              | IBC Backed Path                        | Wrapper Path                 |
| -------------------- | -------------------------------------- | ---------------------------- |
| **Minting**          | No minting/burning (uses existing IBC) | Minting/burning of new denom |
| **Denom Source**     | Existing IBC denom                     | Generated denom              |
| **Configuration**    | Collection invariant                   | Can add paths, no edits      |
| **Standard Minting** | Disabled                               | Enabled                      |


## File: ./learn/minting-and-circulating-supply.md

## Mint Address

The **Mint address** is a reserved address string (`"Mint"`) representing each collection's minting source. It has unlimited balances, and any transfer from the Mint address creates new tokens out of thin air. The Mint address cannot receive tokens, only send/mint them.

```typescript
const transferMsg: MsgTransferTokens = {
    from: 'Mint',
    toAddresses: ['bb1...'],
    balances: [
        {
            amount: 1n,
            tokenIds: [{ start: 1n, end: 1n }],
            ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
        },
    ],
    // ... other fields
}
```

```typescript
const approval: CollectionApproval<bigint> = {
    fromListId: 'Mint',
    toListId: 'All',
    initiatedByListId: 'All',
    // ... other fields
    approvalCriteria: {
        // ... other criteria
        overridesFromOutgoingApprovals: true, // Required for Mint
    },
}
```

### Manager Controls Minting Flow

The **manager** of the collection controls minting by setting and updating collection transferability rules (`collectionApprovals`) and the updatability of such rules via permissions (`collectionPermissions.canUpdateCollectionApprovals`). The manager can:

-   Create, edit, or remove mint approvals (approvals where `fromListId: 'Mint'`) that allow specific minting patterns, according to the updatability permissions set (`canUpdateCollectionApprovals`)
-   Set the updatability permissions to lock the future updatability of mint approvals (locking, enabling, soft-enabling, etc.). This is flexible and allows fine-grained patterns like locking for specific times, to specific addresses, etc.

**Important distinction:** Approvals define what transfers are **allowed**, but minting only occurs on **executed transfers**. Approvals are transferability rules. Transfers execute dependent on those rules. Permissions control the updatability of approvals.

```typescript
// Manager sets initial mint approval
const collection: TokenCollection<bigint> = {
    manager: 'bb1...',
    collectionApprovals: [
        {
            fromListId: 'Mint',
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: [{ start: 1n, end: 18446744073709551615n }],
            tokenIds: [{ start: 1n, end: 18446744073709551615n }],
            ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
            approvalId: 'mint-approval',
            version: 0n,
            // ... other fields
        },
    ],
    collectionPermissions: {
        canUpdateCollectionApprovals: [
            {
                fromListId: 'Mint',
                toListId: 'All',
                initiatedByListId: 'All',
                transferTimes: [{ start: 1n, end: 18446744073709551615n }],
                tokenIds: [{ start: 1n, end: 18446744073709551615n }],
                ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
                approvalId: 'All',
                permanentlyPermittedTimes: [],
                permanentlyForbiddenTimes: [
                    { start: 1n, end: 18446744073709551615n },
                ], // Locks it forever
            },
        ],
        // ... other permission fields
    },
};
```

**To lock minting:** Disable approval updates permanently for any Mint approval. The current approvals set will be frozen and cannot be updated.

### Common Approaches

Two common approaches for managing supply:

#### 1. Mint All at Genesis, Then Lock

Mint all tokens you need upon collection creation, then lock mint approval updates. Control future flow with post-mint transferability.

For example:

1. Create collection with Mint approvals
2. Mint all tokens to yourself you may ever need (via MsgTransferTokens)
3. Lock minting forever

**Result:** Fixed supply. All tokens minted. Control distribution via post-mint transferability rules.

#### 2. Keep Mint as "Escrow" for Future Mints

Keep the Mint address as an escrow for future mints. Control flow with approval updatability and current approvals. For example:

1. Create collection with Mint approvals
2. Edit Mint approvals over time (according to permissions) to enable future minting as needed

**Result:** More dynamic supply. Manager can update mint approvals to enable future minting as needed. Current approvals control immediate minting capabilities, but the manager can always update them to enable more minting in the future.

## Circulating Supply

Circulating supply is the cumulative total of all tokens transferred from the Mint address. It's dynamic, not static. This may be a slightly different concept than you're used to, but it's a powerful one because it allows for you to control the supply of your tokens dynamically and flexibly over time.

Thus, design of your Mint approvals is crucial to the supply control of your collection.

```typescript
// Supply control via approvals
const mintApproval: CollectionApproval<bigint> = {
    fromListId: 'Mint',
    toListId: 'All',
    initiatedByListId: 'All',
    transferTimes: [{ start: 1n, end: 18446744073709551615n }],
    tokenIds: [{ start: 1n, end: 18446744073709551615n }],
    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
    approvalId: 'supply-control',
    version: 0n,
    // Approval criteria control who can mint, when, how much
    approvalCriteria: {
        maxNumTransfers: {
            overallMaxNumTransfers: 1000n,
            perFromAddressMaxNumTransfers: 0n,
            perToAddressMaxNumTransfers: 0n,
            perInitiatedByAddressMaxNumTransfers: 0n,
            amountTrackerId: 'supply-control',
            resetTimeIntervals: null
        },
        overridesFromOutgoingApprovals: true, // Required for Mint address
        // ... other criteria
    },
};
```

### Importance of Updatability Permissions

Even if current approvals don't allow minting, if the manager can update approvals, there is effectively unlimited supply potential. They can simply update and create a new unlimited mint approval. Thus, it is crucial to control both the current approvals and the updatability permissions.

**Visual Example: The Supply Cap Bypass**

Imagine a collection with a capped supply of 1,000 tokens:

```
Current State:
‚îÇ Collection: "Limited Edition Badge"      
‚îÇ Current Supply: 500/1,000                
‚îÇ                                          
‚îÇ Current Mint Approval:                   
‚îÇ   ‚úÖ Allows: 500 more tokens            
‚îÇ   ‚ùå Blocks: Any additional minting      
‚îÇ                                           
‚îÇ Manager Permission:                      
‚îÇ   ‚ö†Ô∏è Can Update Approvals: YES           
```

On the outside, it may seem like only 500 more are allowed. However, the manager still has the ability to update or create new approvals. Thus, the supply is effectively unlimited because they can simply update the approvals to allow unlimited minting.

**Key Takeaway:**

To truly cap supply, you must lock BOTH:
1. **Current approvals** - What minting is allowed now
2. **Updatability permissions** - Whether approvals can be created

## Important Disclaimers

### Never Mix Mint with Other Addresses

**CRITICAL**: When handling collection approvals, you do NOT want to handle the Mint address with other addresses. By default, lists with reserved aliases like "All" include the Mint address. You do not want to accidentally allow minting when you don't intend to.

For proper design, we highly recommend separating minting and post-mint approvals (`fromListId: '!Mint'` vs `fromListId: 'Mint'`).

```typescript
// ‚ùå BAD - Never do this
const badApproval: CollectionApproval<bigint> = {
    fromListId: 'All', // Mixing Mint with other addresses
    toListId: 'All',
    initiatedByListId: 'All',
    transferTimes: [{ start: 1n, end: 18446744073709551615n }],
    tokenIds: [{ start: 1n, end: 18446744073709551615n }],
    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
    approvalId: 'bad-approval',
    version: 0n,
    // ... other fields
};

// ‚úÖ GOOD - Separate mint and post-mint approvals
const mintApproval: CollectionApproval<bigint> = {
    fromListId: 'Mint', // Minting only
    toListId: 'All',
    initiatedByListId: 'All',
    transferTimes: [{ start: 1n, end: 18446744073709551615n }],
    tokenIds: [{ start: 1n, end: 18446744073709551615n }],
    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
    approvalId: 'mint-only',
    version: 0n,
    // ... other fields
};

const postMintApproval: CollectionApproval<bigint> = {
    fromListId: '!Mint', // All addresses except Mint
    toListId: 'All',
    initiatedByListId: 'All',
    transferTimes: [{ start: 1n, end: 18446744073709551615n }],
    tokenIds: [{ start: 1n, end: 18446744073709551615n }],
    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
    approvalId: 'post-mint',
    version: 0n,
    // ... other fields
};
```

**Rules:**

-   Use `"Mint"` for minting approvals only
-   Use `"!Mint"` or `"AllWithoutMint"` for post-mint approvals
-   Never use `"All"` for `fromListId` (it includes Mint)
-   Never mix `"Mint"` with other addresses in the same list

### Mint Approvals Must Override

Mint address approvals must always override its user-level approvals to properly work, since it cannot control its own user-level approvals itself.

```typescript
const mintApproval: CollectionApproval<bigint> = {
    fromListId: 'Mint',
    toListId: 'All',
    initiatedByListId: 'All',
    transferTimes: [{ start: 1n, end: 18446744073709551615n }],
    tokenIds: [{ start: 1n, end: 18446744073709551615n }],
    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
    approvalId: 'mint-approval',
    version: 0n,
    approvalCriteria: {
        overridesFromOutgoingApprovals: true, // Required
        // ... other criteria
    },
};
```

### Mint vs Mint Escrow Address

Most use cases use `"Mint"` as the reserved address in approvals. For advanced cases needing escrows or payouts, you can use the `mintEscrowAddress` as a helper.

```typescript
// Mint Escrow Address (for advanced cases)
const mintEscrowAddress = generateAlias(
    'badges',
    getAliasDerivationKeysForCollection(collectionId)
);
```

The Mint Escrow Address is a generated `bb1` address that holds Cosmos native funds on behalf of the Mint address. It's used for coin transfers, payouts, and escrows. See [Coin Transfers](../token-standard/learn/approval-criteria/usdbadge-transfers.md#mint-escrow-address) for details.


## File: ./learn/permissions.md

## Manager

The **manager** is the central authority for a collection, controlling all administrative operations. The manager executes actions according to permission rules defined in `collectionPermissions`.

```typescript
const collection: TokenCollection<bigint> = {
    manager: 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls',
    collectionPermissions: {
        // Permissions define what the manager can do
    },
    // ... other collection fields
};
```

### Setting Initial Manager

During collection creation:

```typescript
const collection: TokenCollection<bigint> = {
    creator: 'bb1alice...',
    manager: 'bb1alice...',
    collectionPermissions: {
        canUpdateManager: [
            {
                permanentlyPermittedTimes: [
                    { start: 1n, end: 18446744073709551615n },
                ],
                permanentlyForbiddenTimes: [],
            },
        ],
        // ... other permission fields
    },
    // ... other collection fields
};
```

### No Manager

If you don't want a manager, set the manager to an empty string. Permission values don't matter when there's no manager:

```typescript
const manager: string = '';
```

## Manager Capabilities

The manager can execute administrative actions according to permissions:

-   Updating collection metadata
-   Updating token metadata
-   Updating transferability (collection approvals)
-   Updating valid token IDs
-   Archiving the collection
-   Deleting the collection
-   Updating manager
-   And more...

All permissions are defined on-chain with time-based configuration, allowing permissions to change over time.

You may also implement off-chain permissions for the manager, but this is up to you and your use case.

```typescript
// Manager with full control (soft-enabled)
const collectionPermissions: CollectionPermissions<bigint> = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateTokenMetadata: [],
    canUpdateCollectionApprovals: [],
    canUpdateValidTokenIds: [],
    canAddMoreAliasPaths: [],
    canAddMoreCosmosCoinWrapperPaths: [],
    // ... other permission fields
};
```

## User Permissions

User permissions control what individual users can do with their own badges and transfer approvals. Unlike manager permissions which control collection-wide administrative actions, user permissions control user-specific actions like updating auto-approve settings and managing their own incoming/outgoing transfer approvals.

These are almost always never needed unless in advanced situations. Typically, you just leave these soft-enabled (empty arrays) for all. These are only really needed in advanced situations where you want to lock down a user's ability to update their own approvals, such as escrow accounts.

```typescript
const userPermissions: UserPermissions<bigint> = {
    canUpdateAutoApproveSelfInitiatedOutgoingTransfers: [],
    canUpdateAutoApproveSelfInitiatedIncomingTransfers: [],
    canUpdateAutoApproveAllIncomingTransfers: [],
    canUpdateOutgoingApprovals: [],
    canUpdateIncomingApprovals: [],
};
```

## Permissions

Permissions control which actions can be performed and when those actions can be executed. The manager executes administrative actions according to these permission rules.

## Permission States

Permissions have three states:

| State                     | Description                    | Behavior                                                   |
| ------------------------- | ------------------------------ | ---------------------------------------------------------- |
| **Permanently Permitted** | Action ALWAYS allowed (frozen) | Can be executed                                            |
| **Permanently Forbidden** | Action ALWAYS blocked (frozen) | Cannot be executed                                         |
| **Neutral**               | Not specified                  | **Allowed by default now, but can change state in future** |

**Important:** Once set to permanently permitted or forbidden, it can never changed. This is by design to act as a check and balance enforced on-chain.

```typescript
// Lock collection deletion forever
const collectionPermissions: CollectionPermissions<bigint> = {
    canDeleteCollection: [
        {
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
        },
    ],
    // ... other permission fields
};

// Soft-enabled (default behavior - allowed but can be changed)
const collectionPermissions: CollectionPermissions<bigint> = {
    canDeleteCollection: [], // Empty = allowed by default
    // ... other permission fields
};
```

## First Match Policy

Permissions are evaluated as a linear array where each element has criteria and time controls. Only the **first matching element** is applied - all subsequent matches are ignored.

**Key Rules:**

-   **First Match Only**: Only the first element that matches all criteria is used
-   **Deterministic State**: Each criteria combination has exactly one permission state
-   **No Overlap**: Times cannot be in both `permanentlyPermittedTimes` and `permanentlyForbiddenTimes`
-   **Order Matters**: Array order affects which permissions are applied

**Example: Action Permissions**

```typescript
const collectionPermissions: CollectionPermissions<bigint> = {
    canUpdateCollectionMetadata: [
        {
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
        },
    ],
};
```

**Result:**

-   Collection metadata updates: **Forbidden** (locked forever)

## Satisfying Criteria

All criteria in a permission element must match for it to be applied. Partial matches are ignored.

**Example: Token Metadata Permissions**

```typescript
const collectionPermissions: CollectionPermissions<bigint> = {
    canUpdateTokenMetadata: [
        {
            tokenIds: [{ start: 1n, end: 10n }],
            permanentlyPermittedTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
            permanentlyForbiddenTimes: [],
        },
    ],
};
```

**This permission only covers:**

-   Token IDs 1-10

**It does NOT cover:**

-   Token ID 11

These combinations are **unhandled** and **allowed by default** since they do not match the permission criteria.

## Brute Force Pattern

To lock specific criteria, you must specify the target and set all other criteria to maximum ranges (brute forcing all other options).

**Example: Lock Token IDs 1-10**

```typescript
const collectionPermissions: CollectionPermissions<bigint> = {
    canUpdateCollectionApprovals: [
        {
            fromListId: 'All',
            toListId: 'All',
            initiatedByListId: 'All',
            tokenIds: [{ start: 1n, end: 10n }],
            transferTimes: [{ start: 1n, end: 18446744073709551615n }],
            ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
            approvalId: 'All',
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
        },
    ],
};
```

## Permission Types

There are **four types** of permissions, each with different criteria:

| Type                            | Criteria                                       | Examples                                                                                                                                                                                                  |
| ------------------------------- | ---------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Action Permissions**          | Time control only                              | `canDeleteCollection`, `canUpdateCollectionMetadata`, `canUpdateStandards`, `canUpdateCustomData`, `canUpdateManager`, `canArchiveCollection`, `canAddMoreAliasPaths`, `canAddMoreCosmosCoinWrapperPaths` |
| **Token ID Action Permissions** | Token IDs + time control                       | `canUpdateValidTokenIds`, `canUpdateTokenMetadata`                                                                                                                                                        |
| **Approval Permissions**        | Transfer criteria + approval ID + time control | `canUpdateCollectionApprovals`, `canUpdateIncomingApprovals`                                                                                                                                              |

### Action Permissions

Simple time-based permissions with no additional criteria. Control when actions can be executed based solely on time.

**Collection Actions:**

-   `canDeleteCollection` - Delete entire collection
-   `canUpdateCollectionMetadata` - Update collection metadata
-   `canUpdateStandards` - Update standards
-   `canUpdateCustomData` - Update custom data
-   `canUpdateManager` - Update manager
-   `canArchiveCollection` - Archive/unarchive collection
-   `canAddMoreAliasPaths` - Add new alias paths to collection
-   `canAddMoreCosmosCoinWrapperPaths` - Add new cosmos coin wrapper paths to collection

**User Actions:**

-   `canUpdateAutoApproveSelfInitiatedOutgoingTransfers` - Auto-approve outgoing transfers
-   `canUpdateAutoApproveSelfInitiatedIncomingTransfers` - Auto-approve incoming transfers
-   `canUpdateAutoApproveAllIncomingTransfers` - Auto-approve all incoming transfers

**Logic:**

```
For each action request:
    Check if current time is in permanentlyPermittedTimes
        ‚Üí If yes: ALLOW
        ‚Üí If no: Check if current time is in permanentlyForbiddenTimes
            ‚Üí If yes: DENY
            ‚Üí If no: ALLOW (neutral state)
```

**Examples:**

```typescript
// Lock collection deletion forever
const collectionPermissions: CollectionPermissions<bigint> = {
    canDeleteCollection: [
        {
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
        },
    ],
};

// Allow collection deletion only during specific period
const collectionPermissions: CollectionPermissions<bigint> = {
    canDeleteCollection: [
        {
            permanentlyPermittedTimes: [
                { start: 1704067200000n, end: 1735689600000n },
            ],
            permanentlyForbiddenTimes: [],
        },
    ],
};

// Default behavior (no restrictions)
const collectionPermissions: CollectionPermissions<bigint> = {
    canDeleteCollection: [],
};
```

### Token ID Action Permissions

Control when token ID-based fields can be updated. These permissions match on `tokenIds` to determine which token IDs can be updated.

**Token ID Action Permissions:**

-   `canUpdateValidTokenIds` - Update valid token IDs
-   `canUpdateTokenMetadata` - Update token metadata

**Logic:**

```
For each token ID update request:
    Check if token ID matches any tokenIds criteria
        ‚Üí If no match: ALLOW (neutral state)
        ‚Üí If match: Check if current time is in permanentlyPermittedTimes
            ‚Üí If yes: ALLOW
            ‚Üí If no: Check if current time is in permanentlyForbiddenTimes
                ‚Üí If yes: DENY
                ‚Üí If no: ALLOW (neutral state)
```

**Examples:**

```typescript
// Lock token metadata for specific tokens forever
const collectionPermissions: CollectionPermissions<bigint> = {
    canUpdateTokenMetadata: [
        {
            tokenIds: [{ start: 1n, end: 100n }],
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
        },
    ],
};

// Allow token metadata updates only during specific period
const collectionPermissions: CollectionPermissions<bigint> = {
    canUpdateTokenMetadata: [
        {
            tokenIds: [{ start: 1n, end: 100n }],
            permanentlyPermittedTimes: [
                { start: 1704067200000n, end: 1735689600000n },
            ],
            permanentlyForbiddenTimes: [],
        },
    ],
};
```

### Token ID Action Permissions

Control which token-specific actions can be performed based on token IDs.

**Available Actions:**

-   `canUpdateValidTokenIds` - Update valid token ID ranges

**Logic:**

```
For each token action request:
    Check if token ID matches any tokenIds criteria
        ‚Üí If no match: ALLOW (neutral state)
        ‚Üí If match: Check if current time is in permanentlyPermittedTimes
            ‚Üí If yes: ALLOW
            ‚Üí If no: Check if current time is in permanentlyForbiddenTimes
                ‚Üí If yes: DENY
                ‚Üí If no: ALLOW (neutral state)
```

**Examples:**

```typescript
// Lock all token ID updates
const collectionPermissions: CollectionPermissions<bigint> = {
    canUpdateValidTokenIds: [
        {
            tokenIds: [{ start: 1n, end: 18446744073709551615n }],
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
        },
    ],
};

// Lock specific ID range
const collectionPermissions: CollectionPermissions<bigint> = {
    canUpdateValidTokenIds: [
        {
            tokenIds: [{ start: 1n, end: 100n }],
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
        },
    ],
};

// Allow future token IDs only
const collectionPermissions: CollectionPermissions<bigint> = {
    canUpdateValidTokenIds: [
        {
            tokenIds: [{ start: 101n, end: 18446744073709551615n }],
            permanentlyPermittedTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
            permanentlyForbiddenTimes: [],
        },
    ],
};
```

### Approval Permissions

Control when transfer approvals can be updated, allowing you to freeze specific transfer rules. These permissions match on transfer criteria (from, to, initiatedBy, transferTimes, tokenIds, ownershipTimes) and approval ID.

**Available Actions:**

-   `canUpdateCollectionApprovals` - Control collection-level approvals
-   `canUpdateIncomingApprovals` - Control incoming transfer approvals (user)
-   `canUpdateOutgoingApprovals` - Control outgoing transfer approvals (user)

**Note**: For user approvals, `fromListId` and `toListId` are automatically set:

-   **Incoming**: `toListId` is hardcoded to the user's address
-   **Outgoing**: `fromListId` is hardcoded to the user's address

**Logic:**

```
For each approval update request:
    Check if approval criteria match (from, to, initiatedBy, transferTimes, tokenIds, ownershipTimes, approvalId)
        ‚Üí If no match: ALLOW (neutral state)
        ‚Üí If match: Check if current time is in permanentlyPermittedTimes
            ‚Üí If yes: ALLOW
            ‚Üí If no: Check if current time is in permanentlyForbiddenTimes
                ‚Üí If yes: DENY
                ‚Üí If no: ALLOW (neutral state)
```

**Approval Tuple:**
An approval tuple consists of: `(from, to, initiatedBy, tokenIds, transferTimes, ownershipTimes, approvalId)`

**Examples:**

```typescript
// Lock specific token ID range
const collectionPermissions: CollectionPermissions<bigint> = {
    canUpdateCollectionApprovals: [
        {
            fromListId: 'All',
            toListId: 'All',
            initiatedByListId: 'All',
            tokenIds: [{ start: 1n, end: 100n }],
            transferTimes: [{ start: 1n, end: 18446744073709551615n }],
            ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
            approvalId: 'All',
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
        },
    ],
};

// Lock specific approval ID
const collectionPermissions: CollectionPermissions<bigint> = {
    canUpdateCollectionApprovals: [
        {
            fromListId: 'All',
            toListId: 'All',
            initiatedByListId: 'All',
            tokenIds: [{ start: 1n, end: 18446744073709551615n }],
            transferTimes: [{ start: 1n, end: 18446744073709551615n }],
            ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
            approvalId: 'specific-approval-id',
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
        },
    ],
};

// Complete freeze - lock all approvals
const collectionPermissions: CollectionPermissions<bigint> = {
    canUpdateCollectionApprovals: [
        {
            fromListId: 'All',
            toListId: 'All',
            initiatedByListId: 'All',
            tokenIds: [{ start: 1n, end: 18446744073709551615n }],
            transferTimes: [{ start: 1n, end: 18446744073709551615n }],
            ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
            approvalId: 'All',
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: [
                { start: 1n, end: 18446744073709551615n },
            ],
        },
    ],
};
```

**Protection Strategies:**

1. **Specific Approval Lock**: Lock a specific approval by its unique ID
2. **Range Lock with Overlap Protection**: Lock a token range AND all overlapping approvals
3. **Complete Freeze**: Lock all approvals for a collection


## File: ./learn/pre-readings.md

### Explore the BitBadges Platform

Familiarize yourself with the platform by exploring [bitbadges.io](https://bitbadges.io). We always recommend that the best way to learn is just go and try stuff out first. Plenty available in-site is developer-friendly and no-code.

-   Review the landing and explore pages
-   Complete the collection creation flow
-   Examine transaction JSONs by clicking "Show Tx" at the end of different creation flows

You may have all you need directly in-site!

<figure><img src="../.gitbook/assets/image (403).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../.gitbook/assets/image (406).png" alt=""><figcaption></figcaption></figure>


## File: ./learn/transferability.md

# Transferability

Transferability in BitBadges is controlled through a hierarchical approval system with three levels: collection, outgoing, and incoming.

## Three Transferability Levels

BitBadges supports three levels of transferability control:

<div style="overflow-x: auto;">

| Level          | Controlled By  | Approval Level | Approver Address | Stored On                           | Msg                                       | Use Case                               |
| -------------- | -------------- | -------------- | ---------------- | ----------------------------------- | ----------------------------------------- | -------------------------------------- |
| **Collection** | Manager/Issuer | collection     | ""               | TokenCollection.collectionApprovals | MsgCreateCollection / MsgUpdateCollection | Global rules, freezability, compliance |
| **Outgoing**   | Sender         | outgoing       | bb1...           | UserBalanceStore.outgoingApprovals  | MsgUpdateUserApprovals                    | Listings, delegation                   |
| **Incoming**   | Recipient      | incoming       | bb1...           | UserBalanceStore.incomingApprovals  | MsgUpdateUserApprovals                    | Bids, access control                   |

</div>

Each transfer must satisfy collection-level AND (unless overridden) user-level approvals, while also having sufficient balances to transfer.

## Approval vs Permission vs Transfers

-   Approvals define the rules for transfers on multiple levels.
-   Transfers execute if the approval rules defined allow it and sufficient balances.
-   Permissions can control the updatability of approvals - `canUpdateCollectionApprovals`

### Transfer Validation Process

Each transfer must 1) have sufficient balances, 2) satisfy the collection approvals, and 3) satisfy the corresponding user-level approvals (unless overridden).

**Validation flow:**

<figure><img src="../.gitbook/assets/image (1) (1).png" alt=""><figcaption><p>Transfer validation flow</p></figcaption></figure>

## Collection Approvals

Collection approvals define transferability rules for the entire collection on a global level. These rules apply to both minting and post-minting transfers. These let the issuer / manager control global compliance and transferability, such as freezability, revocation, and more.

**All transfers must satisfy the collection approvals.**

**Important:** Approval IDs are unique identifiers and must not collide with other collection approvals.

```typescript
// Stored on TokenCollection.collectionApprovals[] (CollectionApproval<T>[])
interface CollectionApproval<T extends bigint> {
    // Core Fields - Define Who? When? What?
    toListId: string; // Who can receive?
    fromListId: string; // Who can send?
    initiatedByListId: string; // Who can initiate?
    transferTimes: UintRange<T>[]; // When can transfer happen?
    tokenIds: UintRange<T>[]; // Which token IDs?
    ownershipTimes: UintRange<T>[]; // Which ownership times?
    approvalId: string; // Unique identifier - must not collide with other approvals on the same level
    version: T; // Version control (incremented on each update)

    // Optional Fields
    uri?: string; // Metadata link
    customData?: string; // Custom data
    approvalCriteria?: ApprovalCriteria<T>; // Additional restrictions
}
```

### The Six Core Fields

Every approval defines **Who? When? What?** through these six core fields:

| Field               | Type                             | Purpose                                 | Example                                          |
| ------------------- | -------------------------------- | --------------------------------------- | ------------------------------------------------ |
| `toListId`          | Address List ID                  | Who can receive tokens                  | `"All"`, `"Mint"`, `"bb1..."`                    |
| `fromListId`        | Address List ID                  | Who can send tokens                     | `"Mint"`, `"!Mint"`                              |
| `initiatedByListId` | Address List ID                  | Who can initiate transfer               | `"All"`, `"bb1..."`                              |
| `transferTimes`     | UintRange\[] (UNIX Milliseconds) | When transfer can occur                 | `[{start: 1691931600000n, end: 1723554000000n}]` |
| `tokenIds`          | UintRange\[] (Token IDs)         | Which token IDs                         | `[{start: 1n, end: 100n}]`                       |
| `ownershipTimes`    | UintRange\[] (UNIX Milliseconds) | Which ownership times to be transferred | `[{start: 1n, end: 18446744073709551615n}]`      |

### Example Approval

```typescript
const mintApproval: CollectionApproval<bigint> = {
    fromListId: 'Mint',
    toListId: 'All',
    initiatedByListId: 'All',
    transferTimes: [{ start: 1691931600000n, end: 1723554000000n }],
    tokenIds: [{ start: 1n, end: 100n }],
    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
    approvalId: 'mint-to-all',
    version: 0n,
    approvalCriteria: {
        maxNumTransfers: {
            overallMaxNumTransfers: 1000n,
            perFromAddressMaxNumTransfers: 0n,
            perToAddressMaxNumTransfers: 0n,
            perInitiatedByAddressMaxNumTransfers: 1n,
            amountTrackerId: 'mint-to-all',
        },
        overridesFromOutgoingApprovals: true, // Required for Mint
        // ... other criteria
    },
};
```

**Translation:** Allow anyone to claim tokens 1-100 from the Mint address between Aug 13, 2023 and Aug 13, 2024.

### Approval Criteria

Approval criteria adds additional restrictions beyond basic approval matching. They are used to control who can transfer, when, how much, how often, and more. If criteria is not satisfied, the approval is not satisfied.

```typescript
interface ApprovalCriteria<T extends bigint> {
    // Transfer limits and amounts
    maxNumTransfers?: MaxNumTransfers<T>; // Limit number of transfers
    approvalAmounts?: ApprovalAmounts<T>; // Limit transfer amounts
    predeterminedBalances?: PredeterminedBalances<T>; // Exact balance requirements

    // Automatic actions
    coinTransfers?: CoinTransfer<T>[]; // Automatic coin transfers (BADGE or sdk.Coin)
    userRoyalties?: UserRoyalties<T>; // Percentage-based transfer fees

    // Challenge requirements
    merkleChallenges?: MerkleChallenge<T>[]; // Require merkle proofs
    mustOwnTokens?: MustOwnToken<T>[]; // Require owning specific tokens
    dynamicStoreChallenges?: DynamicStoreChallenge<T>[]; // On-chain numeric checks
    ethSignatureChallenges?: ETHSignatureChallenge<T>[]; // Ethereum signature requirements
    votingChallenges?: VotingChallenge<T>[]; // Require weighted quorum thresholds

    // Address relationship requirements
    requireToEqualsInitiatedBy?: boolean; // to == initiatedBy
    requireFromEqualsInitiatedBy?: boolean; // from == initiatedBy
    requireToDoesNotEqualInitiatedBy?: boolean; // to != initiatedBy
    requireFromDoesNotEqualInitiatedBy?: boolean; // from != initiatedBy

    // Address type checks
    senderChecks?: AddressChecks; // Address checks for sender
    recipientChecks?: AddressChecks; // Address checks for recipient
    initiatorChecks?: AddressChecks; // Address checks for initiator

    // Overrides (collection-level only)
    overridesFromOutgoingApprovals?: boolean; // Override sender approvals
    overridesToIncomingApprovals?: boolean; // Override recipient approvals

    // Time-based restrictions
    altTimeChecks?: AltTimeChecks; // Alternative time checks (offline hours/days)

    // Approval behavior
    autoDeletionOptions?: AutoDeletionOptions; // Auto-delete after use
    mustPrioritize?: boolean; // Require explicit prioritization

    // Special address flags (collection-level only)
    allowBackedMinting?: boolean; // Allow approval for IBC backed path operations
    allowSpecialWrapping?: boolean; // Allow approval for cosmos coin wrapper path operations
}
```

See [Approval Criteria](../token-standard/learn/approval-criteria/) for all available criteria.

## User-Level Approvals

Senders and recipients can configure user-level approvals that gate transfers. These follow the same structure as collection approvals (minus hardcoded sender/recipient logic respectively and no override logic). Sender approvals control who can send tokens on behalf of the user. Recipient approvals control who can send tokens to the user.

Stored on UserBalanceStore.outgoingApprovals[] (OutgoingApproval<T>[]) and UserBalanceStore.incomingApprovals[] (IncomingApproval<T>[]).

```typescript
interface UserBalanceStore<T extends bigint> {
    balances: Balance<T>[];
    outgoingApprovals: OutgoingApproval<T>[];
    incomingApprovals: IncomingApproval<T>[];
    autoApproveSelfInitiatedOutgoingTransfers: boolean;
    autoApproveSelfInitiatedIncomingTransfers: boolean;
    autoApproveAllIncomingTransfers: boolean;
    userPermissions: UserPermissions<T>;
    // ... other fields
}
```

#### Outgoing Approvals

Control who can send tokens on behalf of the user:

```typescript
const outgoingApproval: OutgoingApproval<bigint> = {
    // fromListId: 'bb1user...', // Locked to the user's address, not in interface
    toListId: 'bb1...', // Who can receive from this user
    initiatedByListId: 'bb1...', // Who can initiate the transfer
    transferTimes: [{ start: 1n, end: 18446744073709551615n }],
    tokenIds: [{ start: 1n, end: 18446744073709551615n }],
    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
    approvalId: 'my-listing',
    version: 0n,
    approvalCriteria: {
        // ... criteria fields
    },
};
```

#### Incoming Approvals

Control who can send tokens to the user:

```typescript
const incomingApproval: IncomingApproval<bigint> = {
    // toListId: 'bb1user...', // Locked to the user's address, not in interface
    fromListId: 'bb1...', // Who can send to this user
    initiatedByListId: 'bb1...', // Who can initiate the transfer
    transferTimes: [{ start: 1n, end: 18446744073709551615n }],
    tokenIds: [{ start: 1n, end: 18446744073709551615n }],
    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
    approvalId: 'my-bids',
    version: 0n,
    approvalCriteria: {
        // ... criteria fields
    },
};
```

### User-Level Auto-Approval Flags

We provide auto-approval flags to automatically approve transfers without requiring explicit approval matching. These flags are used for convenience and ease of use for user-level approval handling. Typically, we recommend leaving all the auto-approval flags set to true.

#### Auto-Approve Self-Initiated Outgoing Transfers

When `autoApproveSelfInitiatedOutgoingTransfers: true`, outgoing transfers initiated by the user are automatically approved without checking outgoing approvals.

**Use case:** Convenience for users who want to freely send tokens they own without managing outgoing approval configurations.

#### Auto-Approve Self-Initiated Incoming Transfers

When `autoApproveSelfInitiatedIncomingTransfers: true`, incoming transfers initiated by the user are automatically approved without checking incoming approvals.

**Use case:** Convenience for users who want to receive tokens they request (e.g., claiming, requesting airdrops) without managing incoming approval configurations.

#### Auto-Approve All Incoming Transfers

When `autoApproveAllIncomingTransfers: true`, **all** incoming transfers are automatically approved regardless of who initiates them.

**Use case:** Users who want to accept all incoming transfers without restrictions. Useful for open wallets or accounts that should receive tokens from anyone.

## Override Behavior

Collection approvals can override user-level approvals for administrative controls like freezing, revocation, or forced transfers. This is done via the `approvalCriteria` field and only available on the collection approval criteria interface.

If set to true, we do NOT check the corresponding user-level approvals for the sender and/or recipient.

```typescript
const collectionApproval: CollectionApproval<bigint> = {
    approvalCriteria: {
        overridesFromOutgoingApprovals: true, // Skip sender approvals
        overridesToIncomingApprovals: true, // Skip recipient approvals
        // ... other criteria
    },
    // ... other fields
};
```

#### Mint Address Overrides

Because the Mint address cannot control its own user-level approvals, it must always override the sender's outgoing approvals to properly work.

```typescript
const mintApproval: CollectionApproval<bigint> = {
    fromListId: 'Mint',
    // ... other fields
    approvalCriteria: {
        overridesFromOutgoingApprovals: true, // Required for Mint
        // ... other criteria
    },
};
```

#### When Overrides Apply

**Outgoing overrides:** When `overridesFromOutgoingApprovals: true`, the collection approval bypasses the sender's outgoing approvals. This enables:

-   Freezing tokens (prevent transfers regardless of user settings)
-   Forced revocation (remove tokens from users)
-   Administrative transfers (manager-controlled actions)

**Incoming overrides:** When `overridesToIncomingApprovals: true`, the collection approval bypasses the recipient's incoming approvals. This enables:

-   Forced transfers (send tokens even if recipient blocks them)
-   Administrative actions (manager-controlled distributions)

**Important:** Overrides are powerful and should be used carefully. They allow executing transfers that would otherwise be blocked by user settings.

If you want to setup your collection without any overrides, you can simply set the `invariants.noForcefulPostMintTransfers` to true. This will prevent any collection approvals from ever using override flags.

## Break-Down Logic

The system can break down transfers and approvals into partial matches to make transfers succeed. It deducts as much as possible from each approval as it iterates.

For proper design, you should try to design your approvals such that they never have to match to more than one. However, if needed, we break down the transfer and approvals as fine-grained as we can to make it succeed.

See [Auto-Scan and Prioritized Approvals](auto-scan-and-prioritized-approvals.md) for details on how the system selects approvals and how you can selectively prioritize approvals.


## File: ./other-modules/README.md

# üìö Overview

This section contains documentation for additional Cosmos SDK modules used in the BitBadges blockchain.

## Table of Contents

### x/gamm

The `x/gamm` module implements the Generalized Automated Market Maker (GAMM) functionality for the BitBadges blockchain.

* [üìö Overview](x-gamm/) - Module overview and key differences from Osmosis
* [üìñ Introduction](x-gamm/introduction.md) - Detailed introduction to GAMM concepts
* [üì® Messages](x-gamm/messages/) - Transaction messages and handlers
  * [MsgCreateBalancerPool](x-gamm/messages/msg-create-balancer-pool.md) - Create new balancer pool
  * [MsgExitPool](x-gamm/messages/msg-exit-pool.md) - Exit pool and receive tokens
  * [MsgJoinPool](x-gamm/messages/msg-join-pool.md) - Join existing pool with liquidity
  * [MsgSwapExactAmountIn](x-gamm/messages/msg-swap-exact-amount-in.md) - Swap exact amount of tokens in
  * [MsgSwapExactAmountInWithIBCTransfer](x-gamm/messages/msg-swap-exact-amount-in-with-ibc-transfer.md) - Swap and transfer via IBC

### x/custom-ibc-hooks

The Custom IBC Hooks module extends IBC transfer functionality by allowing users to execute custom actions automatically when receiving IBC tokens.

* [üìö Overview](x-custom-ibc-hooks/) - Module overview and key features
* [üìñ Introduction](x-custom-ibc-hooks/overview.md) - Architecture and usage details

### x/ibc-rate-limit

The IBC Rate Limit module provides rate limiting functionality for Inter-Blockchain Communication (IBC) token transfers.

* [üìö Overview](x-ibc-rate-limit/) - Module overview and key features
* [üìñ Introduction](x-ibc-rate-limit/overview.md) - Rate limiting concepts and configuration

### x/managersplitter

The Manager Splitter module provides a permissioned proxy system for managing token collections.

* [üìö Overview](x-managersplitter/) - Module overview and key features
* [üìñ Introduction](x-managersplitter/overview.md) - Permission system and use cases
* [üì® Messages](x-managersplitter/messages/) - Transaction messages and handlers
  * [MsgCreateManagerSplitter](x-managersplitter/messages/msg-create-manager-splitter.md) - Create a new manager splitter
  * [MsgDeleteManagerSplitter](x-managersplitter/messages/msg-delete-manager-splitter.md) - Delete a manager splitter
  * [MsgExecuteUniversalUpdateCollection](x-managersplitter/messages/msg-execute-universal-update-collection.md) - Execute collection updates through manager splitter
  * [MsgUpdateManagerSplitter](x-managersplitter/messages/msg-update-manager-splitter.md) - Update manager splitter permissions


## File: ./other-modules/x-custom-ibc-hooks/README.md

# üîó x/custom-ibc-hooks


## File: ./other-modules/x-gamm/README.md

# üíß x/gamm


## File: ./other-modules/x-ibc-rate-limit/README.md

# üö¶ x/ibc-rate-limit


## File: ./other-modules/x-managersplitter/README.md

# üë• x/managersplitter


## File: ./overview/badge.md

# ü™ô BADGE

BADGE is the native gas token for the BitBadges blockchain. Please read our policies (including our [BADGE disclosure](https://bitbadges.io/credits-disclosure)) on our site for full disclaimers and information.

<figure><img src="../.gitbook/assets/image (402).png" alt=""><figcaption></figcaption></figure>

BADGE has 3 primary purposes:

1. Gas / Transaction Fees
2. Proof of Stake/ Governance - Validators bonding BADGE for the security of the network via staking.
3. In-Site Currency - Although note that we will prioritize others like USDC and other more established ones for in-site use.
4. 0.1% Taker Fees on all transactions go to community pool

### **Distribution**

For current distributions, supply, and more, we refer you to our explorer: [https://explorer.bitbadges.io](https://explorer.bitbadges.io/).

Relevant addresses for undistributed BADGE are:

* bb1kx9532ujful8vgg2dht6k544ax4k9qzsp0sany
* bb1akp5qudlhyp08m4k6826hn8mhqwmely6xvr7t2

BADGE is listed on Osmosis at [https://app.osmosis.zone/assets/BADGE](https://app.osmosis.zone/assets/BADGE) and compatible with other IBC-enabled services.

Excluding block rewards, the initial circulating supply of BADGE was 100M.&#x20;

### **Alternative Chain Deployments**

BitBadges plans to pursue deploying our standard on other chains. BADGE also does not apply here. BADGE is the gas / governance token for the BitBadges blockchain only. Although when exploring agreements for deploying on other chains, we will strongly consider BADGE holders in any licensing agreement.

### **Security Model**

We do recognize that in the short term, BADGE is not worth enough to adequately secure a proof-of-stake network. That is why we adopt a short-term more centralized approach and will look to decentralize over time. Couple notes on our approach to this:

* In the short term, BitBadges still controls a large amount of the supply (>50%+) and operates on a more centralized governance at the moment, simply due to the fact that we have almost enough voting power to make any proposal pass.

In other words, treat BitBadges as much more of a proof of authority chain at the moment.


## File: ./overview/claim-builder/README.md

# üéÅ BitBadges Claims



## File: ./overview/comparing-bitbadges-to-other-protocols.md

# ‚öñÔ∏è BitBadges L1 vs Others

## Comparing BitBadges L1 to Other Protocols

BitBadges is a unique L1 (Layer 1) blockchain built using the Cosmos SDK. The BitBadges token standard is not EVM-compatible, ERC-20 compatible, or Bitcoin Ordinals compatible. Instead, we offer our own flexible, ever-evolving token standard built on Cosmos foundations.

While BitBadges may lack some of the native smart contract support and interoperability features of other protocols, its self-contained design and API-like token standard can be a compelling solution for certain use cases.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Chain Architecture

BitBadges is its own L1 blockchain, not a layer-2 or sidechain solution. It is built using the Cosmos SDK, which gives it flexibility and scalability. It also connects to the IBC ecosystem and all other Cosmos features.

### Security Model

Yes, BitBadges may not be as secure or decentralized (yet) as some other protocols. It is its own L1, and over time, we will only get more decentralized and secure. However, we actually envision BitBadges being a flexible part of any application stack and used where needed rather than an all encompassing solution.

For example, when building an application, you may use BitBadges for authentication / website gating but still accept payments in your native or preferred currency.

### Cross-Chain Interoperability

BitBadges leverages IBC to connect to other chains and use the BitBadges token standard on any Cosmos chain.

### Token Standard

BitBadges offers its own token standard built from the ground up that functions more like an API where everything is already implemented natively, and you just customize the requests (as Cosmos SDK Msgs) behind the scenes. This is how the BitBadges site is all no-code by default.

This approach vastly differs to existing ones requiring an individual smart contract for all tokens. Protocols like Ethereum rely on ERC-20 tokens, which require individual smart contract deployments and management. This approach gets complex, vulnerable to security flaws, and does not support the required structure.

### Smart Contract Support

While BitBadges does not natively support EVM or ERC-20 contracts, it does support CosmWASM contracts, allowing for the extension of functionality and the creation of dApps. However, our goal is to keep evolving our token standard so that no custom contracts are EVER needed.

Protocols like Ethereum and Solana have robust smart contract support, enabling a wide range of decentralized applications.


## File: ./overview/contributing.md

# üë®üíª Contributing

Everything is open-sourced and can be found at [https://github.com/bitbadges](https://github.com/bitbadges). Contributions to the core source code are greatly appreciated.&#x20;

Additionally, you can contribute by building on top of BitBadges. This can be anything from a dApp (decentralized application) to a developer tool to your own frontend for tokens! If you do, reach out to us, so we can add it to [Ecosystem](ecosystem.md).

**Rewarding Developers**

In the future, we plan to host hackathons, bug bounties, and setup a developer funding pool where developers are rewarded for contributing and building with BitBadges.

**Improvement Proposals**

The official BitBadges improvement proposals repository can be found at [https://github.com/BitBadges/BBIPs](https://github.com/BitBadges/BBIPs).&#x20;

**Bug Bounties**

TBD

Let us know if you have another idea and how we can help.


## File: ./overview/faq.md

# ‚ùì FAQ

### **Are smart contracts needed?**

No! One universal standard that can support any use case with no code, no smart contracts. It is all a Cosmos SDK module reused for any token type.

### **How is compliance checked every transfer?**

The `collectionApprovals` of each token collection are checked on every transfer. These define the collection-wide transferability rules. If a transfer does not satisfy a collection approval, it will fail. Thus, by implementing compliance on the collection / token level, this is enforced every transfer no matter the app that is implementing it.

### **Is BitBadges an L1 blockchain or an L2?**

BitBadges is its own Layer-1 blockchain built with Cosmos SDK.

### **Why the registry architecture over unique smart contracts for every collection?**

In the long run, we believe a reusable standard tested thousands of times will win over unique, vulnerable contracts. The registry approach also improves scalability, consistency, and standardization. Standardization wins.

### **Are tokens ERC-721 or ERC-20 or ERC-3643 compatible?**

No. While our token standard takes inspiration from existing standards like ERC-721, our token standard has its own properties and architecture. However, they are a superset of these standards (offer all the features these standards + 1000x more), so you can use them compatibly where needed.

### **Does BitBadges support extending with smart contracts?**

Yes, our token standard is a Cosmos module. While we aim for no smart contracts to ever be needed, you can definitely still call in to our module from EVM and CosmWASM environments. Or, extend our module to call into other environments.&#x20;

### **Pricing? Affiliates?**

BitBadges charges a 0.1% fee on the protocol level on all swaps and transfers. This works as follows:

-   For any x/badges transfers with IBC payments (coinTransfers), we charge in the IBC currency.
-   For any x/gamm swaps, we charge a 0.1% taker fee

Normal x/badges or IBC MsgSends or transfers do not charge a fee.

As for affiliates, you are free to build protocols to charge anything on top of that.

-   For x/badges, simply add another coin transfer to approvals (payout initiator 0.1% or somehting)
-   For x/gamm, we have an in-built affiliates field built into the protocol. If you use the BitBadges API, we will charge a 20% fee of affiliates, but on the protocol level, there is no such charge.


## File: ./overview/learn/badge-concepts/standards.md

# Standards

Collections can optionally implement a specific type of collection or standard. Standards define the expected format of the collection and help others to know how to interpret the details of the collection.

Standards can define the expected values and format of everything about a collection, such as its expected metadata format or the expected genesis conditions. If you implement a standard, it is your responsibility to follow the rules defined by the standard.

Choose the most appropriate standard(s) for your desired use case. You may choose to mix and match more than one as long as they are compatible.

**Example**

```
standards: ["non-fungible", "attendance-event", "No User Ownership"]
```

## List of Standards

1. "No User Ownership" standard - If the standards contains the standard "No User Ownership", then, user ownership is deemed unimportant and all user balances are to not be displayed. This means nothing about transferability, approvals, activity, and so on is displayed. This standard is used by collections where only the token metadata / permissions matter, such as an attestation to something. All tokens are expected to not have any recipient.



## File: ./overview/link-sharing.md

# ü§ù Brand Guidelines

Feel free to use BitBadges name and logo in your site as you see fit. If you have any questions or concerns about usage, please let us know. We are also happy to provide any other logos, images, or information you may need.

<figure><img src="../.gitbook/assets/image (61) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../.gitbook/assets/badge_logo.png" alt=""><figcaption></figcaption></figure>


## File: ./overview/official-links.md

# üîó Official Links and Resources

Below is a list of official links for socials and other platforms. Our preferred contact is Discord. This is not an exhaustive list. See the rest of the documentation for more information on specific subjects.

* [BitBadges App](https://bitbadges.io)
* [Explorer](https://explorer.bitbadges.io)

### Get Featured

* [Get Featured](https://tally.so/r/mBy2aR) - Explore Page

### Documentation

* [LLM .txt](../for-llms.txt) - Entire documentation dumped into one file

### Socials

* [Discord](https://discord.com/invite/TJMaEd9bar)
* [LinkedIn](https://linkedin.com/company/bitbadges)
* [Twitter](https://twitter.com/bitbadges_io)
* [Telegram](https://t.me/BitBadges)
* [GitHub](https://github.com/bitbadges)

### Integrations

* [Zapier](https://zapier.com/apps/bitbadges/integrations)

### API & SDK

* [NPM API / SDK Package](https://www.npmjs.com/package/bitbadgesjs-sdk) ([Docs](../for-developers/bitbadges-sdk/))
* [API Documentation](https://bitbadges.stoplight.io/docs/bitbadges) ([Docs](../for-developers/bitbadges-api/))

```bash
# Using npm
npm install bitbadgesjs-sdk

# Using pnpm
pnpm add bitbadgesjs-sdk

# Using bun
bun add bitbadgesjs-sdk
```



## File: ./overview/use-cases.md

# üé® Use Cases

BitBadges is a powerful platform that enables tokenization of virtually any asset, service, or concept. With its flexible protocol-level controls, multi-currency support, and extensive customization options, BitBadges supports a wide range of use cases across industries.

Beyond tokenization / RWAs, BitBadges is very powerful as a Swiss-Army knife module for development. If you think about it, any use case in crypto is a tokenization use case in one form or another. We provide any primitive you may need in our module for any use case, not just tokenization.

<figure><img src="../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

***

### Asset Tokenization

#### Compliant Tokenized Assets

Tokenize any asset with custom compliance checks enforced on every transfer at the protocol level. Works across liquidity pools, orderbooks, and any application. This ensures that all transfers meet your specific compliance requirements automatically, without relying on individual applications to enforce rules.

#### Real-World Assets

Tokenize physical assets like jewelry, art, collectibles, or any product that can be purchased with any IBC currency. Leverage our multi-currency support and permissioned IBC transfers to create a seamless experience for buyers and sellers across different blockchain networks.

#### Real Estate with License Verification

Tokenize real estate with property licenses verified on every transfer. Ensures only valid, licensed properties can be transferred, providing an additional layer of security and compliance for real estate transactions on-chain.

#### Compliant ICS20 Token Derivatives

Create compliant derivatives of existing ICS20 tokens (like USDC) that are backed 1:1 by the original asset but include custom compliance and transferability rules. For example, wrap USDC into a clUSDC derivative with custom rate limits, compliance checks, withdrawal restrictions, and other programmable constraints. This enables chains to use permissioned, compliant versions of standard tokens while maintaining full backing by the original asset. Perfect for creating siloed compliance environments where you need custom rules for specific use cases without modifying the underlying token standard.

### NFTs and Collectibles

#### Collectibles & Profile Pictures

Standard NFT collection mechanics with full transferability controls. Create collectibles and profile pictures with custom rarity and transfer rules. Perfect for digital art, gaming assets, and social media profile customization.

#### Gated NFTs & Quests

Mint NFTs and quests gated by criteria from 7000+ no-code apps. Email verification, Discord server membership, or any custom requirement can unlock access. This enables sophisticated access control without writing custom code.

#### Quest Rewards as NFTs

Reward quest completion with NFTs that have payouts attached. Use criteria-based approvals to gate quest rewards through 7000+ no-code apps. Ideal for gaming platforms, loyalty programs, and engagement campaigns.

### Soulbound Tokens

#### Soulbound Tokens

Non-transferable tokens for achievements, credentials, attestations, and proof of anything. Make the collection non-transferable to lock tokens to addresses. Perfect for representing permanent achievements, educational credentials, or identity verification that should never be transferred.

#### Compliance-as-a-Service

Integrate BitBadges as a modular compliance checking system alongside existing token standards like ERC-3643 or x/bank. While your token uses standard protocols, BitBadges provides sophisticated compliance verification by checking ownership of compliance tokens‚Äîincluding licenses, subscriptions, NFTs, badges, KYC credentials, address lists, and more. True on-chain compliance requires handling 20+ standardized components automatically.

### Subscriptions and Recurring Payments

#### Auto-Renewing Subscriptions

Create subscription tokens purchasable with any IBC currency that auto-renew via bots. Optional provider revocation capabilities for flexible cancellation policies. Enables seamless subscription management with automatic renewals and flexible cancellation options.

#### Payroll Automation

Develop complex payroll automation systems seamlessly with recurring payments. No-code setup with automated verification. Check if recipients are still employed with NFTs and custom criteria enforcement. Streamline payroll processes with blockchain-based verification and automation.

### Securities and Financial Instruments

#### Stocks with Accredited Investor KYC

Tokenize stocks with accredited investor KYC requirements enforced through custom transferability approvals. Only verified investors can receive securities, ensuring compliance with securities regulations automatically at the protocol level.

#### Freezable & Revocable Currencies

Tokenize currencies with issuer-controlled freezability and revocability features. Managers can freeze or revoke transfers when needed for compliance. Essential for regulated currencies, stablecoins, and financial instruments that require administrative oversight.

#### Bonds & CDs with Clawbacks

Tokenize bonds and certificates of deposit with clawback capabilities. Enables sophisticated financial instruments with built-in administrative controls for compliance and risk management.

### Time-Based Systems

#### Time-Vested Unlocks

Implement time-vested unlock mechanisms that gradually allocate tokens with time-dependent balances, approvals, and more. Perfect for employee stock options, token vesting schedules, and gradual reward distribution.

#### Time-Vested Escrows

Create escrow systems with time-based release conditions. Assets are held in custody until specific time requirements are met. Ideal for milestone-based payments, conditional releases, and time-gated transactions.

#### Expiring Access Tokens

Create authentication tokens, such as tickets, that expire using time-dependent balances. Perfect for temporary access credentials and session management. Enables time-limited access control for events, services, or digital resources.

#### Auto-Expiring Occupation Tokens

Create time-dependent occupation tokens for renting, bookings, or temporary ownership that automatically expire at specified times. Perfect for rental agreements, event tickets, and time-bound access. Ensures automatic expiration without manual intervention.

#### Rental Agreements

Establish time-dependent leases and rental agreements with custom terms of service using flexible approvals. All contracts, payments, and access rights are enforced on-chain with automatic expiration. Provides transparent, automated rental management on the blockchain.

### Legal and Compliance

#### Dispute Resolution & Clearing

Build dispute resolution or clearing protocols. Define the rules to hold, freeze, or reverse transactions. Enables sophisticated dispute management systems with programmable resolution logic.

#### Advanced Admin Controls

Enable advanced revocability and freezability features for administrators. Perfect for regulatory compliance or emergency asset protection. Provides powerful administrative tools for managing tokenized assets in regulated environments.

#### Intellectual Property Rights

Tokenize patents and IP rights with controlled licensing. Enforce IP ownership and licensing terms on every transfer. Ensures that intellectual property rights are properly managed and enforced throughout the token lifecycle.

### Business Operations

#### Refund & Return Policies

Implement receipt systems with automated return policies through custom transferability approvals. Enable seamless refunds with payouts on-chain. Streamlines e-commerce operations with automated refund processing.

#### Address Lists & Reputation

Maintain public address lists for scammers, compromised keys, and trusted entities. Enables reputation systems and security measures that can be referenced across applications and services.

### Key Features Across Use Cases

All BitBadges use cases benefit from:

* **Protocol-Level Enforcement**: Compliance and rules are enforced at the blockchain protocol level, not just in applications
* **Multi-Currency Support**: Accept payments in any IBC-compatible currency
* **Custom Transferability Controls**: Define exactly who can transfer tokens and under what conditions
* **Time-Dependence**: Create time-based logic for unlocks, expirations, and vesting
* **7000+ No-Code Integrations**: Gate access using existing services without writing custom code
* **On-Chain Verification**: All rules and compliance checks are verifiable on the blockchain
* **Flexible Approvals System**: Create complex approval workflows for transfers and operations


## File: ./overview/what-is-bitbadges.md

# ü™Ñ The BitBadges Standard

BitBadges is a project aiming to drive the adoption of Cosmos with one mission: **build the best tokenization standard ever seen and make it exclusively available as a Cosmos module.**

Cosmos sells software-as-a-service, but it is incomplete without offering a state-of-the-art solution for the main primitive of all of crypto (tokenization). The next 5 years are about advanced tokenization (e.g. Project Crypto) and tokenizing everything. What better way to onboard developers and institutions to Cosmos than offer a 1000x tokenization experience that is **Cosmos exclusive**? This is what BitBadges has built.

### Problems With Existing Token Standards

Existing tokenization standards (ERC/CW/ICS-20/721) are good for plenty of use cases, but the whole system is **flawed from the ground up**.

Existing standards are:

**Simple**: They lack the flexibility and feature set needed for 90% of real-world applications. Simple mint, transfer, and burn functionality is nowhere near enough. The industry has been stuck with these simple standards and no innovation for 10+ years due to technical debt. It is a mess.

**Vulnerable**: They are vulnerable by default due to the smart contract approach. Each token contract introduces a new attack vector and chance of vulnerability. We frankly find it crazy how much is spent on smart contract audits and security. The whole smart contract approach is flawed and not sustainable. It is broken from the foundation, and it has been that way for 10+ years with little done to fix it.

**Complex**: A simple contract requires extensive technical knowledge to implement.

**Expensive**: Contracts are expensive to deploy and maintain.

**Low Interoperability**: Interoperability of tokens has improved recently, and IBC is the leading example of this. However, there is still a lot of room for improvement. Companies want an all-in-one solution that works seamlessly with all infrastructure out of the box.

**Many Competing Standards**: There are many competing standards and products for tokenization. Each tokenization product adds its own little twists that are not compatible with other products. This creates fragmentation and confusion. We believe that there should be one universal standard that is the best solution for all use cases.

**And Much More**: I could go on and on, but the point stands: **the whole tokenization approach is broken from the foundation and NEEDS a complete overhaul.**

### The BitBadges Token Standard

To solve all of these problems, BitBadges has taken a ground-up approach to build a new universal token standard supported by our own Cosmos SDK blockchain. Our mission is to build the only token standard anyone will ever need with every possible use case supported natively. No smart contracts. No code. 1000x functionality. Exclusive to Cosmos.

Below, we outline a high-level overview of what BitBadges has built and how it compares to existing tokenization standards. We aim to not go into too low-level details and will do our best to explain all concepts; however, the protocol is incredibly feature-rich, and we may not explain everything as thoroughly as we would like. For the full details, please refer to the BitBadges site or documentation. We actually think the best way of learning all that we offer is our landing page and exploring the site, so we encourage you to check it out before reading below. We are also happy to answer any questions you have.

#### Universality

Our token standard is universal and feature-rich enough for any use case. It can not only be used for NFTs and fungible tokens, but also for subscriptions, quests, credentials, real-world assets, complex regulatory compliance, or anything you can think of. The problem with existing standards is they are too limited for 95% of real-world applications. One standard to rule them all.

#### No-Code / Module Approach

The BitBadges standard is no-code by default. It uses a Cosmos module approach to offer a seamless, developer-friendly API-like experience rather than complex smart contracts. As a result, you actually don't even need any technical knowledge to use our standard. Simply go to our site and start building! The native support is feature-rich enough that we envision that 99% of users will NEVER need to write any code, no matter how complex the use case. As it should be.

This promotes reusability and battle-testing the code, rather than potential vulnerabilities introduced per token contract. We strongly believe that over time, this approach will be proven to be the right approach.

#### Ever-Evolving

BitBadges is an ever-evolving standard. We are not making the same mistakes as ERC-20/721/etc. We are not stuck in the past. We are always on the bleeding edge of technology and will never be behind a trend. New feature idea? We will add it. It is purpose-built for the next-generation of tokenization.

#### IBC Compatibility

We are Cosmos through and through. Our plan is to be the tokenization launchpad for all of Cosmos with IBC at the core of everything.

1. Any token created is wrappable to ICS-20/721 format for use on any other IBC-enabled chain.
2. We can support payments via any IBC denomination (e.g. payments, subscriptions, etc). For example, an NFT / fungible token marketplace or subscription service with payments accepted via any IBC-enabled token.
3. Our module is IBC-enabled and core Msgs can be executed via IBC

For example, you could theoretically:

1. Create a token via our module
2. Wrap 20% of the supply to ICS-20 format
3. Send 10% to Osmosis
4. Send 10% to an EVM chain with IBC Eureka
5. Keep the remaining with time-dependent unlocks in our native module
6. Or any combination you can think of. That is the beauty of it.

Think of BitBadges as a layer above IBC. Tokens are launched on BitBadges for all the features that we offer, and then, they can be wrapped to IBC for interoperability and use with any IBC-enabled service.

#### Value-Add Mindset

BitBadges prioritizes unique value-add to Cosmos over everything else. We are not trying to reinvent the wheel or compete with existing ecosystem projects in Cosmos. We focus on bringing utility and enabling use cases not already out there. For features or services already available, we actually promote using them instead of us by wrapping them and sending them via IBC.

For example, while we could focus on building out a decentralized exchange with our standard, that is incredibly low value-add to Cosmos considering there are plenty of options already available via IBC.

#### Time-Dependent Accounting

We are the first and only token standard to support time-dependent accounting. This is a huge primitive needed to be able to support subscriptions, unlocks, or any other time-dependent functionality at scale. All token balances can be fractionalized down to the millisecond. Think of them like "ownership rights".

This enables use cases like:

-   Auto-expiring / renewing subscription tokens
-   Token unlocks
-   Token vesting

All without needing future transactions to update the balances.

Ex: Bob owns this token ID until next July when the subscription token auto-expires. At that point, the token is no longer owned by Bob.

**Featured Use Case: Subscriptions**:

BitBadges has an in-built standard using our tokenization protocol that leverages time-dependent accounting to implement no-code, recurring tokenized subscriptions. We use a bot-tipping system to handle the recurring payments and time-dependent ownership rights to handle the expiration of the subscription.

This could make Cosmos the premier subscription layer for all of crypto. Anyone can go to our site and in a few clicks create a no-code, auto-recurring, decentralized, peer-to-peer subscription paid using any IBC-enabled token.

#### Transferability Revamped

Probably the biggest innovation of the BitBadges standard is our revamped transferability and approvals system.

**Three Transferability Levels**:

1. **Collection-Level Transferability**: The issuer / manager defines overall rules for the collection. Can forcefully override user-level approvals if needed.
2. **Sender Approvals**: Each user can set rules for outgoing transfers (e.g. listings, etc).
3. **Recipient Approvals**: Each recipient can set rules for incoming transfers (e.g. bids, etc).

This allows for a lot of flexibility and control over the transferability of a token. Each transfer must 1) have sufficient balances from the sender, 2) satisfy the collection transferability, and 3) satisfy the user-level approvals (if not forcefuly overridden by the collection).

This is especially valuable for many real-world use cases that need that issuer control, such as KYC regulatory compliance, freezability, royalties, revokability, etc. Our standard allows you full control to configure whatever you need.

**Revamped On-Chain Approvals**:

Approvals are no longer a simple incremented counter that cannot exceed a threshold. Our approvals are incredibly flexible and powerful while being standardized.

Seamlessly define all the following on-chain for EVERY approval. Define the exact rules and stipulations, enabling complex and powerful transferability rules on the three levels (collection, sender, recipient). All in a standardized manner.

-   Who Can Transfer?
-   Who Can Receive?
-   Who Can Initiate?
-   Transfer Times?
-   Predetermined or Tallied Amounts?
-   How Many Transfers?
-   Revokable?
-   Freezable?
-   BADGE or other IBC transfers?
-   Royalties?
-   Ownership Times?
-   Recurring?
-   Non-Transferable?
-   Incrementing Token IDs?
-   Owns Other Tokens?
-   And plenty more...

**Off-Chain Approval Criteria: 7000+ Web2 Integrations**:

Additionally, BitBadges has an oracle-like system that allows letting a centralized service approve users dynamically by checking off-chain criteria and giving them signed codes to redeem on-chain. BitBadges runs its own criteria checking service that connects to 7000+ Web2 integrations in no-code through in-site plugins. This enables powerful use cases like:

-   Gating mints by Discord membership
-   Gating mints by X followers
-   Gating mints by email
-   Gating mints by checking your private off-chain data
-   Gating mints through claim codes or passwords
-   Gating approvals by AI agents
-   Building your own custom endpoints to check your own criteria
-   And anything else you can think of. We make it easy for anyone to add their own integration, custom plugin, or build their own criteria checking service. All the heavy on-chain hybrid work is done for you. You focus on your application-specific logic.

This is a huge tool for Web2 adoption and onboarding users to on-chain tokenization.

While BitBadges runs its own criteria checking service, anyone can spin up their own oracle-like service to check their own criteria and reduce this trust assumption on BitBadges. It is decentralized in nature.

#### Fine-Grained Permissions

Each token collection can have a manager that can execute administrative actions for full control over whatever is needed. This is a great tool to allow for more complex use cases where centralized control is needed with predefined checks and balances enforced on-chain, like regulatory compliance.

-   Updating the token metadata
-   Updating transferability
-   Archiving the collection
-   Deleting the collection
-   Adding more tokens to the collection
-   Pausing transfers
-   Volume throttling
-   And more...

#### Smart Contract Extendibility

While our approach is no-code by default, we do support CosmWASM for any custom applications or advanced logic. We also plan to support x/evm once it is ready. Our goal is to make it so that 100% of use cases are supported natively without ever needing to extend it. If something is missing, we will add it.


## File: ./token-standard/concepts/permissions/token-id-action-permissions.md

# Token ID Action Permissions



## File: ./token-standard/examples/approvals/README.md

# Approvals



## File: ./token-standard/integrating-the-module/README.md

# ‚õìÔ∏è Integrating The Module?



## File: ./token-standard/integrating-the-module/custom-extension-hooks.md

# Custom Extension Hooks

Within our module, we attempt to make it easy to extend with custom configurations if you are a chain developer. Oftentimes, you want to implement minor global invariants custom to your chain.

In your `app.go` , you can wire up custom code that is run at certain points no matter the collection. If you need to use the `ctx` field, you can. State is rolled back if anything fails.&#x20;

### Custom Approval Criteria Checkers

Custom approval criteria checkers add validation logic during approval processing. These are run along with checking our native approval criteria (every level - collection, incoming, outgoing).

#### Example: Require Specific Address

<pre class="language-go"><code class="lang-go">// Usage in app.go:
app.BadgesKeeper.RegisterCustomApprovalCriteriaChecker(func(approval *types.CollectionApproval) []approvalcriteria.ApprovalCriteriaChecker {
	if approval.ApprovalId == "special-approval" {
		return []approvalcriteria.ApprovalCriteriaChecker{
			NewRequireSpecificAddressChecker("bb1abc123..."),
		}
	}
	return nil
})

// Implementation
<strong>type RequireSpecificAddressChecker struct {
</strong>	requiredAddress string
}

func (c *RequireSpecificAddressChecker) Name() string {
	return "RequireSpecificAddressChecker"
}

func (c *RequireSpecificAddressChecker) Check(
	ctx sdk.Context,
	approval *types.CollectionApproval,
	collection *types.TokenCollection,
	to string,
	from string,
	initiator string,
	// ... other params
) (detErrMsg string, err error) {
	if initiator != c.requiredAddress {
		return "initiator must be " + c.requiredAddress,
			fmt.Errorf("initiator address mismatch")
	}
	return "", nil
}
</code></pre>

### Custom Global Transfer Checkers

Custom global transfer checkers run before `HandleTransfer()` and can reject transfers at a global level. Here, you have access to the balances for the transfer.&#x20;

#### Example: Require Specific Memo

```go
// Usage in app.go:
app.BadgesKeeper.RegisterCustomGlobalTransferChecker(func(
	ctx sdk.Context,
	from string,
	to string,
	initiatedBy string,
	collection *types.TokenCollection,
	transferBalances []*types.Balance,
	memo string,
) []badgesmodulekeeper.GlobalTransferChecker {
	if collection.CollectionId.String() == "1" {
		return []badgesmodulekeeper.GlobalTransferChecker{
			NewRequireSpecificMemoChecker("approved-transfer"),
		}
	}
	return nil
})

// Implementation
type RequireSpecificMemoChecker struct {
	requiredMemo string
}

func (c *RequireSpecificMemoChecker) Name() string {
	return "RequireSpecificMemoChecker"
}

func (c *RequireSpecificMemoChecker) Check(
	ctx sdk.Context,
	from string,
	to string,
	initiatedBy string,
	collection *types.TokenCollection,
	transferBalances []*types.Balance,
	memo string,
) (detErrMsg string, err error) {
	if memo != c.requiredMemo {
		return fmt.Sprintf("memo must be '%s'", c.requiredMemo),
			fmt.Errorf("memo mismatch")
	}
	return "", nil
}
```

### Custom Collection Verifiers

Custom collection verifiers run before collections are stored and can validate collection-level invariants.

#### Example: Require Specific Manager

```go
// Usage in app.go:
app.BadgesKeeper.RegisterCustomCollectionVerifier(
	NewRequireSpecificManagerVerifier("bb1..."),
)

// Implementation
type RequireSpecificManagerVerifier struct {
	requiredManager string
}

func (v *RequireSpecificManagerVerifier) Name() string {
	return "RequireSpecificManagerVerifier"
}

func (v *RequireSpecificManagerVerifier) VerifyCollection(ctx sdk.Context, collection *types.TokenCollection) error {
	currentManager := collection.GetManager(ctx.BlockTime().Unix())

	if currentManager != v.requiredManager {
		return fmt.Errorf("collection manager must be %s, got %s",
			v.requiredManager, currentManager)
	}

	return nil
}

```


## File: ./token-standard/integrating-the-module/support-multiple-standards.md

# Supporting Multiple Standards

To support multiple token standards, we recommend using a SendManager module with **alias denom routing**. It automatically routes transactions to the appropriate handler based on denomination prefixes.

For complete implementation details, see the [source code](https://github.com/BitBadges/bitbadgeschain). We recommend simply copying / importing the implementation and using it directly if all you need is x/badges and x/bank.

It is intended to be a drop-in replacement for the BankKeeper interface. Simply replace anywhere you call k.bankKeeper.SendCoins() with k.sendManagerKeeper.SendCoinsWithAliasRouting() (or whatever other functions you need) and get support for multiple token standards at once via dynamic routing.

```go
type SendManagerKeeper interface {
	SendCoinWithAliasRouting(ctx sdk.Context, fromAddressAcc sdk.AccAddress, toAddressAcc sdk.AccAddress, coin *sdk.Coin) error
	SendCoinsWithAliasRouting(ctx sdk.Context, fromAddressAcc sdk.AccAddress, toAddressAcc sdk.AccAddress, coins sdk.Coins) error
	FundCommunityPoolWithAliasRouting(ctx sdk.Context, fromAddressAcc sdk.AccAddress, coins sdk.Coins) error
	SpendFromCommunityPoolWithAliasRouting(ctx sdk.Context, toAddressAcc sdk.AccAddress, coins sdk.Coins) error
	SendCoinsFromModuleToAccountWithAliasRouting(ctx sdk.Context, moduleName string, toAddressAcc sdk.AccAddress, coins sdk.Coins) error
	SendCoinsFromAccountToModuleWithAliasRouting(ctx sdk.Context, fromAddressAcc sdk.AccAddress, moduleName string, coins sdk.Coins) error
	GetBalanceWithAliasRouting(ctx sdk.Context, address sdk.AccAddress, denom string) (sdk.Coin, error)
}
```

### How It Works

#### Pattern Matching

SendManager uses **prefix-based pattern matching** to route denoms. It checks each registered prefix against the denom and routes to the first matching handler:

```go
// Example: denom = "badgeslp:1:utoken"
func (k Keeper) getRouterForDenom(denom string) (types.AliasDenomRouter, bool) {
    // Check registered prefixes in order (e.g., ["badgeslp:", "badges:"])
    for _, prefix := range k.registeredPrefixes {
        // Does "badgeslp:1:utoken" start with "badgeslp:"? Yes!
        if strings.HasPrefix(denom, prefix) {
            // Return the router registered for this prefix
            return k.prefixToRouter[prefix], true
        }
    }
    // No prefix matched - will use bank keeper for standard coins
    return nil, false
}
```

**Examples**:

* `badgeslp:1:utoken` ‚Üí matches `badgeslp:` prefix ‚Üí routes to x/badges
* `uatom` ‚Üí no prefix match ‚Üí routes to x/bank (standard Cosmos SDK coin)

#### Alias Denoms

BitBadges format: `badgeslp:COLLECTION_ID:denom` (e.g., `badgeslp:1:utoken`). The integer amount converts to `Balances[]` via collection's `cosmosCoinWrapperPaths` field (where the conversion rate is defined). Note that this process has no wrapping involved. The conversion is simply an alias for the full `Balances[]` field for compatibility with other environments.

#### Auto-Scan Mode

All sends through SendManager use **auto-scan mode** (no prioritized approvals). The underlying transfer is executed via `MsgTransferTokens`:

```go
// From SendNativeTokensViaAliasDenom
msg := &badgestypes.MsgTransferTokens{
    Creator:      recipientAddress,
    CollectionId: collection.CollectionId,
    Transfers: []*badgestypes.Transfer{
        {
            From:        recipientAddress,
            ToAddresses: []string{toAddress},
            Balances:    balancesToTransfer,
            // Note: No PrioritizedApprovals field - uses auto-scan mode
        },
    },
}
badgesMsgServer.TransferTokens(ctx, msg)
```

#### User-Level Approvals

SendManager does **not** manage user-level approvals automatically. If they need to be handled, you must set them as needed elsewhere before / after calling SendManager. Note: All x/badges transfers require approvals to be satisfied on the collection, sender, and recipient level, where applicable.

This may be especially important for module addresses or special non-user addresses. They automatically inherit the defaults for the collection.

```go
// Example: Sometimes, you may need both pre and post approval updates to make stuff work and clean up.
preUpdateApprovalsMsg := &badgestypes.MsgUpdateUserApprovals{ ... }
badgesMsgServer.UpdateUserApprovals(ctx, preUpdateApprovalsMsg)

sendManagerKeeper.SendCoinsWithAliasRouting(ctx, from, to, coins)

postUpdateApprovalsMsg := &badgestypes.MsgUpdateUserApprovals{ ... }
badgesMsgServer.UpdateUserApprovals(ctx, postUpdateApprovalsMsg)
```

**Example: Setting approvals before sending (from `FundCommunityPoolViaAliasDenom`)**

For example, the community pool address (depending on the defaults) may not accept incoming approvals by default which is needed to transfer tokens to it in the x/badges module.

```go
func (k Keeper) FundCommunityPoolViaAliasDenom(
    ctx sdk.Context,
    fromAddress string,
    toAddress string,
    denom string,
    amount sdkmath.Uint,
) error {
    collection, err := k.ParseCollectionFromDenom(ctx, denom)
    if err != nil {
        return err
    }

    // Set auto-approvals for recipient to accept incoming transfers
    err = k.SetAllAutoApprovalFlagsForAddress(ctx, collection, toAddress)
    if err != nil {
        return err
    }

    // Now safe to send - recipient has auto-approvals set
    return k.SendNativeTokensViaAliasDenom(ctx, fromAddress, toAddress, denom, amount)
}

// SetAllAutoApprovalFlagsForAddress sets all auto-approval flags for an address
func (k Keeper) SetAllAutoApprovalFlagsForAddress(
    ctx sdk.Context,
    collection *badgestypes.TokenCollection,
    address string,
) error {
    badgesMsgServer := NewMsgServerImpl(k)
    updateApprovalsMsg := &badgestypes.MsgUpdateUserApprovals{
        Creator:                               address,
        CollectionId:                          collection.CollectionId,
        UpdateAutoApproveAllIncomingTransfers: true,
        AutoApproveAllIncomingTransfers:       true,
        UpdateAutoApproveSelfInitiatedOutgoingTransfers: true,
        AutoApproveSelfInitiatedOutgoingTransfers:       true,
        UpdateAutoApproveSelfInitiatedIncomingTransfers: true,
        AutoApproveSelfInitiatedIncomingTransfers:       true,
    }
    _, err := badgesMsgServer.UpdateUserApprovals(ctx, updateApprovalsMsg)
    return err
}
```

#### Routing Flow

```go
func (k Keeper) SendCoinsWithAliasRouting(ctx sdk.Context, from, to sdk.AccAddress, coins sdk.Coins) error {
    for _, coin := range coins {
        router, found := k.getRouterForDenom(coin.Denom)
        if found {
            // Alias denom - use custom router
            amountUint := sdkmath.NewUintFromBigInt(coin.Amount.BigInt())
            return router.SendNativeTokensViaAliasDenom(ctx, from.String(), to.String(), coin.Denom, amountUint)
        }
        // Standard coin - use bank keeper
        return k.bankKeeper.SendCoins(ctx, from, to, sdk.NewCoins(coin))
    }
}
```

### Usage

```go
// Sending - works for both standard coins ("uatom") and alias denoms ("badgeslp:1:utoken")
err := sendManagerKeeper.SendCoinsWithAliasRouting(ctx, from, to, coins)

// Querying - automatically routes to correct handler
balance, err := sendManagerKeeper.GetBalanceWithAliasRouting(ctx, address, denom)
```


## File: ./token-standard/learn/address-lists.md

# Address Lists

Address lists define collections of addresses for use in approval configurations (`fromListId`, `toListId`, `initiatedByListId`). They support reserved IDs, inline colon-separated lists, and user-created stored lists.

## Proto Definition

```protobuf
message AddressList {
  string listId = 1;
  repeated string addresses = 2;
  bool whitelist = 3;  // true = whitelist, false = blacklist
  string uri = 4;
  string customData = 5;
  string createdBy = 6;
}
```

## Matching Logic

```javascript
function checkAddress(address, addressList) {
    const found = addressList.addresses.includes(address);
    return addressList.whitelist ? found : !found;
}
```

* **Whitelist** (`whitelist: true`): Only listed addresses are included
* **Blacklist** (`whitelist: false`): All addresses except listed ones are included

## Reserved IDs

Dynamically generated, zero storage overhead.

| ID                    | Logic                                               | Description                            |
| --------------------- | --------------------------------------------------- | -------------------------------------- |
| `"Mint"`              | `{addresses: ["Mint"], whitelist: true}`            | Only Mint address                      |
| `"All"`               | `{addresses: [], whitelist: false}`                 | All addresses (including Mint)         |
| `"None"`              | `{addresses: [], whitelist: true}`                  | No addresses                           |
| `"AllWithout<addrs>"` | `{addresses: [addrs...], whitelist: false}`         | All except specified (colon-separated) |
| `"addr1:addr2:..."`   | `{addresses: [addr1, addr2, ...], whitelist: true}` | Inline whitelist                       |

## Mint Address Handling

The set of valid addresses includes any valid `bb1` address **and** `"Mint"` (a reserved address representing the collection's mint address).

**Important**: `"All"` includes the Mint address. When creating approvals, especially `fromListId`, be careful with Mint handling since the Mint address has unlimited balances.

```json
// Exclude Mint from senders (common pattern)
{
    "fromListId": "AllWithoutMint",  // All addresses except Mint
    "toListId": "All"
}

// Allow only Mint to send (minting only)
{
    "fromListId": "Mint",
    "toListId": "All"
}
```

## Inversion

Prefix with `!` to invert whitelist/blacklist behavior. **Only works with reserved IDs and inline lists, not user-created lists.** Supports parentheses too for syntax `!(...)`.

```javascript
'!All'; // Inverts All ‚Üí None behavior
'!bb1alice...:bb1bob...'; // Inverts inline list ‚Üí blacklist
'!(AllWithoutMint)'; // Inverts AllWithoutMint ‚Üí whitelist with only Mint
```

Formats: `"!listId"` (if listId doesn't end with `)`) or `"!(listId)"`.

## User-Created Lists

Created via `MsgCreateAddressLists`. **Immutable** once created. Referenced by the custom listId where needed. This approach is useful for large lists that are referenced multiple times to save on gas.

### ID Validation

* Alphanumeric only (`a-z`, `A-Z`, `0-9`)
* Cannot be empty
* Cannot start with `!`
* Cannot conflict with reserved IDs (`"All"`, `"Mint"`, `"None"`, `"AllWithout*"`)
* Must be unique

### Example

```json
{
    "listId": "vipMembers",
    "addresses": ["bb1alice...", "bb1bob...", "bb1charlie..."],
    "whitelist": true,
    "uri": "",
    "customData": "",
    "createdBy": "bb1manager..."
}
```

## Usage Examples

```json
// Universal access
{
    "fromListId": "AllWithoutMint",
    "toListId": "All",
    "initiatedByListId": "All"
}

// Restricted with inline list
{
    "fromListId": "bb1alice...:bb1bob...:bb1charlie...",
    "toListId": "AllWithoutMint:bb1blocked...",
    "initiatedByListId": "All"
}

// User-created list
{
    "fromListId": "vipMembers",
    "toListId": "!bb1banned...",  // Inversion works with inline lists
    "initiatedByListId": "All"
}
```

## Performance

* **Reserved IDs**: Zero storage, dynamic generation, minimal gas
* **Inline lists**: Zero storage, dynamic parsing, efficient for < 10 addresses
* **User-created**: On-chain storage, reusable short ID, efficient lookups, best for large/repeated lists


## File: ./token-standard/learn/approval-criteria/README.md

# Approval Criteria

Additional restrictions and conditions that determine whether a transfer is approved beyond the basic approval matching.

## Interface

```typescript
export interface iApprovalCriteria<T extends NumberType> {
    /** The BADGE or other sdk.Coin transfers to be executed upon every approval. */
    coinTransfers?: iCoinTransfer<T>[];
    /** The list of merkle challenges that need valid proofs to be approved. */
    merkleChallenges?: iMerkleChallenge<T>[];
    /** The list of must own tokens that need valid proofs to be approved. */
    mustOwnTokens?: iMustOwnToken<T>[];
    /** The predetermined balances for each transfer. These allow approvals to use predetermined balance amounts rather than an incrementing tally system. */
    predeterminedBalances?: iPredeterminedBalances<T>;
    /** The maximum approved amounts for this approval. */
    approvalAmounts?: iApprovalAmounts<T>;
    /** The max num transfers for this approval. */
    maxNumTransfers?: iMaxNumTransfers<T>;
    /** Whether the approval should be deleted after one use. */
    autoDeletionOptions?: iAutoDeletionOptions;
    /** Whether the to address must equal the initiatedBy address. */
    requireToEqualsInitiatedBy?: boolean;
    /** Whether the from address must equal the initiatedBy address. */
    requireFromEqualsInitiatedBy?: boolean;
    /** Whether the to address must not equal the initiatedBy address. */
    requireToDoesNotEqualInitiatedBy?: boolean;
    /** Whether the from address must not equal the initiatedBy address. */
    requireFromDoesNotEqualInitiatedBy?: boolean;
    /** Whether this approval overrides the from address's approved outgoing transfers. */
    overridesFromOutgoingApprovals?: boolean;
    /** Whether this approval overrides the to address's approved incoming transfers. */
    overridesToIncomingApprovals?: boolean;
    /** The royalties to apply to the transfer. */
    userRoyalties?: iUserRoyalties<T>;
    /** The list of dynamic store challenges that must pass for approval. Can check initiator, sender, recipient, or a hardcoded address. */
    dynamicStoreChallenges?: iDynamicStoreChallenge<T>[];
    /** The list of ETH signature challenges that require valid Ethereum signatures for approval. */
    ethSignatureChallenges?: iETHSignatureChallenge<T>[];
    /** The list of voting challenges that require weighted quorum thresholds to be met. */
    votingChallenges?: iVotingChallenge<T>[];
    /** Address checks for sender */
    senderChecks?: iAddressChecks;
    /** Address checks for recipient */
    recipientChecks?: iAddressChecks;
    /** Address checks for initiator */
    initiatorChecks?: iAddressChecks;
    /** Alternative time-based checks for approval denial (offline hours/days). */
    altTimeChecks?: iAltTimeChecks;
    /** Whether this approval must be prioritized during evaluation. */
    mustPrioritize?: boolean;
    /** Whether this approval can be used for IBC backed path operations (collection-level only). */
    allowBackedMinting?: boolean;
    /** Whether this approval can be used for cosmos coin wrapper path operations (collection-level only). */
    allowSpecialWrapping?: boolean;
}
```

## Core Components

* [**Approval Trackers**](approval-trackers.md) - Tracking transfer amounts and counts
* [**Tallied Approval Amounts**](tallied-approval-amounts.md) - Amount limits and thresholds
* [**Max Number of Transfers**](max-number-of-transfers.md) - Transfer count limits
* [**Predetermined Balances**](predetermined-balances.md) - Exact balance requirements
* [**Merkle Challenges**](merkle-challenges.md) - Cryptographic proof requirements
* [**Dynamic Store Challenges**](dynamic-store-challenges.md) - On-chain numeric checks
* [**ETH Signature Challenges**](eth-signature-challenges.md) - Ethereum signature requirements
* [**Voting Challenges**](voting-challenges.md) - Weighted quorum threshold requirements
* [**Token Ownership**](badge-ownership.md) - Required token holdings
* [**Cosmos Coin Transfers**](usdbadge-transfers.md) - Payments per approval (BADGE or other sdk.Coin)
* [**Overrides**](overrides.md) - Bypassing user-level approvals
* [**Requires**](requires.md) - Address relationship restrictions
* [**Address Checks**](address-checks.md) - Address type restrictions (WASM contracts, liquidity pools)
* [**Auto-Deletion Options**](auto-deletion-options.md) - Automatic approval cleanup
* [**User Royalties**](user-royalties.md) - Percentage-based transfer fees
* [**Alt Time Checks**](../../../x-badges/concepts/approval-criteria/alt-time-checks.md) - Time-based restrictions (offline hours/days)
* [**Must Prioritize**](../../../x-badges/concepts/approval-criteria/must-prioritize.md) - Requiring explicit approval prioritization
* [**Special Address Flags**](special-address-flags.md) - Control approval eligibility for backed minting and special wrapping (collection-level only)

## Key Concepts

### Tracker IDs

Trackers use IDs with format: `approvalId-trackerId` plus identifying details. All trackers are scoped to a specific `approvalId`.

**Important**: Trackers are increment-only and immutable. Never reuse tracker IDs with prior history.

### Best Practices - Creating / Updating / Deleting

Trackers are increment-only and immutable. Never reuse tracker IDs with prior history when creating approvals that should start from scratch.


## File: ./token-standard/learn/approval-criteria/address-checks.md

# Address Checks

Additional restrictions on address types for transfer approval. These checks validate whether addresses involved in a transfer meet specific requirements (e.g., must be a WASM contract, must not be a liquidity pool).

## Interface

```typescript
interface AddressChecks {
    /** Require the address to be a WASM contract. */
    mustBeWasmContract?: boolean;
    /** Require the address to not be a WASM contract. */
    mustNotBeWasmContract?: boolean;
    /** Require the address to be a liquidity pool. */
    mustBeLiquidityPool?: boolean;
    /** Require the address to not be a liquidity pool. */
    mustNotBeLiquidityPool?: boolean;
}
```

## How It Works

Address checks validate the type of addresses involved in a transfer. The checks are applied to different parties depending on the approval type:

### Collection Approvals

Collection approvals can check all three parties:

-   **`senderChecks`**: Validates the sender address (`from`)
-   **`recipientChecks`**: Validates the recipient address (`to`)
-   **`initiatorChecks`**: Validates the initiator address (`initiatedBy`)

### Incoming Approvals

Incoming approvals can check the sender and initiator (but not the recipient, since the recipient is always the approval owner):

-   **`senderChecks`**: Validates the sender address (`from`)
-   **`initiatorChecks`**: Validates the initiator address (`initiatedBy`)

### Outgoing Approvals

Outgoing approvals can check the recipient and initiator (but not the sender, since the sender is always the approval owner):

-   **`recipientChecks`**: Validates the recipient address (`to`)
-   **`initiatorChecks`**: Validates the initiator address (`initiatedBy`)

## Available Checks

### WASM Contract Checks

-   **`mustBeWasmContract`**: Requires the address to be a CosmWASM smart contract
-   **`mustNotBeWasmContract`**: Requires the address to NOT be a CosmWASM smart contract

### Liquidity Pool Checks

-   **`mustBeLiquidityPool`**: Requires the address to be a liquidity pool
-   **`mustNotBeLiquidityPool`**: Requires the address to NOT be a liquidity pool

## Examples

### Collection Approval: Require Contract Recipients

Only allow transfers to WASM contracts:

```json
{
    "approvalCriteria": {
        "recipientChecks": {
            "mustBeWasmContract": true
        }
    }
}
```

### Collection Approval: Block Liquidity Pool Senders

Prevent transfers from liquidity pools:

```json
{
    "approvalCriteria": {
        "senderChecks": {
            "mustNotBeLiquidityPool": true
        }
    }
}
```

### Incoming Approval: Require Contract Initiators

Only allow transfers initiated by WASM contracts:

```json
{
    "approvalCriteria": {
        "initiatorChecks": {
            "mustBeWasmContract": true
        }
    }
}
```

### Outgoing Approval: Block Liquidity Pool Recipients

Prevent sending tokens to liquidity pools:

```json
{
    "approvalCriteria": {
        "recipientChecks": {
            "mustNotBeLiquidityPool": true
        }
    }
}
```

### Combined Checks

You can combine multiple checks for a single party:

```json
{
    "approvalCriteria": {
        "recipientChecks": {
            "mustBeWasmContract": true,
            "mustNotBeLiquidityPool": true
        },
        "initiatorChecks": {
            "mustNotBeWasmContract": true
        }
    }
}
```

## Use Cases

-   **Smart Contract Integration**: Require transfers to/from specific contract types
-   **Liquidity Protection**: Prevent transfers to/from liquidity pools to maintain token economics
-   **Security**: Enforce that certain operations can only be initiated by contracts or regular addresses
-   **Protocol Compliance**: Ensure transfers comply with protocol-specific address requirements

## Constraints

All checks are evaluated after the address lists (`toList`, `fromList`, `initiatedByList`) are matched. An address must first be in the appropriate list, then pass the address checks.


## File: ./token-standard/learn/approval-criteria/approval-trackers.md

# Approval Trackers

Track transfer amounts and counts using increment-only tallies with thresholds.

## How It Works

Trackers use an incrementing tally system with thresholds:

1. **Setup**: Approved for x10 of token IDs 1-10 with tracker ID "xyz"
2. **Transfer x5**: Tracker "xyz" goes from 0/10 ‚Üí 5/10
3. **Transfer x5**: Tracker "xyz" goes to 10/10
4. **Transfer x1**: Exceeds threshold, transfer fails

## Tracker Identification

Tracker IDs include multiple components:

```
ID: collectionId-approvalLevel-approverAddress-approvalId-amountTrackerId-trackerType-approvedAddress
```

### Tracker ID Details Interface

```typescript
interface ApprovalTrackerIdDetails<T extends NumberType> {
    collectionId: T;
    approvalLevel: 'collection' | 'incoming' | 'outgoing' | '';
    approvalId: string;
    approverAddress: string;
    amountTrackerId: string;
    trackerType: 'overall' | 'to' | 'from' | 'initiatedBy' | '';
    approvedAddress: string;
}
```

### Component Breakdown

-   **collectionId**: The collection this tracker belongs to
-   **approvalLevel**: Level of approval ("collection", "incoming", "outgoing", or empty)
-   **approvalId**: Unique identifier for the specific approval
-   **approverAddress**: Address of the approver (empty for collection-level)
-   **amountTrackerId**: User-defined tracker identifier specified in approvalAmounts or maxNumTransfers (see below)
-   **trackerType**: Type of tracking ("overall", "to", "from", "initiatedBy", or empty)
-   **approvedAddress**: Specific address being tracked (empty for "overall")

```typescript
interface iApprovalAmounts<T extends NumberType> {
    amountTrackerId: string; // Key for tracking tallies
}

interface iMaxNumTransfers<T extends NumberType> {
    amountTrackerId: string; // Key for tracking tallies
}
```

### Tracker Types

-   **"overall"**: Universal tally for any transfer (approvedAddress empty)
-   **"to"**: Per-recipient tally (approvedAddress = recipient)
-   **"from"**: Per-sender tally (approvedAddress = sender)
-   **"initiatedBy"**: Per-initiator tally (approvedAddress = initiator)

## Increment Only and Immutable

Trackers are increment only and immutable in storage. To start an approval tally from scratch, you will need to map the approval to a new unused tracker ID. This can be done simply by editing `amountTrackerId` (because this changes the whole ID) or restructuring to change one of the other fields that make up the overall ID.

**IMPORTANT**: Because of the immutable nature, be careful to not revert to a previously used ID unintentionally because the starting point will be the previous tally (not starting from scratch).

## As-Needed Basis

Only increment when necessary (e.g., if no amount restrictions, don't track amounts). Meaning, if there is no need to increment the tally (unlimited limit and/or not restrictions), we do not increment for efficiency purposes. For example, if we only have requirements for numTransfers but do not need the amounts, we do not increment the amounts.

### Example Tracker States

```json
{
    "fullTrackerId1": {
        "numTransfers": 5,
        "amounts": [
            {
                "amount": 50,
                "tokenIds": [{ "start": 1, "end": 10 }],
                "ownershipTimes": [{ "start": 1, "end": 100000000000 }]
            }
        ],
        "lastUpdatedAt": 1691978400000
    },
    "fullTrackerId2": {
        "numTransfers": 3,
        "amounts": [
            {
                "amount": 15,
                "tokenIds": [{ "start": 1, "end": 5 }],
                "ownershipTimes": [{ "start": 1, "end": 100000000000 }]
            }
        ],
        "lastUpdatedAt": 1691978400000
    }
}
```

## Periodic Resets

Trackers support periodic resets to zero using time intervals.

Leave the values at 0 to disable periodic resets.

```typescript
interface ResetTimeIntervals<T extends NumberType> {
    startTime: T; // Original start time of the first interval
    intervalLength: T; // Interval length in unix milliseconds
}
```

### How It Works

-   **First Update**: If it's the first update of the interval, all tracker progress is reset to zero
-   **Recurring**: Useful for recurring subscriptions (e.g., one transfer per month)
-   **No Reset**: Set both values to 0 for no periodic resets

### Example

```json
{
    "approvalAmounts": {
        "overallApprovalAmount": "100",
        "amountTrackerId": "monthly-tracker",
        "resetTimeIntervals": {
            "startTime": "1691978400000", // Aug 13, 2023
            "intervalLength": "2592000000" // 30 days in milliseconds
        }
    }
}
```

This creates a monthly reset cycle starting from August 13, 2023.


## File: ./token-standard/learn/approval-criteria/auto-deletion-options.md

# Auto-Deletion Options

Automatically delete approvals after specific conditions are met.

## Interface

```typescript
interface AutoDeletionOptions {
    afterOneUse: boolean;
    afterOverallMaxNumTransfers: boolean;
    allowCounterpartyPurge?: boolean;
    allowPurgeIfExpired?: boolean;
}
```

## How It Works

Auto-deletion options allow approvals to be automatically removed when certain conditions are met:

-   **`afterOneUse`**: Delete the approval after it's used once
-   **`afterOverallMaxNumTransfers`**: Delete the approval after the overall max number of transfers threshold is met
-   **`allowCounterpartyPurge`**: If true, allows the counterparty (the only initiator in `initiatedByList`, must be a whitelist with exactly one address) to purge the approval, even if they are not the owner. This may be used for like a rejection of the approval.
-   **`allowPurgeIfExpired`**: If true, allows others (in addition to the approval owner) to purge expired approvals on the owner's behalf. This may be used for a cleanup-like system.

## Usage Examples

### Single-Use Approval

```json
{
    "autoDeletionOptions": {
        "afterOneUse": true,
        "afterOverallMaxNumTransfers": false
    }
}
```

**Result**: Approval is deleted immediately after the first transfer.

### Limited-Use Approval

```json
{
    "maxNumTransfers": {
        "overallMaxNumTransfers": "10"
    },
    "autoDeletionOptions": {
        "afterOneUse": false,
        "afterOverallMaxNumTransfers": true
    }
}
```

**Result**: Approval is deleted after 10 transfers are completed.

### Allow Counterparty Purge

```json
{
    "autoDeletionOptions": {
        "afterOneUse": false,
        "afterOverallMaxNumTransfers": false,
        "allowCounterpartyPurge": true
    }
}
```

**Result**: The counterparty (if they are the only initiator in a whitelist) can purge this approval, even if not the owner.

### Allow Others to Purge Expired Approvals

```json
{
    "autoDeletionOptions": {
        "afterOneUse": false,
        "afterOverallMaxNumTransfers": false,
        "allowPurgeIfExpired": true
    }
}
```

**Result**: Any user can purge this approval if it is expired (no future valid transfer times), not just the owner.


## File: ./token-standard/learn/approval-criteria/badge-ownership.md

# Token Ownership

Require specific token holdings from the initiator as a prerequisite for transfer approval. This approval criteria checks on-chain balances to ensure users own required tokens before allowing transfers.

## Overview

Token ownership requirements enable gating mechanisms where users must possess specific tokens to access certain transfers. This creates dependency relationships between collections and enables sophisticated access control systems.

**Key Benefits**:

-   **Access Control**: Gate transfers based on token ownership
-   **Collection Dependencies**: Create relationships between different collections
-   **On-Chain Verification**: Automatic balance checking without external data
-   **Flexible Requirements**: Support for amount ranges, time-based ownership, and multiple token types

## Interface

```typescript
interface MustOwnTokens<T extends NumberType> {
    collectionId: T;
    amountRange: UintRange<T>; // Min/max amount expected
    ownershipTimes: UintRange<T>[];
    tokenIds: UintRange<T>[];

    overrideWithCurrentTime: boolean; // Use current block time. Overrides ownershipTimes with [{ start: currentTime, end: currentTime }]
    mustSatisfyForAllAssets: boolean; // All vs one requirement
    ownershipCheckParty: string; // Which party to check ownership for: "initiator", "sender", "recipient", or a hardcoded bb1 address (default: "initiator" if empty)
}
```

## Field Descriptions

### collectionId

-   **Type**: `T` (NumberType)
-   **Description**: The ID of the collection containing the required tokens
-   **Example**: `"1"` for collection ID 1

### amountRange

-   **Type**: `UintRange<T>`
-   **Description**: Minimum and maximum amount of tokens the user must own
-   **Format**: `{ start: "minAmount", end: "maxAmount" }`
-   **Example**: `{ start: "1", end: "10" }` requires 1-10 tokens (amounts)

### ownershipTimes

-   **Type**: `UintRange<T>[]`
-   **Description**: Time ranges when the user must have owned the tokens (UNIX milliseconds)
-   **Example**: `[{ start: "1691931600000", end: "1723554000000" }]` for Aug 13, 2023 - Aug 13, 2024

### tokenIds

-   **Type**: `UintRange<T>[]`
-   **Description**: Specific token IDs that must be owned
-   **Example**: `[{ start: "1", end: "100" }]` for token IDs 1-100

### overrideWithCurrentTime

-   **Type**: `boolean`
-   **Description**: When true, ignores `ownershipTimes` and uses current block time
-   **Behavior**: Sets ownership time to `[{ start: currentTime, end: currentTime }]`
-   **Use Case**: Require current ownership only, not historical ownership

### mustSatisfyForAllAssets

-   **Type**: `boolean`
-   **Description**: Controls whether all specified token requirements must be met or just one
-   **True**: User must own ALL specified token combinations
-   **False**: User must own AT LEAST ONE of the specified token combinations

### ownershipCheckParty

-   **Type**: `string`
-   **Description**: Specifies which party of the transfer to check ownership for
-   **Options**:
    -   `"initiator"` (default): Check ownership for the address that initiated the transfer
    -   `"sender"`: Check ownership for the address sending the tokens
    -   `"recipient"`: Check ownership for the address receiving the tokens
    -   Hardcoded bb1 address (e.g., `"bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls"`): Check ownership for a specific address, regardless of transfer parties
-   **Default**: `"initiator"` (if empty or not specified)
-   **Example**: `"sender"` to require the sender to own specific tokens before allowing the transfer
-   **Hardcoded Address Example**: `"bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls"` to require a specific address to own tokens (useful for multi-sig or contract-based checks)

## Example

Require users to own specific tokens to access premium features or exclusive transfers.

```json
{
    "mustOwnTokens": [
        {
            "collectionId": "1",
            "amountRange": { "start": "1", "end": "1" },
            "ownershipTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "tokenIds": [{ "start": "1", "end": "1" }],
            "overrideWithCurrentTime": false,
            "mustSatisfyForAllAssets": true,
            "ownershipCheckParty": "initiator"
        }
    ]
}
```

### Party-Specific Examples

#### Check Initiator Ownership (Default)

```json
{
    "mustOwnTokens": [
        {
            "collectionId": "1",
            "amountRange": { "start": "1", "end": "1" },
            "tokenIds": [{ "start": "1", "end": "1" }],
            "ownershipCheckParty": "initiator"
        }
    ]
}
```

#### Check Sender Ownership

```json
{
    "mustOwnTokens": [
        {
            "collectionId": "1",
            "amountRange": { "start": "1", "end": "1" },
            "tokenIds": [{ "start": "1", "end": "1" }],
            "ownershipCheckParty": "sender"
        }
    ]
}
```

#### Check Recipient Ownership

```json
{
    "mustOwnTokens": [
        {
            "collectionId": "1",
            "amountRange": { "start": "1", "end": "1" },
            "tokenIds": [{ "start": "1", "end": "1" }],
            "ownershipCheckParty": "recipient"
        }
    ]
}
```

#### Check Hardcoded Address Ownership

You can also specify a hardcoded bb1 address to check ownership for a specific address, regardless of who is involved in the transfer. This is useful for multi-sig wallets, contract addresses, or other scenarios where you need to verify ownership for a specific address.

```json
{
    "mustOwnTokens": [
        {
            "collectionId": "1",
            "amountRange": { "start": "1", "end": "1" },
            "tokenIds": [{ "start": "1", "end": "1" }],
            "ownershipCheckParty": "bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls"
        }
    ]
}
```

This example requires the address `bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls` to own the specified tokens, regardless of who initiates, sends, or receives the transfer.


## File: ./token-standard/learn/approval-criteria/dynamic-store-challenges.md

# Dynamic Store Challenges

Require specified parties (initiator, sender, recipient, or a hardcoded address) to pass checks against dynamic stores. Typically, these are used in combination with smart contracts or other custom extensions.

Dynamic stores are standalone (address -> boolean) stores controlled by whoever creates them. They are stored and maintained by the creator. These are powerful for creating dynamic approval criteria with smart contracts and other custom use cases liek global kill switches.

## How It Works

Dynamic store challenges check if a specified party has a value of `true` in specified dynamic stores. The system:

1. **Checks Global Kill Switch**: First checks if the dynamic store's `globalEnabled` field is `true`. If `globalEnabled = false`, the approval fails immediately with error: "dynamic store storeId {id} is globally disabled"
2. **Determines Check Party**: Determines which address to check based on the `ownershipCheckParty` field (defaults to "initiator" if not specified)
3. **Looks Up Address**: If the store is globally enabled, looks up the specified party's address in the dynamic store
4. **Evaluates Boolean**: Returns the boolean value for that address (or `defaultValue` if not set)
5. **Requires All True**: All challenges must return `true` for approval
6. **Fails if Any False**: If any challenge returns `false`, transfer is denied

## Interface

```typescript
interface DynamicStoreChallenge {
    storeId: string; // Dynamic store ID to check
    ownershipCheckParty?: string; // Which party to check: "initiator", "sender", "recipient", or a hardcoded bb1 address (default: "initiator")
}
```

## Usage in Approval Criteria

```json
{
    "dynamicStoreChallenges": [
        { "storeId": "1", "ownershipCheckParty": "initiator" }, // Member store (must be true for initiator, default)
        { "storeId": "2", "ownershipCheckParty": "sender" } // Subscription store (must be true for sender)
    ]
}
```

## Field Descriptions

### storeId

-   **Type**: `string`
-   **Description**: The ID of the dynamic store to check
-   **Required**: Yes
-   **Example**: `"1"` for store ID 1

### ownershipCheckParty

-   **Type**: `string` (optional)
-   **Description**: Specifies which party of the transfer to check the dynamic store value for
-   **Options**:
    -   `"initiator"` (default): Check the dynamic store value for the address that initiated the transfer
    -   `"sender"`: Check the dynamic store value for the address sending the tokens
    -   `"recipient"`: Check the dynamic store value for the address receiving the tokens
    -   Hardcoded bb1 address (e.g., `"bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls"`): Check the dynamic store value for a specific address, regardless of transfer parties
-   **Default**: `"initiator"` (if empty or not specified)
-   **Example**: `"sender"` to require the sender to have `true` in the dynamic store before allowing the transfer
-   **Hardcoded Address Example**: `"bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls"` to require a specific address to have `true` in the store (useful for multi-sig or contract-based checks)

## Global Kill Switch

Each dynamic store has a `globalEnabled` field that acts as a global kill switch. When `globalEnabled = false`, **all approvals** using that store via `DynamicStoreChallenge` will fail immediately, regardless of per-address values.

This is useful for quickly halting all approvals that depend on a specific dynamic store (e.g., if a protocol is compromised and needs to be disabled immediately).

### Behavior

-   **New stores**: `globalEnabled` defaults to `true` (enabled by default)
-   **Existing stores**: All existing stores are set to `globalEnabled = true` for backward compatibility
-   **Disabling**: Set `globalEnabled = false` via [MsgUpdateDynamicStore](../../../x-badges/messages/msg-update-dynamic-store.md) to halt all dependent approvals
-   **Re-enabling**: Set `globalEnabled = true` to restore normal operation

### Usage Example

```json
// Disable all approvals using store "1"
{
    "creator": "bb1...",
    "storeId": "1",
    "defaultValue": true,  // Must pass current value
    "globalEnabled": false  // Disable kill switch
}

// Re-enable when ready
{
    "creator": "bb1...",
    "storeId": "1",
    "defaultValue": true,
    "globalEnabled": true  // Re-enable
}
```

## Managing Dynamic Stores

### Creating Stores

Use [MsgCreateDynamicStore](../../../x-badges/messages/msg-create-dynamic-store.md) to create new dynamic stores with a default boolean value. New stores are created with `globalEnabled = true` by default.

### Updating Stores

Use [MsgUpdateDynamicStore](../../../x-badges/messages/msg-update-dynamic-store.md) to update the store's `defaultValue`, `globalEnabled`, `uri`, and `customData` fields. The `uri` and `customData` fields allow storing additional metadata and arbitrary data associated with the store.

### Setting Values

Use [MsgSetDynamicStoreValue](../../../x-badges/messages/msg-set-dynamic-store-value.md) to set boolean values for specific addresses.

### Querying Values

Use [GetDynamicStoreValue](../../../x-badges/queries/get-dynamic-store-value.md) to check current values for addresses.

Use [GetDynamicStore](../../../x-badges/queries/get-dynamic-store.md) to retrieve the store's configuration, including `globalEnabled` status, `uri`, and `customData` fields.

## Alternatives

For fully off-chain solutions, consider:

-   [Merkle Challenges](merkle-challenges.md) to save gas costs
-   [ETH Signature Challenges](eth-signature-challenges.md) for direct authorization


## File: ./token-standard/learn/approval-criteria/eth-signature-challenges.md

# ETH Signature Challenges

ETH Signature Challenges are a type of approval criteria that require users to provide valid Ethereum signatures from a predetermined signer to complete transfers. The signer approves the transfer by signing a message that contains the nonce and contextual information about the transfer. This feature allows for secure, on-chain verification of off-chain authorization without the complexity of Merkle trees.

## Overview

ETH Signature Challenges work by requiring users to provide Ethereum signatures that prove they have authorization from specific Ethereum addresses. Each signature can only be used once, preventing replay attacks and ensuring the security of the approval system.

## How It Works

### Signature Scheme

The signature scheme follows the pattern:

```
ETHSign(nonce + "-" + initiatorAddress + "-" + collectionId + "-" + approverAddress + "-" + approvalLevel + "-" + approvalId + "-" + challengeId)
```

Where:

-   `nonce`: A unique identifier provided by the user
-   `initiatorAddress`: The address initiating the transfer
-   `collectionId`: The ID of the collection being transferred
-   `approverAddress`: The address that needs to approve the transfer
-   `approvalLevel`: The approval level (e.g., "initial", "update")
-   `approvalId`: The ID of the approval being checked
-   `challengeId`: The challenge tracker ID
-   `-`: Literal dash characters separating the values

This comprehensive signature format ensures that signatures are bound to specific transfer contexts, preventing signature reuse across different transfers, collections, or approval scenarios.

### Challenge Structure

Each ETH Signature Challenge contains:

-   `signer`: The Ethereum address that must sign the challenge
-   `challengeTrackerId`: Unique identifier for tracking used signatures
-   `uri`: Optional metadata URI
-   `customData`: Optional custom data

### Proof Structure

Users provide ETH Signature Proofs containing:

-   `nonce`: The nonce that was signed (this is the only user-provided value in the signature message)
-   `signature`: The Ethereum signature of the full message string

## Key Features

### One-Time Use Signatures

Each signature can only be used once per challenge tracker. This prevents:

-   Replay attacks
-   Double-spending of approvals
-   Unauthorized reuse of signatures

The signature tracking is scoped to the combination of:

-   Collection ID
-   Approver address
-   Approval level
-   Approval ID
-   Challenge tracker ID
-   The signature itself

### Multiple Signers

You can require signatures from multiple Ethereum addresses in a single approval:

```json
{
    "ethSignatureChallenges": [
        {
            "signer": "0x1234567890123456789012345678901234567890",
            "challengeTrackerId": "challenge1"
        },
        {
            "signer": "0x0987654321098765432109876543210987654321",
            "challengeTrackerId": "challenge2"
        }
    ]
}
```

### Context-Aware Signatures

The new signature format includes contextual information about the transfer, ensuring that:

-   Signatures cannot be reused across different collections
-   Signatures cannot be reused across different approvers
-   Signatures cannot be reused across different approval levels
-   Signatures are bound to specific approval IDs and challenge IDs

This provides stronger security guarantees compared to simpler signature schemes.

## Implementation Details

### Signature Verification

The system verifies signatures by:

1. Constructing the signed message: `nonce + "-" + initiatorAddress + "-" + collectionId + "-" + approverAddress + "-" + approvalLevel + "-" + approvalId + "-" + challengeId`
2. Recovering the signer address from the signature using elliptic curve signature verification
3. Comparing the recovered address with the expected `signer` address
4. Checking that the signature hasn't been used before (tracked per collection, approver, approval level, approval ID, and challenge ID)

### Storage

Used signatures are tracked in the blockchain state using:

-   **Key**: `ETHSignatureTrackerKey` constructed from:
    -   Collection ID
    -   Approver address
    -   Approval level
    -   Approval ID
    -   Challenge tracker ID
    -   The signature itself
-   **Value**: Number of times the signature has been used (increment-only, must be 0 for first use)

### Proof Matching

The system checks all provided ETH signature proofs against each challenge. A challenge is satisfied if at least one proof:

1. Has a valid signature from the expected signer
2. Has not been used before
3. Matches the signature scheme with the correct contextual parameters

## Quick Reference

### Interface Definitions

```typescript
interface ETHSignatureChallenge {
    signer: string; // Ethereum address that must sign
    challengeTrackerId: string; // Unique ID for tracking used signatures
    uri?: string; // Optional metadata URI
    customData?: string; // Optional custom data
}

interface ETHSignatureProof {
    nonce: string; // The nonce that was signed (user-provided)
    signature: string; // Ethereum signature of the full message
}
```

### Signature Message Format

When signing, the message string is constructed as:

```
{nonce}-{initiatorAddress}-{collectionId}-{approverAddress}-{approvalLevel}-{approvalId}-{challengeId}
```

All values are joined with literal dash (`-`) characters. The signer must sign this exact string.

## Error Handling

Common error scenarios:

-   **Invalid Signature**: Signature doesn't match the expected signer or the message format is incorrect
-   **Already Used**: Signature has been used before for this specific combination of collection, approver, approval level, approval ID, and challenge ID
-   **Missing Proof**: Required ETH signature proof not provided
-   **Invalid Nonce**: Nonce format or content is invalid
-   **Context Mismatch**: Signature was created for a different transfer context (different collection, approver, etc.)

The system provides clear error messages to help users understand and resolve issues.

## Security Considerations

### Replay Attack Prevention

The combination of contextual information in the signature and one-time-use tracking prevents:

-   Reusing signatures across different transfers
-   Reusing signatures across different collections
-   Reusing signatures across different approvers
-   Reusing signatures after the challenge tracker ID changes

### Signature Binding

By including transfer context in the signature, the system ensures that:

-   Signatures cannot be extracted and used in unauthorized contexts
-   Each signature is cryptographically bound to specific transfer parameters
-   Signers can review exactly what they are approving before signing

### Challenge Tracker ID Management

Changing the `challengeTrackerId` resets the usage tracker, allowing signatures to be reused. This can be useful for:

-   Rotating challenge configurations
-   Resetting usage counters
-   Creating new challenge periods

However, care should be taken to ensure old signatures cannot be maliciously reused when tracker IDs are changed.


## File: ./token-standard/learn/approval-criteria/max-number-of-transfers.md

# Max Number of Transfers

Limit the number of transfers that can occur using approval trackers.

See [Approval Trackers](./approval-trackers.md) for more information on how trackers work.

## Interface

```typescript
interface ApprovalCriteria<T extends NumberType> {
    maxNumTransfers?: MaxNumTransfers<T>;
}
```

## How It Works

Similar to approval amounts, specify maximum transfers on:

-   **Overall**: Universal limit for all transfers
-   **Per Sender**: Limit per unique sender address
-   **Per Recipient**: Limit per unique recipient address
-   **Per Initiator**: Limit per unique initiator address

"0" means unlimited and not tracked. "N" means max N transfers allowed.

## Example

```json
{
    "maxNumTransfers": {
        "overallMaxNumTransfers": "0",
        "perFromAddressMaxNumTransfers": "0",
        "perToAddressMaxNumTransfers": "0",
        "perInitiatedByAddressMaxNumTransfers": "1",
        "amountTrackerId": "uniqueID"
    }
}
```

Alice can initiate 1 transfer, then no more. Bob can still transfer (different tracker).

```typescript
{
    "fullTrackerId": {
        "numTransfers": 1,
        "amounts": [],
        "lastUpdatedAt": 1691978400000
    }
}
```

## As-Needed Basis

We track on an as-needed basis, meaning if we do not have requirements that use the number of transfers, we will not increment the tracker.

Edge Case: In Predetermined Balances, you may need the number of transfers for determining the balances to assign to each transfer (e.g. transfer #10 -> token ID 10). In this case, we do need to track the number of transfers. This is all facilitated via the same tracker, so even if you have "0" or unlimited set for the corresponding value in maxNumTransfers, the tracker may be incremented behind the scenes. Consider this when editing / creating approvals. You do not want to use a tracker that has prior history when you expect it to start from scratch.


## File: ./token-standard/learn/approval-criteria/merkle-challenges.md

# Merkle Challenges

## Overview

Merkle challenges provide cryptographic proof-based approval mechanisms using SHA256 Merkle trees. They enable secure, gas-efficient whitelisting and claim code systems without storing large address lists on-chain.

**Key Benefits**:

-   **Gas Efficiency**: Distribute gas costs among users instead of collection creators
-   **Security**: Cryptographic proof verification prevents unauthorized access
-   **Flexibility**: Support both whitelist trees and claim code systems
-   **Scalability**: Handle large user bases without on-chain storage

## Interface Definition

```typescript
export interface MerkleChallenge<T extends NumberType> {
    root: string; // SHA256 Merkle tree root hash
    expectedProofLength: T; // Required proof length (security)
    useCreatorAddressAsLeaf: boolean; // Use initiator address as leaf?
    maxUsesPerLeaf: T; // Maximum uses per leaf
    uri: string; // Metadata URI
    customData: string; // Custom data field
    challengeTrackerId: string; // Unique tracker identifier
    leafSigner: string; // Optional leaf signature authority
}
```

## Basic Example

```json
{
    "merkleChallenges": [
        {
            "root": "758691e922381c4327646a86e44dddf8a2e060f9f5559022638cc7fa94c55b77",
            "expectedProofLength": "1",
            "useCreatorAddressAsLeaf": false,
            "maxUsesPerLeaf": "1",
            "uri": "ipfs://Qmbbe75FaJyTHn7W5q8EaePEZ9M3J5Rj3KGNfApSfJtYyD",
            "customData": "",
            "challengeTrackerId": "uniqueId",
            "leafSigner": "0x"
        }
    ]
}
```

## Challenge Types

### 1. Claim Code Challenges

Create a Merkle tree of secret claim codes that users must provide to claim tokens.

**Use Case**: Private claim codes, invitation systems, promotional campaigns

**Process**:

1. Generate secret claim codes
2. Build Merkle tree from hashed codes
3. Distribute codes privately to users with leaf signatures
4. Users provide code + Merkle proof in transfer

### 2. Whitelist Challenges

Create a Merkle tree of user addresses for gas-efficient whitelisting.

**Use Case**: Large whitelists, community access, gas cost distribution

**Process**:

1. Collect user addresses
2. Build Merkle tree from hashed addresses
3. Users provide their address + Merkle proof
4. System verifies address is in whitelist / valid proof

**Gas Cost Distribution**: Instead of the collection creator paying gas to store N addresses on-chain, each user pays their own gas for proof verification.

## Understanding useCreatorAddressAsLeaf

The `useCreatorAddressAsLeaf` field determines how the system handles the leaf value in Merkle proofs:

### Whitelist Trees (`useCreatorAddressAsLeaf: true`)

**Purpose**: Verify that the transaction initiator is in the whitelist.

**How It Works**:

1. **Automatic Override**: The system expects the provided leaf to be the initiator's BitBadges address ("bb1...")
2. **Address Verification**: Checks if the initiator's address exists in the Merkle tree
3. **No Manual Leaf**: Users don't need to provide their address as the leaf - the system handles it

**Recommended Configuration**:

-   Set `initiatedByList` to "All" (whitelist tree handles the restriction)
-   Set `useCreatorAddressAsLeaf: true`
-   Build Merkle tree from BitBadges addresses as leaves ["bb1...", "bb2...", "bb3..."]

### Claim Code Trees (`useCreatorAddressAsLeaf: false`)

**Purpose**: Verify that the user possesses a valid claim code.

**How It Works**:

1. **Manual Leaf**: User must provide the actual claim code as the leaf
2. **Code Verification**: System verifies the provided code exists in the Merkle tree
3. **User Responsibility**: Users must know and provide their claim code

**Recommended Configuration**:

-   Set `useCreatorAddressAsLeaf: false`
-   Build Merkle tree from claim codes as leaves ["secret1", "secret2", "secret3"]
-   Post root hash on-chain as challenge
-   Distribute codes privately to users with leaf signatures

## Security Features

### Expected Proof Length

**Critical Security Feature**: All proofs must have the same length to prevent preimage and second preimage attacks.

```typescript
// All proofs must match this length
expectedProofLength: '2'; // 2-level proof required
```

**Design Requirement**: Your Merkle tree must be constructed so all leaves are at the same depth.

### Max Uses Per Leaf

Control how many times each leaf can be used:

| Setting         | Behavior          | Use Case             |
| --------------- | ----------------- | -------------------- |
| `"0"` or `null` | Unlimited uses    | Public claim codes   |
| `"1"`           | One-time use      | Single-use codes     |
| `"5"`           | Five uses maximum | Limited distribution |

**Critical Security Requirement**: For claim code challenges (`useCreatorAddressAsLeaf: false`), `maxUsesPerLeaf` must be `"1"` to prevent replay attacks.

### Replay Attack Protection

**‚ö†Ô∏è CRITICAL SECURITY RISK**: Non-address trees (claim codes) are vulnerable to front-running attacks.

**The Problem**:

1. User submits transaction with valid Merkle proof
2. Proof becomes visible in mempool (public blockchain)
3. Malicious actor sees the proof and front-runs the transaction
4. Original user's transaction fails, attacker gets the token

**Why This Happens**:

-   Merkle proofs for claim codes are reusable until consumed
-   Once in mempool, proofs are publicly visible
-   No built-in protection against proof reuse

**The Solution**: Leaf signatures provide cryptographic protection against this attack.

## Challenge Tracking

### Tracker System

Uses increment-only, immutable trackers to prevent double-spending:

```typescript
{
    collectionId: T;
    approvalId: string;
    approvalLevel: 'collection' | 'incoming' | 'outgoing';
    approverAddress: string; // blank if collection-level
    challengeTrackerId: string;
    leafIndex: T; // Leftmost base layer leaf index = 0, rightmost = numLeaves - 1
}
```

Note the fact we use leaf indices to track usage and not leaf values.

### Tracker Examples

```
1-collection- -approvalId-uniqueID-0  ‚Üí USED 1 TIME
1-collection- -approvalId-uniqueID-1  ‚Üí UNUSED
1-collection- -approvalId-uniqueID-2  ‚Üí USED 3 TIMES
```

**Important**: Trackers are scoped to specific approvals and cannot be shared between different approval configurations.

### Tracker Management

-   **Increment-Only**: Once used, the number of uses cannot be decremented
-   **Immutable**: Tracker state cannot be modified
-   **Best Practice**: Use unique `challengeTrackerId` for fresh tracking of new approvals

## Leaf Signatures

### Protection Against Front-Running

Leaf signatures provide cryptographic protection against front-running attacks on claim code challenges.

**How It Works**:

```typescript
// Signature scheme
signature = ETHSign(leaf + '-' + bitbadgesAddressOfInitiator);
```

**Security Mechanism**:

1. **Address Binding**: Each proof is cryptographically tied to a specific BitBadges address
2. **Replay Prevention**: Even if proof is intercepted, it cannot be used by other addresses
3. **Mempool Safety**: Intercepted proofs in mempool are useless to attackers

### Implementation

```typescript
// Only Ethereum addresses supported currently
leafSigner: '0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b6';
```

**Critical Benefits**:

-   **Front-Running Protection**: Prevents attackers from stealing tokens via mempool interception
-   **Address-Specific**: Each proof is cryptographically bound to the intended recipient
-   **Mempool Safety**: Makes intercepted proofs useless to malicious actors
-   **Required for Claim Codes**: Strongly recommended for all non-address tree challenges

**‚ö†Ô∏è IMPORTANT**: For claim code challenges, leaf signatures are not just recommended‚Äîthey are essential for security against front-running attacks.

## Merkle Tree Construction

### Standard Configuration

```typescript
import { SHA256 } from 'crypto-js';
import MerkleTree from 'merkletreejs';

// For claim codes
const codes = ['secret1', 'secret2', 'secret3'];
const hashedCodes = codes.map((x) => SHA256(x).toString());

// For whitelists
const addresses = ['bb1...', 'bb1...', 'bb1...'];
const hashedAddresses = addresses.map((x) => SHA256(x));

// Tree options (tested configuration)
const treeOptions = {
    fillDefaultHash:
        '0000000000000000000000000000000000000000000000000000000000000000',
};

// Build tree
const tree = new MerkleTree(hashedCodes, SHA256, treeOptions);
const root = tree.getRoot().toString('hex');
const expectedProofLength = tree.getLayerCount() - 1;
```

### Critical Requirements

1. **Same Layer**: All leaves must be at the same depth
2. **Consistent Proof Length**: All proofs must have identical length
3. **Test Thoroughly**: Verify all paths work before deployment
4. **Use Tested Options**: Stick to the `fillDefaultHash` configuration

## Transfer Integration

### Providing Proofs

Include Merkle proofs in [MsgTransferTokens](../../../bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgtransferbadges.md):

```typescript
const txCosmosMsg: MsgTransferTokens<bigint> = {
    creator: chain.bitbadgesAddress,
    collectionId: collectionId,
    transfers: [
        {
            // ... other fields
            merkleProofs: [
                {
                    aunts: proofObj.map((proof) => ({
                        aunt: proof.data.toString('hex'),
                        onRight: proof.position === 'right',
                    })),
                    leaf: isWhitelist ? '' : passwordCodeToSubmit,
                    leafSignature: leafSignature, // if applicable
                },
            ],
        },
    ],
};
```

### Proof Generation

```typescript
// Generate proof for user submission
const passwordCodeToSubmit = 'secretCode123';
const leaf = isWhitelist
    ? SHA256(chain.bitbadgesAddress).toString()
    : SHA256(passwordCodeToSubmit).toString();

const proofObj = tree.getProof(leaf, whitelistIndex);
const isValidProof = proofObj && proofObj.length === tree.getLayerCount() - 1;

// Create signature if needed
const leafSignature = signLeaf(leaf + '-' + chain.bitbadgesAddress);
```

## Comparison with ETH Signature Challenges

Merkle challenges and ETH signature challenges are very similar. The main difference is that Merkle challenges must also check that the signed message was pre-committed to in the tree, whereas ETH signature challenges only need to check that the signature is valid and not used before.

For more information, see [ETH Signature Challenges](eth-signature-challenges.md).

## Best Practices

### Design Considerations

1. **Tree Structure**: Ensure all leaves at same depth
2. **Proof Length**: Test all proof lengths are identical
3. **Tracker Management**: Use unique IDs for fresh tracking
4. **Security**: **MANDATORY** - Enable leaf signatures for claim codes to prevent front-running
5. **Testing**: Verify all paths work before mainnet

### Performance Optimization

1. **Small Lists**: For <100 users, consider regular address lists
2. **Gas Distribution**: Merkle trees excel with large user bases
3. **Proof Verification**: On-chain verification is gas-efficient
4. **Storage**: No on-chain storage of large lists required


## File: ./token-standard/learn/approval-criteria/overrides.md

# Override User Level Approvals

Collection-level approvals can override user-level approvals to force transfers.

## Interface

```typescript
interface ApprovalCriteria<T extends NumberType> {
    overridesFromOutgoingApprovals?: boolean;
    overridesToIncomingApprovals?: boolean;
}
```

## How It Works

-   **`overridesFromOutgoingApprovals: true`**: Skip sender's outgoing approvals
-   **`overridesToIncomingApprovals: true`**: Skip recipient's incoming approvals

This enables forced transfers without user consent.

## Use Cases

-   **Force Revoke**: Remove tokens from users
-   **Freeze Tokens**: Prevent transfers regardless of user settings
-   **Emergency Actions**: Administrative control over transfers

## Mint Address Requirement

**CRITICAL**: Mint address approvals must always override outgoing approvals:

```json
{
    "fromListId": "Mint",
    "approvalCriteria": {
        "overridesFromOutgoingApprovals": true
    }
}
```

The Mint address has no user-level approvals, so overrides are required for functionality.

## Dangerous Configuration Warning

‚ö†Ô∏è **Dangerous Configuration Detected**

When an approval enables forceful transfers without a non-Mint address sender consent (via `overridesFromOutgoingApprovals: true`), this can cause dangerous side effects if not handled properly.

### Risks

Forceful transfers can break protocols that rely on escrow or alternate state. Ensure you understand all side effects of every initiated transfer before proceeding.

**Example**: Revoking from liquidity pools without handling pool shares can desync balances and enable exploits like infinite glitches (e.g. repeated revoke ‚Üí rejoin pool ‚Üí infinite liquidity).

### Recommendations

1. **Educate All Potential Initiators**

    - Ensure all approved initiators understand the risks and will handle transfers responsibly.

2. **Use Multi-Sig**

    - Use multi-sig or governance addresses to prevent single points of failure and unauthorized use.

3. **Consider Alternatives**
    - Do you really need revocation capabilities? If not, consider using safer approaches like whitelists, ownership checks, or other freezing methods instead of revoking to avoid these risks entirely.

## Reserved Addresses Protection

BitBadges reserves certain addresses that cannot be forcefully overridden as a sanity check. This protection is **not a replacement for due diligence** but serves as an additional safety measure to prevent accidental or malicious transfers from critical protocol addresses.

When designing your collection, treat these as external contracts. You can control the flow to / from, but if stuff is already escrowed, you cannot forcefully revoke it. Consider using athe approval criteria address checks for WASM contracts and / or liquidity pool addresses to prevent this.

### Protected Address Types

The following addresses are protected from forceful overrides:

1. **Liquidity Pool Addresses**

    - Every liquidity pool address is protected to prevent desyncing balances and enabling exploits

2. **Cosmos Coin Wrapper Path Addresses**

    - Every cosmos coin wrapper path address is protected to maintain wrapper functionality integrity

3. **Governance-Configured Addresses**
    - Any addresses explicitly set by governance as protected addresses

### Important Notes

-   This protection is a **sanity check**, not a comprehensive security measure
-   You should still perform thorough due diligence when designing approvals and initializing forceful transfers
-   The protection applies to forceful transfers (when `overridesFromOutgoingApprovals: true` is used)
-   This does not apply to transfers to / from these addresses that actually check their user-level approvals.
-   We bypass these protections if the initiatedBy === from address (the initiator is the protected address)
-   Normal transfers (with user consent) are not affected by this protection


## File: ./token-standard/learn/approval-criteria/predetermined-balances.md

# Predetermined Balances

## Overview

Predetermined balances provide fine-grained control over the exact amounts and order of transfers in an approval. Unlike traditional tally-based systems where you approve a total amount (e.g., 100 tokens) without controlling the specific combinations, predetermined balances let you explicitly define:

-   **Exact amounts** that must be transferred
-   **Specific order** of transfers
-   **Precise token IDs and ownership times** for each transfer

**Key Principle**: The transfer will fail if the balances are not EXACTLY as defined in the predetermined balances.

## Interface Definition

```typescript
export interface PredeterminedBalances<T extends NumberType> {
    manualBalances: ManualBalances<T>[];
    incrementedBalances: IncrementedBalances<T>;
    orderCalculationMethod: PredeterminedOrderCalculationMethod;
}
```

## Balance Definition Methods

There are two mutually exclusive ways to define balances:

### 1. Manual Balances

Define an array of specific balance sets manually. Each element corresponds to a different transfer.

```json
{
    "manualBalances": [
        {
            "amount": "1",
            "tokenIds": [
                {
                    "start": "1",
                    "end": "1"
                }
            ],
            "ownershipTimes": [
                {
                    "start": "1691978400000",
                    "end": "1723514400000"
                }
            ]
        },
        {
            "amount": "5",
            "tokenIds": [
                {
                    "start": "2",
                    "end": "6"
                }
            ],
            "ownershipTimes": [
                {
                    "start": "1691978400000",
                    "end": "1723514400000"
                }
            ]
        }
    ]
}
```

**Use Case**: When you need complete control over each specific transfer amount and timing.

### 2. Incremented Balances

Define starting balances and rules for subsequent transfers. Perfect for sequential minting or time-based releases or other common patterns. Note that most options are incompatible with each other.

```json
{
    "incrementedBalances": {
        "startBalances": [
            {
                "amount": "1",
                "tokenIds": [
                    {
                        "start": "1",
                        "end": "1"
                    }
                ],
                "ownershipTimes": [
                    {
                        "start": "1691978400000",
                        "end": "1723514400000"
                    }
                ]
            }
        ],
        "incrementTokenIdsBy": "1",
        "incrementOwnershipTimesBy": "0",
        "durationFromTimestamp": "0",
        "allowOverrideTimestamp": false,
        "allowOverrideWithAnyValidToken": false,
        "recurringOwnershipTimes": {
            "startTime": "0",
            "intervalLength": "0",
            "chargePeriodLength": "0"
        }
    }
}
```

#### Increment Options

| Field                            | Description                                          | Example                                              |
| -------------------------------- | ---------------------------------------------------- | ---------------------------------------------------- |
| `incrementTokenIdsBy`            | Amount to increment token IDs by after each transfer | `"1"` = next transfer gets token ID 2, then 3, etc.  |
| `incrementOwnershipTimesBy`      | Amount to increment ownership times by               | `"86400000"` = add 1 day to ownership times          |
| `durationFromTimestamp`          | Calculate ownership times from timestamp + duration  | `"2592000000"` = 30 days from transfer time          |
| `allowOverrideTimestamp`         | Allow custom timestamp override in transfer          | `true` = users can specify custom start time         |
| `allowOverrideWithAnyValidToken` | Allow any valid token ID (one) override              | `true` = users can specify any single valid token ID |
| `recurringOwnershipTimes`        | Define recurring time intervals                      | Monthly subscriptions, weekly rewards                |

#### Duration From Timestamp

Dynamically calculate ownership times from a timestamp plus a set duration. This overwrites all ownership times in the starting balances.

```json
{
    "durationFromTimestamp": "2592000000", // 30 days in milliseconds
    "allowOverrideTimestamp": true
}
```

**Behavior**:

-   **Default**: Uses transfer time as the base timestamp
-   **Override**: If `allowOverrideTimestamp` is true, users can specify a custom timestamp in `MsgTransferTokens` `precalculationOptions`
-   **Calculation**: `ownershipTime = baseTimestamp + durationFromTimestamp`
-   **Overwrite**: All ownership times in starting balances are replaced with [{ "start": baseTimestamp, "end": baseTimestamp + durationFromTimestamp }]

#### Recurring Ownership Times

Define repeating time intervals for subscriptions or periodic rewards:

```json
{
    "recurringOwnershipTimes": {
        "startTime": "1691978400000", // When intervals begin
        "intervalLength": "2592000000", // 30 days in milliseconds
        "chargePeriodLength": "604800000" // 7 days advance charging
    }
}
```

**Example**: Monthly subscription starting August 13, 2023, with 7-day advance charging period.

## Precalculating Balances

### The Race Condition Problem

Predetermined balances can change rapidly between transaction broadcast and confirmation. For example:

-   Other users' mints get processed
-   Token IDs shift due to concurrent activity
-   Manual balance specification becomes unreliable

### The Solution: Precalculation

Use `precalculateBalancesFromApproval` in [MsgTransferTokens](../../x-badges/messages/msg-transfer-tokens.md) to dynamically calculate balances at execution time.

```typescript
{
  precalculateBalancesFromApproval: {
    approvalId: string;           // The approval to precalculate from
    approvalLevel: string;        // "collection" | "incoming" | "outgoing"
    approverAddress: string;      // "" if collection-level
    version: string;              // Must specify exact version
    precalculationOptions: {
      overrideTimestamp: string;  // Optional: override timestamp (milliseconds)
      tokenIdsOverride: UintRange[]; // Optional: override token IDs
    }
  }
}
```

## Precalculation Options

When using `precalculateBalancesFromApproval`, you can override calculation parameters. These options only apply when the corresponding flags are enabled in `IncrementedBalances`.

| Field               | Type          | When It Applies                                                    | Validation                                    |
| ------------------- | ------------- | ------------------------------------------------------------------ | --------------------------------------------- |
| `overrideTimestamp` | string (Uint) | `durationFromTimestamp` set and `allowOverrideTimestamp` is `true` | If zero, uses current block time              |
| `tokenIdsOverride`  | UintRange[]   | `allowOverrideWithAnyValidToken` is `true`                         | Must be exactly one range with `start == end` |

**overrideTimestamp**: Overrides the base timestamp for ownership time calculation. Ownership times become `[overrideTimestamp, overrideTimestamp + durationFromTimestamp - 1]`.

**tokenIdsOverride**: Replaces incrementally calculated token IDs. The token ID must be in the collection's `validTokenIds`.

```json
{
    "precalculateBalancesFromApproval": {
        "approvalId": "approval-1",
        "approvalLevel": "collection",
        "approverAddress": "",
        "version": "1",
        "precalculationOptions": {
            "overrideTimestamp": "1704067200000",
            "tokenIdsOverride": [{ "start": "5", "end": "5" }]
        }
    }
}
```

If the corresponding flags are `false`, the options are ignored (no error).

## Order Calculation Methods

The system needs to determine which balance set to use for each transfer. This is controlled by the `orderCalculationMethod`.

### How Order Numbers Work

The order number determines which balances to transfer, but it works differently depending on the balance type:

#### Manual Balances

-   **Order number = 0**: Transfer `manualBalances[0]` (first element)
-   **Order number = 1**: Transfer `manualBalances[1]` (second element)
-   **Order number = 5**: Transfer `manualBalances[5]` (sixth element)

**Example**: If you have 3 manual balance sets, order numbers 0, 1, and 2 will use each set once. Order number 3 would be out of bounds.

#### Incremented Balances

-   **Order number = 0**: Use starting balances as-is (no increments)
-   **Order number = 1**: Apply increments once to starting balances
-   **Order number = 5**: Apply increments five times to starting balances

**Example**: Starting with token ID 1, increment by 1:

-   Order 0: Token ID 1
-   Order 1: Token ID 2
-   Order 2: Token ID 3
-   Order 5: Token ID 6

### Transfer-Based Order Numbers

Track the number of transfers to determine order:

| Method                                 | Description           | Use Case                    |
| -------------------------------------- | --------------------- | --------------------------- |
| `useOverallNumTransfers`               | Global transfer count | Simple sequential transfers |
| `usePerToAddressNumTransfers`          | Per-recipient count   | User-specific limits        |
| `usePerFromAddressNumTransfers`        | Per-sender count      | Sender-specific limits      |
| `usePerInitiatedByAddressNumTransfers` | Per-initiator count   | Initiator-specific limits   |

**Important**: Uses the same tracker as [Max Number of Transfers](max-number-of-transfers.md). Trackers are:

-   Increment-only and immutable
-   Shared between predetermined balances and max transfer limits
-   Must be carefully managed to avoid conflicts

### Merkle-Based Order Numbers

Use Merkle challenge leaf indices (leftmost = 0, rightmost = numLeaves - 1) for reserved transfers:

```typescript
{
  "useMerkleChallengeLeafIndex": true,
  "challengeTrackerId": "uniqueId"
}
```

**Use Case**: Reserve specific token IDs for specific users or claim codes.

## Order Calculation Interface

```typescript
export interface PredeterminedOrderCalculationMethod {
    useOverallNumTransfers: boolean;
    usePerToAddressNumTransfers: boolean;
    usePerFromAddressNumTransfers: boolean;
    usePerInitiatedByAddressNumTransfers: boolean;
    useMerkleChallengeLeafIndex: boolean;
    challengeTrackerId: string;
}
```

## Boundary Handling

### Understanding Bounds

Every approval defines bounds through its core fields (tokenIds, ownershipTimes, etc.). For example:

-   **Token IDs**: 1-100
-   **Ownership Times**: Mon-Fri only
-   **Transfer Times**: Specific date range

Predetermined balances must work within these bounds, but note that order numbers can eventually exceed them.

### Boundary Scenarios

#### Complete Out-of-Bounds

**Scenario**: Order number corresponds to balances completely outside approval bounds.

**Example**:

-   Approval allows token IDs 1-100
-   Increment by 1 for each transfer
-   Order number 101 would require token ID 101 (out of bounds)

**Result**: Transfer is ignored because token ID 101 never matches the approval's token ID range.

#### Partial Overlap

**Scenario**: Order number corresponds to balances that partially overlap with approval bounds.

**Example**:

-   Approval allows token IDs 1-100
-   Transfer requires token IDs 95-105
-   Token IDs 95-100 are in bounds, 101-105 are out of bounds

**Result**:

-   Only in-bounds balances (95-100) are approved by current approval
-   Out-of-bounds balances (101-105) must be approved by a separate approval
-   The complete transfer (95-105) must still be exactly as defined

**Important**: The transfer will fail unless all out-of-bounds balances are approved by other approvals.


## File: ./token-standard/learn/approval-criteria/requires.md

# Requires

Additional address relationship restrictions for transfer approval.

## Interface

```typescript
interface ApprovalCriteria<T extends NumberType> {
    requireToEqualsInitiatedBy?: boolean;
    requireToDoesNotEqualInitiatedBy?: boolean;
    requireFromEqualsInitiatedBy?: boolean;
    requireFromDoesNotEqualInitiatedBy?: boolean;
}
```

## How It Works

Enforce additional checks on address relationships:

-   **`requireToEqualsInitiatedBy`**: Recipient must equal initiator
-   **`requireToDoesNotEqualInitiatedBy`**: Recipient must not equal initiator
-   **`requireFromEqualsInitiatedBy`**: Sender must equal initiator
-   **`requireFromDoesNotEqualInitiatedBy`**: Sender must not equal initiator

## Constraints

All checks are bounded by the respective address lists (`toList`, `fromList`, `initiatedByList`).


## File: ./token-standard/learn/approval-criteria/special-address-flags.md

# Special Address Flags

Collection approval criteria include two boolean flags that control whether an approval can be used for **backed minting** and **special wrapping** operations.

## Overview

These flags provide fine-grained control over which collection approvals are eligible for special address operations, ensuring that only explicitly designated approvals can be used for backed minting and special wrapping transfers.

**Important:** These flags are only supported at the **collection approval level** (not user-level approvals).

## Interface

```typescript
interface ApprovalCriteria<T extends NumberType> {
    allowBackedMinting?: boolean;
    allowSpecialWrapping?: boolean;
}
```

## Flags

### `allowBackedMinting`

Controls whether a collection approval can be used for backed minting operations (via `CosmosCoinBackedPath`). Defaults to `false` if not set.

Prevents accidental allowances when `toListIds` is "All" - even if an approval matches all addresses, it won't apply to backing/unbacking operations unless explicitly set to `true`. Validation is bidirectional, checking both `from` and `to` addresses.

### `allowSpecialWrapping`

Controls whether a collection approval can be used for special wrapping operations (via `CosmosCoinWrapperPath`). Defaults to `false` if not set.

Prevents accidental allowances when `toListIds` is "All" - even if an approval matches all addresses, it won't apply to wrapping/unwrapping operations unless explicitly set to `true`. Validation is bidirectional, checking both `from` and `to` addresses.

## Usage

These flags provide fine-grained control over which collection approvals are eligible for special address operations, ensuring that only explicitly designated approvals can be used for backed minting and special wrapping transfers.

### Example: Backed Minting Approval

```typescript
const backingApproval: CollectionApproval<bigint> = {
    fromListId: specialBackedPathAddress,
    toListId: 'All',
    initiatedByListId: 'All',
    transferTimes: [{ start: 1n, end: 18446744073709551615n }],
    tokenIds: [{ start: 1n, end: 100n }],
    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
    approvalId: 'backing-approval',
    version: 0n,
    approvalCriteria: {
        allowBackedMinting: true, // Required for IBC backed path operations
        overridesFromOutgoingApprovals: true,
    },
};
```

### Example: Wrapper Approval

```typescript
const wrapperApproval: CollectionApproval<bigint> = {
    toListId: specialWrapperAddress,
    fromListId: 'AllWithoutMint',
    initiatedByListId: 'All',
    transferTimes: [{ start: 1n, end: 18446744073709551615n }],
    tokenIds: [{ start: 1n, end: 100n }],
    ownershipTimes: [{ start: 1n, end: 18446744073709551615n }],
    approvalId: 'wrapper-approval',
    version: 0n,
    approvalCriteria: {
        allowSpecialWrapping: true, // Required for wrapper path operations
        overridesToIncomingApprovals: true,
    },
};
```

## Important Notes

-   **Collection-level only:** These flags are only supported at the collection approval level (not user-level approvals)
-   **Default:** Both flags default to `false` - approvals must explicitly opt-in to special address operations
-   **Override flags:** When using these flags, you typically also need override flags (`overridesFromOutgoingApprovals` or `overridesToIncomingApprovals`) since special addresses cannot control their own user-level approvals



## File: ./token-standard/learn/approval-criteria/tallied-approval-amounts.md

# Tallied Approval Amounts

Limit transfer amounts using increment-only trackers with thresholds.

## Interface

```typescript
interface ApprovalCriteria<T extends NumberType> {
    approvalAmounts?: ApprovalAmounts<T>;
}
```

## How It Works

Specify maximum amounts that can be transferred using four tracker types:

-   **Overall** (`trackerType = "overall"`): Universal limit for all transfers
-   **Per To Address** (`trackerType = "to"`): Limit per unique recipient
-   **Per From Address** (`trackerType = "from"`): Limit per unique sender
-   **Per Initiated By Address** (`trackerType = "initiatedBy"`): Limit per unique initiator

"0" means unlimited and not tracked. "N" means max N amount allowed.

## Example

```json
{
    "approvalAmounts": {
        "overallApprovalAmount": "1000",
        "perFromAddressApprovalAmount": "0",
        "perToAddressApprovalAmount": "0",
        "perInitiatedByAddressApprovalAmount": "10",
        "amountTrackerId": "uniqueID"
    }
}
```

## Tracker Types

### Overall Tracker

-   **ID**: `1-collection- -approvalId-uniqueID-overall-`
-   **Behavior**: Increments for all transfers regardless of sender/recipient/initiator
-   **Use Case**: Global collection limits

### Per-To Address Tracker

-   **ID**: `1-collection- -approvalId-uniqueID-to-recipientAddress`
-   **Behavior**: Separate tracker for each unique recipient
-   **Use Case**: Limit how much each user can receive

### Per-From Address Tracker

-   **ID**: `1-collection- -approvalId-uniqueID-from-senderAddress`
-   **Behavior**: Separate tracker for each unique sender
-   **Use Case**: Limit how much each user can send

### Per-InitiatedBy Address Tracker

-   **ID**: `1-collection- -approvalId-uniqueID-initiatedBy-initiatorAddress`
-   **Behavior**: Separate tracker for each unique initiator
-   **Use Case**: Limit how much each user can initiate

## Detailed Example

Using the approval amounts defined above, when Alice initiates a transfer of x10 from Bob:

### Two Trackers Get Incremented

**#1) Overall Tracker**

-   **ID**: `1-collection- -approvalId-uniqueID-overall-`
-   **Before**: 0/1000
-   **After**: 10/1000
-   **Behavior**: Any subsequent transfers (from Charlie, etc.) will also increment this universal tracker

**#2) Per-Initiator Tracker**

-   **ID**: `1-collection- -approvalId-uniqueID-initiatedBy-alice`
-   **Before**: 0/10
-   **After**: 10/10 (fully used)
-   **Behavior**: Only incremented when Alice initiates. Charlie's transfers use a separate tracker: `1-collection- -approvalId-uniqueID-initiatedBy-charlie`

### Amount Tracking with Balance Type

Trackers store amounts using the balance type structure. Above, we simplified it to just the amount.

```json
{
    "amounts": [
        {
            "amount": 10n,
            "tokenIds": [{ "start": 1n, "end": 1n }],
            "ownershipTimes": [{ "start": 1n, "end": 100000000000n }]
        }
    ]
}
```

**What Gets Incremented**:

-   **Amount**: The total quantity transferred
-   **Token IDs**: Specific token IDs that were transferred
-   **Ownership Times**: The ownership time ranges that were transferred

### Unlimited Trackers (No Increment)

Since "to" and "from" trackers are set to "0" (unlimited), no tracking occurs for these types.

## Tracker Behavior

-   **As-Needed**: Only increment trackers when necessary (unlimited = no tracking)
-   **Separate Counts**: Each tracker type maintains independent tallies
-   **Address Scoped**: Per-address trackers create unique counters per address
-   **Balance Tracking**: Increments for specific token IDs and ownership times transferred

## Resets and ID Changes

### Changing Tracker ID

When you update `amountTrackerId` from "uniqueID" to "uniqueID2":

```
1-collection- -approvalId-uniqueID-initiatedBy-alice
‚Üì
1-collection- -approvalId-uniqueID2-initiatedBy-alice
```

**Result**: All tracker IDs change, so all tallies start from scratch.

### Reusing Old IDs

If you later change back to "uniqueID", the starting point will be the previous tally:

-   Alice's initiatedBy tracker: 10/10 used (not 0/10)

**Important**: Never reuse tracker IDs unless you want to continue from the previous state. They are increment-only.


## File: ./token-standard/learn/approval-criteria/usdbadge-transfers.md

# Coin Transfers

Automatic token transfers to be executed on every approval use. These are triggered every time this approval is used. This is useful for payments, payouts, swaps, and more.

Couple notes:

-   This forfeits auto-scan mode for the approval
-   Subject to allowed denominations set by the module parameters
-   Can be used with x/bank denominations or BitBadges alias denominations

## Interface

```typescript
interface iCoinTransfer<T extends NumberType> {
    to: string; // Recipient BitBadges address
    coins: iCosmosCoin<T>[];

    overrideFromWithApproverAddress: boolean; // By default (false), this is the initiator address. In the case of a collection approval, approver address is the mint escrow address.
    overrideToWithInitiator: boolean; // By default (false), this is the to address specified
}

interface iCosmosCoin<T extends NumberType> {
    amount: T;
    denom: string; // Any Cosmos SDK denomination (e.g., "ubadge", "uatom", "uosmo")
}
```

## Mint Escrow Address

The Mint Escrow Address (_mintEscrowAddress_) is a special reserved address generated from the collection ID that holds Cosmos native funds on behalf of the "Mint" address for a specific collection. This address has no known private key and is not controlled by anyone. The only way to get funds out is via collection approvals from the Mint address.

For collection approvals with `overrideFromWithApproverAddress: true`, the approver address is this special mint escrow address.

### Generation

```typescript
const mintEscrowAddress = generateAlias(
    'badges',
    getAliasDerivationKeysForCollection(collectionId)
);
```

### Properties

-   Longer than normal addresses
-   No private key (cannot be controlled by users)
-   Can receive Cosmos-native tokens
-   Only collection approvals can trigger transfers from it
-   Holds Cosmos native tokens (like "ubadge" tokens) associated with the Mint address for a specific collection

### Auto-Escrow During Collection Creation

The `MsgCreateCollection` interface includes a `mintEscrowCoinsToTransfer` field of type `repeated cosmos.base.v1beta1.Coin` that allows you to automatically escrow native coins to the Mint Escrow Address during collection creation.

**Benefits:**

-   **Unknown collection ID** - Escrow coins before knowing the final collection ID
-   **Automatic transfer** - Coins are automatically transferred to the generated Mint Escrow Address
-   **Collection initialization** - Funds are available immediately when the collection is created
-   **Single transaction** - Combine collection creation and coin escrow in one operation

**Usage:**

```typescript
const msgCreateCollection: MsgCreateCollection = {
    creator: 'cosmos1...',
    collectionId: '0',
    mintEscrowCoinsToTransfer: [
        {
            denom: 'ubadge',
            amount: '1000000',
        },
    ],
    // ... other collection fields
};
```

This field is particularly useful when you need to fund the Mint Escrow Address but don't know the collection ID beforehand, since the escrow address is derived from the collection ID itself. Thus, it can be done all in one transaction.

## Example

```json
[
    {
        "to": "bb1...",
        "coins": [{ "amount": "1000000000", "denom": "ubadge" }],
        "overrideFromWithApproverAddress": false,
        "overrideToWithInitiator": false
    }
]
```


## File: ./token-standard/learn/approval-criteria/user-royalties.md

# User Royalties

Apply percentage-based royalties to transfers.

## Interface

```typescript
interface UserRoyalties {
    percentage: string; // 1 to 10000 represents basis points (0.01% to 100%)
    payoutAddress: string; // Address to receive the royalties
}
```

## How It Works

User royalties automatically deduct a percentage from transfers and send it to a specified payout address:

-   **Percentage**: Expressed in basis points (1 = 0.01%, 100 = 1%, 10000 = 100%)
-   **Payout**: Automatically sent to the specified address on each transfer
-   **Deduction**: Applied to the transfer amount before the transfer is processed

## Usage Examples

### 5% Royalty

```json
{
    "userRoyalties": {
        "percentage": "500", // 500 basis points = 5%
        "payoutAddress": "bb1creator..."
    }
}
```

**Result**: 5% of each transfer amount is sent to the creator's address.

### 2.5% Royalty

```json
{
    "userRoyalties": {
        "percentage": "250", // 250 basis points = 2.5%
        "payoutAddress": "bb1artist..."
    }
}
```

**Result**: 2.5% of each transfer amount is sent to the artist's address.

## Edge Case: One per Transfer

Currently, we only support one specific royalty percentage applied per transfer. If a transfer matches to different approvals with multiple royalties, the transfer may fail.


## File: ./token-standard/learn/approval-criteria/voting-challenges.md

# Voting Challenges

Voting challenges require a weighted quorum threshold to be met through votes from specified voters. This enables multi-signature-like approval where multiple parties must vote to approve transfers, with each voter having a configurable weight. Votes are stored separately and can be updated.

The system requires a minimum percentage of total voter weight to vote "yes" before a transfer can be approved. Each voter has a weight, and each vote allocates a percentage (0-100%) to "yes" with the remainder going to "no".

## Structure

### Challenge Fields

| Field             | Type    | Description                                                      |
| ----------------- | ------- | ---------------------------------------------------------------- |
| `proposalId`      | string  | Unique identifier for tracking votes                             |
| `quorumThreshold` | string  | Percentage (0-100) of total possible weight that must vote "yes" |
| `voters`          | Voter[] | List of voters with addresses and weights                        |
| `uri`             | string  | Optional metadata URI                                            |
| `customData`      | string  | Optional custom data                                             |

### Vote Fields

| Field        | Type   | Description                                                   |
| ------------ | ------ | ------------------------------------------------------------- |
| `proposalId` | string | Proposal ID this vote is for                                  |
| `voter`      | string | Address of the voter casting the vote                         |
| `yesWeight`  | string | Percentage (0-100) allocated to "yes"; remainder goes to "no" |

## Voting Process

1. **Cast Vote**: Voters use `MsgCastVote` with `yesWeight` (0-100%)
2. **Store Vote**: Votes stored with key: `collectionId-approverAddress-approvalLevel-approvalId-proposalId-voterAddress`
3. **Update Vote**: Casting a new vote with same parameters overwrites the previous vote
4. **Calculate Threshold**: On transfer attempt:
    - Retrieve all votes for the proposal
    - Calculate each voter's yes contribution: `(voterWeight √ó yesWeight) / 100`
    - Sum all yes contributions
    - Calculate percentage: `(totalYesWeight √ó 100) / totalPossibleWeight`
    - Compare to `quorumThreshold`

## Weighted Voting

Each voter has a configurable weight:

```json
{
    "votingChallenges": [
        {
            "proposalId": "proposal-1",
            "quorumThreshold": "50",
            "voters": [
                { "address": "bb1abc...", "weight": "100" },
                { "address": "bb1def...", "weight": "200" },
                { "address": "bb1ghi...", "weight": "50" }
            ]
        }
    ]
}
```

**Example:**

-   Total possible weight: 350
-   Quorum threshold: 50% of 350 = 175 weight must vote "yes"

## Partial Votes

Voters can allocate a percentage to "yes" with the remainder going to "no":

| `yesWeight` | Yes % | No % |
| ----------- | ----- | ---- |
| `100`       | 100%  | 0%   |
| `70`        | 70%   | 30%  |
| `50`        | 50%   | 50%  |
| `0`         | 0%    | 100% |

## Threshold Calculation

**Important**: The threshold is calculated as a percentage of **total possible weight** (all voters), not just voters who have cast votes. Non-voting voters count as 0% yes.

**Example:**

-   Voter A: weight 100, votes 100% yes ‚Üí contributes 100 yes weight
-   Voter B: weight 200, votes 50% yes ‚Üí contributes 100 yes weight
-   Voter C: weight 50, doesn't vote ‚Üí contributes 0 yes weight
-   Total possible weight: 350
-   Quorum threshold: 50%

**Calculation:**

-   Total yes weight: 100 + 100 + 0 = 200
-   Percentage: (200 √ó 100) / 350 = 57.14%
-   Result: 57.14% ‚â• 50% ‚Üí **Challenge satisfied**

## Implementation Details

### Vote Key Format

Votes are stored with key: `collectionId-approverAddress-approvalLevel-approvalId-proposalId-voterAddress`

This scopes votes to specific collection, approver, approval level, approval ID, proposal ID, and voter.

### Vote Verification

When checking if a challenge is satisfied:

1. Retrieve all votes for voters in the challenge
2. For each voter:
    - If vote exists: calculate yes contribution `(voterWeight √ó yesWeight) / 100`
    - If no vote: contribution is 0
3. Sum all yes contributions
4. Calculate percentage: `(totalYesWeight √ó 100) / totalPossibleWeight`
5. Compare to `quorumThreshold`

## Type Definitions

```typescript
interface VotingChallenge {
    proposalId: string; // Unique ID for tracking votes
    quorumThreshold: string; // Percentage (0-100) of total weight that must vote yes
    voters: Voter[]; // List of voters with their weights
    uri?: string; // Optional metadata URI
    customData?: string; // Optional custom data
}

interface Voter {
    address: string; // Address of the voter
    weight: string; // Weight of this voter's vote
}
```

Cast votes using [MsgCastVote](../../x-badges/messages/msg-cast-vote.md).

## Use Cases

### Multi-Signature Approval

Require unanimous approval from multiple parties:

```json
{
    "votingChallenges": [
        {
            "proposalId": "multisig-1",
            "quorumThreshold": "100",
            "voters": [
                { "address": "bb1alice...", "weight": "1" },
                { "address": "bb1bob...", "weight": "1" },
                { "address": "bb1charlie...", "weight": "1" }
            ]
        }
    ]
}
```

Requires all three voters to vote 100% yes.

### Weighted Governance

Different stakeholders have different voting power:

```json
{
    "votingChallenges": [
        {
            "proposalId": "governance-1",
            "quorumThreshold": "66",
            "voters": [
                { "address": "bb1founder...", "weight": "1000" },
                { "address": "bb1investor...", "weight": "500" },
                { "address": "bb1community...", "weight": "100" }
            ]
        }
    ]
}
```

Requires 66% of total weight (1056 out of 1600) to vote yes.

### Flexible Approval

Lower threshold for partial approval:

```json
{
    "votingChallenges": [
        {
            "proposalId": "flexible-1",
            "quorumThreshold": "30",
            "voters": [
                { "address": "bb1voter1...", "weight": "100" },
                { "address": "bb1voter2...", "weight": "100" },
                { "address": "bb1voter3...", "weight": "100" }
            ]
        }
    ]
}
```

Allows approval with 30% of total weight voting yes.

## Error Conditions

The system fails if:

-   Voter is not in the challenge's voters list
-   `yesWeight` is greater than 100
-   Percentage of yes votes is less than the quorum threshold
-   `proposalId` doesn't match any voting challenge in the approval
-   Challenge has no voters or all voters have zero weight

## Security Considerations

### Proposal ID Management

Changing the `proposalId` resets the vote tracker. Use unique proposal IDs for each challenge to prevent vote overlap. Useful for rotating challenge configurations or creating new voting periods, but ensure old votes cannot be maliciously reused.

### Vote Tampering Prevention

Votes are stored on-chain and cannot be tampered with. Votes can be updated by the voter, are scoped to specific contexts (preventing cross-context reuse), and the system validates voters are in the challenge's voters list.

### Abstention Handling

Non-voting voters are treated as 0% yes (100% no). Set realistic thresholds that account for expected participation. High thresholds with many voters may be difficult to meet if voters abstain.

### Weight Distribution

Weight distribution affects security. If one voter has most of the weight, they can control approvals. Distribute weights appropriately to prevent single points of failure. Use equal weights for multi-signature scenarios.

Use the `uri` and `customData` fields to provide context about what voters are approving. Monitor vote tallies to understand approval status.


## File: ./token-standard/learn/balance-system.md

# Balances

The Balance system in BitBadges is designed to represent ownership of tokens across different IDs and time ranges. Ownership times are a new concept to BitBadges allowing you to set that someone owns a token during a specific time but not other times.

## Balance Interface

```typescript
export interface Balance<T extends NumberType> {
    amount: T;
    tokenIds: UintRange<T>[];
    ownershipTimes: UintRange<T>[];
}
```

* `amount`: The quantity of tokens owned
* `tokenIds`: An array of ID ranges representing the tokens owned
* `ownershipTimes`: An array of time ranges during which the tokens are owned

## Interpreting Balances

When interpreting balances, it's crucial to understand that multiple ranges of token IDs and ownership times within a single Balance structure represent all possible combinations.

### Interpretation Algorithm

```javascript
for (balance of balances) {
    for (tokenIdRange of balance.tokenIds) {
        for (ownershipTimeRange of balance.ownershipTimes) {
            // User owns x(balance.amount) of (tokenIdRange) for the times (ownershipTimeRange)
        }
    }
}
```

### Example

Consider the following balance:

```json
{
    "amount": 1,
    "tokenIds": [
        { "start": 1, "end": 10 },
        { "start": 20, "end": 30 }
    ],
    "ownershipTimes": [
        { "start": 20, "end": 50 },
        { "start": 100, "end": 200 }
    ]
}
```

This balance expands to:

1. 1x of IDs 1-10 from times 20-50
2. 1x of IDs 1-10 from times 100-200
3. 1x of IDs 20-30 from times 20-50
4. 1x of IDs 20-30 from times 100-200

## Balance Subtraction

When subtracting balances, you may need to represent the result as multiple Balance objects. For example, if we subtract the first set of balances from the example above (1x of IDs 1-10 from times 20-50), the result would be:

```json
[
    {
        "amount": 1,
        "tokenIds": [
            { "start": 1, "end": 10 },
            { "start": 20, "end": 30 }
        ],
        "ownershipTimes": [{ "start": 100, "end": 200 }]
    },
    {
        "amount": 1,
        "tokenIds": [{ "start": 20, "end": 30 }],
        "ownershipTimes": [{ "start": 20, "end": 50 }]
    }
]
```

## Handling Duplicates

When duplicate token IDs are specified in balances, they are combined and their amounts are added. For example:

```json
{
    "amount": 1,
    "tokenIds": [
        { "start": 1, "end": 10 },
        { "start": 1, "end": 10 }
    ],
    "ownershipTimes": [{ "start": 100, "end": 200 }]
}
```

This is equivalent to and will be treated as:

```json
{
    "amount": 2,
    "tokenIds": [{ "start": 1, "end": 10 }],
    "ownershipTimes": [{ "start": 100, "end": 200 }]
}
```

## Best Practices

1. **Efficient Representation**: Try to represent balances in the most compact form possible by combining overlapping ranges
2. **Careful Subtraction**: When subtracting balances, ensure that you correctly split the remaining balances to accurately represent the result
3. **Avoid Duplicates**: While the system handles duplicates by combining them, it's more efficient to represent balances without duplicates in the first place
4. **Time-Aware Operations**: Always consider the time dimension when performing operations on balances, as ownership can vary over time
5. **Range Calculations**: Familiarize yourself with range operations, as they are crucial for correctly manipulating and interpreting balances


## File: ./token-standard/learn/collection-setup-fields.md

# Collection Configuration

There are plenty of fields to define the core configuration for your collection during creation. These are all stored on the collection object controlled by the manager. These fields control metadata, standards, valid token IDs, custom data, and immutable invariants.

Most fields are updatable over time, according to their corresponding permissions set in the collection permissions object (e.g. canUpdateValidTokenIds, canUpdateCollectionMetadata, etc). However, some fields are immutable and cannot be changed after creation (invariants).

## Complete Example

```typescript
import { MsgCreateCollection } from 'bitbadgesjs-sdk';

const msg: MsgCreateCollection = {
    creator: 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls',
    defaultBalances: {
        balances: [],
        outgoingApprovals: [],
        incomingApprovals: [],
        autoApproveSelfInitiatedOutgoingTransfers: false,
        autoApproveSelfInitiatedIncomingTransfers: true,
        autoApproveAllIncomingTransfers: false,
        userPermissions: {
            // ... permission fields
        },
    },
    validTokenIds: [{ start: 1n, end: 100n }],
    collectionPermissions: {
        // ... permission fields
    },
    manager: 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls',
    collectionMetadata: {
        uri: 'ipfs://Qmf8xxN2fwXGgouue3qsJtN8ZRSsnoHxM9mGcynTPhh6Ub',
        customData: '',
    },
    tokenMetadata: [
        {
            uri: 'ipfs://Qmf8xxN2fwXGgouue3qsJtN8ZRSsnoHxM9mGcynTPhh6Ub/{id}',
            tokenIds: [{ start: 1n, end: 100n }],
            customData: '',
        },
    ],
    customData: 'Application-specific data',
    collectionApprovals: [
        // ... approval fields
    ],
    standards: ['Tradable', 'NFT'],
    isArchived: false,
    invariants: {
        noCustomOwnershipTimes: false,
        maxSupplyPerId: '0',
        cosmosCoinBackedPath: undefined,
        noForcefulPostMintTransfers: false,
        disablePoolCreation: false,
    },
    // ... other fields
};
```

## Valid Token IDs

`validTokenIds` defines the range of token IDs that exist within a collection. This is mainly informational but may also be used to enforce certain rules like canOverrideWithAnyValidTokenId.

Must be sequential from 1 to the total supply of the collection.

```typescript
const validTokenIds: UintRange<bigint>[] = [{ start: 1n, end: 100n }];
```

**Key points:**

-   Set during collection creation or via `MsgUpdateCollection`
-   Controlled by `canUpdateValidTokenIds` permission
-   Strongly recommended to be set at genesis and locked forever. Expanding / reducing valid token IDs is not recommended in most cases and advanced.

## Standards

`standards` provides informational tags that guide how to interpret and implement collection features. Standards are purely informational‚Äîno blockchain validation.

```typescript
const standards: string[] = ['Tradable', 'NFT', 'Cosmos Wrappable'];
```

**BitBadges Site Standards:**

-   **Tradable**: Enables trading interface, orderbook tracking, and marketplace features
-   **NFT**: Expects supply = 1 per token ID with full ownership times
-   **Cosmos Wrappable**: Can be wrapped into Cosmos SDK coin denominations
-   **Subscriptions**: Designed for recurring content delivery and subscription systems
-   **Quests**: Achievement-based systems and quest completion tracking

For more information on compatibility with the BitBadges site, please reach out.

**Important:** Standards are informational only. Applications must verify compliance.

## Collection Metadata

`collectionMetadata` defines metadata for the entire collection.

```typescript
const collectionMetadata: CollectionMetadata = {
    uri: 'ipfs://Qmf8xxN2fwXGgouue3qsJtN8ZRSsnoHxM9mGcynTPhh6Ub',
    customData: '',
};
```

**Metadata Format:** The BitBadges API expects metadata to follow this interface:

```typescript
interface Metadata {
    name: string;
    description: string;
    image: string;
}
```

**Permission Control:** Updates controlled by `canUpdateCollectionMetadata` permission.

## Token Metadata

`tokenMetadata` defines metadata for individual tokens. Uses first-match approach via linear scan for specific token IDs. We support the dynamic token ID replacement feature {id} in the URI.

```typescript
const tokenMetadata: TokenMetadata[] = [
    {
        uri: 'ipfs://Qmf8xxN2fwXGgouue3qsJtN8ZRSsnoHxM9mGcynTPhh6Ub/{id}',
        tokenIds: [{ start: 1n, end: 100n }],
        customData: '',
    },
];
```

**Key Features:**

-   **Dynamic Token ID Replacement**: URI `{id}` placeholder is replaced with actual token ID
-   **First-Match Logic**: Entries evaluated in order; first matching entry for a token ID is used, subsequent entries are ignored.
-   **Permission Control**: Updates controlled by `canUpdateTokenMetadata` permission

## Custom Data

`customData` provides generic string storage for application-specific information. Not used by BitBadges site‚Äîfor future customization and extensibility.

This is often used for application-specific implementations or contract integrations. You may also see `customData` used elsewhere like in approvals, address lists, and other structures.

```typescript
const customData: string = 'Any string value you want to store';
```

**Where Custom Data Appears:**

-   Collection-level: `customData`
-   Token metadata: `customData` within token metadata structures
-   Address lists: `customData` for list-specific information
-   Messages: Various transaction messages include custom data fields

**Permission Control:** Updates controlled by `canUpdateCustomData` permission.

## Default Balances

`defaultBalances` are predefined balance stores automatically assigned to new users (uninitialized balance stores) when they first interact with a collection. Set during collection creation only‚Äîcannot be updated after genesis.

This is not often used but can be useful for certain use cases:

-   Blocking incoming transfers by default (enforcing opt-in only restrictions)
-   Default starting balances for all users
-   Default approval settings for all users

```typescript
const defaultBalances: UserBalanceStore<bigint> = {
    balances: [],
    outgoingApprovals: [],
    incomingApprovals: [],
    autoApproveSelfInitiatedOutgoingTransfers: false,
    autoApproveSelfInitiatedIncomingTransfers: true,
    autoApproveAllIncomingTransfers: false,
    userPermissions: {
        // ... permission fields
    },
};
```

**Important Limitations:**

-   **No complex approval criteria**: Cannot include any approvals not compatible with auto-scan mode. See [Auto-Scan and Prioritized Approvals](../../x-badges/learn/auto-scan-and-prioritized-approvals.md) for more information.

**Key points:**

-   Creation-only field‚Äîset once during collection creation
-   Establishes baseline behavior for all new users
-   Users can customize their own approval settings after initialization

## IsArchived

`isArchived` controls whether a collection is archived, temporarily or permanently disabling all transactions while keeping collection data verifiable and public on-chain.

This is a collection-level option that can be used to temporarily or permanently disable all transactions until unarchived. Controlled by the manager. Useful for pausing, halts, or other maintenance operations.

Note that there are also other ways to implement halting logic which may be better suited for your use case.

-   Chain-level x/circuit breakers
-   Dynamic stores / token ownership requirements that can be controlled by another entity

```typescript
const isArchived: boolean = false;
```

**Transaction Behavior:**

-   **When archived**: All transactions fail (no updates, transfers, or changes allowed). Read operations continue. Only unarchiving transactions can succeed.
-   **When unarchived**: Normal operations resume. All collection data remains intact. Standard permission checks apply.

**Permission Control:** Updates controlled by `canArchiveCollection` permission. Note that this permission controls the updatability of the `isArchived` field, not the current archive status. You can lock the archive status forever (either `true` or `false`) by permanently forbidding updates.

## Invariants

`invariants` are immutable rules set upon collection creation that cannot be broken or modified afterward. They enforce fundamental constraints on collection behavior.

```typescript
const invariants: CollectionInvariants<bigint> = {
    noCustomOwnershipTimes: false,
    maxSupplyPerId: '0',
    cosmosCoinBackedPath: undefined,
    noForcefulPostMintTransfers: false,
    disablePoolCreation: false,
};
```

### Available Invariants

**noCustomOwnershipTimes**

-   Enforces all ownership times must be full ranges `[{ start: 1n, end: 18446744073709551615n }]` for all time-dependent structures - balances, approvals, etc.
-   Prevents time-based restrictions on token ownership
-   Affects collection approvals, user approvals, and transfer balances
-   Typically recommended to be set to true if you do not need such functionality.

**maxSupplyPerId**

-   Maximum supply per token ID (string-based uint64)
-   Prevents any balance amount from exceeding the specified maximum
-   Zero value means no enforcement
-   Sanity check to enforce a minting cap. Should NOT replace proper approval design.

**cosmosCoinBackedPath**

-   IBC backed (sdk.coin) path for the collection
-   Only one path allowed per collection
-   See [IBC Backed Minting Invariants](../../learn/ibc-backed-minting.md) for details

**noForcefulPostMintTransfers**

-   Disallows collection approvals with `overridesFromOutgoingApprovals` or `overridesToIncomingApprovals` set to `true` (excluding the Mint address which is exempt)
-   Prevents forceful transfers that bypass user-level approvals
-   Easy way for you to enforce that there will never be any forceful transfers that bypass user-level approvals ever in your collection.

**disablePoolCreation**

-   Prevents creation of liquidity pools using assets from this collection in our gamm module.
-   When enabled, pool creation attempts will fail

**Important:** Invariants can only be set during collection creation and cannot be updated or removed afterward.


## File: ./token-standard/learn/uintrange.md

# UintRanges

The `UintRange` is the fundamental data structure used throughout the tokens module to represent inclusive ranges of unsigned integers efficiently. This type enables powerful range-based operations and is primarily used for token IDs, time ranges, and amounts.

## Proto Definition

```protobuf
message UintRange {
  string start = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string end = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

## Usage Patterns

UintRanges are used to represent:

* **Token ID ranges**: `[1-100]` represents token IDs 1 through 100 (inclusive)
* **Time ranges**: `[1640995200000-1672531200000]` represents a year in UNIX milliseconds
* **Amount ranges**: `[1-5]` represents quantities from 1 to 5
* **Ownership time ranges**: When tokens are valid for ownership

## Restrictions & Valid Values

Unless otherwise specified, we only allow numbers in the ranges to be from **1 to Go Max UInt64**:

* **Valid range**: 1 to 18446744073709551615 (Go's `math.MaxUint64`)
* **Zero and negative values**: Not allowed
* **Values greater than maximum**: Not allowed

## Validation Rules

* `start` must be ‚â§ `end`
* Ranges in the same array cannot overlap
* Zero amounts are not allowed in balance ranges
* All values must be within the valid range (1 to MaxUint64)

## Special Cases

### Full Range

To represent a complete range covering all possible values:

```protobuf
// Full range from 1 to maximum
{
  start: "1",
  end: "18446744073709551615"
}
```

### Single Value

To represent a single value, use the same value for start and end:

```protobuf
// Single token ID 5
{
  start: "5",
  end: "5"
}
```

### Range Inversion

Inverting a range results in all values from 1 to 18446744073709551615 that are **not** in the current range. This is useful for exclusion logic.

## Examples

### Token ID Examples

```typescript
// Token IDs 1-10 (inclusive)
const badgeRange: UintRange[] = [{ start: '1', end: '10' }];

// Multiple non-overlapping ranges
const multipleBadges: UintRange[] = [
    { start: '1', end: '10' },
    { start: '20', end: '50' },
];
```

### Go Code Examples

```go
// Token IDs 1-10
tokenIdRange := UintRange{Start: NewUint(1), End: NewUint(10)}

// Unlimited amount
unlimitedAmount := UintRange{Start: NewUint(1), End: MaxUint}

// Single token ID
singleBadge := UintRange{Start: NewUint(5), End: NewUint(5)}
```

## Efficiency Benefits

* **Compact representation**: Ranges avoid storing individual values
* **Range operations**: Efficient intersection, union, and containment checks
* **Gas optimization**: Reduces transaction size and computational costs
* **Scalability**: Handles large ranges without performance degradation


## File: ./token-standard/messages/msgsettokenmetadata.md

# MsgSetTokenMetadata



## File: ./token-standard/pre-readings.md

# üìî Pre-Readings

Before diving deep into the behind the scenes of our token standard, we encourage you to do two things.

1\) Explore the landing and explore page ([https://bitbadges.io](https://bitbadges.io\)/)) in our site to get an idea of what is possible! Also, go through the create flow to see what all is possible! At the end of the create flow, you can click on the Show Tx button to see what the JSON transaction looks like behind the scenes.

<figure><img src="../.gitbook/assets/image (403).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../.gitbook/assets/image (406).png" alt=""><figcaption></figcaption></figure>

2\) For a full A-Z description of what BitBadges is and why we built it, read this:

{% content-ref url="../overview/what-is-bitbadges.md" %}
[what-is-bitbadges.md](../overview/what-is-bitbadges.md)
{% endcontent-ref %}

3\) How does BitBadges transferability work from a high-level?

**Mint Address**

The Mint address has unlimited balances. Any 'Mint' creates a token out of thin air.

**Circulating Supply**

The circulating supply is not a static number but rather the total amount of tokens transferred from the Mint address. Set approvals and permissions accordingly.

**Collection Approvals (Transferability)**

Collection approvals (minting and post-minting) define the overall rules for the collection. All transfers must always obey a collection approval. This gives you overarching control about the transferability of the collection. Examples: freezability, non-transferable, revoking, etc.

**User-Level Approvals**

The sender / receiver can also set user-level approvals that must be satisfied by default to gate who can send on their behalf or send to them.

These can be skipped / forcefully overriden by the collection-level approvals (for implementing forceful functionality like freezing, etc).

**What is checked on each transfer?**

Each transfer must have sufficient balances, satisfy a collection approval, and satisfy user-level approvals if not overridden.

<figure><img src="../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./x-badges/README.md

# üìö Overview

This directory contains comprehensive developer documentation for the BitBadges blockchain's `x/badges` module.

> üí° **Note:** For most development, you may actually not need to know many of the underlying details of x/badges that we describe in this section. For example, you may only need high-level API getters like fetching balances and metadata as well as the no-code Create tab in the BitBadges site.

## Table of Contents

1. [Concepts](../learn/)- Core data structures and business logic
2. [Messages](messages/) - Transaction messages and handlers
3. [Queries](queries/) - Query types and endpoints
4. [Examples](examples/) - Common usage patterns and building blocks

## Main Features

-   No code, no smart contracts - All implemented as a Cosmos module
-   1000x transferability customization for whatever requirements you may need
-   Three transferability levels enforced for as much or as little customization as needed (collection-level, sender, recipient approvals)
-   Seamless compatibility for checking off-chain criteria like in the BitBadges site where you can gate mints by 7000+ no-code plugins
-   Supports any IBC currency
-   IBC interoperable through wrapping to x/bank IBC denoms
-   Transferability is checked EVERY transfer on-chain, enforcing compliance seamlessly at the protocol level
-   Extendible with smart contract frameworks

## Message Reference

### Collection Management

-   [MsgCreateCollection](messages/msg-create-collection.md) - Create new collection
-   [MsgUpdateCollection](messages/msg-update-collection.md) - Update existing collection
-   [MsgUniversalUpdateCollection](messages/msg-universal-update-collection.md) - Universal create/update interface with invariants support
-   [MsgDeleteCollection](messages/msg-delete-collection.md) - Delete collection

### Token Transfers

-   [MsgTransferTokens](messages/msg-transfer-tokens.md) - Transfer tokens between addresses

### User Approvals

-   [MsgUpdateUserApprovals](messages/msg-update-user-approvals.md) - Update transfer approvals
-   [MsgCastVote](messages/msg-cast-vote.md) - Cast or update votes for voting challenges

### Address Lists & Dynamic Stores

-   [MsgCreateAddressLists](messages/msg-create-address-lists.md) - Create reusable address lists
-   [MsgCreateDynamicStore](messages/msg-create-dynamic-store.md) - Create boolean store
-   [MsgUpdateDynamicStore](messages/msg-update-dynamic-store.md) - Update dynamic store properties
-   [MsgDeleteDynamicStore](messages/msg-delete-dynamic-store.md) - Delete dynamic store
-   [MsgSetDynamicStoreValue](messages/msg-set-dynamic-store-value.md) - Set boolean values for addresses
-   [More messages...](messages/) - See full message reference

## Query Reference

### Core Queries

-   [GetCollection](queries/get-collection.md) - Retrieve collection data
-   [GetBalance](queries/get-balance.md) - Get user balances
-   [GetApprovalTracker](queries/get-approval-tracker.md) - Get approval usage data
-   [GetAddressList](queries/get-address-list.md) - Retrieve address list
-   [More queries...](queries/) - See full query reference

## Quick Links

-   [BitBadges Chain Repository](https://github.com/bitbadges/bitbadgeschain)
-   [BitBadges Documentation](https://docs.bitbadges.io)
-   [Proto Definitions](https://github.com/bitbadges/bitbadgeschain/tree/master/proto/badges)

## Documentation Style

This documentation follows the [Cosmos SDK module documentation standards](https://docs.cosmos.network/main/building-modules/README) and is designed for developers building on or integrating with the BitBadges blockchain.


## File: ./x-badges/concepts/approval-criteria/alt-time-checks.md

# Alt Time Checks

Alternative time-based checks for approval denial. If the transfer time falls within any of the specified offline hours or days, the approval is denied.

## Interface

```typescript
interface AltTimeChecks {
    /** Hours (0-23) when transfers should be denied. Uses UTC timezone. */
    offlineHours?: UintRange[];
    /** Days (0-6, where 0=Sunday, 1=Monday, ..., 6=Saturday) when transfers should be denied. Uses UTC timezone. */
    offlineDays?: UintRange[];
}

interface ApprovalCriteria<T extends NumberType> {
    altTimeChecks?: AltTimeChecks;
}
```

## How It Works

Alt time checks provide an additional layer of time-based restrictions beyond the standard `transferTimes` field. While `transferTimes` defines when transfers are **allowed**, `altTimeChecks` defines when transfers are **denied** based on the hour of day or day of week.

### Timezone

All time checks use **UTC timezone** for a neutral, timezone-independent approach. This ensures consistent behavior regardless of where users or validators are located.

### Offline Hours

The `offlineHours` field specifies ranges of hours (0-23) when transfers should be denied:

-   **0** = Midnight (00:00 UTC)
-   **23** = 11 PM (23:00 UTC)
-   Ranges are inclusive (e.g., `{start: 22, end: 2}` covers 22:00, 23:00, 00:00, 01:00, 02:00 UTC)

### Offline Days

The `offlineDays` field specifies ranges of days (0-6) when transfers should be denied:

-   **0** = Sunday
-   **1** = Monday
-   **2** = Tuesday
-   **3** = Wednesday
-   **4** = Thursday
-   **5** = Friday
-   **6** = Saturday

## Evaluation Logic

The approval is **denied** if the transfer time falls within **any** of the specified offline hours or days:

1. Check if the current UTC hour falls within any `offlineHours` range
2. Check if the current UTC day of week falls within any `offlineDays` range
3. If either condition is true, the approval is denied

## Examples

### Block Transfers During Night Hours

Prevent transfers between 10 PM and 6 AM UTC:

```json
{
    "approvalCriteria": {
        "altTimeChecks": {
            "offlineHours": [{ "start": "22", "end": "5" }]
        }
    }
}
```

This blocks transfers from 22:00 UTC (10 PM) through 05:00 UTC (5 AM), covering the night hours.

## Relationship to Transfer Times

Alt time checks work **in addition to** the standard `transferTimes` field:

1. First, the transfer time must fall within the `transferTimes` ranges (if specified)
2. Then, the transfer time must **not** fall within any `offlineHours` or `offlineDays` ranges

If either condition fails, the approval is denied.

## Constraints

-   Hour values must be in the range **0-23** (inclusive)
-   Day values must be in the range **0-6** (inclusive), where 0=Sunday, 6=Saturday
-   All time checks use **UTC timezone**
-   Ranges within the same array should not overlap (though overlapping ranges will still work, they may be redundant)
-   If both `offlineHours` and `offlineDays` are specified, the approval is denied if **either** condition matches


## File: ./x-badges/concepts/approval-criteria/must-prioritize.md

# Must Prioritize

Control whether an approval requires explicit prioritization in transfer requests or can be used in auto-scan mode.

## Interface

```typescript
interface ApprovalCriteria<T extends NumberType> {
    mustPrioritize?: boolean;
}
```

## How It Works

The `mustPrioritize` field determines how an approval can be used during transfer evaluation:

### `mustPrioritize: true` (Required Prioritization)

When set to `true`, the approval **must** be explicitly specified in the `prioritizedApprovals` field of `MsgTransferTokens`. The transfer will fail if:

-   The approval is not included in `prioritizedApprovals`
-   The specified version doesn't match the current approval version
-   The approval doesn't match the transfer criteria

### `mustPrioritize: false` or `undefined` (Auto-Scan Compatible)

When set to `false` or not specified, the approval can be used in **auto-scan mode** if other auto-scan criteria are met:

-   The approval has [Empty Approval Criteria](../examples/empty-approval-criteria.md) (no side effects)
-   No custom logic or side effects are present
-   The transfer doesn't require explicit version control

## Use Cases

### Requiring Explicit Prioritization

Use `mustPrioritize: true` when you need:

-   **Version Control**: Ensure users are aware of the exact approval version they're using
-   **Side Effects**: Approvals with coin transfers, custom logic, or other side effects
-   **Deterministic Behavior**: Guarantee which approval will be used for the transfer
-   **Security**: Prevent accidental use of the wrong approval

### Allowing Auto-Scan

Use `mustPrioritize: false` (or omit) when:

-   **Simple Transfers**: No side effects or custom logic
-   **User Convenience**: Allow automatic approval selection
-   **Empty Criteria**: Using [Empty Approval Criteria](../examples/empty-approval-criteria.md)

## Examples

### Required Prioritization

An approval that requires explicit prioritization:

```json
{
    "approvalCriteria": {
        "mustPrioritize": true,
        "coinTransfers": [
            {
                "coins": [
                    {
                        "denom": "ubadge",
                        "amount": "1000000"
                    }
                ],
                "toAddress": "bb1..."
            }
        ]
    }
}
```

**Transfer must include**:

```typescript
{
    "prioritizedApprovals": [
        {
            "approvalId": "reward-approval",
            "approvalLevel": "collection",
            "approverAddress": "",
            "version": "1" // Must match current version
        }
    ],
    "onlyCheckPrioritizedCollectionApprovals": true
}
```

### Auto-Scan Compatible

An approval that can be auto-scanned:

```json
{
    "approvalCriteria": {
        "mustPrioritize": false
        // ... empty approval criteria with no side effects
    }
}
```

**Transfer can use auto-scan**:

```typescript
{
    "prioritizedApprovals": [], // Empty - will auto-scan
    // System will automatically find and use matching approval
}
```

## Relationship to Auto-Scan Mode

The `mustPrioritize` field works in conjunction with the auto-scan system:

### Auto-Scan Mode

-   **Default behavior**: System automatically scans approvals
-   **Works with**: Approvals where `mustPrioritize: false` or `undefined`
-   **Requires**: [Empty Approval Criteria](../examples/empty-approval-criteria.md) (no side effects)
-   **No versioning**: System handles approval selection automatically

### Prioritized Mode

-   **Explicit selection**: User must specify approvals in `prioritizedApprovals`
-   **Required for**: Approvals where `mustPrioritize: true`
-   **Version control**: Must specify exact approval version
-   **Deterministic**: Guarantees which approval will be used

## Important Notes

-   **Default Behavior**: If `mustPrioritize` is not specified, it defaults to `false` (auto-scan compatible)
-   **Side Effects**: Approvals with side effects (coin transfers, custom logic) should typically use `mustPrioritize: true`
-   **Race Conditions**: Using `mustPrioritize: true` with version control prevents race conditions from approval updates
-   **Transfer Flags**: When using prioritized approvals, set `onlyCheckPrioritizedCollectionApprovals` (or corresponding flags) to `true` for deterministic behavior


## File: ./x-badges/concepts/ibc-backed-paths.md

# IBC Backed Paths

## Overview

IBC Backed Paths enable bidirectional conversion between badge tokens and IBC coins (standard Cosmos SDK coins). This feature allows badge collections to be "backed" by IBC-denominated tokens, enabling seamless interoperability between the badge system and the broader Cosmos ecosystem.

## Core Concept

An IBC Backed Path creates a special address that acts as an intermediary for converting badge tokens to and from IBC coins. When configured, users can:

-   **Back tokens**: Send badge tokens to the special address and receive IBC coins in return
-   **Unback tokens**: Send IBC coins to the special address and receive badge tokens in return

## Key Components

### Special Address

Each IBC backed path has a **special address** that is automatically generated based on the IBC denomination. This address:

-   Is deterministically derived from the IBC denom using a hash function
-   Acts as the intermediary for all conversions
-   Is marked as a reserved protocol address
-   Holds the IBC coins that back the badge tokens

### Configuration Structure

```protobuf
message CosmosCoinBackedPath {
  string address = 1;              // Auto-generated special address (from conversion.sideA.denom)
  Conversion conversion = 2;       // Conversion structure with sideA (amount+denom) and sideB (balances)
}

message Conversion {
  ConversionSideAWithDenom sideA = 1;  // Contains amount + denom (from old ibcAmount + ibcDenom)
  repeated Balance sideB = 2;          // Badge token balances (from old balances field)
}

message ConversionSideAWithDenom {
  string amount = 1;  // IBC coin amount (from old ibcAmount)
  string denom = 2;   // IBC denomination (from old ibcDenom)
}
```

### Conversion Mechanism

The conversion uses a structured format that combines the IBC denom and amount:

```
conversion.sideA (amount, denom) = conversion.sideB[] (x/badges)
Ex: { amount: "1000000", denom: "ibc/1234..." } = [{ amount: 1n, tokenIds: [{ start: 1n, end: 1n }], ownershipTimes: UintRangeArray.FullRanges() }]
```

## Transferability Requirements

Even though this is a special address, it is still subject to the same transferability requirements as any other address. This means that you can user-gate, rate-limit, or anything else you can do with an address and its transferability.

**Important:** Collection approvals used for IBC backed path operations must have `allowBackedMinting: true` set in their `approvalCriteria`. See [Special Address Flags](../../token-standard/learn/approval-criteria/special-address-flags.md) for details.

This allows you to build complex minting / unwinding logic. For example:

-   $2500 per day withdrawal limit
-   Must KYC on way out
-   Or any other logic you can think of

Behind the scenes, think of this address as an external contract that updates its approvals dynamically. So, swaps are technically treated as initiated by the user but approved by the address itself.

## Configuration Requirements

### Collection Invariants

IBC backed paths are configured as **collection invariants**, meaning:

-   They can only be set during collection creation
-   They cannot be modified after creation
-   Only **one** backed path is allowed per collection

## Restrictions and Limitations

### Mint Address Restrictions

When an IBC backed path is configured:

-   Transfers **from** the Mint address are not allowed
-   All mints must be done through the IBC backed path
-   Collection approvals cannot include the Mint address in `FromListId`
-   This prevents minting tokens that would bypass the backing mechanism and cause desyncs in the system

## Technical Implementation

### Address Detection

The system automatically detects when transfers involve the special address:

-   Checks if `to` address matches the backed path address (backing)
-   Checks if `from` address matches the backed path address (unbacking)
-   Triggers the appropriate conversion logic

Note this is done from our MsgTransferTokens implementation as the entrypoint. Simply using the bank module to detect the address will not work as the bank module does not know about the IBC backed path.

### State Management

-   Badge token balances are managed normally
-   IBC coin balances are managed via the bank module
-   Special address holds IBC coins for backing operations
-   Special address technically has unlimited badge balances but only allows transfers when adequate IBC coins are present and sent or received

## Example Configuration

```json
{
    "invariants": {
        "cosmosCoinBackedPath": {
            "conversion": {
                "sideA": {
                    "amount": "1000000",
                    "denom": "ibc/1234567890ABCDEF"
                },
                "sideB": [
                    {
                        "amount": "1",
                        "tokenIds": [{ "start": "1", "end": "1" }],
                        "ownershipTimes": [
                            { "start": "1", "end": "18446744073709551615" }
                        ]
                    }
                ]
            }
        }
    }
}
```

## Security Considerations

### Reserved Protocol Address

The special address is automatically marked as a reserved protocol address:

-   Prevents accidental use in other contexts
-   Ensures proper handling by the system
-   Maintains address integrity

### Atomic Operations

All conversions are atomic:

-   Either the entire operation succeeds or fails
-   No partial conversions
-   Maintains balance consistency

## Differences from Wrapper Paths

IBC backed paths differ mainly from which IBC denom is used for minting.

| Feature | IBC Backed Path                              | Wrapper Path                             |
| ------- | -------------------------------------------- | ---------------------------------------- |
| Minting | No minting/burning (uses existing IBC denom) | Minting/burning of generated denom (new) |

## Summary

IBC Backed Paths provide a powerful mechanism for connecting badge tokens to the broader Cosmos ecosystem through IBC coins. By enabling bidirectional conversion between badges and IBC-denominated assets, they unlock cross-chain interoperability, DeFi integration, and liquidity provision while maintaining the unique features and capabilities of the badge system.


## File: ./x-badges/concepts/manager.md

# Manager

The manager is the central authority for a collection, controlling all administrative operations and having exclusive rights to perform updates, deletions, and other management tasks.

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

## Manager

### Structure

```json
"manager": "bb1alice..."
```

## Manager Permissions

The manager role can be granted various permissions, allowing for flexible administration of the collection. These permissions include:

### Core Administrative Permissions

1. **Collection Deletion** - The ability to permanently remove the collection from the system
2. **Collection Archiving** - Archive a collection, making it read-only and rejecting all transactions until unarchived
3. **Core Collection Updates** - Modifying essential details such as metadata URLs and collection standards
4. **Manager Role Transfer** - The ability to pass the manager role to another address
5. **Token Creation** - Permission to mint additional tokens within the collection
6. **Custom Permissions** - Collection-specific permissions depending on setup

### Metadata Management

-   **Collection Metadata Updates** - Modify collection-level metadata and URIs
-   **Token Metadata Updates** - Update individual token metadata (with token-specific permissions)
-   **Metadata Management** - Update collection and token metadata

### Transferability Control

-   **Approval Settings** - Modify the collection's approval settings that determine how tokens can be transferred
-   **Transfer Rules** - Update transferability conditions and restrictions
-   **Permission Updates** - Configure transferability permissions

### Off-Chain Management

-   **Off-chain Balance Management** - For collections using off-chain balance storage, managers can update these balances
-   **External Integrations** - Manager role can extend to off-chain functionalities and custom utilities

### User-Level Operation Limits

The manager cannot directly:

-   Modify user balances (must follow approval system)
-   Access user private keys or personal data

## Fine-Grained Permission Customizability

One of the key features of the manager role in BitBadges is the ability to customize permissions at a granular level. This allows for precise control over the collection's management.

Permissions can be customized based on various factors:

### Permission Dimensions

-   **Token Specificity** - Which particular tokens within the collection can be affected
-   **Time Constraints** - When can certain actions be performed
-   **Value Limitations** - What specific values or ranges are allowed for updates
-   **Conditional Triggers** - Under what circumstances can certain permissions be exercised

### Permission States

Each permission can exist in one of three states:

1. **Forbidden + Permanently Frozen**
    - The permission is permanently disallowed
    - This state cannot be changed, ensuring certain actions remain off-limits indefinitely
2. **Permitted + Not Frozen**
    - The permission is currently allowed
    - This state can be changed to either of the other two states, offering flexibility in management
3. **Permitted + Permanently Frozen**
    - The permission is permanently allowed
    - Like the first state, this cannot be changed, ensuring certain capabilities always remain available

**Note**: There is no "Forbidden + Not Frozen" state because such a state could theoretically be updated to "Permitted" at any time and then immediately executed, effectively making it a "Permitted" state.

## Permission Control Examples

### Manager Updates

Manager updates are controlled by the `canUpdateManager` permission:

```json
"canUpdateManager": [
  {
    "permanentlyPermittedTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyForbiddenTimes": []
  }
]
```

## Usage Examples

### Setting Initial Manager

During collection creation:

```json
{
    "creator": "bb1alice...",
    "manager": "bb1alice...",
    "collectionPermissions": {
        "canUpdateManager": [
            {
                "permanentlyPermittedTimes": [
                    { "start": "1", "end": "18446744073709551615" }
                ],
                "permanentlyForbiddenTimes": []
            }
        ]
    }
}
```


## File: ./x-badges/concepts/total-supply.md

# Total Supply

The total circulating supply is not a fixed value but rather dynamically determined through the collection approvals and permissions. The total supply is the sum of all the tokens that have been transferred from the Mint address (which has unlimited balances). Setting the Mint approvals and using them determines the total supply. Permissions are used to control the ability to set, update, or delete the Mint approvals by the manager.


## File: ./x-badges/examples/README.md

# üí° Examples and Snippets

This directory contains practical examples and building blocks for x/badges.

## Contents

* [Base Collection Configuration](base-collection-details.md) - Standard base collection configuration template
* [Empty Approval Criteria](empty-approval-criteria.md) - Template for unrestricted approval criteria
* [Defining Circulating Supply](defining-circulating-supply.md) - How to define and lock circulating supply
* [Building Collection Approvals](building-collection-approvals.md) - Guide to building collection-level approvals
* [Building User Approvals](building-user-approvals.md) - Guide to building user-level incoming and outgoing approvals
* [Building Collection Permissions](building-collection-permissions.md) - Guide to configuring collection permissions
* [Building User Permissions](building-user-permissions.md) - Guide to configuring user-level permissions
* [Cosmos Coin Wrapper Example](cosmos-coin-wrapper-example.md) - Example of wrapping tokens as Cosmos coins
* [Mint All to Self Tutorial](mint-all-to-self-tutorial.md) - Tutorial for creating collection and minting tokens to yourself
* [Approvals](approvals/) - Common approval patterns and examples
  * [Transferable Approval](approvals/transferable-approval.md) - Basic transferable approval configuration
  * [Burnable Approval](approvals/burnable-approval.md) - Approval allowing tokens to be burned
  * [Cosmos Wrapper Approval](approvals/cosmos-wrapper-approval.md) - Approval for wrapping tokens as Cosmos coins
  * [Cosmos Unwrapper Approval](approvals/cosmos-unwrapper-approval.md) - Approval for unwrapping Cosmos coins back to tokens
  * [Admin Override Approval](approvals/admin-override-approval.md) - Admin approval that overrides user-level restrictions
* [Permissions](permissions/) - Common permission patterns and examples
* [Transactions](txs/) - Full transaction examples
  * [MsgCreateCollection](txs/msgcreatecollection/) - Complete transaction examples for creating collections


## File: ./x-badges/examples/approvals/admin-override-approval.md

# Admin Override Approval

This example demonstrates how to create an approval that allows a specific address to forcefully transfer tokens, overriding all user-level approvals. This provides complete administrative control for emergency situations or management purposes.

## Overview

An admin override approval grants a specific address the power to:

* Transfer tokens from any address to any address
* Override user-level incoming and outgoing approvals
* Bypass normal approval restrictions
* Maintain complete administrative control

‚ö†Ô∏è **Warning**: This approval type grants significant power and should be used carefully with trusted addresses only.

## Code Example

```typescript
const approveSelfForcefully = (address: string) => {
    const id = 'complete-admin-control';

    return {
        fromListId: 'Mint',
        toListId: 'All',
        initiatedByListId: address,
        transferTimes: UintRangeArray.FullRanges(),
        tokenIds: UintRangeArray.FullRanges(),
        ownershipTimes: UintRangeArray.FullRanges(),
        approvalId: id,
        version: 0n,
        approvalCriteria: {
            ...EmptyApprovalCriteria,
            overridesFromOutgoingApprovals: true,
            overridesToIncomingApprovals: true,
        },
    };
};
```


## File: ./x-badges/examples/approvals/burnable-approval.md

# Burnable Approval

This example demonstrates how to create a burnable approval that allows tokens to be sent to the burn address, effectively removing them from circulation.

## Overview

A burnable approval enables tokens to be permanently destroyed by sending them to the zero address.

## Code Example

```typescript
const burnableApproval = new CollectionApproval({
    fromListId: '!Mint', // Excludes the Mint address
    toListId: 'bb1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs7gvmv', // Burn address (bb-prefixed)
    initiatedByListId: 'All',
    transferTimes: UintRangeArray.FullRanges(),
    ownershipTimes: UintRangeArray.FullRanges(),
    tokenIds: UintRangeArray.FullRanges(),
    approvalId: 'burnable-approval',
    version: 0n,
    approvalCriteria: undefined, // No additional restrictions
});
```


## File: ./x-badges/examples/approvals/cosmos-unwrapper-approval.md

# Cosmos Unwrapper Approval

This example demonstrates how to create an approval that allows the Cosmos coin wrapper address to send tokens back to users, enabling conversion from Cosmos coins back to tokens (unwrapping).

You pretty much: 1) figure out your address and 2) figure out a path that users can send from this address without needing the address to control its approvals.

Full example: [Cosmos Coin Wrapper Example](broken-reference/)

## Code Example

```typescript
export const unwrapperApproval = ({
    specialAddress,
    tokenIds,
    ownershipTimes,
    approvalId,
}: {
    specialAddress: string;
    tokenIds: iUintRange<bigint>[];
    ownershipTimes: iUintRange<bigint>[];
    approvalId: string;
}): RequiredApprovalProps => {
    const id = approvalId;
    const toSet: RequiredApprovalProps = {
        version: 0n,
        fromListId: specialAddress,
        fromList: AddressList.getReservedAddressList(specialAddress),
        toListId: 'All',
        toList: AddressList.AllAddresses(),
        initiatedByListId: 'All',
        initiatedByList: AddressList.AllAddresses(),
        transferTimes: UintRangeArray.FullRanges(),
        tokenIds: tokenIds,
        ownershipTimes: ownershipTimes,
        approvalId: id,
        approvalCriteria: {
            ...EmptyApprovalCriteria,
            allowSpecialWrapping: true, // Required for wrapper path operations
            overridesFromOutgoingApprovals: true,
        },
    };

    return toSet;
};
```


## File: ./x-badges/examples/approvals/cosmos-wrapper-approval.md

# Cosmos Wrapper Approval

This example demonstrates how to create an approval that allows tokens to be sent to a Cosmos coin wrapper address, enabling conversion to native Cosmos SDK coins.

You pretty much: 1) figure out your address and 2) figure out a path that users can send to this address without needing the address to control its approvals. Oftentimes, you may not even need to forcefully override the incoming approvals because you default allow all incoming transfers which also applies to the wrapper address automatically.

Full example: [Cosmos Coin Wrapper Example](broken-reference/)

## Code Example

```typescript
export const wrapperApproval = ({
    specialAddress,
    tokenIds,
    ownershipTimes,
    approvalId,
}: {
    specialAddress: string;
    tokenIds: iUintRange<bigint>[];
    ownershipTimes: iUintRange<bigint>[];
    approvalId: string;
}): RequiredApprovalProps => {
    const id = approvalId;
    const toSet: RequiredApprovalProps = {
        version: 0n,
        toListId: specialAddress,
        toList: AddressList.getReservedAddressList(specialAddress),
        fromListId: 'AllWithoutMint',
        fromList: AddressList.getReservedAddressList('AllWithoutMint'),
        initiatedByListId: 'All',
        initiatedByList: AddressList.AllAddresses(),
        transferTimes: UintRangeArray.FullRanges(),
        tokenIds: tokenIds,
        ownershipTimes: ownershipTimes,
        approvalId: id,
        approvalCriteria: {
            ...EmptyApprovalCriteria,
            allowSpecialWrapping: true, // Required for wrapper path operations
            overridesToIncomingApprovals: true,
        },
    };

    return toSet;
};
```


## File: ./x-badges/examples/approvals/transferable-approval.md

# Transferable Approval

This example demonstrates how to create a basic transferable approval that allows tokens to be freely transferred between any users after minting.

## Overview

A transferable approval enables tokens to be moved between addresses without restrictions.

## Code Example

```typescript
const transferableApproval = new CollectionApproval({
    fromListId: '!Mint', // Excludes the Mint address
    toListId: 'All',
    initiatedByListId: 'All',
    transferTimes: UintRangeArray.FullRanges(),
    ownershipTimes: UintRangeArray.FullRanges(),
    tokenIds: UintRangeArray.FullRanges(),
    approvalId: 'transferable-approval',
    version: 0n,
    approvalCriteria: undefined, // No additional restrictions
});
```


## File: ./x-badges/examples/base-collection-details.md

# Base Collection Details

BitBadges collections are very expressive but also can lead to verbose configurations. We will provide additional examples in this section but also refer you to the corresponding concepts section for more details on any specific field.

### Reference Links

For detailed information about each field, see the corresponding concepts documentation:

| Field                         | Concepts Link                                                                                            |
| ----------------------------- | -------------------------------------------------------------------------------------------------------- |
| `validTokenIds`               | [Collection Setup Fields](../../token-standard/learn/collection-setup-fields.md)                         |
| `manager`                     | [Manager / Permissions](../../learn/permissions.md)                                                      |
| `collectionMetadata`          | [Collection Setup Fields](../../token-standard/learn/collection-setup-fields.md)                         |
| `tokenMetadata`               | [Collection Setup Fields](../../token-standard/learn/collection-setup-fields.md)                         |
| `customData`                  | [Collection Setup Fields](../../token-standard/learn/collection-setup-fields.md)                         |
| `standards`                   | [Collection Setup Fields](../../token-standard/learn/collection-setup-fields.md)                         |
| `isArchived`                  | [Collection Setup Fields](../../token-standard/learn/collection-setup-fields.md)                         |
| `defaultBalances`             | [Collection Setup Fields](../../token-standard/learn/collection-setup-fields.md)                         |
| `mintEscrowCoinsToTransfer`   | [Coin Transfers](../../token-standard/learn/approval-criteria/usdbadge-transfers.md#mint-escrow-address) |
| `cosmosCoinWrapperPathsToAdd` | [Cosmos Coin Wrapper Paths](../../learn/cosmos-coin-wrapper-paths.md)                                    |

## Base Collection Details

For most collections, your base configuration for these fields will be very similar to this. Note that this excludes collection permissions and approvals. See the [Building Collection Approvals](building-collection-approvals.md) example and [Building Collection Permissions](building-collection-permissions.md) example for these.

```typescript
const BaseCollectionDetails = {
    validTokenIds: [
        {
            start: '1',
            end: '100', // Set to your max ID
        },
    ],
    manager: 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls', // Set to your address
    collectionMetadata: {
        uri: 'ipfs://QmSTZZPgYF58gS9bM7q3nWVegUJH51WBdT91fz7q94qDwS', // Points to a valid .json metadata file
        customData: '',
    },
    tokenMetadata: [
        {
            uri: 'ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/{id}', // Points to a valid .json metadata file (replacing {id} with the token ID)
            tokenIds: [
                {
                    start: '1',
                    end: '100',
                },
            ],
            customData: '',
        },
        // You can have multiple entries. This is useful for placeholder metadata.
        {
            uri: 'ipfs://QmSTZZPgYF58gS9bM7q3nWVegUJH51WBdT91fz7q94qDwS', // Placeholder metadata
            tokenIds: [
                {
                    start: '101',
                    end: '100000000',
                },
            ],
            customData: '',
        },
    ],
    customData: '',
    standards: ['Subscriptions'],
    isArchived: false,

    // Coins to send to the mint escrow address. You can also fund after the fact. This is just useful for genesis since the address is dependent on the collectionId which you don't know until after the collection is created.
    mintEscrowCoinsToTransfer: [
        {
            denom: 'ubadge',
            amount: '1',
        },
    ],

    // If you want to add paths to wrap tokens as Cosmos coins, you can do so here.
    cosmosCoinWrapperPathsToAdd: [],

    defaultBalances: {
        // Everyone starts with empty balances and no approvals
        balances: [],
        incomingApprovals: [],
        outgoingApprovals: [],
        // Empty = Soft Enabled (i.e. enabled but can be disabled at any time by each user)
        userPermissions: {
            canUpdateOutgoingApprovals: [],
            canUpdateIncomingApprovals: [],
            canUpdateAutoApproveSelfInitiatedOutgoingTransfers: [],
            canUpdateAutoApproveSelfInitiatedIncomingTransfers: [],
            canUpdateAutoApproveAllIncomingTransfers: [],
        },

        // Typically, these flags are all you need to set.
        autoApproveSelfInitiatedIncomingTransfers: true,
        autoApproveSelfInitiatedOutgoingTransfers: true,
        autoApproveAllIncomingTransfers: true,
    },
};
```

For information on building collection approvals, see [Building Collection Approvals](building-collection-approvals.md).


## File: ./x-badges/examples/building-collection-approvals.md

# Building Your Collection Approvals

The collection-level transferability is determined by the collection-level approvals. The important thing to consider here is that any approval that allows transfers from the "Mint" address will mint balances out of thin air.

## Approval Categories

It is typically recommended to split into two categories:

* **Mint Approvals** (`fromListId: 'Mint'`)
* **Post-Mint Approvals** (`fromListId: '!Mint'`)

## Important Notes

1. The reserved "All" list ID includes Mint. Do not use "All" for the fromListId for post-mint approvals.
2. To function, the "Mint" approval must forcefully override the user-level outgoing approval because it cannot be managed.

## Code Example

Mix and match the approvals as you see fit. See the examples in the Approvals folder for a bunch of examples.

* [Transferable Approval](approvals/transferable-approval.md)
* [Burnable Approval](approvals/burnable-approval.md)

```typescript
const mintApprovals = [
    // Mint approvals with fromListId: 'Mint'
];

const postMintApprovals = [
    // Post-mint approvals with fromListId: '!Mint'
    transferableApproval,
    burnableApproval,
];

const collectionApprovals = [...mintApprovals, ...postMintApprovals];

const collectionApprovals = [...mintApprovals, ...postMintApprovals];
```


## File: ./x-badges/examples/building-collection-permissions.md

# Building Your Collection Permissions

Collection permissions are executable by the manager. They are used to control who can perform various management actions on your collection and when those actions are allowed.

```typescript
const manager = collection.getCurrentManager();
```

## Setting Your Permissions

You have a few options for setting your permissions.

1. No Manager

If you simply don't want a manager, you can set the manager to an empty string. Then, the permission values never matter.

```typescript
const manager = '';
```

2. Complete Control - Soft Enabled

Each permission is enabled by default, unless you permanently disabled it. Thus, an empty array means that the permission is enabled for all times. However, it is soft enabled, meaning that the manager can disable it at any time. This configuration offers full control with ability to disable in the future.

```typescript
const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateTokenMetadata: [],
    canUpdateCollectionApprovals: [],
    canUpdateValidTokenIds: [],
    canAddMoreAliasPaths: [],
    canAddMoreCosmosCoinWrapperPaths: [],
};
```

3. Custom Permissions

Oftentimes, you want a little more control over your permissions though.

Each permission follows the same pattern:

1. For the times `permanentlyPermittedTimes`, the permission is always permitted for the given values.
2. For the times `permanentlyForbiddenTimes`, the permission is always forbidden for the given values.
3. If the item is not explicity in either, then the permission is enabled for the given values, but the status can change.

```typescript
const CanArchiveCollection = {
    permanentlyPermittedTimes: [],
    permanentlyForbiddenTimes: FullTimeRanges,
};
```

Each permission type follows the same pattern of two categories:

```typescript
// Part 1. Enabled vs Disabled Times For The Execution Of The Permission
const permanentlyPermittedTimes = [];
const permanentlyForbiddenTimes = FullTimeRanges;

// Part 2. For what values (if any) does this apply? This is dependent on the permission type.
const {
    tokenIds,
    fromListId,
    toListId,
    initiatedByListId,
    transferTimes,
    ownershipTimes,
    approvalId,
} = permission;
```

## Main Permissions To Consider

1. Should the number of token IDs in the collection be expandable? frozen upon genesis? -> Handle with `canUpdateValidTokenIds`
2. What about the transferability? -> Handle with `canUpdateCollectionApprovals`
   * Should the transferability be frozen upon genesis?
   * Should we disallow updating transferability for only some token IDs? some approvals? Mint? Post-Mint?
   * This could be critical for enforcing total circulating supply. For example, if you can create more approvals from the Mint address, then you can theoretically mint however many tokens you want.

## Examples

We refer you to the [examples](permissions/) or relevant concepts for more detailed examples.


## File: ./x-badges/examples/building-user-approvals.md

# Building User-Level Approvals

User-level approvals allow individual users to control their token transfers through incoming and outgoing approvals. These work similarly to [collection-level approvals](building-collection-approvals.md) with key restrictions.

We refer you to the collection-level examples and just apply the same logic to the user-level types with these differences.

## Key Differences from Collection Approvals

* **Fixed Address Lists**:
  * Incoming approvals: `fromListId` is locked to the user's address
  * Outgoing approvals: `toListId` is locked to the user's address
* **No Override Functionality**: Cannot override other approval levels
* **User-Controlled**: Only the user can update their own approvals

## Incoming Approvals

Control what tokens the user can receive:

```typescript
const userIncomingApproval = {
    fromListId: 'user-address', // Locked to approver's address
    toListId: 'All', // Can specify recipients
    initiatedByListId: 'All',
    transferTimes: [{ start: '1', end: '18446744073709551615' }],
    tokenIds: [{ start: '1', end: '100' }],
    ownershipTimes: [{ start: '1', end: '18446744073709551615' }],
    approvalId: 'user-incoming-approval',

    // Use any approval criteria from collection examples
    approvalCriteria: {
        // See: transferable-approval.md, burnable-approval.md, etc.
        // OR use EmptyApprovalCriteria for no restrictions
        ...EmptyApprovalCriteria,
    },
};
```

## Outgoing Approvals

Control what tokens the user can send:

```typescript
const userOutgoingApproval = {
    fromListId: 'All', // Can specify senders
    toListId: 'user-address', // Locked to approver's address
    initiatedByListId: 'All',
    transferTimes: [{ start: '1', end: '18446744073709551615' }],
    tokenIds: [{ start: '1', end: '100' }],
    ownershipTimes: [{ start: '1', end: '18446744073709551615' }],
    approvalId: 'user-outgoing-approval',

    // Use any approval criteria from collection examples
    approvalCriteria: {
        // See: transferable-approval.md, burnable-approval.md, etc.
        // OR use EmptyApprovalCriteria for no restrictions
        ...EmptyApprovalCriteria,
    },
};
```

## Implementation

Users update their approvals via `MsgUpdateUserApprovals`:

```typescript
const updateUserApprovals = {
    creator: 'bb1...', // Your address
    collectionId: '1',
    updateIncomingApprovals: true,
    incomingApprovals: [userIncomingApproval],
    updateOutgoingApprovals: true,
    outgoingApprovals: [userOutgoingApproval],
    // ...
};
```

## Reference

For approval criteria examples, see:

* [Empty Approval Criteria](empty-approval-criteria.md) - No restrictions template
* [Transferable Approval](approvals/transferable-approval.md) - Basic transfer restrictions
* [Burnable Approval](approvals/burnable-approval.md) - Burn functionality
* [Address Checks](../../token-standard/learn/approval-criteria/address-checks.md) - Address type restrictions
* [Building Collection Approvals](building-collection-approvals.md) - Collection-level patterns

For concepts, see:

* [Transferability](../../learn/transferability.md)
* [Approval Criteria](broken-reference/)


## File: ./x-badges/examples/building-user-permissions.md

# Building User-Level Permissions

User-level permissions allow individual users to control their ability to update their own approvals. Note that these are almost always never needed unless in advanced situations. Typically, you just leave these soft-enabled (empty arrays) for all. These are only really needed in advanced situations where you want to lock down a user's ability to update their own approvals, such as escrow accounts.

The canUpdateOutgoingApprovals and canUpdateIncomingApprovals work similarly to [canUpdateCollectionApprovals](building-collection-permissions.md) with key restrictions. - `fromListId` is locked to the user's address for outgoing approvals - `toListId` is locked to the user's address for incoming approvals

## User Permission Structure

```typescript
const userPermissions = {
    canUpdateOutgoingApprovals: [
        {
            // fromListId: 'user-address', // Locked to user's address
            toListId: 'All', // Can specify recipients
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            tokenIds: FullTimeRanges,
            ownershipTimes: FullTimeRanges,
            approvalId: 'All',
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // Lock forever
        },
    ],
    canUpdateIncomingApprovals: [
        {
            fromListId: 'All', // Can specify senders
            //  toListId: 'user-address', // Locked to user's address
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            tokenIds: FullTimeRanges,
            ownershipTimes: FullTimeRanges,
            approvalId: 'All',
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // Lock forever
        },
    ],
    canUpdateAutoApproveSelfInitiatedOutgoingTransfers: [
        {
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges,
        },
    ],
    canUpdateAutoApproveSelfInitiatedIncomingTransfers: [
        {
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges,
    canUpdateAutoApproveAllIncomingTransfers: [
        {
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges,
        },
    ],
};
```

## Implementation

Users update their permissions via `MsgUpdateUserApprovals`:

```typescript
const updateUserApprovals = {
    creator: 'bb1...', // User's address
    collectionId: '1',
    updateUserPermissions: true,
    userPermissions,
    // ... other approval updates
};
```

## Related Examples

For permission patterns, see:

* [Freezing Mint Transferability](permissions/freezing-mint-transferability.md) - Collection permission example
* [Locking Specific Approval ID](permissions/locking-specific-approval-id.md) - Approval ID targeting
* [Locking Specific Token IDs](permissions/locking-specific-token-ids.md) - Token ID targeting
* [Building Collection Permissions](building-collection-permissions.md) - Collection-level patterns

For user approval configuration, see:

* [Building User Approvals](building-user-approvals.md) - User approval setup


## File: ./x-badges/examples/cosmos-coin-wrapper-example.md

# Cosmos Coin Wrapper Tutorial

This tutorial walks you through setting up cosmos coin wrappers to bridge BitBadges with the broader Cosmos ecosystem. Cosmos coin wrappers automatically convert tokens to fungible Cosmos coins and vice versa.

## Prerequisites

* Understanding of [Cosmos Wrapper Paths](/broken/pages/QmxEDk1kIqoymCdRaTfg)
* Basic knowledge of BitBadges collections and approvals

## Step 1: Set Up Your Cosmos Denominations

First, define your cosmos coin wrapper paths. For detailed information about available options, see [Cosmos Wrapper Paths](/broken/pages/QmxEDk1kIqoymCdRaTfg).

```typescript
const cosmosCoinWrapperPaths = [ ... ];
```

## Step 2: Generate Your Special Address

When you create a collection with cosmos coin wrapper paths, the system automatically generates a special address for each wrapper. This address acts as the bridge between tokens and cosmos coins. This will also be available on the BitBadges site if you want to go that route.

```typescript
import { generateAliasAddressForDenom } from 'bitbadgesjs-sdk';

const denom = 'utoken1';
const wrapperAddress = generateAliasAddressForDenom(denom);
console.log('Wrapper Address:', wrapperAddress);
```

### Dynamic Address Generation for {id} Placeholders

The {id} is actually kept for the hash preimage, so we always have one address per wrapper path regardless of the token ID.

## Step 3: Set Up Approvals for Wrapping/Unwrapping

The transfers still operate under the approval / transferability system. We will use the following examples from our examples section, but you can customize as you see fit. Note the need to override the wrapper address's approvals where necessary because the wrapper address is uncontrollable.

* [Cosmos Wrapper Approval](approvals/cosmos-wrapper-approval.md)
* [Cosmos Unwrapper Approval](approvals/cosmos-unwrapper-approval.md)

```typescript
const collection = {
    ...BaseCollectionDetails,
    collectionApprovals: [
        ...otherApprovals,
        wrapperApproval,
        unwrapperApproval,
    ],
};
```


## File: ./x-badges/examples/defining-circulating-supply.md

# Defining and Locking Circulating Supply

This example demonstrates how circulating supply is dynamically calculated and how to control it through mint approval management.

## Overview

Unlike traditional blockchains with set-and-forget supply mechanisms, BitBadges supply is **dynamically calculated** based on the ability to use mint approvals and the ability to create new ones or edit them.

Thus, note that if the manager can create any new Mint approval, they can theoretically increase the supply by whatever the approval allows.

## Lock Supply Forever (Fixed Cap)

```typescript
const FullTimeRanges = [
    {
        start: '1',
        end: '18446744073709551615',
    },
];

const collectionPermissions = {
    // ... other permissions
    canUpdateCollectionApprovals: [
        {
            fromListId: 'Mint', // Target all mint approvals
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            tokenIds: FullTimeRanges,
            ownershipTimes: FullTimeRanges,
            approvalId: 'All',
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // Cannot update mint approvals
        },
    ],
};
```

**Result**: All Mint approvals are final. Whatever currently possible is possible but final.

## Controlled Supply (Managed Growth)

```typescript
const collectionPermissions = {
    // ... other permissions
    canUpdateCollectionApprovals: [
        {
            fromListId: 'Mint',
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            tokenIds: FullTimeRanges,
            ownershipTimes: FullTimeRanges,
            approvalId: 'initial-mint', // Only lock initial mint approval
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges,
        },
    ],
};
```

**Result**: "initial-mint" approval locked, but manager can add new ones.

## Dynamic Supply (Fully Flexible)

```typescript
const collectionPermissions = {
    // ... other permissions
    canUpdateCollectionApprovals: [], // Soft-enabled
    canAddMoreAliasPaths: [],
    canAddMoreCosmosCoinWrapperPaths: [],
};
```

**Result**: Manager can always modify mint approvals and adjust supply

## Lock Specific Token IDs

```typescript
const collectionPermissions = {
    // ... other permissions
    canUpdateCollectionApprovals: [
        {
            fromListId: 'Mint',
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            tokenIds: [
                {
                    start: '1',
                    end: '100',
                },
            ],
            ownershipTimes: FullTimeRanges,
            approvalId: 'All',
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges,
        },
    ],
};
```

**Result**: The Mint approvals for tokens 1-100 are locked and final. The manager can still create new Mint approvals for other token IDs or post-mint approvals for those tokens.

## Related Examples

-   [Freezing Mint Transferability](permissions/freezing-mint-transferability.md) - Lock all mint approvals
-   [Building Collection Approvals](building-collection-approvals.md) - Create mint approvals
-   [Empty Approval Criteria](empty-approval-criteria.md) - Unlimited mint template


## File: ./x-badges/examples/empty-approval-criteria.md

# Empty Approval Criteria Template

When creating collection approvals with empty approval criteria, you can use this template for "no additional restrictions". We reference this for simplicity in other examples.

## Template

```typescript
const EmptyApprovalCriteria = {
    approvalCriteria: {
        // No challenges to be completed
        merkleChallenges: [],
        // No specific balances to check
        predeterminedBalances: {
            manualBalances: [],
            incrementedBalances: {
                startBalances: [],
                incrementTokenIdsBy: '0',
                incrementOwnershipTimesBy: '0',
                durationFromTimestamp: '0',
                allowOverrideTimestamp: false,
                recurringOwnershipTimes: {
                    startTime: '0',
                    intervalLength: '0',
                    chargePeriodLength: '0',
                },
                allowOverrideWithAnyValidToken: false,
            },
            orderCalculationMethod: {
                useOverallNumTransfers: false,
                usePerToAddressNumTransfers: false,
                usePerFromAddressNumTransfers: false,
                usePerInitiatedByAddressNumTransfers: false,
                useMerkleChallengeLeafIndex: false,
                challengeTrackerId: '',
            },
        },
        // No approval amounts to check (0 = unlimited)
        approvalAmounts: {
            overallApprovalAmount: '0',
            perToAddressApprovalAmount: '0',
            perFromAddressApprovalAmount: '0',
            perInitiatedByAddressApprovalAmount: '0',
            amountTrackerId:
                'a4ab9bc5e8752842a35a79238de4f627677ceae1d8fa9de44b52416e085f7f11',
            resetTimeIntervals: {
                startTime: '0',
                intervalLength: '0',
            },
        },
        // No max number of transfers to check (0 = unlimited)
        maxNumTransfers: {
            overallMaxNumTransfers: '0',
            perToAddressMaxNumTransfers: '0',
            perFromAddressMaxNumTransfers: '0',
            perInitiatedByAddressMaxNumTransfers: '0',
            amountTrackerId:
                'd711e23dbe57b786dfb2d86d4a6792fb8c9951a18223065ea0c07d424225a738',
            resetTimeIntervals: {
                startTime: '0',
                intervalLength: '0',
            },
        },
        // No coin transfers to execute
        coinTransfers: [],

        // No ETH signature challenges to be completed
        ethSignatureChallenges: [],
        // No dynamic store challenges to be completed
        dynamicStoreChallenges: [],

        // No address matching requirements
        requireToEqualsInitiatedBy: false,
        requireFromEqualsInitiatedBy: false,
        requireToDoesNotEqualInitiatedBy: false,
        requireFromDoesNotEqualInitiatedBy: false,
        // No overrides from outgoing approvals
        overridesFromOutgoingApprovals: false,
        // No overrides to incoming approvals
        overridesToIncomingApprovals: false,
        // No auto deletion options
        autoDeletionOptions: {
            afterOneUse: false,
            afterOverallMaxNumTransfers: false,
        },
        // No user royalties
        userRoyalties: {
            percentage: '0',
            payoutAddress: '',
        },
        // No tokens to check ownership of
        mustOwnTokens: [],
        // No address checks
        senderChecks: {
            mustBeWasmContract: false,
            mustNotBeWasmContract: false,
            mustBeLiquidityPool: false,
            mustNotBeLiquidityPool: false,
        },
        recipientChecks: {
            mustBeWasmContract: false,
            mustNotBeWasmContract: false,
            mustBeLiquidityPool: false,
            mustNotBeLiquidityPool: false,
        },
        initiatorChecks: {
            mustBeWasmContract: false,
            mustNotBeWasmContract: false,
            mustBeLiquidityPool: false,
            mustNotBeLiquidityPool: false,
        },
        // No alternative time checks
        altTimeChecks: {
            offlineHours: [],
            offlineDays: [],
        },
        // No priority requirement
        mustPrioritize: false,
    },
};
```

## Related Documentation

-   [Approval Criteria Overview](broken-reference)
-   [Building Collection Approvals](building-collection-approvals.md)
-   [Transferability](../../learn/transferability.md)


## File: ./x-badges/examples/mint-all-to-self-tutorial.md

# Mint All Tokens to Self - Tutorial

This tutorial walks through the process of creating a collection and minting all tokens to yourself in a single transaction. This is useful for creating collections where you want to control the initial distribution.

## Overview

This is a two-step process that can be executed as a single multi-message transaction:

1. **Create Collection** with a mint approval that allows you to mint tokens
2. **Execute Transfer** using that approval to mint tokens to yourself

## Step 1: Create Mint Approval

First, create an approval that allows you to mint tokens from the "**Mint**" address:

```typescript
// Step 1: Set up your mint approval
const mintApproval = {
    fromListId: 'Mint', // From the mint address
    toListId: 'All', // To any address
    initiatedByListId: myAddress, // Only you can initiate
    transferTimes: UintRangeArray.FullRanges(),
    tokenIds: UintRangeArray.FullRanges(), // All token IDs
    ownershipTimes: UintRangeArray.FullRanges(),
    approvalId: 'mint-approval',
    version: 0n,
    approvalCriteria: {
        // No restrictions - you can mint unlimited amounts
        ...defaultNoRestrictionsApprovalCriteria,
        overridesFromOutgoingApprovals: true, // Required for mint address
    },
};

// Step 1: Create your collection with the mint approval
const collection = {
    ...BaseCollectionDetails,
    collectionApprovals: [mintApproval, ...otherApprovals],
};

// Create the collection
```

## Step 2: Execute Mint Transfer

After creating the collection, use the mint approval to transfer tokens to yourself:

```typescript
// Step 2: Mint tokens to yourself using the approval
const transfers = [
    {
        from: 'Mint', // From mint address
        toAddresses: [myAddress], // To your address
        balances: [
            {
                tokenIds: [{ start: 1n, end: 100n }],
                ownershipTimes: UintRangeArray.FullRanges(),
                amount: 100n,
            },
        ],
        // ... other transfer details
    },
];
```


## File: ./x-badges/examples/msg-transfer/README.md

# Message Transfer Examples

This section contains practical examples of token transfer messages for the BitBadges protocol.

## Examples

-   [Simple Token Transfer](simple-badge-transfer.md) - Basic mint-to-address transfer example
-   [Transfer with Precalculation](transfer-with-precalculation.md) - Transfer using approval-based precalculation


## File: ./x-badges/examples/msg-transfer/simple-badge-transfer.md

# Simple Token Transfer

This example demonstrates a basic token transfer from the mint to a specific address.

## Overview

This transfer creates token ID 1 from collection 20 and sends it to the creator address. The token has full ownership time range and uses collection-level approval.

## Transfer Details

-   **Collection ID**: 20
-   **Token ID**: 1
-   **Amount**: 1
-   **From**: Mint (new token creation)
-   **To**: Creator address
-   **Approval**: Collection-level approval (assumes user-level approvals successfully auto-scan)

## JSON Structure

```json
[
    {
        "creator": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
        "collectionId": "20",
        "transfers": [
            {
                "from": "Mint",
                "toAddresses": ["bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl"],
                "balances": [
                    {
                        "amount": "1",
                        "ownershipTimes": [
                            {
                                "start": "1",
                                "end": "18446744073709551615"
                            }
                        ],
                        "tokenIds": [
                            {
                                "start": "1",
                                "end": "1"
                            }
                        ]
                    }
                ],
                "precalculateBalancesFromApproval": {
                    "approvalId": "",
                    "approvalLevel": "",
                    "approverAddress": "",
                    "version": "0"
                },
                "merkleProofs": [],
                "ethSignatureProofs": [],
                "memo": "",
                "prioritizedApprovals": [
                    {
                        "approvalId": "4a1ed47db7bc0f9f7174eab12aa9b8c9b9e4e37474ca2264668cf8e1b1598dde",
                        "approvalLevel": "collection",
                        "approverAddress": "",
                        "version": "0"
                    }
                ],
                "onlyCheckPrioritizedCollectionApprovals": true,
                "onlyCheckPrioritizedIncomingApprovals": false,
                "onlyCheckPrioritizedOutgoingApprovals": false
            }
        ]
    }
]
```

## Key Components Explained

### Transfer Source

-   `"from": "Mint"` - Indicates this is a new token creation from the mint

### Destination

-   `"toAddresses": ["bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl"]` - The recipient address

### Balance Specification

-   `"amount": "1"` - Transfer 1 token
-   `"ownershipTimes"` - Full ownership time range (1 to max uint64)
-   `"tokenIds"` - Specific token ID range (1 to 1)

### Approval Configuration

-   `"prioritizedApprovals"` - Uses collection-level approval
-   `"onlyCheckPrioritizedCollectionApprovals": true` - Only check collection approvals
-   `"approvalId"` - Specific approval identifier for the collection

### Additional Settings

-   `"merkleProofs": []` - No merkle proofs required for this simple transfer
-   `"ethSignatureProofs": []` - No ETH signature proofs required for this simple transfer
-   `"memo": ""` - No memo attached

## Usage

This example can be used as a template for basic token minting operations where you want to create a new token and transfer it to a specific address using collection-level approval.


## File: ./x-badges/examples/msg-transfer/transfer-with-precalculation.md

# Transfer with Precalculation

This example demonstrates a token transfer that uses precalculation from approval criteria instead of manually specifying balances.

## Overview

This transfer creates tokens from collection 20 and sends them to the creator address. Instead of manually specifying the balance amounts, it uses precalculation from the approval criteria to determine what tokens to transfer.

## Transfer Details

-   **Collection ID**: 20
-   **From**: Mint (new token creation)
-   **To**: Creator address
-   **Approval**: Collection-level approval with precalculation
-   **Precalculation**: Enabled with specific approval ID

## JSON Structure

```json
[
    {
        "creator": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
        "collectionId": "20",
        "transfers": [
            {
                "from": "Mint",
                "toAddresses": ["bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl"],
                "balances": [],
                "precalculateBalancesFromApproval": {
                    "approvalId": "fd1cef5941fb08487ecc1038af09fb29a6d7d40a89d8e4889c9c954978aa7e41",
                    "approvalLevel": "collection",
                    "approverAddress": "",
                    "version": "0",
                    "precalculationOptions": {
                        "overrideTimestamp": "0",
                        "tokenIdsOverride": []
                    }
                },
                "merkleProofs": [],
                "ethSignatureProofs": [],
                "memo": "",
                "prioritizedApprovals": [
                    {
                        "approvalId": "fd1cef5941fb08487ecc1038af09fb29a6d7d40a89d8e4889c9c954978aa7e41",
                        "approvalLevel": "collection",
                        "approverAddress": "",
                        "version": "0"
                    }
                ],
                "onlyCheckPrioritizedCollectionApprovals": true,
                "onlyCheckPrioritizedIncomingApprovals": false,
                "onlyCheckPrioritizedOutgoingApprovals": false
        ]
    }
]
```

## Key Components Explained

### Precalculation Configuration

-   `"balances": []` - Empty balances array since amounts are calculated from approval
-   `"precalculateBalancesFromApproval"` - Specifies which approval to use for calculation
-   `"approvalId"` - The specific approval ID that defines the transfer criteria

### Prioritized Approvals

-   `"prioritizedApprovals"` - Uses the same approval ID for both precalculation and transfer
-   `"onlyCheckPrioritizedCollectionApprovals": true` - Only check collection-level approvals
-   `"onlyCheckPrioritizedIncomingApprovals": false` - Skip incoming approval checks
-   `"onlyCheckPrioritizedOutgoingApprovals": false` - Skip outgoing approval checks

### Precalculation Options

-   `"precalculationOptions.overrideTimestamp": "0"` - Use current timestamp for calculations (only applies if `allowOverrideTimestamp` is true in approval)
-   `"precalculationOptions.tokenIdsOverride": []` - No token ID overrides, use approval criteria (only applies if `allowOverrideWithAnyValidToken` is true in approval)

### Non-Auto-Scan Behavior

This example demonstrates "prioritized non-auto-scan" behavior where:

-   Only the specified approval is checked (no automatic scanning of other approvals)
-   The system doesn't automatically look for other valid approvals
-   Transfer is limited to what the specified approval allows
-   Can use approvals with side effects and custom criteria like merkle challenges and ETH signature challenges
-   Shows proper versioning of approvals

## Usage

This example is useful when:

-   You want to transfer tokens based on approval criteria rather than manual specification
-   You need precise control over which approval is used
-   You want to avoid automatic approval scanning
-   The approval criteria dynamically determine amounts and IDs

## Differences from Simple Transfer

| Feature               | Simple Transfer      | Precalculation Transfer   |
| --------------------- | -------------------- | ------------------------- |
| Balance Specification | Manual amounts       | Calculated from approval  |
| Approval Scanning     | Auto-scan enabled    | Only specified approval   |
| Flexibility           | Fixed amounts        | Dynamic based on criteria |
| Control               | Direct specification | Approval-driven           |

---


## File: ./x-badges/examples/permissions/README.md

# Permission Examples

This directory contains practical examples of different permission configurations for collections. Each example demonstrates specific patterns and use cases for controlling collection management.

## Contents

* [Freezing Mint Transferability](freezing-mint-transferability.md) - Permanently freeze minting capabilities
* [Locking Specific Approval ID](locking-specific-approval-id.md) - Lock specific approval IDs with granular control
* [Locking Specific Token IDs](locking-specific-token-ids.md) - Lock approvals for specific token ID ranges
* [Locking Valid Token IDs](locking-valid-token-ids.md) - Control valid token ID range updates

## Permission System Overview

BitBadges permissions follow a time-based system where:

1. **Permanently Permitted Times** - Permission is always allowed
2. **Permanently Forbidden Times** - Permission is always denied
3. **Default (Empty)** - Permission is soft-enabled (manager can change)

## Common Patterns

* **No Manager** - Set manager to empty string to disable all management
* **Complete Control** - Empty permission arrays for full soft-enabled control
* **Locked Forever** - Use `permanentlyForbiddenTimes: FullTimeRanges`
* **Time-Limited** - Use specific time ranges for temporary control


## File: ./x-badges/examples/permissions/freezing-mint-transferability.md

# Freezing Mint Transferability

This example demonstrates how to permanently freeze minting capabilities by making mint-related collection approvals immutable.

## Overview

By setting `permanentlyForbiddenTimes` for mint approval updates, you can ensure that no new minting approvals can be added and existing ones cannot be modified.

## Permission Configuration

```typescript
const FullTimeRanges = [
    {
        start: '1',
        end: '18446744073709551615',
    },
];

const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateValidTokenIds: [],
    canUpdateTokenMetadata: [],
    canUpdateCollectionApprovals: [
        {
            // Which approvals does this permission apply to? Approvals must match ALL criteria.
            fromListId: 'Mint',
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            tokenIds: FullTimeRanges,
            ownershipTimes: FullTimeRanges,
            approvalId: 'All',

            // What is status of this approval at any given time? (Unhandled = soft-enabled)
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges,
        },
    ],
};
```

## Implementation

```typescript
const createCollection = {
    // ... other collection fields
    collectionPermissions,
    collectionApprovals: [
        // Include any initial mint approvals here
        // These will be the ONLY mint approvals ever possible
        {
            fromListId: 'Mint',
            toListId: 'creator-address',
            // ... initial mint approval configuration
        },
    ],
};
```

## Important Notes

### ‚ö†Ô∏è Irreversible Action

Once set to permanently forbidden, mint permissions cannot be restored. Carefully configure initial mint approvals before freezing. Ensure all mint approvals you will ever need are set.

## Related Examples

-   [Building Collection Permissions](../building-collection-permissions.md) - General permission patterns
-   [Building Collection Approvals](../building-collection-approvals.md) - Approval configuration


## File: ./x-badges/examples/permissions/locking-specific-approval-id.md

# Locking Specific Approval ID

This example demonstrates how to permanently lock a specific approval ID while keeping other approvals updatable.

## Overview

By targeting a specific `approvalId`, you can freeze that approval permanently while allowing updates to other approvals. The `!` operator can be used to target all approvals EXCEPT a specific ID.

## Lock Specific Approval ID

```typescript
const FullTimeRanges = [
    {
        start: '1',
        end: '18446744073709551615',
    },
];

const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateValidTokenIds: [],
    canUpdateTokenMetadata: [],
    canUpdateCollectionApprovals: [
        {
            // Which approvals does this permission apply to? Approvals must match ALL criteria.
            fromListId: 'All',
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            tokenIds: FullTimeRanges,
            ownershipTimes: FullTimeRanges,
            approvalId: 'abc123', // Only targets this specific approval ID

            // What is status of this approval at any given time? (Unhandled = soft-enabled)
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // Permanently locked
        },
    ],
};
```

## Lock All EXCEPT Specific Approval ID

```typescript
const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateValidTokenIds: [],
    canUpdateTokenMetadata: [],
    canUpdateCollectionApprovals: [
        {
            // Which approvals does this permission apply to? Approvals must match ALL criteria.
            fromListId: 'All',
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            tokenIds: FullTimeRanges,
            ownershipTimes: FullTimeRanges,
            approvalId: '!abc123', // All approvals EXCEPT abc123

            // What is status of this approval at any given time? (Unhandled = soft-enabled)
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // All others permanently locked
        },
    ],
};
```

## Implementation

```typescript
const createCollection = {
    // ... other collection fields
    collectionPermissions,
    collectionApprovals: [
        {
            approvalId: 'abc123',
            // ... this approval will be locked/unlocked based on configuration
        },
        {
            approvalId: 'other-approval',
            // ... this approval's updateability depends on configuration
        },
    ],
};
```

## Related Examples

-   [Freezing Mint Transferability](./freezing-mint-transferability.md) - Lock all mint approvals
-   [Building Collection Permissions](../building-collection-permissions.md) - General permission patterns


## File: ./x-badges/examples/permissions/locking-specific-token-ids.md

# Locking Specific Token IDs

This example demonstrates how to permanently lock approvals for specific token IDs while keeping other approvals updatable.

## Overview

By targeting specific `tokenIds`, you can freeze approvals for those tokens permanently while allowing updates to approvals for other token IDs.

## Lock Token IDs 1-100

```typescript
const FullTimeRanges = [
    {
        start: '1',
        end: '18446744073709551615',
    },
];

const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateValidTokenIds: [],
    canUpdateTokenMetadata: [],
    canUpdateCollectionApprovals: [
        {
            // Which approvals does this permission apply to? Approvals must match ALL criteria.
            fromListId: 'All',
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            tokenIds: [
                {
                    start: '1',
                    end: '100', // Only targets tokens 1-100
                },
            ],
            ownershipTimes: FullTimeRanges,
            approvalId: 'All',

            // What is status of this approval at any given time? (Unhandled = soft-enabled)
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // Permanently locked
        },
    ],
};
```

## Lock All Tokens EXCEPT 1-100

```typescript
const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateValidTokenIds: [],
    canUpdateTokenMetadata: [],
    canUpdateCollectionApprovals: [
        {
            // Which approvals does this permission apply to? Approvals must match ALL criteria.
            fromListId: 'All',
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            tokenIds: [
                {
                    start: '101',
                    end: '18446744073709551615', // All tokens except 1-100
                },
            ],
            ownershipTimes: FullTimeRanges,
            approvalId: 'All',

            // What is status of this approval at any given time? (Unhandled = soft-enabled)
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // All others permanently locked
        },
    ],
};
```

## Implementation

```typescript
const createCollection = {
    // ... other collection fields
    collectionPermissions,
    collectionApprovals: [
        {
            tokenIds: [{ start: '1', end: '50' }],
            // ... this approval will be locked if it overlaps with permission criteria
        },
        {
            tokenIds: [{ start: '150', end: '200' }],
            // ... this approval's updateability depends on configuration
        },
    ],
};
```

## Use Cases

-   **Lock Founder Tokens**: Prevent modification of special token 1-100 transfer rules
-   **Preserve Rare Items**: Keep limited edition tokens (1-100) immutable
-   **Tier-Based Control**: Lock specific tiers while allowing others to evolve

## Important Notes

### ‚ö†Ô∏è ID Range Targeting

The permission only applies to approvals that overlap with the specified token ID ranges. Approvals targeting token IDs outside the range remain updatable.

## Related Examples

-   [Locking Specific Approval ID](./locking-specific-approval-id.md) - Lock by approval ID
-   [Freezing Mint Transferability](./freezing-mint-transferability.md) - Lock all mint approvals


## File: ./x-badges/examples/permissions/locking-valid-token-ids.md

# Locking Valid Token IDs

This example demonstrates how to control updates to the `validTokenIds` field, either locking it permanently or allowing controlled expansion. The `validTokenIds` field is used to control which token IDs are considered valid for the collection.

## Overview

The `canUpdateValidTokenIds` permission controls whether the valid token ID ranges can be modified.

## Lock Valid Token IDs Forever

```typescript
const FullTimeRanges = [
    {
        start: '1',
        end: '18446744073709551615',
    },
];

const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateValidTokenIds: [
        {
            // Which token IDs does this permission apply to?
            tokenIds: FullTimeRanges, // All token IDs

            // What is status of this permission at any given time?
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // Never allowed to update
        },
    ],
    canUpdateTokenMetadata: [],
    canUpdateCollectionApprovals: [],
    canAddMoreAliasPaths: [],
    canAddMoreCosmosCoinWrapperPaths: [],
};
```

## Lock Token IDs 1-100, Allow Future Expansion

```typescript
const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateValidTokenIds: [
        {
            // Which token IDs does this permission apply to?
            tokenIds: [
                {
                    start: '1',
                    end: '100', // Only applies to tokens 1-100
                },
            ],

            // What is status of this permission at any given time?
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // Token IDs 1-100 locked forever
        },
        // Token IDs 101+ remain soft-enabled (can be updated by manager)
    ],
    canUpdateTokenMetadata: [],
    canUpdateCollectionApprovals: [],
    canAddMoreAliasPaths: [],
    canAddMoreCosmosCoinWrapperPaths: [],
};
```

## Implementation

```typescript
const createCollection = {
    // ... other collection fields
    collectionPermissions,
    validTokenIds: [
        {
            start: '1',
            end: '100', // Initial valid range
        },
    ],
};
```

## Important Notes

### ‚ö†Ô∏è Token ID Targeting

* Permissions only apply to the specified token ID ranges
* Unspecified ranges remain soft-enabled for manager updates
* Cannot reduce valid token IDs once locked (only expansion possible for unlocked ranges)

## Related Examples

* [Locking Specific Token IDs](locking-specific-token-ids.md) - Lock approval updates for token ranges
* [Freezing Mint Transferability](freezing-mint-transferability.md) - Lock mint approvals


## File: ./x-badges/examples/txs/README.md

# Transaction Examples

This directory contains complete transaction examples for the x/badges module.

## Contents

-   [MsgCreateCollection](msgcreatecollection/) - Examples for creating collections
-   [MsgUpdateUserApprovals](msgupdate-user-approvals/) - Examples for updating user-level approvals


## File: ./x-badges/examples/txs/msgcreatecollection/README.md

# MsgCreateCollection Examples

This directory contains complete examples for creating collections using the `MsgCreateCollection` transaction.

## Contents

-   [Quest Token Collection](quest-badge-collection.md) - Example of creating a quest collection with Merkle proofs
-   [Tradable NFT Collection](tradable-nft-collection.md) - Example of creating a tradable NFT collection for marketplace trading


## File: ./x-badges/examples/txs/msgcreatecollection/quest-badge-collection.md

# Quest Token Collection Example

This example demonstrates creating a quest collection.

## Transaction Structure

```json
[
    {
        "creator": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
        "collectionId": "0",
        "defaultBalances": {
            "balances": [],
            "outgoingApprovals": [],
            "incomingApprovals": [],
            "autoApproveSelfInitiatedOutgoingTransfers": true,
            "autoApproveSelfInitiatedIncomingTransfers": true,
            "autoApproveAllIncomingTransfers": true,
            "userPermissions": {
                "canUpdateOutgoingApprovals": [],
                "canUpdateIncomingApprovals": [],
                "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [],
                "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [],
                "canUpdateAutoApproveAllIncomingTransfers": []
            }
        },
        "validTokenIds": [
            {
                "start": "1",
                "end": "1"
            }
        ],
        "collectionPermissions": {
            "canDeleteCollection": [],
            "canArchiveCollection": [],
            "canUpdateStandards": [],
            "canUpdateCustomData": [],
            "canUpdateManager": [],
            "canUpdateCollectionMetadata": [],
            "canUpdateValidTokenIds": [],
            "canUpdateTokenMetadata": [],
            "canUpdateCollectionApprovals": [],
            "canAddMoreAliasPaths": [],
            "canAddMoreCosmosCoinWrapperPaths": []
        },
        "manager": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
        "collectionMetadata": {
            "uri": "ipfs://QmRbRYYyphz73apphqP3QQmkeZxbtMWmAxasGfhcw1RApD",
            "customData": ""
        },
        "tokenMetadata": [
            {
                "uri": "ipfs://QmRbRYYyphz73apphqP3QQmkeZxbtMWmAxasGfhcw1RApD",
                "customData": "",
                "tokenIds": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ]
            }
        ],
        "customData": "",
        "collectionApprovals": [
            {
                "fromListId": "Mint",
                "toListId": "All",
                "initiatedByListId": "All",
                "transferTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "tokenIds": [
                    {
                        "start": "1",
                        "end": "1"
                    }
                ],
                "ownershipTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "uri": "ipfs://QmPUAjAPMDQMJZV8mpnaYbhBu2BUS4u449c7KsRNZip9uf",
                "customData": "",
                "approvalId": "quests-approval",
                "approvalCriteria": {
                    "merkleChallenges": [
                        {
                            "root": "5958c51f7c54d8e27ac42a9a2f03069c1412071abb87bf0e7be0dde790a82dbb",
                            "expectedProofLength": "0",
                            "useCreatorAddressAsLeaf": false,
                            "maxUsesPerLeaf": "1",
                            "uri": "ipfs://QmRsSK3Fw63bcJPuiYutNfBK3TYdnB8X5QG8W6ksVMuNcH",
                            "customData": "",
                            "challengeTrackerId": "1c5b9f3c390d26981996a6b593fe42300023b0e43534954a73075b912d9ca2e6",
                            "leafSigner": "0xa612B14Ff99DAe9FBC9613bF4553781086c5F887"
                        }
                    ],
                    "ethSignatureChallenges": [],
                    "predeterminedBalances": {
                        "manualBalances": [],
                        "incrementedBalances": {
                            "startBalances": [
                                {
                                    "amount": "1",
                                    "ownershipTimes": [
                                        {
                                            "start": "1",
                                            "end": "18446744073709551615"
                                        }
                                    ],
                                    "tokenIds": [
                                        {
                                            "start": "1",
                                            "end": "1"
                                        }
                                    ]
                                }
                            ],
                            "incrementTokenIdsBy": "0",
                            "incrementOwnershipTimesBy": "0",
                            "durationFromTimestamp": "0",
                            "allowOverrideTimestamp": false,
                            "recurringOwnershipTimes": {
                                "startTime": "0",
                                "intervalLength": "0",
                                "chargePeriodLength": "0"
                            },
                            "allowOverrideWithAnyValidToken": false
                        },
                        "orderCalculationMethod": {
                            "useOverallNumTransfers": true,
                            "usePerToAddressNumTransfers": false,
                            "usePerFromAddressNumTransfers": false,
                            "usePerInitiatedByAddressNumTransfers": false,
                            "useMerkleChallengeLeafIndex": false,
                            "challengeTrackerId": ""
                        }
                    },
                    "approvalAmounts": {
                        "overallApprovalAmount": "0",
                        "perToAddressApprovalAmount": "0",
                        "perFromAddressApprovalAmount": "0",
                        "perInitiatedByAddressApprovalAmount": "0",
                        "amountTrackerId": "quests-approval",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "maxNumTransfers": {
                        "overallMaxNumTransfers": "1",
                        "perToAddressMaxNumTransfers": "0",
                        "perFromAddressMaxNumTransfers": "0",
                        "perInitiatedByAddressMaxNumTransfers": "0",
                        "amountTrackerId": "quests-approval",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "coinTransfers": [
                        {
                            "to": "",
                            "coins": [
                                {
                                    "denom": "ubadge",
                                    "amount": "5000000000"
                                }
                            ],
                            "overrideFromWithApproverAddress": true,
                            "overrideToWithInitiator": true
                        }
                    ],
                    "requireToEqualsInitiatedBy": false,
                    "requireFromEqualsInitiatedBy": false,
                    "requireToDoesNotEqualInitiatedBy": false,
                    "requireFromDoesNotEqualInitiatedBy": false,
                    "overridesFromOutgoingApprovals": true,
                    "overridesToIncomingApprovals": false,
                    "autoDeletionOptions": {
                        "afterOneUse": false,
                        "afterOverallMaxNumTransfers": false
                    },
                    "userRoyalties": {
                        "percentage": "0",
                        "payoutAddress": ""
                    },
                    "mustOwnTokens": []
                },
                "version": "0"
            }
        ],
        "standards": ["Quests"],
        "isArchived": false,
        "mintEscrowCoinsToTransfer": [
            {
                "denom": "ubadge",
                "amount": "5000000000"
            }
        ],
        "cosmosCoinWrapperPathsToAdd": []
    }
]
```

## Key Features

### Quest Token Collection

This example creates a quest collection with the following characteristics:

-   **Single Token**: Only token ID 1 is valid (`validTokenIds: [{"start": "1", "end": "1"}]`)
-   **Quest Standard**: Uses the "Quests" standard for quest-related functionality
-   **Merkle Proof Verification**: Requires users to provide valid Merkle proofs (BitBadges claims) to claim tokens
-   **Coin Rewards**: Transfers 5000000000 ubadge coins to successful claimants and properly handles the Mint escrow coins

### Approval System

#### Collection Approval (Minting)

-   **From/To**: Mint ‚Üí All users
-   **Merkle Challenge**: Root hash `5958c51f7c54d8e27ac42a9a2f03069c1412071abb87bf0e7be0dde790a82dbb`
-   **Leaf Signer**: `0xa612B14Ff99DAe9FBC9613bF4553781086c5F887` (Ethereum address)
-   **Max Uses**: 1 per leaf, overall max 1 transfer
-   **Coin Transfer**: 5000000000 ubadge coins per successful claim

#### Default User Approvals

-   **Incoming**: Allows all incoming transfers from any source
-   **Auto-approve**: Self-initiated transfers are automatically approved
-   **User Permissions**: No user permissions to update approvals (all soft-enabled)

### Manager and Permissions

-   **Manager**: `bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl` (one manager)
-   **Collection Permissions**: All permissions are empty (all soft-enabled)

### Metadata

-   **Collection URI**: `ipfs://QmRbRYYyphz73apphqP3QQmkeZxbtMWmAxasGfhcw1RApD`
-   **Token URI**: Same as collection URI for all tokens
-   **Approval URI**: `ipfs://QmPUAjAPMDQMJZV8mpnaYbhBu2BUS4u449c7KsRNZip9uf`
-   **Challenge URI**: `ipfs://QmRsSK3Fw63bcJPuiYutNfBK3TYdnB8X5QG8W6ksVMuNcH`

### Escrow and Funding

-   **Mint Escrow**: 5000000000 ubadge coins are escrowed to fund the coin transfers
-   **No Cosmos Coin Wrapper**: Empty `cosmosCoinWrapperPathsToAdd` array. No wrapping allowed.


## File: ./x-badges/examples/txs/msgcreatecollection/tradable-nft-collection.md

# Tradable Collection Example

This example demonstrates creating a tradable collection that supports orderbook-style trading.

## Transaction Structure

```json
[
    {
        "creator": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
        "collectionId": "0",
        "defaultBalances": {
            "balances": [],
            "outgoingApprovals": [],
            "incomingApprovals": [],
            "autoApproveSelfInitiatedOutgoingTransfers": true,
            "autoApproveSelfInitiatedIncomingTransfers": true,
            "autoApproveAllIncomingTransfers": true,
            "userPermissions": {
                "canUpdateOutgoingApprovals": [],
                "canUpdateIncomingApprovals": [],
                "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [],
                "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [],
                "canUpdateAutoApproveAllIncomingTransfers": []
            }
        },
        "validTokenIds": [
            {
                "start": "1",
                "end": "100"
            }
        ],
        "collectionPermissions": {
            "canDeleteCollection": [],
            "canArchiveCollection": [],
            "canUpdateStandards": [],
            "canUpdateCustomData": [],
            "canUpdateManager": [],
            "canUpdateCollectionMetadata": [],
            "canUpdateValidTokenIds": [],
            "canUpdateTokenMetadata": [],
            "canUpdateCollectionApprovals": [],
            "canAddMoreAliasPaths": [],
            "canAddMoreCosmosCoinWrapperPaths": []
        },
        "manager": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
        "collectionMetadata": {
            "uri": "ipfs://QmdqD7VE4MTZz2V1XeCBqdFcQ9orE6a4PEUzbFi2SfFxoR",
            "customData": ""
        },
        "tokenMetadata": [
            {
                "uri": "ipfs://QmRbRYYyphz73apphqP3QQmkeZxbtMWmAxasGfhcw1RApD",
                "customData": "",
                "tokenIds": [
                    {
                        "start": "101",
                        "end": "18446744073709551615"
                    }
                ]
            },
            {
                "uri": "ipfs://QmdqD7VE4MTZz2V1XeCBqdFcQ9orE6a4PEUzbFi2SfFxoR",
                "customData": "",
                "tokenIds": [
                    {
                        "start": "1",
                        "end": "100"
                    }
                ]
            }
        ],
        "customData": "",
        "collectionApprovals": [
            {
                "fromListId": "Mint",
                "toListId": "All",
                "initiatedByListId": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
                "transferTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "tokenIds": [
                    {
                        "start": "1",
                        "end": "100"
                    }
                ],
                "ownershipTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "uri": "",
                "customData": "",
                "approvalId": "a4ab9bc5e8752842a35a79238de4f627677ceae1d8fa9de44b52416e085f7f11",
                "approvalCriteria": {
                    "merkleChallenges": [],
                    "ethSignatureChallenges": [],
                    "predeterminedBalances": {
                        "manualBalances": [],
                        "incrementedBalances": {
                            "startBalances": [],
                            "incrementTokenIdsBy": "0",
                            "incrementOwnershipTimesBy": "0",
                            "durationFromTimestamp": "0",
                            "allowOverrideTimestamp": false,
                            "recurringOwnershipTimes": {
                                "startTime": "0",
                                "intervalLength": "0",
                                "chargePeriodLength": "0"
                            },
                            "allowOverrideWithAnyValidToken": false
                        },
                        "orderCalculationMethod": {
                            "useOverallNumTransfers": false,
                            "usePerToAddressNumTransfers": false,
                            "usePerFromAddressNumTransfers": false,
                            "usePerInitiatedByAddressNumTransfers": false,
                            "useMerkleChallengeLeafIndex": false,
                            "challengeTrackerId": ""
                        }
                    },
                    "approvalAmounts": {
                        "overallApprovalAmount": "0",
                        "perToAddressApprovalAmount": "0",
                        "perFromAddressApprovalAmount": "0",
                        "perInitiatedByAddressApprovalAmount": "0",
                        "amountTrackerId": "a4ab9bc5e8752842a35a79238de4f627677ceae1d8fa9de44b52416e085f7f11",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "maxNumTransfers": {
                        "overallMaxNumTransfers": "0",
                        "perToAddressMaxNumTransfers": "0",
                        "perFromAddressMaxNumTransfers": "0",
                        "perInitiatedByAddressMaxNumTransfers": "0",
                        "amountTrackerId": "d711e23dbe57b786dfb2d86d4a6792fb8c9951a18223065ea0c07d424225a738",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "coinTransfers": [],
                    "requireToEqualsInitiatedBy": false,
                    "requireFromEqualsInitiatedBy": false,
                    "requireToDoesNotEqualInitiatedBy": false,
                    "requireFromDoesNotEqualInitiatedBy": false,
                    "overridesFromOutgoingApprovals": true,
                    "overridesToIncomingApprovals": true,
                    "autoDeletionOptions": {
                        "afterOneUse": false,
                        "afterOverallMaxNumTransfers": false
                    },
                    "userRoyalties": {
                        "percentage": "0",
                        "payoutAddress": ""
                    },
                    "mustOwnTokens": []
                },
                "version": "0"
            },
            {
                "fromListId": "!Mint",
                "toListId": "All",
                "initiatedByListId": "All",
                "transferTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "tokenIds": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "ownershipTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "uri": "",
                "customData": "",
                "approvalId": "transferable-approval",
                "approvalCriteria": {
                    "merkleChallenges": [],
                    "ethSignatureChallenges": [],
                    "predeterminedBalances": {
                        "manualBalances": [],
                        "incrementedBalances": {
                            "startBalances": [],
                            "incrementTokenIdsBy": "0",
                            "incrementOwnershipTimesBy": "0",
                            "durationFromTimestamp": "0",
                            "allowOverrideTimestamp": false,
                            "recurringOwnershipTimes": {
                                "startTime": "0",
                                "intervalLength": "0"
                            },
                            "allowOverrideWithAnyValidToken": false
                        },
                        "orderCalculationMethod": {
                            "useOverallNumTransfers": false,
                            "usePerToAddressNumTransfers": false,
                            "usePerFromAddressNumTransfers": false,
                            "usePerInitiatedByAddressNumTransfers": false,
                            "useMerkleChallengeLeafIndex": false,
                            "challengeTrackerId": ""
                        }
                    },
                    "approvalAmounts": {
                        "overallApprovalAmount": "0",
                        "perToAddressApprovalAmount": "0",
                        "perFromAddressApprovalAmount": "0",
                        "perInitiatedByAddressApprovalAmount": "0",
                        "amountTrackerId": "d79af272f33e76e5ba77c4edc356ad5b2e4014dd93ec7cea2b45ba56c65e11ac",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "maxNumTransfers": {
                        "overallMaxNumTransfers": "0",
                        "perToAddressMaxNumTransfers": "0",
                        "perFromAddressMaxNumTransfers": "0",
                        "perInitiatedByAddressMaxNumTransfers": "0",
                        "amountTrackerId": "d79af272f33e76e5ba77c4edc356ad5b2e4014dd93ec7cea2b45ba56c65e11ac",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "coinTransfers": [],
                    "requireToEqualsInitiatedBy": false,
                    "requireFromEqualsInitiatedBy": false,
                    "requireToDoesNotEqualInitiatedBy": false,
                    "requireFromDoesNotEqualInitiatedBy": false,
                    "overridesFromOutgoingApprovals": false,
                    "overridesToIncomingApprovals": false,
                    "autoDeletionOptions": {
                        "afterOneUse": false,
                        "afterOverallMaxNumTransfers": false
                    },
                    "userRoyalties": {
                        "percentage": "0",
                        "payoutAddress": ""
                    },
                    "mustOwnTokens": []
                },
                "version": "0"
            }
        ],
        "standards": [
            "Tradable",
            "NFTs",
            "DefaultDisplayCurrency:ibc/F082B65C88E4B6D5EF1DB243CDA1D331D002759E938A0F5CD3FFDC5D53B3E349"
        ],
        "isArchived": false,
        "mintEscrowCoinsToTransfer": [],
        "cosmosCoinWrapperPathsToAdd": [] // No wrapping allowed
    }
]
```


## File: ./x-badges/examples/txs/msgupdate-user-approvals/README.md

# MsgUpdateUserApprovals Examples

This directory contains complete examples for updating user-level approvals using the `MsgUpdateUserApprovals` transaction.

## Contents

-   [Updating Outgoing Approvals](updating-outgoing-approvals.md) - Example of updating user outgoing approvals


## File: ./x-badges/examples/txs/msgupdate-user-approvals/updating-outgoing-approvals.md

# Updating Outgoing Approvals

This example demonstrates how to update user outgoing approvals to control what tokens a user can send and to whom.

## Transaction Structure

```json
[
    {
        "creator": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
        "collectionId": "1",
        "updateOutgoingApprovals": true,
        "outgoingApprovals": [
            {
                "toListId": "All",
                "initiatedByListId": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
                "transferTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "tokenIds": [
                    {
                        "start": "1",
                        "end": "20"
                    }
                ],
                "ownershipTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "uri": "",
                "customData": "",
                "approvalId": "87bc6dd97492b913b3d2b6c91c71b7a2bc98d41a715e49285180e8db9f4ea0bb",
                "approvalCriteria": {
                    "merkleChallenges": [],
                    "ethSignatureChallenges": [],
                    "predeterminedBalances": {
                        "manualBalances": [],
                        "incrementedBalances": {
                            "startBalances": [],
                            "incrementTokenIdsBy": "0",
                            "incrementOwnershipTimesBy": "0",
                            "durationFromTimestamp": "0",
                            "allowOverrideTimestamp": false,
                            "recurringOwnershipTimes": {
                                "startTime": "0",
                                "intervalLength": "0",
                                "chargePeriodLength": "0"
                            },
                            "allowOverrideWithAnyValidToken": false
                        },
                        "orderCalculationMethod": {
                            "useOverallNumTransfers": false,
                            "usePerToAddressNumTransfers": false,
                            "usePerFromAddressNumTransfers": false,
                            "usePerInitiatedByAddressNumTransfers": false,
                            "useMerkleChallengeLeafIndex": false,
                            "challengeTrackerId": ""
                        }
                    },
                    "approvalAmounts": {
                        "overallApprovalAmount": "1",
                        "perToAddressApprovalAmount": "0",
                        "perFromAddressApprovalAmount": "0",
                        "perInitiatedByAddressApprovalAmount": "1",
                        "amountTrackerId": "87bc6dd97492b913b3d2b6c91c71b7a2bc98d41a715e49285180e8db9f4ea0bb",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "maxNumTransfers": {
                        "overallMaxNumTransfers": "0",
                        "perToAddressMaxNumTransfers": "0",
                        "perFromAddressMaxNumTransfers": "0",
                        "perInitiatedByAddressMaxNumTransfers": "0",
                        "amountTrackerId": "fe1ffc5f6ff98f0e41b097f33623248868d367dc36dd7f22b2717b61b9d7c91c",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "coinTransfers": [],
                    "requireToEqualsInitiatedBy": false,
                    "requireToDoesNotEqualInitiatedBy": false,
                    "autoDeletionOptions": {
                        "afterOneUse": false,
                        "afterOverallMaxNumTransfers": false
                    },
                    "mustOwnTokens": []
                },
                "version": "0"
            }
        ],

        // All other updates are false, so values do not ma
        "updateIncomingApprovals": false,
        "incomingApprovals": [],
        "updateAutoApproveSelfInitiatedOutgoingTransfers": true,
        "autoApproveSelfInitiatedOutgoingTransfers": true,
        "updateAutoApproveSelfInitiatedIncomingTransfers": false,
        "autoApproveSelfInitiatedIncomingTransfers": false,
        "updateAutoApproveAllIncomingTransfers": false,
        "autoApproveAllIncomingTransfers": false,
        "updateUserPermissions": false,
        "userPermissions": {
            "canUpdateOutgoingApprovals": [],
            "canUpdateIncomingApprovals": [],
            "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [],
            "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [],
            "canUpdateAutoApproveAllIncomingTransfers": []
        }
    }
]
```

## Related Examples

* [Building User Approvals](../../building-user-approvals.md) - User approval patterns
* [Empty Approval Criteria](../../empty-approval-criteria.md) - Template for unrestricted approvals


## File: ./x-badges/messages/README.md

# üì® Messages

This directory contains detailed documentation for all message types supported by the tokens module.

## Message Categories

### Collection Management

-   [MsgCreateCollection](msg-create-collection.md) - Create new collection
-   [MsgUpdateCollection](msg-update-collection.md) - Update existing collection properties
-   [MsgUniversalUpdateCollection](msg-universal-update-collection.md) - Universal create/update interface with invariants support
-   [MsgDeleteCollection](msg-delete-collection.md) - Archive/delete collection

### Helper Collection Update Messages

-   [MsgSetValidTokenIds](msg-set-valid-token-ids.md) - Update valid token IDs and permissions
-   [MsgSetManager](msg-set-manager.md) - Update manager and permissions
-   [MsgSetCollectionMetadata](msg-set-collection-metadata.md) - Update collection metadata and permissions
-   [MsgSetTokenMetadata](msg-set-badge-metadata.md) - Update token metadata and permissions
-   [MsgSetCustomData](msg-set-custom-data.md) - Update custom data and permissions
-   [MsgSetStandards](msg-set-standards.md) - Update standards and permissions
-   [MsgSetCollectionApprovals](msg-set-collection-approvals.md) - Update collection approvals and permissions
-   [MsgSetIsArchived](msg-set-is-archived.md) - Update isArchived status and permissions

### Token Transfers

-   [MsgTransferTokens](msg-transfer-tokens.md) - Transfer tokens between addresses with approval validation

### User Approval Management

-   [MsgUpdateUserApprovals](msg-update-user-approvals.md) - Update user transfer approval settings
-   [MsgSetIncomingApproval](msg-set-incoming-approval.md) - Set a single incoming approval (helper)
-   [MsgDeleteIncomingApproval](msg-delete-incoming-approval.md) - Delete a single incoming approval (helper)
-   [MsgSetOutgoingApproval](msg-set-outgoing-approval.md) - Set a single outgoing approval (helper)
-   [MsgDeleteOutgoingApproval](msg-delete-outgoing-approval.md) - Delete a single outgoing approval (helper)
-   [MsgPurgeApprovals](msg-purge-approvals.md) - Purge expired approvals (helper)
-   [MsgCastVote](msg-cast-vote.md) - Cast or update a vote for a voting challenge in approval criteria

### Address List Management

-   [MsgCreateAddressLists](msg-create-address-lists.md) - Create reusable address lists for access control

### Dynamic Store Management

-   [MsgCreateDynamicStore](msg-create-dynamic-store.md) - Create boolean stores for approval criteria
-   [MsgUpdateDynamicStore](msg-update-dynamic-store.md) - Update dynamic store configuration
-   [MsgDeleteDynamicStore](msg-delete-dynamic-store.md) - Delete dynamic store
-   [MsgSetDynamicStoreValue](msg-set-dynamic-store-value.md) - Set boolean values for addresses in dynamic store

## Additional Message Types

The following message types exist in the protocol but may be documented separately:

-   **MsgUpdateParams** - Update module parameters via governance


## File: ./x-badges/messages/msg-cast-vote.md

# MsgCastVote

Casts or updates a vote for a voting challenge in an approval criteria. Used in weighted quorum voting systems where multiple parties must vote to approve transfers.

Votes can be updated by casting a new vote with the same parameters, which overwrites the previous vote.

## Authorization

Only addresses in the voting challenge's `voters` list can cast votes. The `creator` address must match one of the voters in the challenge.

### Proto Definition

```protobuf
message MsgCastVote {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/CastVote";

  // The address of the voter casting the vote.
  string creator = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // The collection ID for the voting challenge.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // The approval level ("collection", "incoming", or "outgoing").
  string approvalLevel = 3;

  // The approver address (empty string for collection-level approvals).
  string approverAddress = 4;

  // The approval ID.
  string approvalId = 5;

  // The proposal ID (challenge ID) from the VotingChallenge.
  string proposalId = 6;

  // The percentage weight (0-100) allocated to "yes" vote.
  // The remaining percentage (100 - yesWeight) is allocated to "no" vote.
  // Example: yesWeight=70 means 70% yes, 30% no.
  string yesWeight = 7 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}

message MsgCastVoteResponse {}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges cast-vote '[tx-json]' --from voter-key
```

#### JSON Example

```json
{
    "creator": "bb1voter123...",
    "collectionId": "1",
    "approvalLevel": "collection",
    "approverAddress": "",
    "approvalId": "multisig-approval",
    "proposalId": "proposal-1",
    "yesWeight": "100"
}
```

## Fields

| Field             | Type   | Description                                                                     |
| ----------------- | ------ | ------------------------------------------------------------------------------- |
| `creator`         | string | Voter address casting the vote (must be in challenge's voters list)             |
| `collectionId`    | string | Collection ID containing the approval                                           |
| `approvalLevel`   | string | Approval level: `"collection"`, `"incoming"`, or `"outgoing"`                   |
| `approverAddress` | string | Approver address (empty `""` for collection-level, user address for user-level) |
| `approvalId`      | string | ID of the approval containing the voting challenge                              |
| `proposalId`      | string | Proposal ID from the `VotingChallenge`                                          |
| `yesWeight`       | string | Percentage weight (0-100) for "yes" vote; remaining goes to "no" vote           |

## Vote Calculation

The system calculates the voter's contribution to the "yes" weight as:

```
yesContribution = (voterWeight √ó yesWeight) / 100
```

**Example:**

-   Voter weight: 200
-   `yesWeight`: 75
-   Contribution: (200 √ó 75) / 100 = 150 yes weight

Casting a new vote with the same parameters overwrites the previous vote, allowing voters to change their position.

## Examples

### Collection-Level Vote

```json
{
    "creator": "bb1voter123...",
    "collectionId": "1",
    "approvalLevel": "collection",
    "approverAddress": "",
    "approvalId": "governance-approval",
    "proposalId": "governance-proposal-1",
    "yesWeight": "100"
}
```

### User-Level Vote

```json
{
    "creator": "bb1voter123...",
    "collectionId": "1",
    "approvalLevel": "outgoing",
    "approverAddress": "bb1user456...",
    "approvalId": "delegation-approval",
    "proposalId": "delegation-proposal-1",
    "yesWeight": "80"
}
```

### Partial Vote

```json
{
    "creator": "bb1voter123...",
    "collectionId": "1",
    "approvalLevel": "collection",
    "approverAddress": "",
    "approvalId": "flexible-approval",
    "proposalId": "flexible-proposal-1",
    "yesWeight": "60"
}
```

This allocates 60% to "yes" and 40% to "no".

## Error Conditions

The message fails if:

-   `creator` is not in the voting challenge's voters list
-   `yesWeight` is greater than 100
-   `approvalLevel` is not `"collection"`, `"incoming"`, or `"outgoing"`
-   `proposalId` doesn't match any voting challenge in the specified approval
-   The approval with the specified ID doesn't exist

For details on voting challenges, see [Voting Challenges](../../token-standard/learn/approval-criteria/voting-challenges.md).


## File: ./x-badges/messages/msg-create-address-lists.md

# MsgCreateAddressLists

Creates reusable address lists by ID for gas optimizations. Note these serve no other purpose than to be an immutable shorthand ID reference to save on gas. These are permanent once created and cannot be deleted or edited.

## Important Notes

1. **Create Only**: There are no update, edit, or delete functions for address lists. Once created, they are immutable.

2. **Optional Efficiency Tool**: This is completely optional and serves as a reusable shorthand ID to avoid repetition of long reserved address list IDs. The primary purpose is gas efficiency.

3. **Minimal Metadata**: Typically, `uri` and `customData` are left blank as these fields are not supported on the BitBadges site and are different from off-chain lists you may see elsewhere.

## Proto Definition

```protobuf
message MsgCreateAddressLists {
  string creator = 1; // Address creating the address lists
  repeated AddressList addressLists = 2; // Lists to create in single transaction
}

message MsgCreateAddressListsResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges create-address-lists '[tx-json]' --from creator-key
```

### JSON Example

```json
{
    "creator": "bb1...",
    "addressLists": [
        {
            "listId": "", // Unique ID for the address list
            "addresses": ["bb1...", "bb1..."],
            "whitelist": true,
            "uri": "",
            "customData": ""
        }
    ]
}
```


## File: ./x-badges/messages/msg-create-collection.md

# MsgCreateCollection

Creates a new collection.

The collectionId will be assigned at execution time and is obtainable in the transaction response. Subsequent updates to the collection will be through MsgUpdateCollection.

## Creation Only Properties

The creation or genesis transaction for a collection is unique in a couple ways.

There are no permissions previously set, so there are no restrictions for what can be set vs not. Subsequent updates to the collection must follow any previously set permissions.

This is the only time that you can specify the `defaultBalances` information.

## Proto Definition

```protobuf
message MsgCreateCollection {
  string creator = 1; // Address creating the collection
  UserBalanceStore defaultBalances = 2;
  repeated UintRange validTokenIds  = 3; // Token ID ranges to include
  CollectionPermissions collectionPermissions = 4;
  string manager = 5;
  CollectionMetadata collectionMetadata = 6;
  repeated TokenMetadata tokenMetadata = 7;
  string customData = 8;
  repeated CollectionApproval collectionApprovals = 9;
  repeated string standards = 10;
  bool isArchived = 11;
  repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 12;
  repeated CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 13;
  repeated AliasPathAddObject aliasPathsToAdd = 14; // NEW: Separate array for alias paths
  CollectionInvariants invariants = 15;
}

message MsgCreateCollectionResponse {
  string collectionId = 1; // ID of the created collection
}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges create-collection '[tx-json]' --from creator-key
```

### JSON Example

For complete transaction examples, see [MsgCreateCollection Examples](../examples/txs/msgcreatecollection/).

```json
{
    "creator": "bb1...",
    "defaultBalances": {
        "balances": [],
        "outgoingApprovals": [],
        "incomingApprovals": [],
        "autoApproveSelfInitiatedOutgoingTransfers": false,
        "autoApproveSelfInitiatedIncomingTransfers": true,
        "autoApproveAllIncomingTransfers": false,
        "userPermissions": {
            "canUpdateOutgoingApprovals": [],
            "canUpdateIncomingApprovals": [],
            "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [],
            "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [],
            "canUpdateAutoApproveAllIncomingTransfers": []
        }
    },
    "validTokenIds": [{ "start": "1", "end": "100" }],
    "collectionPermissions": {
        "canDeleteCollection": [],
        "canArchiveCollection": [],
        "canUpdateStandards": [],
        "canUpdateCustomData": [],
        "canUpdateManager": [],
        "canUpdateCollectionMetadata": [],
        "canUpdateValidTokenIds": [],
        "canUpdateTokenMetadata": [],
        "canUpdateCollectionApprovals": [],
        "canAddMoreAliasPaths": [],
        "canAddMoreCosmosCoinWrapperPaths": []
    },
    "manager": "",
    "collectionMetadata": {},
    "tokenMetadata": [],
    "customData": "",
    "collectionApprovals": [],
    "standards": [],
    "isArchived": false,
    "mintEscrowCoinsToTransfer": [],
    "cosmosCoinWrapperPathsToAdd": [],
    "aliasPathsToAdd": [],
    "invariants": {
        "noCustomOwnershipTimes": false,
        "maxSupplyPerId": "0",
        "cosmosCoinBackedPath": undefined,
        "noForcefulPostMintTransfers": false,
        "disablePoolCreation": false
    }
}
```


## File: ./x-badges/messages/msg-create-dynamic-store.md

# MsgCreateDynamicStore

Creates a new dynamic store for boolean key-value storage. New stores are created with `globalEnabled = true` by default, meaning the store is active and can be used in approval criteria.

## Proto Definition

```protobuf
message MsgCreateDynamicStore {
  string creator = 1; // Address creating the dynamic store
  bool defaultValue = 2; // Default boolean value for uninitialized addresses
  string uri = 3; // Optional: URI for additional metadata or resources
  string customData = 4; // Optional: Custom data field for arbitrary data
}

message MsgCreateDynamicStoreResponse {
  string storeId = 1; // ID of the created dynamic store
}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges create-dynamic-store [true|false] --from creator-key
```

### JSON Examples

**Basic example (without metadata):**

```json
{
    "creator": "bb1...",
    "defaultValue": false
}
```

**With optional metadata fields:**

```json
{
    "creator": "bb1...",
    "defaultValue": false,
    "uri": "https://example.com/store-metadata",
    "customData": "{\"description\": \"Member store\", \"version\": \"1.0\"}"
}
```

## Metadata Fields

Both `uri` and `customData` are **optional** fields:

-   **`uri`**: URI for additional metadata or resources associated with this dynamic store. Typically used for URLs pointing to hosted JSON metadata or documentation. No validation is performed on the URI format.
-   **`customData`**: Custom data field for storing arbitrary string data. Commonly used to store JSON-encoded structured data, but can contain any string value. No validation is performed on the content.


## File: ./x-badges/messages/msg-delete-collection.md

# MsgDeleteCollection

Deletes a collection.

## Authorization

Collection deletion can only be performed by the **current manager** of the collection and requires the `canDeleteCollection` permission to be enabled at the current time in the collection's permissions.

## Proto Definition

```protobuf
message MsgDeleteCollection {
  string creator = 1; // Address requesting deletion (must be manager)
  string collectionId = 2; // ID of collection to delete
}

message MsgDeleteCollectionResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges delete-collection [collection-id] --from manager-key
```

### JSON Example

```json
{
    "creator": "bb1...",
    "collectionId": "1"
}
```


## File: ./x-badges/messages/msg-delete-dynamic-store.md

# MsgDeleteDynamicStore

Deletes a dynamic store.

## Proto Definition

```protobuf
message MsgDeleteDynamicStore {
  string creator = 1; // Address deleting the store (must be creator)
  string storeId = 2; // ID of dynamic store to delete
}

message MsgDeleteDynamicStoreResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges delete-dynamic-store [store-id] --from creator-key
```

### JSON Example

```json
{
    "creator": "bb1...",
    "storeId": "1"
}
```


## File: ./x-badges/messages/msg-delete-incoming-approval.md

# MsgDeleteIncomingApproval

A helper message to delete a single incoming approval for token transfers. This is a developer-friendly wrapper around `MsgUpdateUserApprovals` that simplifies deleting individual incoming approvals. For more information, we refer to the [MsgUpdateUserApprovals](./msg-update-user-approvals.md) documentation.

## Overview

This message allows you to delete a single incoming approval by its ID without having to construct the full `MsgUpdateUserApprovals` message with an empty approval list.

## Proto Definition

```protobuf
message MsgDeleteIncomingApproval {
  string creator = 1; // User deleting the approval
  string collectionId = 2; // Target collection for approval
  string approvalId = 3; // The ID of the approval to delete
}

message MsgDeleteIncomingApprovalResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges delete-incoming-approval [collection-id] [approval-id] --from user-key
```

### Example

```bash
bitbadgeschaind tx badges delete-incoming-approval 1 "my-approval-1" --from user-key
```

## Behavior

-   **Approval Lookup**: The system searches for an incoming approval with the specified `approvalId`
-   **Deletion**: If found, the approval is removed from the user's incoming approvals list
-   **Error Handling**: If the approval ID is not found, an error is returned
-   **Validation**: The deletion is validated according to the collection's permissions and user's approval update permissions

## Authorization & Permissions

Users can only delete their own incoming approvals. The operation must be performed according to the permissions set (i.e. the `userPermissions` previously set for that user).

## Related Messages

-   [MsgUpdateUserApprovals](./msg-update-user-approvals.md) - Full approval management
-   [MsgSetIncomingApproval](./msg-set-incoming-approval.md) - Set an incoming approval
-   [MsgDeleteOutgoingApproval](./msg-delete-outgoing-approval.md) - Delete an outgoing approval


## File: ./x-badges/messages/msg-delete-outgoing-approval.md

# MsgDeleteOutgoingApproval

A helper message to delete a single outgoing approval for token transfers. This is a developer-friendly wrapper around `MsgUpdateUserApprovals` that simplifies deleting individual outgoing approvals. For more information, we refer to the [MsgUpdateUserApprovals](./msg-update-user-approvals.md) documentation.

## Overview

This message allows you to delete a single outgoing approval by its ID without having to construct the full `MsgUpdateUserApprovals` message with an empty approval list.

## Proto Definition

```protobuf
message MsgDeleteOutgoingApproval {
  string creator = 1; // User deleting the approval
  string collectionId = 2; // Target collection for approval
  string approvalId = 3; // The ID of the approval to delete
}

message MsgDeleteOutgoingApprovalResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges delete-outgoing-approval [collection-id] [approval-id] --from user-key
```

### Example

```bash
bitbadgeschaind tx badges delete-outgoing-approval 1 "my-approval-1" --from user-key
```

## Behavior

-   **Approval Lookup**: The system searches for an outgoing approval with the specified `approvalId`
-   **Deletion**: If found, the approval is removed from the user's outgoing approvals list
-   **Error Handling**: If the approval ID is not found, an error is returned
-   **Validation**: The deletion is validated according to the collection's permissions and user's approval update permissions

## Authorization & Permissions

Users can only delete their own outgoing approvals. The operation must be performed according to the permissions set (i.e. the `userPermissions` previously set for that user).

## Related Messages

-   [MsgUpdateUserApprovals](./msg-update-user-approvals.md) - Full approval management
-   [MsgSetOutgoingApproval](./msg-set-outgoing-approval.md) - Set an outgoing approval
-   [MsgDeleteIncomingApproval](./msg-delete-incoming-approval.md) - Delete an incoming approval


## File: ./x-badges/messages/msg-purge-approvals.md

# MsgPurgeApprovals

A message to purge specific approvals from approval lists. This is a targeted approach that requires specifying exactly which approvals to purge.

## Overview

This message allows you to purge specific approvals by their identifier.

### Usage 1: Self-Purge (Creator purging their own approvals)

-   **`purgeExpired` must be `true`**
-   **`purgeCounterpartyApprovals` must be `false`**
-   **`approvalsToPurge` must contain the specific approvals to purge**
-   Specified approvals will be purged if they are expired (no future transfer times)

### Usage 2: Other-Purge (Creator purging someone else's approvals)

-   Can set either `purgeExpired` or `purgeCounterpartyApprovals` (or both)
-   **`approvalsToPurge` must contain the specific approvals to purge**
-   Purge permissions are determined by the approval's auto-deletion options in `approvalCriteria`:
    -   `allowPurgeIfExpired`: Allows others to purge expired approvals
    -   `allowCounterpartyPurge`: Allows counterparty to purge if they are the only initiator (initiatedByList must be a whitelist with exactly one address matching the counterparty)
-   Specified approvals that match the conditions will be purged

## Fields

-   `creator`: The address submitting the transaction.
-   `collectionId`: The target collection for approval cleanup.
-   `purgeExpired`: Whether to purge expired approvals (must be true for self-purge).
-   `approverAddress`: The address whose approvals to purge. If empty, defaults to `creator`.
-   `purgeCounterpartyApprovals`: Whether to purge counterparty approvals (must be false for self-purge).
-   `approvalsToPurge`: **Required** - An array of approval identifier details specifying exactly which approvals to purge. Cannot be empty.

## ApprovalIdentifierDetails

Each approval to purge must be specified with:

```typescript
interface ApprovalIdentifierDetails {
    approvalId: string; // The ID of the approval
    approvalLevel: string; // "collection", "incoming", or "outgoing"
    approverAddress: string; // Address of the approver (empty for collection-level)
    version: string; // Version of the approval (must match or else we will not purge)
}
```

## Auto-Deletion Options

The following flags in approval criteria control purge permissions in `approvalCriteria`:

-   `allowCounterpartyPurge`: Allows the counterparty to purge the approval if they are the ONLY initiator in `initiatedByList` (must be a whitelist with exactly one address matching the counterparty).
-   `allowPurgeIfExpired`: Allows others (besides the approval owner) to call `PurgeApprovals` on their behalf for expired approvals.

## Permissions

Although user approval permissions are rarely disabled, we still check these purges obey them. If the user does not have permission to purge their own approval, the purge will fail. With counterparty purges, this can be thought of purging on behalf of the user, so the user's permissions are still checked.

## Example Usage

```bash
# [collectionId, purgeExpired, approverAddress, purgeCounterpartyApprovals, approvalsToPurge]

bitbadgeschaind tx badges purge-approvals 1 true "" false '[{"approvalId":"my-approval","approvalLevel":"outgoing","approverAddress":"bb1...","version":"0"}]' --from user-key
```

## Response

The response includes the number of approvals that were successfully purged:

```json
{
    "numPurged": "3"
}
```

## Related Messages

-   [MsgUpdateUserApprovals](./msg-update-user-approvals.md) - Full approval management
-   [MsgSetIncomingApproval](./msg-set-incoming-approval.md) - Set an incoming approval
-   [MsgDeleteIncomingApproval](./msg-delete-incoming-approval.md) - Delete a single incoming approval
-   [MsgSetOutgoingApproval](./msg-set-outgoing-approval.md) - Set a single outgoing approval
-   [MsgDeleteOutgoingApproval](./msg-delete-outgoing-approval.md) - Delete a single outgoing approval


## File: ./x-badges/messages/msg-set-collection-approvals.md

# MsgSetCollectionApprovals

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetCollectionApprovals

Sets the collection approvals and update permissions for a collection. This is a convenience message that focuses specifically on collection approvals management.

### Overview

This message allows you to:

* Set collection approvals for the collection
* Configure permissions to update the collection approvals in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to update collection approvals according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetCollectionApprovals {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetCollectionApprovals";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New collection approvals to set.
  repeated CollectionApproval collectionApprovals = 3;

  // Permission to update collection approvals
  repeated CollectionApprovalPermission canUpdateCollectionApprovals = 4;
}

message MsgSetCollectionApprovalsResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-collection-approvals '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "collectionApprovals": [
        {
            "fromListId": "list1",
            "toListId": "list2",
            "initiatedByListId": "list3",
            "transferTimes": [{ "start": "1000", "end": "2000" }],
            "tokenIds": [{ "start": "1", "end": "10" }],
            "ownershipTimes": [{ "start": "1", "end": "100" }],
            "approvalId": "approval1",
            "approvalCriteria": {
                "mustOwnTokens": [],
                "merkleChallenges": [],
                "ethSignatureChallenges": [],
                "coinTransfers": [],
                "predeterminedBalances": null,
                "approvalAmounts": null,
                "autoDeletionOptions": null,
                "maxNumTransfers": null,
                "dynamicStoreChallenges": []
            }
        }
    ],
    "canUpdateCollectionApprovals": [
        {
            "fromListId": "list1",
            "toListId": "list2",
            "initiatedByListId": "list3",
            "transferTimes": [{ "start": "1000", "end": "2000" }],
            "tokenIds": [{ "start": "1", "end": "10" }],
            "ownershipTimes": [{ "start": "1", "end": "100" }],
            "approvalId": "approval1",
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Related Messages

* [MsgUniversalUpdateCollection](broken-reference) - Full collection update with all fields
* [MsgUpdateCollection](broken-reference) - Legacy update message


## File: ./x-badges/messages/msg-set-collection-metadata.md

# MsgSetCollectionMetadata

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetCollectionMetadata

Sets the collection metadata and update permissions for a collection. This is a convenience message that focuses specifically on collection metadata management.

### Overview

This message allows you to:

-   Set collection metadata for the collection
-   Configure permissions to update the collection metadata in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to update the collection metadata according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetCollectionMetadata {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetCollectionMetadata";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New collection metadata to set.
  CollectionMetadata collectionMetadata = 3;

  // Permission to update collection metadata
  repeated ActionPermission canUpdateCollectionMetadata = 4;
}

message MsgSetCollectionMetadataResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-collection-metadata '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "collectionMetadata": {
        "uri": "https://example.com/collection.json",
        "customData": "{\"description\": \"My collection\"}"
    },
    "canUpdateCollectionMetadata": [
        {
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Related Messages

-   [MsgUniversalUpdateCollection](broken-reference) - Full collection update with all fields
-   [MsgUpdateCollection](broken-reference) - Legacy update message


## File: ./x-badges/messages/msg-set-custom-data.md

# MsgSetCustomData

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetCustomData

Sets the custom data and update permissions for a collection. This is a convenience message that focuses specifically on custom data management.

### Overview

This message allows you to:

-   Set custom data for the collection
-   Configure permissions to update the custom data in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to update the custom data according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetCustomData {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetCustomData";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New custom data to set.
  string customData = 3;

  // Permission to update custom data
  repeated ActionPermission canUpdateCustomData = 4;
}

message MsgSetCustomDataResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-custom-data '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "customData": "{\"description\": \"My custom data\", \"version\": \"1.0\"}",
    "canUpdateCustomData": [
        {
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Related Messages

-   [MsgUniversalUpdateCollection](broken-reference) - Full collection update with all fields
-   [MsgUpdateCollection](broken-reference) - Legacy update message


## File: ./x-badges/messages/msg-set-dynamic-store-value.md

# MsgSetDynamicStoreValue

Sets a boolean value for a specific address in a dynamic store.

## Proto Definition

```protobuf
message MsgSetDynamicStoreValue {
  string creator = 1; // Address setting the value (must be store creator)
  string storeId = 2; // ID of the dynamic store
  string address = 3; // Address to set the value for
  bool value = 4; // Boolean value to set
}

message MsgSetDynamicStoreValueResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-dynamic-store-value [store-id] [address] [true|false] --from creator-key
```

### JSON Example
```json
{
  "creator": "bb1...",
  "storeId": "1",
  "address": "bb1...",
  "value": true
}
```

## File: ./x-badges/messages/msg-set-incoming-approval.md

# MsgSetIncomingApproval

A helper message to set a single incoming approval for token transfers. This is a developer-friendly wrapper around `MsgUpdateUserApprovals` that simplifies setting individual incoming approvals. For more information, we refer to the [MsgUpdateUserApprovals](./msg-update-user-approvals.md) documentation.

## Overview

This message allows you to set or update a single incoming approval without having to construct the full `MsgUpdateUserApprovals` message. It automatically handles version management and validation.

## Proto Definition

```protobuf
message MsgSetIncomingApproval {
  string creator = 1; // User setting the approval
  string collectionId = 2; // Target collection for approval
  UserIncomingApproval approval = 3; // The incoming approval to set
}

message MsgSetIncomingApprovalResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-incoming-approval [collection-id] '[approval-json]' --from user-key
```

## Behavior

-   **New Approval**: If the approval ID doesn't exist, a new approval is created with version 0
-   **Update Existing**: If the approval ID already exists, the approval is updated and the version is incremented
-   **No Change**: If the approval content hasn't changed, the version remains the same
-   **Validation**: The approval is validated according to the collection's permissions and user's approval update permissions

## Authorization & Permissions

Users can only set their own incoming approvals. The operation must be performed according to the permissions set (i.e. the `userPermissions` previously set for that user).

## Related Messages

-   [MsgUpdateUserApprovals](./msg-update-user-approvals.md) - Full approval management
-   [MsgDeleteIncomingApproval](./msg-delete-incoming-approval.md) - Delete an incoming approval
-   [MsgSetOutgoingApproval](./msg-set-outgoing-approval.md) - Set an outgoing approval


## File: ./x-badges/messages/msg-set-is-archived.md

# MsgSetIsArchived

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetIsArchived

Sets the isArchived status and update permissions for a collection. This is a convenience message that focuses specifically on archiving management.

### Overview

This message allows you to:

-   Set isArchived status for the collection
-   Configure permissions to archive the collection in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to archive the collection according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetIsArchived {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetIsArchived";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New isArchived status to set.
  bool isArchived = 3;

  // Permission to archive collection
  repeated ActionPermission canArchiveCollection = 4;
}

message MsgSetIsArchivedResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-is-archived '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "isArchived": true,
    "canArchiveCollection": [
        {
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Related Messages

-   [MsgUniversalUpdateCollection](broken-reference) - Full collection update with all fields
-   [MsgUpdateCollection](broken-reference) - Legacy update message


## File: ./x-badges/messages/msg-set-manager.md

# MsgSetManager

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetManager

Sets the manager and update permissions for a collection. This is a convenience message that focuses specifically on manager management.

### Overview

This message allows you to:

-   Set who manages the collection
-   Configure permissions to update the manager in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to update the manager according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetManager {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetManager";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New manager to set.
  string manager = 3;

  // Permission to update manager
  repeated ActionPermission canUpdateManager = 4;
}

message MsgSetManagerResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-manager '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "manager": "bb1def456...",
    "canUpdateManager": [
        {
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Related Messages

-   [MsgUniversalUpdateCollection](broken-reference) - Full collection update with all fields
-   [MsgUpdateCollection](broken-reference) - Legacy update message


## File: ./x-badges/messages/msg-set-outgoing-approval.md

# MsgSetOutgoingApproval

A helper message to set a single outgoing approval for token transfers. This is a developer-friendly wrapper around `MsgUpdateUserApprovals` that simplifies setting individual outgoing approvals. For more information, we refer to the [MsgUpdateUserApprovals](./msg-update-user-approvals.md) documentation.

## Overview

This message allows you to set or update a single outgoing approval without having to construct the full `MsgUpdateUserApprovals` message. It automatically handles version management and validation.

## Proto Definition

```protobuf
message MsgSetOutgoingApproval {
  string creator = 1; // User setting the approval
  string collectionId = 2; // Target collection for approval
  UserOutgoingApproval approval = 3; // The outgoing approval to set
}

message MsgSetOutgoingApprovalResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-outgoing-approval [collection-id] '[approval-json]' --from user-key
```

## Behavior

-   **New Approval**: If the approval ID doesn't exist, a new approval is created with version 0
-   **Update Existing**: If the approval ID already exists, the approval is updated and the version is incremented
-   **No Change**: If the approval content hasn't changed, the version remains the same
-   **Validation**: The approval is validated according to the collection's permissions and user's approval update permissions

## Authorization & Permissions

Users can only set their own outgoing approvals. The operation must be performed according to the permissions set (i.e. the `userPermissions` previously set for that user).

## Related Messages

-   [MsgUpdateUserApprovals](./msg-update-user-approvals.md) - Full approval management
-   [MsgDeleteOutgoingApproval](./msg-delete-outgoing-approval.md) - Delete an outgoing approval
-   [MsgSetIncomingApproval](./msg-set-incoming-approval.md) - Set an incoming approval


## File: ./x-badges/messages/msg-set-standards.md

# MsgSetStandards

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetStandards

Sets the standards and update permissions for a collection. This is a convenience message that focuses specifically on standards management.

### Overview

This message allows you to:

-   Set standards for the collection
-   Configure permissions to update the standards in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to update the standards according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetStandards {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetStandards";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New standards to set.
  repeated string standards = 3;

  // Permission to update standards
  repeated ActionPermission canUpdateStandards = 4;
}

message MsgSetStandardsResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-standards '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "standards": ["ERC1155", "ERC721"],
    "canUpdateStandards": [
        {
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```


## File: ./x-badges/messages/msg-set-token-metadata.md

# MsgSetTokenMetadata

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetTokenMetadata

Sets the token metadata and update permissions for a collection. This is a convenience message that focuses specifically on token metadata management.

### Overview

This message allows you to:

-   Set token metadata for the collection
-   Configure permissions to update the token metadata in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to update the token metadata according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetTokenMetadata {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetTokenMetadata";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New token metadata to set.
  repeated TokenMetadata tokenMetadata = 3;

  // Permission to update token metadata
  repeated TokenIdsActionPermission canUpdateTokenMetadata = 4;
}

message MsgSetTokenMetadataResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-badge-metadata '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "tokenMetadata": [
        {
            "uri": "https://example.com/badge1.json",
            "customData": "{\"description\": \"First token\"}",
            "tokenIds": [{ "start": "1", "end": "10" }]
        }
    ],
    "canUpdateTokenMetadata": [
        {
            "tokenIds": [{ "start": "1", "end": "10" }],
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Related Messages

-   [MsgUniversalUpdateCollection](broken-reference) - Full collection update with all fields
-   [MsgUpdateCollection](broken-reference) - Legacy update message


## File: ./x-badges/messages/msg-set-valid-token-ids.md

# MsgSetValidTokenIds

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetValidTokenIds

Sets the valid token IDs and update permissions for a collection. This is a convenience message that focuses specifically on token ID management.

### Overview

This message allows you to:

* Set which token IDs are valid for the collection
* Configure permissions to update the valid token IDs in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to update valid token IDs according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetValidTokenIds {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetValidTokenIds";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New token IDs to add to this collection
  repeated UintRange validTokenIds = 3;

  // Permission to update valid token IDs
  repeated TokenIdsActionPermission canUpdateValidTokenIds = 4;
}

message MsgSetValidTokenIdsResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-valid-token-ids '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "validTokenIds": [
        { "start": "1", "end": "100" },
        { "start": "200", "end": "300" }
    ],
    "canUpdateValidTokenIds": [
        {
            "tokenIds": [{ "start": "1", "end": "50" }],
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Related Messages

* [MsgUniversalUpdateCollection](broken-reference) - Full collection update with all fields
* [MsgUpdateCollection](broken-reference) - Legacy update message


## File: ./x-badges/messages/msg-transfer-tokens.md

# MsgTransferTokens

Executes token transfers between addresses.

## Proto Definition

```protobuf
message MsgTransferTokens {
  string creator = 1; // Address initiating the transfer
  string collectionId = 2; // Collection containing tokens to transfer
  repeated Transfer transfers = 3; // Transfer operations (must pass approvals)
}

message MsgTransferTokensResponse {}

message Transfer {
  // The address of the sender of the transfer.
  string from = 1;
  // The addresses of the recipients of the transfer.
  repeated string toAddresses = 2;
  // The balances to be transferred.
  repeated Balance balances = 3;
  // If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.
  // We will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.
  PrecalculateBalancesFromApprovalDetails precalculateBalancesFromApproval = 4;
  // The Merkle proofs / solutions for all Merkle challenges required for the transfer.
  repeated MerkleProof merkleProofs = 5;
  // The ETH signature proofs / solutions for all ETH signature challenges required for the transfer.
  repeated ETHSignatureProof ethSignatureProofs = 6;
  // The memo for the transfer.
  string memo = 7;
  // The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.
  // This field can be used to prioritize specific approvals and scan through them first.
  repeated ApprovalIdentifierDetails prioritizedApprovals = 8;
  // Whether to only check prioritized approvals for the transfer.
  // If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
  // If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
  bool onlyCheckPrioritizedCollectionApprovals = 9;
  // Whether to only check prioritized approvals for the transfer.
  // If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
  // If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
  bool onlyCheckPrioritizedIncomingApprovals = 10;
  // Whether to only check prioritized approvals for the transfer.
  // If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
  // If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
  bool onlyCheckPrioritizedOutgoingApprovals = 11;
}

message PrecalculateBalancesFromApprovalDetails {
  string approvalId = 1;
  string approvalLevel = 2;  // "collection", "incoming", or "outgoing"
  string approverAddress = 3;  // "" if collection-level
  string version = 4 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  PrecalculationOptions precalculationOptions = 5;
}

message PrecalculationOptions {
  string overrideTimestamp = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  repeated UintRange tokenIdsOverride = 2;
}
```

## Auto-Scan vs Prioritized Approvals

The transfer approval system operates in two modes to balance efficiency and precision:

### Auto-Scan Mode (Default)

By default, the system automatically scans through available approvals to find a match for the transfer. This mode:

-   **Works with**: Approvals using [Empty Approval Criteria](../examples/empty-approval-criteria.md) (no side effects)
-   **Behavior**: Automatically finds and uses the first matching approval
-   **Use case**: Simple transfers without custom logic or side effects
-   **No versioning required**: The system handles approval selection automatically

### Prioritized Approvals (Required for Side Effects)

**CRITICAL REQUIREMENT**: Any transfer with side effects or custom approval criteria MUST always be prioritized with proper versioning set. No exceptions.

#### Race Condition Protection

The versioning control ensures that before submitting, the user knows the exact approval they are using:

```typescript
"prioritizedApprovals": [
    {
        "approvalId": "abc123",
        "approvalLevel": "collection",
        "approverAddress": "",
        "version": "2" // Must specify exact version
    }
]
```

#### Example: Coin Transfer Approval

```typescript
// MUST be prioritized - has coin transfer side effects
"prioritizedApprovals": [
    {
        "approvalId": "reward-approval",
        "approvalLevel": "collection",
        "approverAddress": "",
        "version": "1"
    }
],
"onlyCheckPrioritizedCollectionApprovals": true
```

#### Example: Auto-Scan Safe Transfer

```typescript
// Can use auto-scan - no side effects
"prioritizedApprovals": [], // Empty - will auto-scan

// Only will succeed if it finds an approval has empty approval criteria with no custom logic
```

### Control Flags

-   `onlyCheckPrioritizedCollectionApprovals`: If true, only check prioritized approvals
-   `onlyCheckPrioritizedIncomingApprovals`: If true, only check prioritized incoming approvals
-   `onlyCheckPrioritizedOutgoingApprovals`: If true, only check prioritized outgoing approvals

**Setting these to `true` is recommended when using prioritized approvals to ensure deterministic behavior.**

### Related Documentation

-   [Empty Approval Criteria](../examples/empty-approval-criteria.md) - Template for auto-scan compatible approvals
-   [Approval Criteria](broken-reference/) - Understanding approval complexity
-   [Coin Transfers](../../token-standard/learn/approval-criteria/usdbadge-transfers.md) - Side effect examples

## Transfer Validation Process

Each transfer undergoes a systematic validation process to ensure security and proper authorization:

### Validation Steps

```
PRE. CALCULATE BALANCES (if needed)
  ‚îî‚îÄ‚îÄ If precalculateBalancesFromApproval is specified, we will use the predeterminedBalances from the specified approval to pre-calculate the balances at execution time.

1. BALANCE CHECK
   ‚îî‚îÄ‚îÄ Verify sender has sufficient balances for the transfer including ownership times
   ‚îî‚îÄ‚îÄ FAIL if insufficient balances

2. COLLECTION APPROVAL CHECK
   ‚îî‚îÄ‚îÄ Scan collection-level approvals (prioritized first, then auto-scan) to find a match for the entire transfer
   ‚îî‚îÄ‚îÄ If match found:
       ‚îú‚îÄ‚îÄ Check approval criteria (merkle proofs, amounts, timing, etc.) and constraints
       ‚îú‚îÄ‚îÄ Check if it overrides sender approvals (overridesFromOutgoingApprovals)
       ‚îú‚îÄ‚îÄ Check if it overrides recipient approvals (overridesToIncomingApprovals)
       ‚îî‚îÄ‚îÄ PROCEED with override flags set
   ‚îî‚îÄ‚îÄ Else:
        ‚îî‚îÄ‚îÄ Continue scanning
   ‚îî‚îÄ‚îÄ If some attempted transfer balances have no valid collection approval: FAIL

3. SENDER APPROVAL CHECK (if not overridden)
   ‚îî‚îÄ‚îÄ Check sender's outgoing approvals for this transfer
   ‚îî‚îÄ‚îÄ Verify approval criteria and constraints
   ‚îî‚îÄ‚îÄ FAIL if no valid outgoing approval found

4. RECIPIENT APPROVAL CHECK (if not overridden)
   ‚îî‚îÄ‚îÄ Check each recipient's incoming approvals
   ‚îî‚îÄ‚îÄ Verify approval criteria and constraints
   ‚îî‚îÄ‚îÄ FAIL if any recipient lacks valid incoming approval

5. EXECUTE TRANSFER
   ‚îî‚îÄ‚îÄ Update balances
   ‚îî‚îÄ‚îÄ Execute any approved side effects
   ‚îî‚îÄ‚îÄ Emit transfer events
   ‚îî‚îÄ‚îÄ SUCCESS
```

### Override Behavior

Collection approvals can override user-level approvals:

-   **`overridesFromOutgoingApprovals: true`** - Forcefully skips sender approval check
-   **`overridesToIncomingApprovals: true`** - Forcefully skips recipient approval checks

This allows collection managers to enable transfers that would otherwise be blocked by user settings.

### Failure Points

Transfers fail at the first validation step that doesn't pass:

1. **Insufficient Balances** - Sender doesn't own the tokens
2. **No Collection Approval** - No valid collection-level approval found
3. **Blocked by Sender** - Sender's outgoing approvals reject the transfer
4. **Blocked by Recipient** - Recipient's incoming approvals reject the transfer

### ETH Signature Proofs

ETH Signature Proofs are required when transfers use [ETH Signature Challenges](../../token-standard/learn/approval-criteria/eth-signature-challenges.md). Each proof contains:

-   **`nonce`**: The unique identifier that was signed
-   **`signature`**: The Ethereum signature of the message `nonce + "-" + creatorAddress`

**Important**: Each signature can only be used once per challenge tracker. The system tracks used signatures to prevent replay attacks.

### Related Documentation

-   [Transferability](../../learn/transferability.md) - Approval system overview
-   [Collection Approvals](broken-reference/) - Collection-level controls
-   [User Approvals](../examples/building-user-approvals.md) - User-level settings
-   [ETH Signature Challenges](../../token-standard/learn/approval-criteria/eth-signature-challenges.md) - Ethereum signature requirements

## Precalculating Balances

When using `precalculateBalancesFromApproval`, you can override certain calculation parameters using `precalculationOptions`. These options only apply when the corresponding flags are enabled in the approval's `IncrementedBalances`.

### PrecalculationOptions

| Field               | Type          | Description                                                      |
| ------------------- | ------------- | ---------------------------------------------------------------- |
| `overrideTimestamp` | string (Uint) | Override timestamp for ownership time calculation (milliseconds) |
| `tokenIdsOverride`  | UintRange[]   | Override token IDs (must be single ID if provided)               |

**overrideTimestamp**:

-   Only applies when `IncrementedBalances.durationFromTimestamp` is set and `allowOverrideTimestamp` is `true`
-   If zero or not provided, uses current block time
-   Used to calculate ownership times as `[overrideTimestamp, overrideTimestamp + durationFromTimestamp - 1]`

**tokenIdsOverride**:

-   Only applies when `IncrementedBalances.allowOverrideWithAnyValidToken` is `true`
-   Must contain exactly one `UintRange` with `start == end` (single token ID)
-   Token ID must be in the collection's `validTokenIds`

For detailed documentation, see [Predetermined Balances](../../token-standard/learn/approval-criteria/predetermined-balances.md#precalculation-options).

## Collection ID Auto-Lookup

If you specify `collectionId` as `"0"`, it will automatically lookup the latest collection ID created. This can be used if you are creating a collection and do not know the official collection ID yet but want to perform a multi-message transaction.

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges transfer-tokens '[tx-json]' --from sender-key
```

### JSON Example

```json
{
    "creator": "bb1initiator123...",
    "collectionId": "1",
    "transfers": [
        {
            "from": "bb1sender123...",
            "toAddresses": ["bb1recipient123..."],
            // Balances to transfer (can be left blank if you are using precalculateBalancesFromApproval)
            "balances": [
                {
                    "amount": "10",
                    "ownershipTimes": [
                        { "start": "1", "end": "18446744073709551615" }
                    ],
                    "tokenIds": [{ "start": "1", "end": "5" }]
                }
            ],
            // Specific approval to calculate balances dynamically for (from the approvalCriteria.predeterminedBalances)
            "precalculateBalancesFromApproval": {
                "approvalId": "approval-1",
                "approvalLevel": "collection",
                "approverAddress": "",
                "version": "1",
                "precalculationOptions": {
                    "overrideTimestamp": "0", // Optional: override timestamp (milliseconds)
                    "tokenIdsOverride": [] // Optional: override token IDs (must be single ID if provided)
                }
            },
            // Supply all merkle proofs for any merkle challenges that need to be satisfied
            "merkleProofs": [],
            // Supply all ETH signature proofs for any ETH signature challenges that need to be satisfied
            "ethSignatureProofs": [],
            // Memo for the transfer (can be left blank)
            "memo": "",

            // Any approval IDs that you want to prioritize for this transfer
            // Note: All approvals with side effects must be prioritized with proper versioning
            "prioritizedApprovals": [
                {
                    "approvalId": "abc123",
                    "approvalLevel": "collection",
                    "approverAddress": "", // blank for collection, otherwise the address of the approver
                    "version": "0"
                }
            ],

            // If specified, we will stop checking after the prioritized approvals list.
            // If false, we will check prioritized first, but then continue to check the rest of the approvals in auto-scan mode
            "onlyCheckPrioritizedCollectionApprovals": false,
            "onlyCheckPrioritizedIncomingApprovals": false,
            "onlyCheckPrioritizedOutgoingApprovals": false
        }
    ]
}
```


## File: ./x-badges/messages/msg-universal-update-collection.md

# MsgUniversalUpdateCollection

A universal message that can be used to either create a new collection or update an existing one. This message combines the functionality of both `MsgCreateCollection` and `MsgUpdateCollection` into a single interface.

## Dual Purpose

-   **Collection Creation**: When `collectionId` is set to `"0"`, this message creates a new collection
-   **Collection Update**: When `collectionId` is set to an existing collection ID, this message updates that collection

## Update Flag Pattern

This message uses an update flag + value pattern for selective updates. Each updatable field has a corresponding boolean flag (e.g., `updateValidTokenIds`, `updateCollectionPermissions`).

-   **If update flag is `true`**: The corresponding value field is processed and the collection is updated with the new value
-   **If update flag is `false`**: The corresponding value field is completely ignored, regardless of what data is provided

## Authorization & Permissions

-   **For Collection Creation**: Can be executed by any address
-   **For Collection Updates**: Can only be executed by the **current manager** of the collection. All updates must obey the previously set permissions.

### Path Addition Permissions

When adding paths to an existing collection, the following permissions are checked:

-   **`cosmosCoinWrapperPathsToAdd`**: Requires `canAddMoreCosmosCoinWrapperPaths` permission
-   **`aliasPathsToAdd`**: Requires `canAddMoreAliasPaths` permission

These permissions are checked before paths are processed. If the permission check fails, the transaction will be rejected. Both permissions use the `ActionPermission` type with time-based controls. Empty/nil permissions mean the action is allowed (neutral state).

## Proto Definition

```protobuf
message MsgUniversalUpdateCollection {
  string creator = 1; // Address creating/updating collection
  string collectionId = 2; // "0" for new collection, existing ID for updates

  // Creation-only fields (only used when collectionId = "0")
  UserBalanceStore defaultBalances = 3;

  // Updateable fields (used for both creation and updates)
  repeated UintRange validTokenIds = 4;
  bool updateCollectionPermissions = 5;
  CollectionPermissions collectionPermissions = 6;
  bool updateManager = 7;
  string manager = 8;
  bool updateCollectionMetadata = 9;
  CollectionMetadata collectionMetadata = 10;
  bool updateTokenMetadata = 11;
  repeated TokenMetadata tokenMetadata = 12;
  bool updateCustomData = 13;
  string customData = 14;
  bool updateCollectionApprovals = 15;
  repeated CollectionApproval collectionApprovals = 16;
  bool updateStandards = 17;
  repeated string standards = 18;
  bool updateIsArchived = 19;
  bool isArchived = 20;

  // Transfer fields
  repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 21;
  repeated CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 22; // Requires canAddMoreCosmosCoinWrapperPaths permission
  repeated AliasPathAddObject aliasPathsToAdd = 23; // Requires canAddMoreAliasPaths permission

  // Invariants (creation-only)
  CollectionInvariants invariants = 24;
}

message MsgUniversalUpdateCollectionResponse {
  string collectionId = 1; // ID of created/updated collection
}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges universal-update-collection '[tx-json]' --from creator-key
```

### JSON Example - Creating a New Collection

```json
{
    "creator": "bb1abc123...",
    "collectionId": "0",
    "defaultBalances": {
        "balances": [],
        "outgoingApprovals": [],
        "incomingApprovals": [],
        "autoApproveSelfInitiatedOutgoingTransfers": false,
        "autoApproveSelfInitiatedIncomingTransfers": true,
        "autoApproveAllIncomingTransfers": false,
        "userPermissions": {
            "canUpdateOutgoingApprovals": [],
            "canUpdateIncomingApprovals": [],
            "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [],
            "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [],
            "canUpdateAutoApproveAllIncomingTransfers": []
        }
    },
    "validTokenIds": [{ "start": "1", "end": "100" }],
    "updateCollectionPermissions": true,
    "collectionPermissions": {
        "canDeleteCollection": [],
        "canArchiveCollection": [],
        "canUpdateStandards": [],
        "canUpdateCustomData": [],
        "canUpdateManager": [],
        "canUpdateCollectionMetadata": [],
        "canUpdateValidTokenIds": [],
        "canUpdateTokenMetadata": [],
        "canUpdateCollectionApprovals": [],
        "canAddMoreAliasPaths": [],
        "canAddMoreCosmosCoinWrapperPaths": []
    },
    "updateManager": true,
    "manager": "",
    "updateCollectionMetadata": true,
    "collectionMetadata": {},
    "updateTokenMetadata": true,
    "tokenMetadata": [],
    "updateCustomData": true,
    "customData": "",
    "updateCollectionApprovals": true,
    "collectionApprovals": [],
    "updateStandards": true,
    "standards": [],
    "updateIsArchived": true,
    "isArchived": false,
    "mintEscrowCoinsToTransfer": [],
    "cosmosCoinWrapperPathsToAdd": [],
    "aliasPathsToAdd": [],
    "invariants": {
        "noCustomOwnershipTimes": false,
        "maxSupplyPerId": "0",
        "cosmosCoinBackedPath": undefined,
        "noForcefulPostMintTransfers": false,
        "disablePoolCreation": false
    }
}
```

### JSON Example - Updating an Existing Collection

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "updateValidTokenIds": true,
    "validTokenIds": [{ "start": "1", "end": "200" }],
    "updateCollectionPermissions": false,
    "collectionPermissions": {},
    "updateManager": false,
    "manager": "",
    "updateCollectionMetadata": false,
    "collectionMetadata": {},
    "updateTokenMetadata": false,
    "tokenMetadata": [],
    "updateCustomData": false,
    "customData": "",
    "updateCollectionApprovals": false,
    "collectionApprovals": [],
    "updateStandards": false,
    "standards": [],
    "updateIsArchived": false,
    "isArchived": false,
    "mintEscrowCoinsToTransfer": [],
    "cosmosCoinWrapperPathsToAdd": [],
    "aliasPathsToAdd": [],
    "invariants": {}
}
```

## Key Differences from Other Messages

### vs MsgCreateCollection

-   More flexible update flag pattern
-   Can be used for both creation and updates
-   Includes invariants support

### vs MsgUpdateCollection

-   Can create new collections when collectionId = "0"
    -   Includes creation-only fields like `defaultBalances`
-   Includes invariants support

## Invariants Support

When creating a new collection (collectionId = "0"), you can set collection invariants using the `invariants` field. Invariants cannot be modified after collection creation.

```json
{
    "invariants": {
        "noCustomOwnershipTimes": true,
        "maxSupplyPerId": "0",
        "cosmosCoinBackedPath": undefined,
        "noForcefulPostMintTransfers": false,
        "disablePoolCreation": false
    }
}
```

## Related Messages

-   [MsgCreateCollection](msg-create-collection.md)
-   [MsgUpdateCollection](msg-update-collection.md)
-   [Collection Setup Fields](../../token-standard/learn/collection-setup-fields.md)


## File: ./x-badges/messages/msg-update-collection.md

# MsgUpdateCollection

Updates an existing collection's properties.

## Update Flag Pattern

This message uses an update flag + value pattern for selective updates. Each updatable field has a corresponding boolean flag (e.g., `updateValidTokenIds`, `updateCollectionPermissions`).

-   **If update flag is `true`**: The corresponding value field is processed and the collection is updated with the new value
-   **If update flag is `false`**: The corresponding value field is completely ignored, regardless of what data is provided

This allows you to update only specific fields without affecting others, and you can safely leave unused value fields empty or with placeholder data.

## Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. All updates must obey the previously set permissions - meaning the permission settings that were in effect _before_ this message was started.

**Important**: If you update the permissions in the current message, those new permissions are applied last and will not be applicable until the following transaction. This prevents circumventing permission restrictions within the same transaction.

## Proto Definition

```protobuf
message MsgUpdateCollection {
  string creator = 1; // Address updating collection (must be manager)
  string collectionId = 2; // ID of collection to update
  bool updateValidTokenIds = 3;
  repeated UintRange validTokenIds = 4;
  bool updateCollectionPermissions = 5;
  CollectionPermissions collectionPermissions = 6;
  bool updateManager = 7;
  string manager = 8;
  bool updateCollectionMetadata = 9;
  CollectionMetadata collectionMetadata = 10;
  bool updateTokenMetadata = 11;
  repeated TokenMetadata tokenMetadata = 12;
  bool updateCustomData = 13;
  string customData = 14;
  bool updateCollectionApprovals = 15;
  repeated CollectionApproval collectionApprovals = 16;
  bool updateStandards = 17;
  repeated string standards = 18;
  bool updateIsArchived = 19;
  bool isArchived = 20;
  repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 21;
  repeated CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 22;
  repeated AliasPathAddObject aliasPathsToAdd = 23;
  CollectionInvariants invariants = 24;
}

message MsgUpdateCollectionResponse {
  string collectionId = 1; // ID of updated collection
}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges update-collection '[tx-json]' --from manager-key
```

### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "updateValidTokenIds": true,
    "validTokenIds": [{ "start": "1", "end": "200" }],
    "updateCollectionPermissions": false,
    "collectionPermissions": {
        "canDeleteCollection": [],
        "canArchiveCollection": [],
        "canUpdateStandards": [],
        "canUpdateCustomData": [],
        "canUpdateManager": [],
        "canUpdateCollectionMetadata": [],
        "canUpdateValidTokenIds": [],
        "canUpdateTokenMetadata": [],
        "canUpdateCollectionApprovals": [],
        "canAddMoreAliasPaths": [],
        "canAddMoreCosmosCoinWrapperPaths": []
    },
    "updateManager": false,
    "manager": "",
    "updateCollectionMetadata": false,
    "collectionMetadata": {},
    "updateTokenMetadata": false,
    "tokenMetadata": [],
    "updateCustomData": false,
    "customData": "",
    "updateCollectionApprovals": false,
    "collectionApprovals": [],
    "updateStandards": false,
    "standards": [],
    "updateIsArchived": false,
    "isArchived": false,
    "mintEscrowCoinsToTransfer": [],
    "cosmosCoinWrapperPathsToAdd": [],
    "aliasPathsToAdd": [],
    "invariants": {
        "noCustomOwnershipTimes": false,
        "maxSupplyPerId": "0",
        "cosmosCoinBackedPath": undefined,
        "noForcefulPostMintTransfers": false,
        "disablePoolCreation": false
    }
}
```


## File: ./x-badges/messages/msg-update-dynamic-store.md

# MsgUpdateDynamicStore

Updates an existing dynamic store's default value, global kill switch status, and optional metadata fields.

## Proto Definition

```protobuf
message MsgUpdateDynamicStore {
  string creator = 1; // Address updating the store (must be creator)
  string storeId = 2; // ID of dynamic store to update
  bool defaultValue = 3; // New default value for uninitialized addresses
  bool globalEnabled = 4; // Global kill switch. When false, all approvals using this store fail immediately
  string uri = 5; // Optional: URI for additional metadata or resources
  string customData = 6; // Optional: Custom data field for arbitrary data
}

message MsgUpdateDynamicStoreResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges update-dynamic-store [store-id] [default-value] [global-enabled] --from creator-key
```

### JSON Examples

**Update default value only (keep globalEnabled unchanged):**
```json
{
    "creator": "bb1...",
    "storeId": "1",
    "defaultValue": true,
    "globalEnabled": true  // Must pass current value to avoid changing it
}
```

**Disable global kill switch (halt all approvals using this store):**
```json
{
    "creator": "bb1...",
    "storeId": "1",
    "defaultValue": true,  // Must pass current value
    "globalEnabled": false  // Disable kill switch
}
```

**Re-enable global kill switch:**
```json
{
    "creator": "bb1...",
    "storeId": "1",
    "defaultValue": true,
    "globalEnabled": true  // Re-enable
}
```

**Update metadata fields:**
```json
{
    "creator": "bb1...",
    "storeId": "1",
    "defaultValue": true,
    "globalEnabled": true,
    "uri": "https://example.com/updated-metadata",
    "customData": "{\"updated\": true, \"timestamp\": \"2024-01-01\"}"
}
```

**Clear metadata fields (set to empty strings):**
```json
{
    "creator": "bb1...",
    "storeId": "1",
    "defaultValue": true,
    "globalEnabled": true,
    "uri": "",
    "customData": ""
}
```

## Global Kill Switch

The `globalEnabled` field acts as a global kill switch for the dynamic store. When `globalEnabled = false`:
- All approvals using this store via `DynamicStoreChallenge` will fail immediately
- The error message will be: "dynamic store storeId {id} is globally disabled"
- Per-address values are ignored when the kill switch is disabled

This is useful for quickly halting all approvals that depend on a specific dynamic store (e.g., if a protocol is compromised).

**Note**: When updating a store, you must pass the current `globalEnabled` value if you want to keep it unchanged. Proto3 bools default to `false`, so you must explicitly pass `true` to maintain an enabled state.

## Metadata Fields

The `uri` and `customData` fields can be updated along with other store properties:

- **`uri`**: URI for additional metadata or resources. Can be set, updated, or cleared (set to empty string).
- **`customData`**: Custom data field for arbitrary string data. Can be set, updated, or cleared (set to empty string).


## File: ./x-badges/messages/msg-update-user-approvals.md

# MsgUpdateUserApprovals

Updates a user's approval settings for token transfers.

## Collection ID Auto-Lookup

If you specify `collectionId` as `"0"`, it will automatically lookup the latest collection ID created. This can be used if you are creating a collection and do not know the official collection ID yet but want to perform a multi-message transaction.

## Update Flag Pattern

This message uses an update flag + value pattern for selective updates. Each updatable field has a corresponding boolean flag (e.g., `updateOutgoingApprovals`, `updateIncomingApprovals`, `updateAutoApproveSelfInitiatedOutgoingTransfers`).

-   **If update flag is `true`**: The corresponding value field is processed and the user's settings are updated with the new value
-   **If update flag is `false`**: The corresponding value field is completely ignored, regardless of what data is provided

This allows you to update only specific approval settings without affecting others, and you can safely leave unused value fields empty or with placeholder data.

## Authorization & Permissions

Users can only update their own approvals. Updates must be performed according to the permissions set (i.e. the `userPermissions` previously set for that user).

**Note**: Typically, user permissions are almost always permanently allowed/set to enabled. These permissions only need to be customized in advanced cases where fine-grained control over user approval updates is required.

## Proto Definition

```protobuf
message MsgUpdateUserApprovals {
  string creator = 1; // User updating their approval settings
  string collectionId = 2; // Target collection for approval updates
  bool updateOutgoingApprovals = 3;
  repeated UserOutgoingApproval outgoingApprovals = 4;
  bool updateIncomingApprovals = 5;
  repeated UserIncomingApproval incomingApprovals = 6;
  bool updateAutoApproveSelfInitiatedOutgoingTransfers = 7;
  bool autoApproveSelfInitiatedOutgoingTransfers = 8;
  bool updateAutoApproveSelfInitiatedIncomingTransfers = 9;
  bool autoApproveSelfInitiatedIncomingTransfers = 10;
  bool updateAutoApproveAllIncomingTransfers = 11;
  bool autoApproveAllIncomingTransfers = 12;
  bool updateUserPermissions = 13;
  UserPermissions userPermissions = 14;
}

message MsgUpdateUserApprovalsResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges update-user-approved-transfers '[tx-json]' --from user-key
```

### JSON Example

For complete transaction examples, see [MsgUpdateUserApprovals Examples](../examples/txs/msgupdate-user-approvals/).

```json
{
    "creator": "bb1user123...",
    "collectionId": "1",

    "updateOutgoingApprovals": false,
    "outgoingApprovals": [],

    "updateIncomingApprovals": false,
    "incomingApprovals": [],

    "updateAutoApproveSelfInitiatedOutgoingTransfers": true,
    "autoApproveSelfInitiatedOutgoingTransfers": true,

    "updateAutoApproveSelfInitiatedIncomingTransfers": false,
    "autoApproveSelfInitiatedIncomingTransfers": true,

    "updateAutoApproveAllIncomingTransfers": false,
    "autoApproveAllIncomingTransfers": false,

    "updateUserPermissions": false,
    "userPermissions": {
        "canUpdateOutgoingApprovals": [],
        "canUpdateIncomingApprovals": [],
        "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [],
        "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [],
        "canUpdateAutoApproveAllIncomingTransfers": []
    }
}
```


## File: ./x-badges/queries/README.md

# üîç Queries

This directory contains detailed documentation for all query types supported by the tokens module.

## Query Categories

### Collection Queries

-   [GetCollection](./get-collection.md) - Retrieve collection data and properties

### Balance Queries

-   [GetBalance](./get-balance.md) - Get user balances for a collection
-   [GetWrappableBalances](./get-wrappable-balances.md) - Get maximum amount of tokens that can be wrapped into cosmos coins

### Address List Queries

-   [GetAddressList](./get-address-list.md) - Retrieve address list information

### Approval Tracking Queries

-   [GetApprovalTracker](./get-approval-tracker.md) - Get approval usage tracking data and limits
-   [GetChallengeTracker](./get-challenge-tracker.md) - Get challenge completion tracking status
-   [GetETHSignatureTracker](./get-eth-signature-tracker.md) - Get ETH signature challenge usage tracking status

### Dynamic Store Queries

-   [GetDynamicStore](./get-dynamic-store.md) - Get dynamic store configuration and metadata
-   [GetDynamicStoreValue](./get-dynamic-store-value.md) - Get numeric value for specific address in store

### System Queries

-   [Params](./params.md) - Get current module parameters and configuration


## File: ./x-badges/queries/get-address-list.md

# GetAddressList

Retrieves information about a specific address list.

## Proto Definition

```protobuf
message QueryGetAddressListRequest {
  string listId = 1; // ID of address list to retrieve
}

message QueryGetAddressListResponse {
  AddressList list = 1;
}

message AddressList {
  string listId = 1; // Unique identifier for the address list
  repeated string addresses = 2; // List of addresses included in the list
  bool whitelist = 3; // Whether list includes (true) or excludes (false) specified addresses
  string uri = 4; // URI providing metadata, if applicable
  string customData = 5; // Custom arbitrary data or additional information
  string createdBy = 6; // The user or entity who created the address list
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-address-list [id]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_address_list/1"
```

### Response Example

```json
{
    "list": {
        "listId": "1",
        "addresses": ["bb1...", "bb1..."],
        "whitelist": true,
        "uri": "",
        "customData": "",
        "createdBy": "bb1..."
    }
}
```


## File: ./x-badges/queries/get-approval-tracker.md

# GetApprovalTracker

Retrieves tracking information for approval usage.

## Proto Definition

```protobuf
message QueryGetApprovalTrackerRequest {
  string amountTrackerId = 1; 
  string approvalLevel = 2; // "collection", "incoming", or "outgoing"
  string approverAddress = 3; // Leave blank if approvalLevel is "collection"
  string trackerType = 4; // "overall", "to", "from", "initiatedBy"
  string collectionId = 5;
  string approvedAddress = 6; // Leave blank if trackerType is "overall"
  string approvalId = 7;
}

message QueryGetApprovalTrackerResponse {
  ApprovalTracker tracker = 1;
}

message ApprovalTracker {
  string numTransfers = 1; // Number of transfers that have been processed
  repeated Balance amounts = 2; // Cumulative balances associated with processed transfers
  string lastUpdatedAt = 3; // Last updated at time (UNIX millisecond timestamp)
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-approval-tracker [collectionId] [approvalLevel] [approverAddress] [approvalId] [amountTrackerId] [trackerType] [approvedAddress]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_approvals_tracker/1/outgoing/bb1.../approval-1/tracker-1/overall/"
```

### Response Example
```json
{
  "tracker": {
    "numTransfers": "5",
    "amounts": [
      {
        "amount": "100",
        "tokenIds": [{"start": "1", "end": "10"}],
        "ownershipTimes": [{"start": "1672531200000", "end": "18446744073709551615"}]
      }
    ],
    "lastUpdatedAt": "1672531200000"
  }
}
```

## File: ./x-badges/queries/get-balance.md

# GetBalance

Retrieves balances for a specific address in a collection.

## Proto Definition

```protobuf
message QueryGetBalanceRequest {
  string collectionId = 1; // Collection ID to query
  string address = 2; // Address to get balances for
}

message QueryGetBalanceResponse {
  UserBalanceStore balance = 1;
}

message UserBalanceStore {
  repeated Balance balances = 1; // List of balances associated with this user
  repeated UserOutgoingApproval outgoingApprovals = 2; // Approved outgoing transfers
  repeated UserIncomingApproval incomingApprovals = 3; // Approved incoming transfers
  bool autoApproveSelfInitiatedOutgoingTransfers = 4; // Auto-approve self-initiated outgoing transfers
  bool autoApproveSelfInitiatedIncomingTransfers = 5; // Auto-approve self-initiated incoming transfers
  bool autoApproveAllIncomingTransfers = 6; // Auto-approve all incoming transfers
  UserPermissions userPermissions = 7; // Permissions for this user's actions
}

// See all the proto definitions [here](https://github.com/BitBadges/bitbadgeschain/tree/master/proto/badges)
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-balance [collection-id] [address]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_balance/1/bb1..."
```

### Response Example

```json
{
    "balance": {
        "balances": [
            {
                "amount": "1",
                "tokenIds": [{ "start": "1", "end": "1" }],
                "ownershipTimes": [
                    { "start": "1672531200000", "end": "18446744073709551615" }
                ]
            }
        ],
        "outgoingApprovals": [
            // ...
        ],
        "incomingApprovals": [
            // ...
        ],
        "autoApproveSelfInitiatedOutgoingTransfers": true,
        "autoApproveSelfInitiatedIncomingTransfers": true,
        "autoApproveAllIncomingTransfers": true,
        "userPermissions": {
            // ...
        }
    }
}
```


## File: ./x-badges/queries/get-challenge-tracker.md

# GetChallengeTracker

Retrieves the number of times a given leaf has been used for a specific challenge tracker.

## Proto Definition

```protobuf
message QueryGetChallengeTrackerRequest {
  string collectionId = 1;
  string approvalLevel = 2; // "collection", "incoming", or "outgoing"
  string approverAddress = 3; // Leave blank if approvalLevel is "collection"
  string challengeTrackerId = 4;
  string leafIndex = 5;
  string approvalId = 6;
}

message QueryGetChallengeTrackerResponse {
  string numUsed = 1; // Number of times this leaf has been used
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-challenge-tracker [collectionId] [approvalLevel] [approverAddress] [approvalId] [challengeTrackerId] [leafIndex]

# REST API
# Note for blank values, use "" so you may have // in the query
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_challenge_tracker/1/collection//approval-123/challenge-1/42"
```

### Response Example

```json
{
    "numUsed": "1"
}
```


## File: ./x-badges/queries/get-collection.md

# GetCollection

Retrieves complete information about a collection.

## Proto Definition

```protobuf
message QueryGetCollectionRequest {
  string collectionId = 1; // ID of collection to retrieve
}

message QueryGetCollectionResponse {
  TokenCollection collection = 1;
}

message TokenCollection {
  string collectionId = 1; // Unique identifier for this collection
  CollectionMetadata collectionMetadata = 2; // Collection metadata
  repeated TokenMetadata tokenMetadata = 3; // Token metadata
  string customData = 4; // Arbitrary custom data
  string manager = 5; // Manager address
  CollectionPermissions collectionPermissions = 6; // Collection permissions
  repeated CollectionApproval collectionApprovals = 7; // Collection-level approvals
  repeated string standards = 8; // Standards
  bool isArchived = 9; // Archive status
  UserBalanceStore defaultBalances = 10; // Default balance store for users
  string createdBy = 11; // Creator of the collection
  repeated UintRange validTokenIds = 12; // Valid token ID ranges
  string mintEscrowAddress = 13; // Generated escrow address for the collection
}

// See all the proto definitions [here](https://github.com/bitbadges/bitbadgeschain/tree/master/proto/badges)
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-collection [id]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_collection/1"
```

### Response Example

```json
{
    "collection": {
        "collectionId": "1"
        // ...
    }
}
```


## File: ./x-badges/queries/get-dynamic-store-value.md

# GetDynamicStoreValue

Retrieves the boolean value for a specific address in a dynamic store.

## Proto Definition

```protobuf
message QueryGetDynamicStoreValueRequest {
  string storeId = 1; // ID of dynamic store to query
  string address = 2; // Address to get value for
}

message QueryGetDynamicStoreValueResponse {
  DynamicStoreValue value = 1;
}

message DynamicStoreValue {
  string storeId = 1; // The dynamic store ID
  string address = 2; // The address this value applies to
  bool value = 3; // The boolean value
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-dynamic-store-value [store-id] [address]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_dynamic_store_value/1/bb1..."
```

### Response Example

```json
{
    "value": {
        "storeId": "1",
        "address": "bb1...",
        "value": true
    }
}
```


## File: ./x-badges/queries/get-dynamic-store.md

# GetDynamicStore

Retrieves information about a dynamic store.

## Proto Definition

```protobuf
message QueryGetDynamicStoreRequest {
  string storeId = 1;
}

message QueryGetDynamicStoreResponse {
  DynamicStore store = 1;
}

message DynamicStore {
  // The unique identifier for this dynamic store. This is assigned by the blockchain.
  string storeId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  // The address of the creator of this dynamic store.
  string createdBy = 2;
  // The default value for uninitialized addresses.
  bool defaultValue = 3;
  // Global kill switch. When false, all approvals using this store fail immediately.
  bool globalEnabled = 4;
  // URI for additional metadata or resources associated with this dynamic store.
  string uri = 5;
  // Custom data field for storing arbitrary data associated with this dynamic store.
  string customData = 6;
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-dynamic-store [store-id]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_dynamic_store/1"
```

### Response Example

```json
{
    "store": {
        "storeId": "1",
        "createdBy": "bb1...",
        "defaultValue": false,
        "globalEnabled": true,
        "uri": "https://example.com/metadata",
        "customData": "{\"key\": \"value\"}"
    }
}
```

**Note**: Both `uri` and `customData` are optional fields. They may be empty strings (`""`) if not set when creating or updating the store.

## Global Kill Switch

The `globalEnabled` field indicates whether the global kill switch is enabled for this store. When `globalEnabled = false`, all approvals using this store via `DynamicStoreChallenge` will fail immediately, regardless of per-address values.

-   **New stores**: Default to `globalEnabled = true`
-   **Existing stores**: Set to `globalEnabled = true` for backward compatibility
-   **Disabling**: Use [MsgUpdateDynamicStore](../messages/msg-update-dynamic-store.md) to set `globalEnabled = false`


## File: ./x-badges/queries/get-eth-signature-tracker.md

# GetETHSignatureTracker

Retrieves the number of times a given signature has been used for a specific ETH signature challenge tracker.

## Proto Definition

```protobuf
message QueryGetETHSignatureTrackerRequest {
  string collectionId = 1;
  string approvalLevel = 2; // "collection", "incoming", or "outgoing"
  string approverAddress = 3; // Leave blank if approvalLevel is "collection"
  string approvalId = 4;
  string challengeTrackerId = 5;
  string signature = 6;
}

message QueryGetETHSignatureTrackerResponse {
  string numUsed = 1; // Number of times this signature has been used
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-num-used-for-eth-signature-challenge [collectionId] [approvalLevel] [approverAddress] [approvalId] [challengeTrackerId] [signature]

# REST API
# Note for blank values, use "" so you may have // in the query
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_eth_signature_tracker/1/collection//approval-123/challenge-1/bb1..."
```

### Response Example

```json
{
    "numUsed": "1"
}
```

## Notes

- Each signature can only be used once per challenge tracker
- If a signature has never been used, the response will be "0"
- The signature parameter should be the full Ethereum signature (0x-prefixed hex string) 

## File: ./x-badges/queries/get-wrappable-balances.md

# GetWrappableBalances

Retrieves the maximum amount of tokens that can be wrapped into cosmos coins for a specific denom and user address.

## Proto Definition

```protobuf
message QueryGetWrappableBalancesRequest {
  string denom = 1; // The cosmos coin denom (e.g., "badges:1:mytoken")
  string address = 2; // Address to get wrappable balances for
}

message QueryGetWrappableBalancesResponse {
  Uint maxWrappableAmount = 1; // Maximum amount that can be wrapped
}
```

## Description

This query calculates the maximum amount of tokens that a user can wrap into cosmos coins for a given denom. It:

1. **Parses the denom**: Extracts the collection ID from the denom format `badges:COLL_ID:*` or `badgeslp:COLL_ID:*`
2. **Finds the wrapper path**: Locates the corresponding cosmos coin wrapper path for the denom
3. **Calculates maximum wrappable amount**: Determines the largest amount the user can wrap based on their current balances

The query supports both static denoms and dynamic `{id}` placeholder denoms. For dynamic denoms, it extracts numeric characters from the base denom to replace the `{id}` placeholder.

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-wrappable-balances [denom] [address]

# Example with static denom
bitbadgeschaind query badges get-wrappable-balances "badges:1:mytoken" "bb1..."

# Example with dynamic denom (where 123 is the token ID)
bitbadgeschaind query badges get-wrappable-balances "badgeslp:1:token123" "bb1..."
```

### REST API

```bash
# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_wrappable_balances?denom=badges:1:mytoken&address=bb1..."
```

### Response Example

```json
{
    "maxWrappableAmount": "1000"
}
```

## Error Cases

-   **Invalid denom format**: Denom must start with "badges:" or "badgeslp:" and follow the format `badges:COLL_ID:*` or `badgeslp:COLL_ID:*`
-   **Collection not found**: The specified collection ID doesn't exist
-   **Wrapper path not found**: No cosmos coin wrapper path matches the given denom
-   **No balances**: User has no balances for the required token IDs and ownership times

## Use Cases

-   **Pre-wrapping validation**: Check how much a user can wrap before attempting the wrap operation
-   **UI display**: Show users their maximum wrappable amount for different tokens
-   **Batch operations**: Calculate optimal amounts for multiple wrapping operations
-   **Integration testing**: Verify wrapper path configurations work correctly

## Related Queries

-   [GetBalance](./get-balance.md) - Get user's current balances
-   [GetCollection](./get-collection.md) - Get collection details including wrapper paths


## File: ./x-badges/queries/params.md

# Params

Retrieves the current module parameters.

## Proto Definition

```protobuf
message QueryParamsRequest {}

message QueryParamsResponse {
  Params params = 1;
}

message Params {
  // Array of allowed denominations for fee payments and escrow operations
  repeated string allowed_denoms = 1;
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges params

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/params"
```

### Response Example
```json
{
  "params": {
    "allowedDenoms": ["ubadge", "ibc/1234567890"]
  }
}
```


## File: ./x-custom-ibc-hooks/README.md

# Overview

This directory contains comprehensive developer documentation for the BitBadges blockchain's `x/custom-ibc-hooks` module.

The Custom IBC Hooks module extends IBC transfer functionality by allowing users to execute custom actions (such as swaps and transfers) automatically when receiving IBC tokens. This enables complex cross-chain workflows in a single transaction (e.g. Skip:Go compatibility or other IBC aggregators).

## Key Features

* **Swap and Transfer**: Automatically swap received tokens and transfer the output to a destination
* **Swap and IBC Transfer**: Swap received tokens and send them to another chain via IBC
* **Cross-chain DeFi**: Enable seamless cross-chain DeFi operations without manual intervention
* **Atomic Execution**: All operations are executed atomically - either all succeed or all fail

## Architecture

The module operates as an IBC middleware hook that:

1. Intercepts incoming IBC transfer packets
2. Parses hook data from the transfer memo
3. Executes the IBC transfer first (to receive the tokens)
4. Executes the custom hook actions (swap, transfer, etc.)
5. Returns an error acknowledgement if the hook fails, rolling back the entire transaction

## Table of Contents

1. [Introduction](overview.md) - Overview and key concepts


## File: ./x-custom-ibc-hooks/overview.md

# Introduction

## Architecture

The module operates as an IBC middleware hook that:

1. Intercepts incoming IBC transfer packets
2. Parses hook data from the transfer memo
3. Executes the IBC transfer first (to receive the tokens)
4. Executes the custom hook actions (swap, transfer, etc.)
5. Returns an error acknowledgement if the hook fails, rolling back the entire transaction

```
Warning: Native x/badges assets cannot be IBC transferred. Only x/bank assets can be.
```

## Key Concepts

### Hook Data Format

Hook data is specified in the IBC transfer memo using JSON format. The module supports the `swap_and_action` format, similar to Skip Protocol's implementation with a couple minor differences (some features may not be supported).

### Swap and Action

The primary hook type is `swap_and_action`, which:

1. Executes a swap operation using the received tokens
2. Performs a post-swap action (local transfer or IBC transfer)

### Intermediate Sender Address

The module derives an intermediate sender address from the IBC channel and original sender. This address is used to:

* Receive the IBC transfer tokens
* Execute the swap operation
* Send tokens to the final destination

Use here for generation if needed

<pre class="language-typescript"><code class="lang-typescript"><strong>import { deriveIntermediateSender } from 'bitbadgesjs-sdk';
</strong>
// deriveIntermediateSender('channel-0', 'osmo1...', 'bb');
export function deriveIntermediateSender(channel: string, originalSender: string, bech32Prefix: string)
</code></pre>

### Atomic Execution

All operations are executed atomically:

* If the IBC transfer succeeds but the hook fails, the entire transaction is rolled back
* If the hook fails, an error acknowledgement is returned, preventing the IBC transfer from completing
* State changes are only committed if all operations succeed

## Hook Data Structure

### HookData

```go
type HookData struct {
    SwapAndAction *SwapAndAction `json:"swap_and_action,omitempty"`
}
```

### SwapAndAction

```go
type SwapAndAction struct {
    UserSwap                  *UserSwap       `json:"user_swap,omitempty"`
    MinAsset                  *MinAsset       `json:"min_asset,omitempty"`
    TimeoutTimestamp          *uint64         `json:"timeout_timestamp,omitempty"`
    PostSwapAction            *PostSwapAction `json:"post_swap_action,omitempty"`
    DestinationRecoverAddress string          `json:"destination_recover_address,omitempty"`
    Affiliates                []Affiliate     `json:"affiliates,omitempty"`
}
```

### UserSwap

```go
type UserSwap struct {
    SwapExactAssetIn *SwapExactAssetIn `json:"swap_exact_asset_in,omitempty"`
}
```

### SwapExactAssetIn

```go
type SwapExactAssetIn struct {
    SwapVenueName string      `json:"swap_venue_name,omitempty"`
    Operations    []Operation `json:"operations"`
}
```

### Operation

```go
type Operation struct {
    Pool     string `json:"pool"`     // Pool ID as string
    DenomIn  string `json:"denom_in"`
    DenomOut string `json:"denom_out"`
}
```

### MinAsset

```go
type MinAsset struct {
    Native *NativeAsset `json:"native,omitempty"`
}
```

### NativeAsset

```go
type NativeAsset struct {
    Denom  string `json:"denom"`
    Amount string `json:"amount"`
}
```

### PostSwapAction

```go
type PostSwapAction struct {
    IBCTransfer *IBCTransferInfo `json:"ibc_transfer,omitempty"`
    Transfer    *TransferInfo    `json:"transfer,omitempty"`
}
```

**Note**: Exactly one of `IBCTransfer` or `Transfer` must be specified.

### TransferInfo

```go
type TransferInfo struct {
    ToAddress string `json:"to_address"`
}
```

### IBCTransferInfo

```go
type IBCTransferInfo struct {
    IBCInfo *IBCInfo `json:"ibc_info,omitempty"`
}
```

### IBCInfo

```go
type IBCInfo struct {
    SourceChannel  string `json:"source_channel"`
    Receiver       string `json:"receiver"`
    Memo           string `json:"memo,omitempty"`
    RecoverAddress string `json:"recover_address,omitempty"`
}
```

### Affiliate

```go
type Affiliate struct {
    BasisPointsFee string `json:"basis_points_fee"`
    Address        string `json:"address"`
}
```

#### Affiliates

The `affiliates` field allows you to specify fee recipients who will receive a portion of the swap output as an affiliate fee. This is useful for referral programs, partnerships, or revenue sharing.

* **Optional**: If not specified, no affiliate fees are deducted
* **Basis points**: Fees are specified in basis points (1 basis point = 0.01%, 100 basis points = 1%)
* **Multiple affiliates**: You can specify multiple affiliates, each receiving their specified fee
* **Fee calculation**: Fees are calculated on the swap output amount before any post-swap actions
* **Address format**: Must be a valid Bech32 address on the destination chain

**Example**:

```json
{
    "affiliates": [
        {
            "basis_points_fee": "10", // 0.1% fee
            "address": "bb1..."
        },
        {
            "basis_points_fee": "25", // 0.25% fee
            "address": "bb1..."
        }
    ]
}
```

In this example, if the swap outputs 1,000,000 tokens:

* First affiliate receives: 1,000,000 √ó 0.001 = 1,000 tokens
* Second affiliate receives: 1,000,000 √ó 0.0025 = 2,500 tokens
* Remaining amount: 1,000,000 - 1,000 - 2,500 = 996,500 tokens

The remaining amount (996,500 tokens) is then used for the post-swap action.

#### DestinationRecoverAddress

The `destination_recover_address` field specifies what to do in the case of a swap failure. The typical behavior is that if a swap of asset A to asset B fails, the whole IBC transfer is failed (acknowledgement error) and funds (asset A) are rolled back to the source chain. However, by specifying the address here, you can let the hook know that you are okay with just keeping asset A in the specified destination address in the case of a swap failure on the destination chain. Any post-swap action will not be executed since the swap failed. It will simply be treated as a standard IBC transfer to the specified address with no swap or post-swap action.

```json
{
    "destination_recover_address": "bb1..." // Destination chain address (optional)
}
```

This only applies in the case of swap failures. Swap logic failures include, but are not limited to:

* Exceeds slippage tolerance
* Compliance not passed
* Insufficient funds (should never happen since we use the amount transferred via IBC as the input amount)
* Calculated amount out equals zero
* etc.

This is not applied in the cases below. Standard behavior is used in these cases.

* Misconfigurations of the messages (wrong prefixes, missing fields, etc.)
* Invalid pool IDs
* Standard IBC transfer failures (rate limits, timeouts, etc.)

Logic here is that in the event of a swap failure, the expected chain where the user expects funds to be recoverable is the source chain.

For example, if we have a multi-swap path like:

1. Send Asset A from BitBadges to Osmosis
2. Swap Asset A to Asset B on Osmosis
3. Send Asset B from Osmosis to BitBadges
4. Swap Asset B to Asset C on BitBadges

If Step 4 fails, the default behavior is that funds (Asset B) will be recoverable on Osmosis (bad UX). With this recovery logic, if Step 4 fails, funds (Asset B) will be recoverable on BitBadges (better UX). Minor, but it avoids confusion for the user and potentially needing to interact with other chains for recovery. It isn't a catch-all solution, but it is a good UX improvement in many cases.

## Validation Rules

1. **Post-swap action is required**: The `post_swap_action` field must be present
2. **Exactly one action**: Either `ibc_transfer` or `transfer` must be specified, but not both
3. **Swap required**: If `post_swap_action` is defined, a swap must also be defined
4. **Single-hop swaps**: Only single-operation swaps are currently supported
5. **Denom matching**: The swap's `denom_in` must match the received token denomination and the amount will automatically be the received amount
6. **Channel validation**: For IBC transfers, the source channel must exist
7. **Address validation**: All addresses must be valid Bech32 addresses
8. **Capability validation**: Channel capabilities must exist for IBC transfers

### Post-Swap Actions

#### Local Transfer

Transfers the swapped tokens to a local address:

```json
{
    "transfer": {
        "to_address": "bb1..."
    }
}
```

#### IBC Transfer

Sends the swapped tokens to another chain via IBC:

```json
{
    "ibc_transfer": {
        "ibc_info": {
            "source_channel": "channel-0",
            "receiver": "bb1...",
            "memo": "...",
            "recover_address": "bb1..."
        }
    }
}
```

## Limitations

1. **Single-hop swaps only**: Multi-hop swaps are not supported
2. **GAMM pools only**: Only GAMM pool swaps are supported
3. **No BitBadges IBC transfers**: BitBadges denominations cannot be IBC transferred
4. **Required swap**: A swap is required if using post-swap actions (use packet-forward-middleware for transfers without swaps)

## Usage Example

### Swap and Local Transfer

```json
{
    "swap_and_action": {
        "user_swap": {
            "swap_exact_asset_in": {
                "swap_venue_name": "bitbadges-poolmanager",
                "operations": [
                    {
                        "pool": "1",
                        "denom_in": "ubadge",
                        "denom_out": "ibc/ABC..."
                    }
                ]
            }
        },
        "min_asset": {
            "native": {
                "denom": "ibc/ABC...",
                "amount": "1000000"
            }
        },
        "post_swap_action": {
            "transfer": {
                "to_address": "bb1..."
            }
        }
    }
}
```

### Swap and IBC Transfer

```json
{
    "swap_and_action": {
        "user_swap": {
            "swap_exact_asset_in": {
                "swap_venue_name": "bitbadges-poolmanager",
                "operations": [
                    {
                        "pool": "1",
                        "denom_in": "ubadge",
                        "denom_out": "ibc/ABC..."
                    }
                ]
            }
        },
        "min_asset": {
            "native": {
                "denom": "ibc/ABC...",
                "amount": "1000000"
            }
        },
        "timeout_timestamp": 1234567890000000000,
        "post_swap_action": {
            "ibc_transfer": {
                "ibc_info": {
                    "source_channel": "channel-0",
                    "receiver": "cosmos1xyz789...",
                    "recover_address": "cosmos1intermediate..."
                }
            }
        },
        "destination_recover_address": "bb1...",
        "affiliates": [
            {
                "basis_points_fee": "10",
                "address": "bb1..."
            }
        ]
    }
}
```

### Swap with Affiliates

```json
{
    "swap_and_action": {
        "user_swap": {
            "swap_exact_asset_in": {
                "swap_venue_name": "bitbadges-poolmanager",
                "operations": [
                    {
                        "pool": "1",
                        "denom_in": "ubadge",
                        "denom_out": "ibc/ABC..."
                    }
                ]
            }
        },
        "min_asset": {
            "native": {
                "denom": "ibc/ABC...",
                "amount": "1000000"
            }
        },
        "post_swap_action": {
            "transfer": {
                "to_address": "bb1..."
            }
        },
        "affiliates": [
            {
                "basis_points_fee": "50", // 0.5% fee
                "address": "bb1affiliate1..."
            },
            {
                "basis_points_fee": "25", // 0.25% fee
                "address": "bb1affiliate2..."
            }
        ]
    }
}
```


## File: ./x-gamm/README.md

# Overview

This directory contains comprehensive developer documentation for the BitBadges blockchain's `x/gamm` module.

This module was forked from Osmosis's `x/gamm` module with several key modifications to support BitBadges tokens and enhance compatibility.

## Key Differences from Osmosis

### 1. Interface Revamps

* Removed `smoothWeightChangeParams` and other unused parameters
* Updated certain type definitions for better compatibility with our codebase
* Streamlined interfaces for improved performance
* Remove unneeded logic like stableswap pools and governance proposal handling
* Removed future pool governor functionality
* Removed pool creation fee requirements

### 2. Badge Token Integration

The main difference is in the badge token handling system. With every attempted transfer of BitBadges tokens, the system:

* **Wrapping Conversion**: Uses `cosmosCoinWrapperPaths` defined by the collection to abstract badge tokens to `x/bank` denominations (using the `path.balances` array) at a set conversion rate
* **Mint/Burns**: Behind the scenes, `x/badges` denomination is used before / after each swap and to/from a pool if the asset is a BitBadges token.
* **Pool Compatibility**: Ensures seamless integration with existing pool infrastructure
* **Automatic Conversion**: Handles badge token transfers to/from pools automatically

There actually is not any minting / burning behind the scenes. For implementation purpsoes, the pool treats it as a "ghost denom": badgeslp:collectionID:denom, but it is really backed by core x/badges tokens.

#### Conversion Example

Here's how the badge token conversion works:

**Badge Token**: `badgeslp:21:utoken`

* Collection ID: `21`
* Base Denom: `utoken`
* Wrapper Path Balances Conversion Rate: `[{ amount: 1n, tokenIds: [{ start: 1n, end: 1n }], ownershipTimes: UintRangeArray.FullRanges() }]`

**Conversion Process**:

```
1 badgeslp:21:utoken = [{ amount: 1n, tokenIds: [{ start: 1n, end: 1n }], ownershipTimes: UintRangeArray.FullRanges() }]

2 badgeslp:21:utoken = [{ amount: 2n, tokenIds: [{ start: 1n, end: 1n }], ownershipTimes: UintRangeArray.FullRanges() }]
```

### 3. Transferability Requirements and Compliance

Even though badge tokens are converted to pool-compatible denominations for liquidity pool operations, they are still subject to the same transferability requirements as any other badge token transfer via MsgTransferTokens. This means that all badge token transfers to/from pools must satisfy the collection's approval criteria, including user-level and collection-level approvals.

This design enables powerful compliance features:

* **User-Gated Pools**: Restrict who can join or exit pools based on approval criteria
* **Rate Limiting**: Implement daily/weekly withdrawal limits for pool exits
* **KYC/AML Integration**: Require identity verification before allowing pool participation
* **Geographic Restrictions**: Control pool access based on user addresses or other criteria
* **Time-Based Controls**: Restrict pool operations to specific time windows
* **Custom Compliance Logic**: Implement any approval criteria that can be expressed through the badge approval system

Behind the scenes, pool operations involving badge tokens are treated as transfers initiated by the user but approved by the pool address itself.

## Table of Contents

1. [Introduction](broken-reference/) - Overview and key concepts
2. [Messages](messages/) - Transaction messages and handlers

## Message Reference

### Core Operations

* [MsgCreateBalancerPool](messages/msg-create-balancer-pool.md) - Create new balancer pool
* [MsgJoinPool](messages/msg-join-pool.md) - Join existing pool with liquidity
* [MsgSwapExactAmountIn](messages/msg-swap-exact-amount-in.md) - Swap exact amount of tokens in
* [MsgExitPool](messages/msg-exit-pool.md) - Exit pool and receive tokens

## Query Reference

For all GAMM queries, please refer to the [BitBadges LCD API](https://lcd.bitbadges.io/).

The LCD provides comprehensive query endpoints for:

* Pool information and statistics
* Trading data and spot prices
* Module parameters
* And more

All queries follow the standard Cosmos SDK query patterns and can be accessed via REST API or gRPC.

## Quick Links

* [BitBadges Chain Repository](https://github.com/bitbadges/bitbadgeschain)
* [BitBadges Documentation](https://docs.bitbadges.io)
* [Proto Definitions](https://github.com/bitbadges/bitbadgeschain/tree/master/proto/gamm)

## Documentation Style

This documentation follows the [Cosmos SDK module documentation standards](https://docs.cosmos.network/main/building-modules/README) and is designed for developers building on or integrating with the BitBadges blockchain.


## File: ./x-gamm/introduction.md

# Introduction

The `x/gamm` module implements the Generalized Automated Market Maker (GAMM) functionality for the BitBadges blockchain. This module was forked from Osmosis's `x/gamm` module and provides the core infrastructure for decentralized exchange (DEX) operations, including liquidity pool creation, token swaps, and yield farming.

## Fork from Osmosis

This module maintains compatibility with Osmosis's GAMM functionality while adding specialized support for BitBadges tokens. The key modifications include:

-   **Interface Simplification**: Removed unused parameters and streamlined type definitions
-   **Badge Token Support**: Integrated native badge token handling with automatic conversion
-   **Enhanced Compatibility**: Ensures seamless operation with existing DeFi infrastructure

## Key Concepts

### Automated Market Maker (AMM)

An AMM is a decentralized exchange protocol that uses mathematical formulas to determine token prices and facilitate trades without the need for traditional orderbooks.

### Liquidity Pools

Liquidity pools are smart contracts that hold pairs of tokens and allow users to trade between them. Each pool has:

-   **Pool Assets**: The tokens held in the pool
-   **Pool Shares**: LP tokens representing ownership of the pool
-   **Swap Fee**: Fee charged on each trade
-   **Exit Fee**: Fee charged when exiting the pool

### Pool Types

The GAMM module currently supports:

-   **Balancer Pools**: Standard AMM pools with configurable weights


## File: ./x-gamm/messages/README.md

# Messages

This directory contains documentation for the core transaction messages supported by the `x/gamm` module.

## Core Operations

### Pool Management

* [MsgCreateBalancerPool](msg-create-balancer-pool.md) - Create new balancer pool with initial liquidity
* [MsgJoinPool](msg-join-pool.md) - Join existing pool with liquidity
* [MsgExitPool](msg-exit-pool.md) - Exit pool and receive underlying tokens

### Trading

* [MsgSwapExactAmountIn](msg-swap-exact-amount-in.md) - Swap exact amount of tokens in
* [MsgSwapExactAmountInWithIBCTransfer](msg-swap-exact-amount-in-with-ibc-transfer.md) - Swap exact amount of tokens in and send via IBC

## Core Message List

The GAMM module supports 5 core transaction messages:

1. **MsgCreateBalancerPool** - Create new balancer pool
2. **MsgJoinPool** - Join pool with proportional tokens
3. **MsgSwapExactAmountIn** - Swap exact input for minimum output
4. **MsgSwapExactAmountInWithIBCTransfer** - Swap exact input and send output via IBC
5. **MsgExitPool** - Exit pool and receive underlying tokens


## File: ./x-gamm/messages/msg-create-balancer-pool.md

# MsgCreateBalancerPool

Creates a new balancer pool.

The poolId will be assigned at execution time and is obtainable in the transaction response. The pool creator must provide initial liquidity and set pool parameters.

## Pool Creation Properties

The creation transaction for a balancer pool is unique in several ways:

-   Initial liquidity must be provided by the creator
-   Pool parameters like swap fee and exit fee are set
-   Token weights are configured for the pool assets
-   A dedicated module account is created for the pool

## Proto Definition

```protobuf
// ===================== MsgCreatePool
message MsgCreateBalancerPool {
  option (amino.name) = "gamm/create-balancer-pool";
  option (cosmos.msg.v1.signer) = "sender";

  string sender = 1 [ (gogoproto.moretags) = "yaml:\"sender\"" ];

  gamm.poolmodels.balancer.PoolParams pool_params = 2
      [ (gogoproto.moretags) = "yaml:\"pool_params\"" ];

  repeated gamm.poolmodels.balancer.PoolAsset pool_assets = 3
      [ (gogoproto.nullable) = false ];
}

// Returns the poolID
message MsgCreateBalancerPoolResponse {
  uint64 pool_id = 1 [ (gogoproto.customname) = "PoolID" ];
}
```

### JSON Example

```json
{
    "sender": "bb1abc123...",
    "pool_params": {
        "swap_fee": "0.003", // Note: Depending on serialization format this may be something like "300000000" for compatibility with sdk.Int format
        "exit_fee": "0.000"
    },
    "pool_assets": [
        {
            "token": {
                "denom": "ubadge",
                "amount": "1000000"
            },
            "weight": "50"
        },
        {
            "token": {
                "denom": "badgeslp:21:utoken",
                "amount": "5000000"
            },
            "weight": "50"
        }
    ]
}
```


## File: ./x-gamm/messages/msg-exit-pool.md

# MsgExitPool

Exits an existing pool by burning LP tokens and receiving underlying tokens.

Users can exit a pool by burning their LP tokens. In return, they receive the underlying pool tokens proportional to their share.

## Exit Pool Properties

When exiting a pool:

-   LP tokens are burned from the user
-   Underlying tokens are returned proportionally
-   Pool liquidity decreases
-   Exit fees may be applied

## Proto Definition

```protobuf
// ===================== MsgExitPool
message MsgExitPool {
  option (amino.name) = "gamm/exit-pool";
  option (cosmos.msg.v1.signer) = "sender";

  string sender = 1 [ (gogoproto.moretags) = "yaml:\"sender\"" ];
  uint64 pool_id = 2 [ (gogoproto.moretags) = "yaml:\"pool_id\"" ];
  string share_in_amount = 3 [

    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.moretags) = "yaml:\"share_in_amount\"",
    (gogoproto.nullable) = false
  ];

  repeated cosmos.base.v1beta1.Coin token_out_mins = 4 [
    (gogoproto.moretags) = "yaml:\"token_out_min_amounts\"",
    (gogoproto.nullable) = false
  ];
}

message MsgExitPoolResponse {
  repeated cosmos.base.v1beta1.Coin token_out = 1 [
    (gogoproto.moretags) = "yaml:\"token_out\"",
    (gogoproto.nullable) = false
  ];
}
```

### JSON Example

```json
{
    "sender": "bb1abc123...",
    "pool_id": "1",
    "share_in_amount": "100000",
    "token_out_mins": [
        {
            "denom": "uatom",
            "amount": "10000"
        },
        {
            "denom": "uosmo",
            "amount": "50000"
        }
    ]
}
```

## Token Proportions

The tokens received will be in the same proportion as the current pool composition. The user cannot specify which tokens to receive.

## Slippage Protection

The `token_out_mins` field provides slippage protection by setting minimum amounts for each token that must be received from the exit operation.

## Exit Fees

Some pools may charge exit fees, which are deducted from the tokens returned to the user.

## LP Token Burning

Upon successful exit, LP tokens are burned from the user's address, reducing their ownership stake in the pool.


## File: ./x-gamm/messages/msg-join-pool.md

# MsgJoinPool

Joins an existing pool by providing liquidity. Users can join a pool by providing tokens proportional to the current pool composition. In return, they receive LP tokens representing their share of the pool.

## Join Pool Properties

When joining a pool:

-   Tokens must be provided in the correct proportions
-   LP tokens are minted to the user
-   Pool liquidity increases
-   User becomes eligible for trading fees

## Proto Definition

```protobuf
// ===================== MsgJoinPool
// This is really MsgJoinPoolNoSwap
message MsgJoinPool {
  option (amino.name) = "gamm/join-pool";
  option (cosmos.msg.v1.signer) = "sender";

  string sender = 1 [ (gogoproto.moretags) = "yaml:\"sender\"" ];
  uint64 pool_id = 2 [ (gogoproto.moretags) = "yaml:\"pool_id\"" ];
  string share_out_amount = 3 [

    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.moretags) = "yaml:\"pool_amount_out\"",
    (gogoproto.nullable) = false
  ];
  repeated cosmos.base.v1beta1.Coin token_in_maxs = 4 [
    (gogoproto.moretags) = "yaml:\"token_in_max_amounts\"",
    (gogoproto.nullable) = false
  ];
}

message MsgJoinPoolResponse {
  string share_out_amount = 1 [

    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.moretags) = "yaml:\"share_out_amount\"",
    (gogoproto.nullable) = false
  ];
  repeated cosmos.base.v1beta1.Coin token_in = 2 [
    (gogoproto.moretags) = "yaml:\"token_out\"",
    (gogoproto.nullable) = false
  ];
}
```

### JSON Example

```json
{
    "sender": "bb1abc123...",
    "pool_id": "1",
    "share_out_amount": "1000000",
    "token_in_maxs": [
        {
            "denom": "uatom",
            "amount": "100000"
        },
        {
            "denom": "uosmo",
            "amount": "500000"
        }
    ]
}
```

## Token Proportions

The tokens provided must be in the same proportion as the current pool composition. If not, the transaction will fail or tokens will be returned.

## Slippage Protection

The `token_in_maxs` field provides slippage protection by setting maximum amounts for each token that can be used in the join operation.

## LP Token Minting

Upon successful join, LP tokens are minted to the user's address. These tokens represent ownership of the pool and can be used for:

-   Earning trading fees
-   Governance participation
-   Staking in yield farming programs


## File: ./x-gamm/messages/msg-swap-exact-amount-in-with-ibc-transfer.md

# MsgSwapExactAmountInWithIBCTransfer

Swaps an exact amount of tokens in for a minimum amount of tokens out, then automatically sends the output tokens to another chain via IBC transfer.

This message combines a swap operation with an IBC transfer, enabling seamless cross-chain swaps in a single transaction.

## Swap and Transfer Properties

When executing this message:

-   Exact input amount is specified
-   Minimum output amount provides slippage protection
-   Swap fee is deducted from the input
-   Output tokens are automatically sent via IBC to the specified receiver
-   All operations are atomic - if any step fails, the entire transaction is rolled back

## TypeScript Interface

```typescript
export interface iIBCTransferInfo<T extends NumberType> {
    sourceChannel: string;
    receiver: string;
    memo: string;
    timeoutTimestamp: T;
}

export interface iMsgSwapExactAmountInWithIBCTransfer<T extends NumberType> {
    sender: string;
    routes: iSwapAmountInRoute<T>[];
    tokenIn: iCosmosCoin<T>;
    tokenOutMinAmount: T;
    ibcTransferInfo: iIBCTransferInfo<T>;
    affiliates?: iAffiliate[];
}

export interface iAffiliate {
    basisPointsFee: string;
    address: string;
}
```

## JSON Example

```json
{
    "sender": "bb1abc123...",
    "routes": [
        {
            "pool_id": "1",
            "token_out_denom": "uosmo"
        }
    ],
    "token_in": {
        "denom": "uatom",
        "amount": "1000000"
    },
    "token_out_min_amount": "5000000",
    "ibc_transfer_info": {
        "source_channel": "channel-0",
        "receiver": "cosmos1xyz789...",
        "memo": "Cross-chain swap",
        "timeout_timestamp": "1234567890000000000"
    },
    "affiliates": [
        {
            "basis_points_fee": "10",
            "address": "bb1..."
        }
    ]
}
```

## Multi-Hop Swaps

The `routes` field allows for multi-hop swaps through multiple pools. The swap will execute through each pool in sequence before the IBC transfer.

## Slippage Protection

The `token_out_min_amount` field ensures that the user receives at least the specified amount of output tokens, protecting against price slippage during the swap.

## IBC Transfer Details

The `ibc_transfer_info` field specifies:

-   **source_channel**: The IBC channel to send tokens through
-   **receiver**: The address on the destination chain to receive the tokens
-   **memo**: Optional memo to include with the IBC transfer
-   **timeout_timestamp**: The timestamp after which the IBC transfer will timeout

## Atomic Execution

This message executes atomically:

1. Swap tokens through the specified route(s)
2. Verify minimum output amount is met
3. Send output tokens via IBC transfer

If any step fails, the entire transaction is rolled back and no state changes are committed.

## Swap Fees

Each pool in the swap route charges a swap fee, which is deducted from the input amount before the swap is executed. The IBC transfer fee is also deducted from the output tokens.

## Affiliate Fees

The `affiliates` field allows you to specify fee recipients who will receive a portion of the swap output before the IBC transfer. Affiliate fees are:

-   **Optional**: If not specified, no affiliate fees are deducted
-   **Calculated on output**: Fees are calculated on the swap output amount (before IBC transfer)
-   **Multiple affiliates**: You can specify multiple affiliates, each receiving their specified fee
-   **Basis points**: Fees are specified in basis points (1 basis point = 0.01%)

**Example**: If a swap outputs 1,000,000 tokens and you specify an affiliate with 10 basis points (0.1%):
-   Affiliate receives: 1,000,000 √ó 0.001 = 1,000 tokens
-   Remaining for IBC transfer: 1,000,000 - 1,000 = 999,000 tokens

## Use Cases

-   **Cross-chain DeFi**: Swap tokens on one chain and send to another in a single transaction
-   **Liquidity Routing**: Route liquidity through multiple chains efficiently
-   **Automated Trading**: Execute complex cross-chain trading strategies atomically


## File: ./x-gamm/messages/msg-swap-exact-amount-in.md

# MsgSwapExactAmountIn

Swaps an exact amount of tokens in for a minimum amount of tokens out.

This message allows users to swap a specific amount of input tokens for output tokens, with slippage protection through the minimum output amount.

## Swap Properties

When executing a swap:

-   Exact input amount is specified
-   Minimum output amount provides slippage protection
-   Swap fee is deducted from the input
-   Price impact is calculated based on pool liquidity

## Proto Definition

```protobuf
// ===================== MsgSwapExactAmountIn
message MsgSwapExactAmountIn {
  option (amino.name) = "gamm/SwapExactAmountIn";
  option (cosmos.msg.v1.signer) = "sender";

  string sender = 1 [ (gogoproto.moretags) = "yaml:\"sender\"" ];
  repeated poolmanager.v1beta1.SwapAmountInRoute routes = 2
      [ (gogoproto.nullable) = false ];
  cosmos.base.v1beta1.Coin token_in = 3 [
    (gogoproto.moretags) = "yaml:\"token_in\"",
    (gogoproto.nullable) = false
  ];
  string token_out_min_amount = 4 [

    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.moretags) = "yaml:\"token_out_min_amount\"",
    (gogoproto.nullable) = false
  ];
  repeated Affiliate affiliates = 5;
}

message MsgSwapExactAmountInResponse {
  string token_out_amount = 1 [

    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.moretags) = "yaml:\"token_out_amount\"",
    (gogoproto.nullable) = false
  ];
}
```

### Affiliate

```protobuf
message Affiliate {
  string basis_points_fee = 1;
  string address = 2;
}
```

The `affiliates` field allows you to specify fee recipients who will receive a portion of the swap output as an affiliate fee. Fees are specified in basis points (1 basis point = 0.01%, 100 basis points = 1%) and are calculated on the swap output amount.

### JSON Example

```json
{
    "sender": "bb1abc123...",
    "routes": [
        {
            "pool_id": "1",
            "token_out_denom": "uosmo"
        }
    ],
    "token_in": {
        "denom": "uatom",
        "amount": "1000000"
    },
    "token_out_min_amount": "5000000",
    "affiliates": [
        {
            "basis_points_fee": "10",
            "address": "bb1..."
        }
    ]
}
```

## Multi-Hop Swaps

The `routes` field allows for multi-hop swaps through multiple pools. The swap will execute through each pool in sequence.

## Slippage Protection

The `token_out_min_amount` field ensures that the user receives at least the specified amount of output tokens, protecting against price slippage.

## Swap Fees

Each pool in the swap route charges a swap fee, which is deducted from the input amount before the swap is executed.

## Affiliate Fees

The `affiliates` field allows you to specify fee recipients who will receive a portion of the swap output. Affiliate fees are:

-   **Optional**: If not specified, no affiliate fees are deducted
-   **Calculated on output**: Fees are calculated on the swap output amount
-   **Multiple affiliates**: You can specify multiple affiliates, each receiving their specified fee
-   **Basis points**: Fees are specified in basis points (1 basis point = 0.01%)

**Example**: If a swap outputs 1,000,000 tokens and you specify an affiliate with 10 basis points (0.1%):

-   Affiliate receives: 1,000,000 √ó 0.001 = 1,000 tokens
-   User receives: 1,000,000 - 1,000 = 999,000 tokens


## File: ./x-ibc-rate-limit/README.md

# Overview

This directory contains comprehensive developer documentation for the BitBadges blockchain's `x/ibc-rate-limit` module.

The IBC Rate Limit module provides rate limiting functionality for Inter-Blockchain Communication (IBC) token transfers. It allows the chain to enforce limits on token transfers across IBC channels to prevent excessive inflows or outflows that could destabilize the chain's token supply.

## Key Features

* **Control Supply Shifts**: Limit the net change in token supply (inflows minus outflows) over specified timeframes
* **Limit Unique Senders**: Restrict the number of unique addresses that can send tokens through a channel within a timeframe
* **Enforce Per-Address Limits**: Set limits on the number of transfers and total amount per address within a timeframe
* **Multiple Timeframes**: Support for block-based, hour-based, and day-based rate limits

## Architecture

The module operates as an IBC middleware that intercepts IBC transfer packets before they are processed. It uses hooks to:

1. Check rate limits before processing incoming packets (`OnRecvPacketOverride`)
2. Check rate limits before sending packets (`SendPacketOverride`)
3. Track transfer statistics after successful transfers

## Table of Contents

1. [Introduction](overview.md) - Overview and key concepts


## File: ./x-ibc-rate-limit/overview.md

# Introduction

## Overview

The IBC Rate Limit module provides rate limiting functionality for Inter-Blockchain Communication (IBC) token transfers. It allows the chain to enforce limits on token transfers across IBC channels to prevent excessive inflows or outflows that could destabilize the chain's token supply.

## Purpose

The module serves as a security mechanism to:

* **Control supply shifts**: Limit the net change in token supply (inflows minus outflows) over specified timeframes
* **Limit unique senders**: Restrict the number of unique addresses that can send tokens through a channel within a timeframe
* **Enforce per-address limits**: Set limits on the number of transfers and total amount per address within a timeframe

## Key Concepts

### Rate Limit Configuration

Rate limits are configured per channel and denomination through the module's parameters. Each configuration can specify:

* **Channel ID**: The IBC channel to apply the limit to (empty string applies to all channels)
* **Denomination**: The token denomination to limit (must be specified)
* **Supply Shift Limits**: Limits on the absolute value of net flow (inflows - outflows)
* **Unique Sender Limits**: Limits on the number of unique sender addresses
* **Address Limits**: Per-address limits on transfer count and total amount

### Timeframes

The module supports three types of timeframes:

* **BLOCK**: Duration measured in blocks
* **HOUR**: Duration measured in hours (converted to blocks using block time)
* **DAY**: Duration measured in days (converted to blocks using block time)

Multiple timeframe limits can be configured for the same channel/denom combination, and all limits are checked. If any limit would be exceeded, the transfer is rejected.

## Authority

The module's parameters can be updated by the authority address, which defaults to the governance module account. This allows governance to adjust rate limits as needed.


## File: ./x-managersplitter/README.md

# Overview

This directory contains comprehensive developer documentation for the BitBadges blockchain's `x/managersplitter` module.

The Manager Splitter module provides a permissioned proxy system for managing token collections. It allows collection managers to delegate specific permissions to approved addresses while maintaining control over the collection.

For example, you may want to delegate an approved address to delete the collection on your behalf but none of the other permissions.

## Key Features

* **Permission Delegation**: Split collection management permissions among multiple addresses
* **Granular Control**: Define which addresses can perform which actions on a collection
* **Admin Override**: Maintain a permanent admin address with full control
* **Secure Execution**: Execute badge collection updates through the manager splitter with permission checks

## Architecture

The module creates **Manager Splitter** entities that:

1. Have a derived address that is to be set as the collection manager
2. Define permissions for each collection management action
3. Allow approved addresses to execute actions on behalf of the manager splitter
4. Maintain an admin address with permanent full control

## Table of Contents

1. [Introduction](overview.md) - Overview and key concepts
2. [Messages](messages/) - Transaction messages and handlers

## Message Reference

### Core Operations

* [MsgCreateManagerSplitter](messages/msg-create-manager-splitter.md) - Create a new manager splitter
* [MsgUpdateManagerSplitter](messages/msg-update-manager-splitter.md) - Update manager splitter permissions
* [MsgDeleteManagerSplitter](messages/msg-delete-manager-splitter.md) - Delete a manager splitter
* [MsgExecuteUniversalUpdateCollection](messages/msg-execute-universal-update-collection.md) - Execute collection updates through manager splitter


## File: ./x-managersplitter/messages/README.md

# Messages

This directory contains documentation for the core transaction messages supported by the `x/managersplitter` module.

## Core Operations

### Manager Splitter Management

* [MsgCreateManagerSplitter](msg-create-manager-splitter.md) - Create a new manager splitter with permissions
* [MsgUpdateManagerSplitter](msg-update-manager-splitter.md) - Update manager splitter permissions
* [MsgDeleteManagerSplitter](msg-delete-manager-splitter.md) - Delete a manager splitter

### Execution

* [MsgExecuteUniversalUpdateCollection](msg-execute-universal-update-collection.md) - Execute collection updates through manager splitter

## Core Message List

The Manager Splitter module supports 5 core transaction messages:

1. **MsgCreateManagerSplitter** - Create new manager splitter
2. **MsgUpdateManagerSplitter** - Update manager splitter permissions
3. **MsgDeleteManagerSplitter** - Delete manager splitter
4. **MsgExecuteUniversalUpdateCollection** - Execute collection updates


## File: ./x-managersplitter/messages/msg-create-manager-splitter.md

# MsgCreateManagerSplitter

## Overview

`MsgCreateManagerSplitter` creates a new Manager Splitter entity with specified permissions. The manager splitter receives a module-derived address that can be used as a collection manager.

## Message Structure

```protobuf
message MsgCreateManagerSplitter {
  option (cosmos.msg.v1.signer) = "admin";
  option (amino.name) = "managersplitter/CreateManagerSplitter";

  // Admin address creating the entity.
  string admin = 1;

  // Permissions mapping each CollectionPermission field to execution criteria.
  ManagerSplitterPermissions permissions = 2;
}
```

## Fields

### `admin` (string, required)

The address that will be the permanent admin of the manager splitter. This address:

* Has full control over the manager splitter
* Can always execute all permissions
* Can update and delete the manager splitter
* Cannot be changed after creation

Must be a valid Bech32 address.

### `permissions` (ManagerSplitterPermissions, optional)

The permissions configuration for the manager splitter. Each permission maps to `PermissionCriteria` that specifies which addresses can execute that permission.

If `nil` or not provided, an empty permissions structure is created (all permissions denied except for admin).

## ManagerSplitterPermissions Structure

```protobuf
message ManagerSplitterPermissions {
  PermissionCriteria canDeleteCollection = 1;
  PermissionCriteria canArchiveCollection = 2;
  PermissionCriteria canUpdateStandards = 3;
  PermissionCriteria canUpdateCustomData = 4;
  PermissionCriteria canUpdateManager = 5;
  PermissionCriteria canUpdateCollectionMetadata = 6;
  PermissionCriteria canUpdateValidTokenIds = 7;
  PermissionCriteria canUpdateTokenMetadata = 8;
  PermissionCriteria canUpdateCollectionApprovals = 9;
}
```

Each field is optional. If a permission is not set, it is denied by default (except for the admin).

## PermissionCriteria Structure

```protobuf
message PermissionCriteria {
  // List of approved addresses that can execute this permission.
  repeated string approvedAddresses = 1;
}
```

### `approvedAddresses` (string\[], optional)

A list of Bech32 addresses that are approved to execute this permission. If empty, only the admin can execute this permission.

## Response

```protobuf
message MsgCreateManagerSplitterResponse {
  // The address of the created manager splitter.
  string address = 1;
}
```

### `address` (string)

The module-derived address of the created manager splitter. This address:

* Is deterministic based on the manager splitter ID
* Can be used as a collection manager address
* Is derived using `ModuleAddress(ModuleName, ID_bytes)`

## Validation

The message is validated to ensure:

1. The `admin` address is a valid Bech32 address
2. The manager splitter address doesn't already exist (shouldn't happen, but checked for safety)

## State Changes

1. A new Manager Splitter entity is created with:
   * A module-derived address (based on next available ID)
   * The specified admin address
   * The specified permissions (or empty if not provided)
2. The next manager splitter ID is incremented

## Usage Example

```json
{
  "admin": "bb1...",
  "permissions": {
    "canUpdateCollectionMetadata": {
      "approvedAddresses": [
        "bb1abc..."
      ]
    },
    "canUpdateTokenMetadata": {
      "approvedAddresses": [
        "bb1def456..."
      ]
    },
    "canUpdateValidTokenIds": {
      "approvedAddresses": []
    }
  }
}
```


## File: ./x-managersplitter/messages/msg-delete-manager-splitter.md

# MsgDeleteManagerSplitter

## Overview

`MsgDeleteManagerSplitter` deletes an existing Manager Splitter entity. Only the admin address can delete the manager splitter.

## Message Structure

```protobuf
message MsgDeleteManagerSplitter {
  option (cosmos.msg.v1.signer) = "admin";
  option (amino.name) = "managersplitter/DeleteManagerSplitter";

  // Admin address deleting the entity.
  string admin = 1;

  // Address of the manager splitter to delete.
  string address = 2;
}
```

## Fields

### `admin` (string, required)

The admin address of the manager splitter. This must match the manager splitter's stored admin address. Must be a valid Bech32 address.

### `address` (string, required)

The address of the manager splitter to delete. This is the module-derived address returned when the manager splitter was created. Must be a valid Bech32 address.

## Response

```protobuf
message MsgDeleteManagerSplitterResponse {}
```

An empty response indicates successful deletion.

## Authorization

Only the admin address can delete the manager splitter. If the `admin` field doesn't match the manager splitter's stored admin, the transaction will fail with an unauthorized error.

## Usage Example

```json
{
  "admin": "cosmos1abc123...",
  "address": "cosmos1managersplitter..."
}
```


## File: ./x-managersplitter/messages/msg-execute-universal-update-collection.md

# MsgExecuteUniversalUpdateCollection

## Overview

`MsgExecuteUniversalUpdateCollection` allows an approved address (or admin) to execute a `UniversalUpdateCollection` message from the Badges module through a Manager Splitter. The message checks permissions before execution and uses the manager splitter address as the collection manager.

## Message Structure

```protobuf
message MsgExecuteUniversalUpdateCollection {
  option (cosmos.msg.v1.signer) = "executor";
  option (amino.name) = "managersplitter/ExecuteUniversalUpdateCollection";

  // Address executing the message (must be approved or admin).
  string executor = 1;

  // Address of the manager splitter to execute through.
  string managerSplitterAddress = 2;

  // The UniversalUpdateCollection message to execute.
  badges.MsgUniversalUpdateCollection universalUpdateCollectionMsg = 3;
}
```

## Fields

### `executor` (string, required)

The address that is executing the message. This address must be:

-   The admin of the manager splitter, OR
-   An approved address for all permissions required by the `UniversalUpdateCollection` message

Must be a valid Bech32 address.

### `managerSplitterAddress` (string, required)

The address of the manager splitter to execute through. This is the module-derived address returned when the manager splitter was created. Must be a valid Bech32 address.

### `universalUpdateCollectionMsg` (badges.MsgUniversalUpdateCollection, required)

The `UniversalUpdateCollection` message from the Badges module to execute. This message will be executed with the manager splitter address as the creator/manager.

Note that you should only set the fields you are allowed to update. Use the update flag approach = false for all others.

## Permission Checking

The module checks permissions based on which fields are being updated in the `UniversalUpdateCollection` message:

-   **UpdateValidTokenIds**: Requires `canUpdateValidTokenIds` permission
-   **UpdateCollectionPermissions**: Requires `canUpdateCollectionApprovals` permission
-   **UpdateManager**: Requires `canUpdateManager` permission
-   **UpdateCollectionMetadata**: Requires `canUpdateCollectionMetadata` permission
-   **UpdateTokenMetadata**: Requires `canUpdateTokenMetadata` permission
-   **UpdateCustomData**: Requires `canUpdateCustomData` permission
-   **UpdateCollectionApprovals**: Requires `canUpdateCollectionApprovals` permission
-   **UpdateStandards**: Requires `canUpdateStandards` permission
-   **UpdateIsArchived**: Requires `canArchiveCollection` permission
-   **CosmosCoinWrapperPathsToAdd**: Requires `canAddMoreCosmosCoinWrapperPaths` permission
-   **AliasPathsToAdd**: Requires `canAddMoreAliasPaths` permission

**Important**: All required permissions are checked. If the executor is not approved for any required permission (and is not the admin), the transaction will fail.

## Response

```protobuf
message MsgExecuteUniversalUpdateCollectionResponse {
  // ID of the collection that was updated.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### `collectionId` (Uint)

The ID of the collection that was updated, returned from the Badges module's `UniversalUpdateCollection` execution.

## Validation

The message is validated to ensure:

1. The `executor` address is a valid Bech32 address
2. The `managerSplitterAddress` is a valid Bech32 address
3. The manager splitter exists
4. The executor has permission to execute all required actions
5. The `universalUpdateCollectionMsg` is valid

## Authorization

The executor must be:

-   The admin of the manager splitter (has full permissions), OR
-   An approved address for all permissions required by the update

If the executor doesn't have the required permissions, the transaction will fail with a permission denied error.

## Usage Example

```json
{
  "executor": "bb1...",
  "managerSplitterAddress": "bb1managersplitter...",
  "universalUpdateCollectionMsg": {
    "creator": "bb1managersplitter...",
    "collectionId": "1",
    ...
    "updateCollectionMetadata": true,
    "collectionMetadata": {...}
  }
}
```


## File: ./x-managersplitter/messages/msg-update-manager-splitter.md

# MsgUpdateManagerSplitter

## Overview

`MsgUpdateManagerSplitter` updates the permissions of an existing Manager Splitter entity. Only the admin address can update the manager splitter.

## Message Structure

```protobuf
message MsgUpdateManagerSplitter {
  option (cosmos.msg.v1.signer) = "admin";
  option (amino.name) = "managersplitter/UpdateManagerSplitter";

  // Admin address updating the entity.
  string admin = 1;

  // Address of the manager splitter to update.
  string address = 2;

  // New permissions to set.
  ManagerSplitterPermissions permissions = 3;
}
```

## Fields

### `admin` (string, required)

The admin address of the manager splitter. This must match the manager splitter's stored admin address. Must be a valid Bech32 address.

### `address` (string, required)

The address of the manager splitter to update. This is the module-derived address returned when the manager splitter was created. Must be a valid Bech32 address.

### `permissions` (ManagerSplitterPermissions, required)

The new permissions configuration to set. This completely replaces the existing permissions structure.

## ManagerSplitterPermissions Structure

```protobuf
message ManagerSplitterPermissions {
  PermissionCriteria canDeleteCollection = 1;
  PermissionCriteria canArchiveCollection = 2;
  PermissionCriteria canUpdateStandards = 3;
  PermissionCriteria canUpdateCustomData = 4;
  PermissionCriteria canUpdateManager = 5;
  PermissionCriteria canUpdateCollectionMetadata = 6;
  PermissionCriteria canUpdateValidTokenIds = 7;
  PermissionCriteria canUpdateTokenMetadata = 8;
  PermissionCriteria canUpdateCollectionApprovals = 9;
}
```

Each field is optional. If a permission is not set in the update, it will be removed (denied by default).

## PermissionCriteria Structure

```protobuf
message PermissionCriteria {
  // List of approved addresses that can execute this permission.
  repeated string approvedAddresses = 1;
}
```

### `approvedAddresses` (string\[], optional)

A list of Bech32 addresses that are approved to execute this permission. If empty or not provided, only the admin can execute this permission.

## Response

```protobuf
message MsgUpdateManagerSplitterResponse {}
```

An empty response indicates successful update.

## Usage Example

```json
{
  "admin": "bb1abc123...",
  "address": "bb1managersplitter...",
  "permissions": {
    "canUpdateCollectionMetadata": {
      "approvedAddresses": [...]
    },
    "canUpdateTokenMetadata": {
      "approvedAddresses": [
        "bb1..."
      ]
    }
  }
}
```


## File: ./x-managersplitter/overview.md

# Introduction

## Overview

The Manager Splitter module provides a permissioned proxy system for managing token collections. It allows collection managers to delegate specific permissions to approved addresses while maintaining control over the collection.

### Manager Splitter Entity

A Manager Splitter is a permissioned proxy that:

* **Address**: A module-derived address (derived from module name + ID) that serves as the collection manager. This is to be set as the actual manager in x/badges.
* **Admin**: A permanent admin address with full control over the splitter and all permissions
* **Permissions**: A mapping of collection permission types to execution criteria

Then, any token collection updates must be handled through this module and through the proxied address.

### Permission System

The module mirrors the Badges module's `CollectionPermissions` structure but maps each permission to `PermissionCriteria`:

* **CanDeleteCollection**: Permission to delete the collection
* **CanArchiveCollection**: Permission to archive the collection
* **CanUpdateStandards**: Permission to update collection standards
* **CanUpdateCustomData**: Permission to update custom data
* **CanUpdateManager**: Permission to update the manager
* **CanUpdateCollectionMetadata**: Permission to update collection metadata
* **CanUpdateValidTokenIds**: Permission to update valid token IDs
* **CanUpdateTokenMetadata**: Permission to update token metadata
* **CanUpdateCollectionApprovals**: Permission to update collection approvals

### Permission Criteria

Each permission can specify:

* **Approved Addresses**: A whitelist of addresses that can execute this permission

If a permission has no criteria set, it is denied by default (except for the admin).

### Admin Privileges

The admin address:

* Has full control over the manager splitter
* Can always execute all permissions
* Can create, update, and delete the manager splitter
* Cannot be changed after creation

## Use Cases

1. **Multi-sig Management**: Multiple addresses can manage different aspects of a collection
2. **Role-based Access**: Different addresses can have different permission levels
3. **Delegated Management**: Delegate specific management tasks to trusted addresses
4. **Governance Integration**: Use manager splitters for governance-controlled collections

## Security Model

1. **Admin Control**: Only the admin can create, update, or delete the manager splitter
2. **Permission Checks**: All actions check permissions before execution
3. **Address Validation**: All addresses are validated before use
4. **Atomic Execution**: Permission checks and execution are atomic
5. **Immutable Admin**: The admin address cannot be changed after creation

## Limitations

1. **Single Admin**: Each manager splitter has one permanent admin
2. **Approved Addresses Only**: Currently supports whitelist-based permissions only
3. **UniversalUpdateCollection Only**: Currently only supports executing `UniversalUpdateCollection` messages
4. **No Permission Inheritance**: Permissions must be explicitly set for each action type

## Alternative

This is an alternative to standard single manager approach. You can also explore setting up managerial systems with:

* x/group - Cosmos SDK module for multisigs / DAOs and voting
* DAO tooling
* Custom WASM or EVM contracts


## File: ./.github/workflows/for--llms.yml

```
name: Generate LLM Training Text

on:
    push:
        branches: [main, master]
    workflow_dispatch: # Allows manual triggering

jobs:
    generate-llm-text:
        runs-on: ubuntu-latest
        permissions:
            contents: write
        steps:
            - name: Checkout repository
              uses: actions/checkout@v3

            - name: Set up Python
              uses: actions/setup-python@v4
              with:
                  python-version: '3.10'

            - name: Install dependencies
              run: |
                  python -m pip install --upgrade pip

            - name: Create for-llms.txt file
              run: |
                  echo "# Gitbook Documentation Compilation" > for-llms.txt
                  echo "Generated on $(date)" >> for-llms.txt
                  echo "" >> for-llms.txt

                  # Find all markdown files
                  find . -type f -name "*.md" | sort | while read -r file; do
                    # Skip hidden directories and node_modules
                    if [[ "$file" != *"/.git/"* && "$file" != */node_modules/* && "$file" != */build/* && "$file" != */dist/* ]]; then
                      echo "Processing $file"
                      
                      # Add file path as header
                      echo -e "\n\n## File: $file\n" >> for-llms.txt
                      
                      # Add file content
                      cat "$file" >> for-llms.txt
                    fi
                  done

                  # Also find and process any other text-based documentation files
                  find . -type f -name "*.txt" -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" | sort | while read -r file; do
                    if [[ "$file" != *"/.git/"* && "$file" != */node_modules/* && "$file" != */build/* && "$file" != */dist/* && "$file" != *"for-llms.txt"* ]]; then
                      echo "Processing $file"
                      
                      # Add file path as header
                      echo -e "\n\n## File: $file\n" >> for-llms.txt
                      echo '```' >> for-llms.txt
                      
                      # Add file content
                      cat "$file" >> for-llms.txt
                      
                      echo '```' >> for-llms.txt
                    fi
                  done

            - name: Upload for-llms.txt as artifact
              uses: actions/upload-artifact@v4
              with:
                  name: llm-training-data
                  path: for-llms.txt

            - name: Commit and push for-llms.txt
              run: |
                  git config --local user.email "action@github.com"
                  git config --local user.name "GitHub Action"
                  git add for-llms.txt
                  git commit -m "Update for-llms.txt via GitHub Action" || echo "No changes to commit"
                  git push
```


## File: ./.vscode/settings.json

```
{
  "workbench.colorCustomizations": {
    "activityBar.background": "#2E2461",
    "titleBar.activeBackground": "#403287",
    "titleBar.activeForeground": "#FBFBFE"
  }
}```

# Gitbook Documentation Compilation
Generated on Wed Oct 29 14:21:23 UTC 2025



## File: ./.gitbook/assets/README (1).md

BitBadges / [Exports](modules.md)


## File: ./.gitbook/assets/README.md

BitBadges / [Exports](modules.md)


## File: ./.gitbook/assets/modules (1).md

[BitBadges](README.md) / Exports

# BitBadges

## Table of contents

### Enumerations

-   [DistributionMethod](enums/DistributionMethod.md)
-   [MetadataAddMethod](enums/MetadataAddMethod.md)
-   [SupportedChain](enums/SupportedChain.md)
-   [TransactionStatus](enums/TransactionStatus.md)

### Interfaces

-   [AccountDocs](interfaces/AccountDocs.md)
-   [AccountDocument](interfaces/AccountDocument.md)
-   [AccountMap](interfaces/AccountMap.md)
-   [AccountResponse](interfaces/AccountResponse.md)
-   [ActivityItem](interfaces/ActivityItem.md)
-   [Addresses](interfaces/Addresses.md)
-   [AnnouncementActivityItem](interfaces/AnnouncementActivityItem.md)
-   [Approval](interfaces/Approval.md)
-   [BadgeMetadata](interfaces/BadgeMetadata.md)
-   [BadgeMetadataMap](interfaces/BadgeMetadataMap.md)
-   [BadgeSupplyAndAmount](interfaces/BadgeSupplyAndAmount.md)
-   [BadgeUri](interfaces/BadgeUri.md)
-   [Balance](interfaces/Balance.md)
-   [BalanceObject](interfaces/BalanceObject.md)
-   [BalancesMap](interfaces/BalancesMap.md)
-   [BitBadgeCollection](interfaces/BitBadgeCollection.md)
-   [BitBadgeMintObject](interfaces/BitBadgeMintObject.md)
-   [BitBadgesUserInfo](interfaces/BitBadgesUserInfo.md)
-   [ClaimItem](interfaces/ClaimItem.md)
-   [ClaimItemWithTrees](interfaces/ClaimItemWithTrees.md)
-   [Claims](interfaces/Claims.md)
-   [CollectionDocs](interfaces/CollectionDocs.md)
-   [CollectionMap](interfaces/CollectionMap.md)
-   [CosmosAccountInformation](interfaces/CosmosAccountInformation.md)
-   [DbStatus](interfaces/DbStatus.md)
-   [Docs](interfaces/Docs.md)
-   [GetAccountResponse](interfaces/GetAccountResponse.md)
-   [GetBalanceResponse](interfaces/GetBalanceResponse.md)
-   [GetBalanceResponse](interfaces/GetBalanceResponse.md)
-   [GetCollectionResponse](interfaces/GetCollectionResponse.md)
-   [GetOwnersResponse](interfaces/GetOwnersResponse.md)
-   [GetPortfolioResponse](interfaces/GetPortfolioResponse.md)
-   [IdRange](interfaces/IdRange.md)
-   [IndexerStatus](interfaces/IndexerStatus.md)
-   [LatestBlockStatus](interfaces/LatestBlockStatus.md)
-   [MetadataDocs](interfaces/MetadataDocs.md)
-   [MetadataDocument](interfaces/MetadataDocument.md)
-   [PaginationInfo](interfaces/PaginationInfo.md)
-   [PasswordDocument](interfaces/PasswordDocument.md)
-   [PendingTransfer](interfaces/PendingTransfer.md)
-   [Proof](interfaces/Proof.md)
-   [SearchResponse](interfaces/SearchResponse.md)
-   [StoredBadgeCollection](interfaces/StoredBadgeCollection.md)
-   [SubassetSupply](interfaces/SubassetSupply.md)
-   [TransferActivityItem](interfaces/TransferActivityItem.md)
-   [TransferList](interfaces/TransferList.md)
-   [TransferListWithUnregisteredUsers](interfaces/TransferListWithUnregisteredUsers.md)
-   [Transfers](interfaces/Transfers.md)
-   [TransfersExtended](interfaces/TransfersExtended.md)
-   [UserBalance](interfaces/UserBalance.md)

### Type Aliases

-   [Permissions](modules.md#permissions)

### Variables

-   [AllAddressesTransferList](modules.md#alladdressestransferlist)
-   [CHAIN_DETAILS](modules.md#chain_details)
-   [CanCreateMoreBadgesDigit](modules.md#cancreatemorebadgesdigit)
-   [CanDeleteDigit](modules.md#candeletedigit)
-   [CanManagerBeTransferredDigit](modules.md#canmanagerbetransferreddigit)
-   [CanUpdateBytesDigit](modules.md#canupdatebytesdigit)
-   [CanUpdateDisallowedDigit](modules.md#canupdatedisalloweddigit)
-   [CanUpdateUrisDigit](modules.md#canupdateurisdigit)
-   [DefaultPlaceholderMetadata](modules.md#defaultplaceholdermetadata)
-   [ErrorMetadata](modules.md#errormetadata)
-   [GO_MAX_UINT_64](modules.md#go_max_uint_64)
-   [MAX_DATE_TIMESTAMP](modules.md#max_date_timestamp)
-   [METADATA_PAGE_LIMIT](modules.md#metadata_page_limit)
-   [MINT_ACCOUNT](modules.md#mint_account)
-   [NUM_PERMISSIONS](modules.md#num_permissions)

### Functions

-   [AddBalancesForIdRanges](modules.md#addbalancesforidranges)
-   [DeleteBalanceForIdRanges](modules.md#deletebalanceforidranges)
-   [GetAccountByNumberRoute](modules.md#getaccountbynumberroute)
-   [GetAccountRoute](modules.md#getaccountroute)
-   [GetAccountsRoute](modules.md#getaccountsroute)
-   [GetBalanceRoute](modules.md#getbalanceroute)
-   [GetBalanceInfoToInsertToStorage](modules.md#getbalanceinfotoinserttostorage)
-   [GetBalanceRoute](modules.md#getbalanceroute)
-   [GetBalancesForIdRanges](modules.md#getbalancesforidranges)
-   [GetCollectionRoute](modules.md#getcollectionroute)
-   [GetCollectionsRoute](modules.md#getcollectionsroute)
-   [GetIdRangeToInsert](modules.md#getidrangetoinsert)
-   [GetIdRangesToInsertToStorage](modules.md#getidrangestoinserttostorage)
-   [GetIdRangesWithOmitEmptyCaseHandled](modules.md#getidrangeswithomitemptycasehandled)
-   [GetIdxSpanForRange](modules.md#getidxspanforrange)
-   [GetIdxToInsertForNewId](modules.md#getidxtoinsertfornewid)
-   [GetMetadataRoute](modules.md#getmetadataroute)
-   [GetOwnersRoute](modules.md#getownersroute)
-   [GetPermissionNumberValue](modules.md#getpermissionnumbervalue)
-   [GetPermissions](modules.md#getpermissions)
-   [GetPortfolioRoute](modules.md#getportfolioroute)
-   [GetSearchRoute](modules.md#getsearchroute)
-   [GetStatusRoute](modules.md#getstatusroute)
-   [InsertRangeToIdRanges](modules.md#insertrangetoidranges)
-   [MergePrevOrNextIfPossible](modules.md#mergeprevornextifpossible)
-   [NormalizeIdRange](modules.md#normalizeidrange)
-   [RemoveIdsFromIdRange](modules.md#removeidsfromidrange)
-   [SafeAdd](modules.md#safeadd)
-   [SafeSubtract](modules.md#safesubtract)
-   [SearchBalances](modules.md#searchbalances)
-   [SearchIdRangesForId](modules.md#searchidrangesforid)
-   [SetBalanceForIdRanges](modules.md#setbalanceforidranges)
-   [SortIdRangesAndMergeIfNecessary](modules.md#sortidrangesandmergeifnecessary)
-   [SubtractBalancesForIdRanges](modules.md#subtractbalancesforidranges)
-   [UpdateBalancesForIdRanges](modules.md#updatebalancesforidranges)
-   [UpdatePermissions](modules.md#updatepermissions)
-   [ValidatePermissions](modules.md#validatepermissions)
-   [ValidatePermissionsUpdate](modules.md#validatepermissionsupdate)
-   [checkIfApproved](modules.md#checkifapproved)
-   [checkIfApprovedInTransferList](modules.md#checkifapprovedintransferlist)
-   [checkIfIdRangesOverlap](modules.md#checkifidrangesoverlap)
-   [convertToBitBadgesUserInfo](modules.md#converttobitbadgesuserinfo)
-   [convertToBitBadgesAddress](modules.md#converttocosmosaddress)
-   [createCollectionFromMsgNewCollection](modules.md#createcollectionfrommsgnewcollection)
-   [doesChainMatchName](modules.md#doeschainmatchname)
-   [filterTokenActivityForBadgeId](modules.md#filterbadgeactivityforbadgeid)
-   [getAbbreviatedAddress](modules.md#getabbreviatedaddress)
-   [getBadgeIdsToDisplayForPageNumber](modules.md#getbadgeidstodisplayforpagenumber)
-   [getBalanceAfterTransfer](modules.md#getbalanceaftertransfer)
-   [getBalanceAfterTransfers](modules.md#getbalanceaftertransfers)
-   [getBlankBalance](modules.md#getblankbalance)
-   [getChainForAddress](modules.md#getchainforaddress)
-   [getClaimsFromClaimItems](modules.md#getclaimsfromclaimitems)
-   [getIdRangesForAllBadgeIdsInCollection](modules.md#getidrangesforallbadgeidsincollection)
-   [getMatchingAddressesFromTransferList](modules.md#getmatchingaddressesfromtransferlist)
-   [getMaxBatchId](modules.md#getmaxbatchid)
-   [getMetadataForBadgeId](modules.md#getmetadataforbadgeid)
-   [getMetadataMapObjForBadgeId](modules.md#getmetadatamapobjforbadgeid)
-   [getNonTransferableDisallowedTransfers](modules.md#getnontransferabledisallowedtransfers)
-   [getSupplyByBadgeId](modules.md#getsupplybybadgeid)
-   [getTransferListForSelectOptions](modules.md#gettransferlistforselectoptions)
-   [getTransfersFromClaimItems](modules.md#gettransfersfromclaimitems)
-   [isAddressValid](modules.md#isaddressvalid)
-   [isTransferListFull](modules.md#istransferlistfull)
-   [populateFieldsOfOtherBadges](modules.md#populatefieldsofotherbadges)
-   [updateMetadataForBadgeIdsFromIndexerIfAbsent](modules.md#updatemetadataforbadgeidsfromindexerifabsent)
-   [updateMetadataMap](modules.md#updatemetadatamap)
-   [updateTransferListAccountNums](modules.md#updatetransferlistaccountnums)

## Type Aliases

### Permissions

Ƭ **Permissions**: `Object`

#### Type declaration

| Name                      | Type      |
| :------------------------ | :-------- |
| `CanCreateMoreBadges`     | `boolean` |
| `CanDelete`               | `boolean` |
| `CanManagerBeTransferred` | `boolean` |
| `CanUpdateBytes`          | `boolean` |
| `CanUpdateDisallowed`     | `boolean` |
| `CanUpdateUris`           | `boolean` |

#### Defined in

[permissions.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L3)

## Variables

### AllAddressesTransferList

• `Const` **AllAddressesTransferList**: [`TransferList`](interfaces/TransferList.md)

#### Defined in

[badges.ts:109](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L109)

---

### CHAIN_DETAILS

• `Const` **CHAIN_DETAILS**: `Object`

#### Type declaration

| Name            | Type     |
| :-------------- | :------- |
| `chainId`       | `number` |
| `cosmosChainId` | `string` |

#### Defined in

[constants.ts:9](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L9)

---

### CanCreateMoreBadgesDigit

• `Const` **CanCreateMoreBadgesDigit**: `2`

#### Defined in

[permissions.ts:16](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L16)

---

### CanDeleteDigit

• `Const` **CanDeleteDigit**: `6`

#### Defined in

[permissions.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L12)

---

### CanManagerBeTransferredDigit

• `Const` **CanManagerBeTransferredDigit**: `4`

#### Defined in

[permissions.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L14)

---

### CanUpdateBytesDigit

• `Const` **CanUpdateBytesDigit**: `5`

#### Defined in

[permissions.ts:13](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L13)

---

### CanUpdateDisallowedDigit

• `Const` **CanUpdateDisallowedDigit**: `1`

#### Defined in

[permissions.ts:17](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L17)

---

### CanUpdateUrisDigit

• `Const` **CanUpdateUrisDigit**: `3`

#### Defined in

[permissions.ts:15](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L15)

---

### DefaultPlaceholderMetadata

• `Const` **DefaultPlaceholderMetadata**: [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[constants.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L14)

---

### ErrorMetadata

• `Const` **ErrorMetadata**: [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[constants.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L20)

---

### GO_MAX_UINT_64

• `Const` **GO_MAX_UINT_64**: `1000000000000000`

#### Defined in

[constants.ts:7](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L7)

---

### MAX_DATE_TIMESTAMP

• `Const` **MAX_DATE_TIMESTAMP**: `number`

#### Defined in

[constants.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L5)

---

### METADATA_PAGE_LIMIT

• `Const` **METADATA_PAGE_LIMIT**: `100`

#### Defined in

[constants.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L3)

---

### MINT_ACCOUNT

• `Const` **MINT_ACCOUNT**: [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Defined in

[chains.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L5)

---

### NUM_PERMISSIONS

• `Const` **NUM_PERMISSIONS**: `6`

#### Defined in

[permissions.ts:1](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L1)

## Functions

### AddBalancesForIdRanges

▸ **AddBalancesForIdRanges**(`userBalanceInfo`, `ranges`, `balanceToAdd`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name              | Type                                       |
| :---------------- | :----------------------------------------- |
| `userBalanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |
| `ranges`          | [`IdRange`](interfaces/IdRange.md)[]       |
| `balanceToAdd`    | `number`                                   |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:116](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L116)

---

### DeleteBalanceForIdRanges

▸ **DeleteBalanceForIdRanges**(`ranges`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name             | Type                                 |
| :--------------- | :----------------------------------- |
| `ranges`         | [`IdRange`](interfaces/IdRange.md)[] |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:142](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L142)

---

### GetAccountByNumberRoute

▸ **GetAccountByNumberRoute**(`id`): `string`

#### Parameters

| Name | Type     |
| :--- | :------- |
| `id` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:8](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L8)

---

### GetAccountRoute

▸ **GetAccountRoute**(`bech32address`): `string`

#### Parameters

| Name            | Type     |
| :-------------- | :------- |
| `bech32address` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:4](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L4)

---

### GetAccountsRoute

▸ **GetAccountsRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L12)

---

### GetBalanceRoute

▸ **GetBalanceRoute**(`collectionId`, `accountNumber`): `string`

#### Parameters

| Name            | Type     |
| :-------------- | :------- |
| `collectionId`  | `number` |
| `accountNumber` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:28](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L28)

---

### GetBalanceInfoToInsertToStorage

▸ **GetBalanceInfoToInsertToStorage**(`balanceInfo`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name          | Type                                       |
| :------------ | :----------------------------------------- |
| `balanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:254](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L254)

---

### GetBalanceRoute

▸ **GetBalanceRoute**(`bech32address`): `string`

#### Parameters

| Name            | Type     |
| :-------------- | :------- |
| `bech32address` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:16](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L16)

---

### GetBalancesForIdRanges

▸ **GetBalancesForIdRanges**(`badgeIds`, `currentUserBalances`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name                  | Type                                 |
| :-------------------- | :----------------------------------- |
| `badgeIds`            | [`IdRange`](interfaces/IdRange.md)[] |
| `currentUserBalances` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L36)

---

### GetCollectionRoute

▸ **GetCollectionRoute**(`collectionId`): `string`

#### Parameters

| Name           | Type     |
| :------------- | :------- |
| `collectionId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L20)

---

### GetCollectionsRoute

▸ **GetCollectionsRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:24](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L24)

---

### GetIdRangeToInsert

▸ **GetIdRangeToInsert**(`start`, `end`): `Object`

#### Parameters

| Name    | Type     |
| :------ | :------- |
| `start` | `number` |
| `end`   | `number` |

#### Returns

`Object`

| Name    | Type     |
| :------ | :------- |
| `end`   | `number` |
| `start` | `number` |

#### Defined in

[idRanges.ts:152](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L152)

---

### GetIdRangesToInsertToStorage

▸ **GetIdRangesToInsertToStorage**(`idRanges`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name       | Type                                 |
| :--------- | :----------------------------------- |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:31](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L31)

---

### GetIdRangesWithOmitEmptyCaseHandled

▸ **GetIdRangesWithOmitEmptyCaseHandled**(`ids`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name  | Type                                 |
| :---- | :----------------------------------- |
| `ids` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:144](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L144)

---

### GetIdxSpanForRange

▸ **GetIdxSpanForRange**(`targetRange`, `targetIdRanges`): [[`IdRange`](interfaces/IdRange.md), `boolean`]

#### Parameters

| Name             | Type                                 |
| :--------------- | :----------------------------------- |
| `targetRange`    | [`IdRange`](interfaces/IdRange.md)   |
| `targetIdRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[[`IdRange`](interfaces/IdRange.md), `boolean`]

#### Defined in

[idRanges.ts:111](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L111)

---

### GetIdxToInsertForNewId

▸ **GetIdxToInsertForNewId**(`id`, `targetIds`): `number`

#### Parameters

| Name        | Type                                 |
| :---------- | :----------------------------------- |
| `id`        | `number`                             |
| `targetIds` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

`number`

#### Defined in

[idRanges.ts:176](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L176)

---

### GetMetadataRoute

▸ **GetMetadataRoute**(`collectionId`): `string`

#### Parameters

| Name           | Type     |
| :------------- | :------- |
| `collectionId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:40](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L40)

---

### GetOwnersRoute

▸ **GetOwnersRoute**(`collectionId`, `badgeId`): `string`

#### Parameters

| Name           | Type     |
| :------------- | :------- |
| `collectionId` | `number` |
| `badgeId`      | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:32](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L32)

---

### GetPermissionNumberValue

▸ **GetPermissionNumberValue**(`permissions`): `number`

#### Parameters

| Name          | Type                                    |
| :------------ | :-------------------------------------- |
| `permissions` | [`Permissions`](modules.md#permissions) |

#### Returns

`number`

#### Defined in

[permissions.ts:19](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L19)

---

### GetPermissions

▸ **GetPermissions**(`permissions`): [`Permissions`](modules.md#permissions)

#### Parameters

| Name          | Type     |
| :------------ | :------- |
| `permissions` | `number` |

#### Returns

[`Permissions`](modules.md#permissions)

#### Defined in

[permissions.ts:118](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L118)

---

### GetPortfolioRoute

▸ **GetPortfolioRoute**(`accountNumber`): `string`

#### Parameters

| Name            | Type     |
| :-------------- | :------- |
| `accountNumber` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L36)

---

### GetSearchRoute

▸ **GetSearchRoute**(`query`): `string`

#### Parameters

| Name    | Type     |
| :------ | :------- |
| `query` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:44](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L44)

---

### GetStatusRoute

▸ **GetStatusRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:48](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L48)

---

### InsertRangeToIdRanges

▸ **InsertRangeToIdRanges**(`rangeToAdd`, `targetIds`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name         | Type                                 |
| :----------- | :----------------------------------- |
| `rangeToAdd` | [`IdRange`](interfaces/IdRange.md)   |
| `targetIds`  | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:274](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L274)

---

### MergePrevOrNextIfPossible

▸ **MergePrevOrNextIfPossible**(`targetIds`, `insertedAtIdx`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name            | Type                                 |
| :-------------- | :----------------------------------- |
| `targetIds`     | [`IdRange`](interfaces/IdRange.md)[] |
| `insertedAtIdx` | `number`                             |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:218](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L218)

---

### NormalizeIdRange

▸ **NormalizeIdRange**(`rangeToNormalize`): `Object`

#### Parameters

| Name               | Type                               |
| :----------------- | :--------------------------------- |
| `rangeToNormalize` | [`IdRange`](interfaces/IdRange.md) |

#### Returns

`Object`

| Name    | Type     |
| :------ | :------- |
| `end`   | `number` |
| `start` | `number` |

#### Defined in

[idRanges.ts:164](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L164)

---

### RemoveIdsFromIdRange

▸ **RemoveIdsFromIdRange**(`rangeToRemove`, `rangeObject`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name            | Type                               |
| :-------------- | :--------------------------------- |
| `rangeToRemove` | [`IdRange`](interfaces/IdRange.md) |
| `rangeObject`   | [`IdRange`](interfaces/IdRange.md) |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:47](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L47)

---

### SafeAdd

▸ **SafeAdd**(`left`, `right`): `number`

#### Parameters

| Name    | Type     |
| :------ | :------- |
| `left`  | `number` |
| `right` | `number` |

#### Returns

`number`

#### Defined in

[balances-gpt.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L5)

---

### SafeSubtract

▸ **SafeSubtract**(`left`, `right`): `number`

#### Parameters

| Name    | Type     |
| :------ | :------- |
| `left`  | `number` |
| `right` | `number` |

#### Returns

`number`

#### Defined in

[balances-gpt.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L14)

---

### SearchBalances

▸ **SearchBalances**(`targetAmount`, `balanceObjects`): (`number` \| `boolean`)[]

#### Parameters

| Name             | Type                                 |
| :--------------- | :----------------------------------- |
| `targetAmount`   | `number`                             |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

(`number` \| `boolean`)[]

#### Defined in

[balances-gpt.ts:224](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L224)

---

### SearchIdRangesForId

▸ **SearchIdRangesForId**(`id`, `idRanges`): [`number`, `boolean`]

#### Parameters

| Name       | Type                                 |
| :--------- | :----------------------------------- |
| `id`       | `number`                             |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`number`, `boolean`]

#### Defined in

[idRanges.ts:92](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L92)

---

### SetBalanceForIdRanges

▸ **SetBalanceForIdRanges**(`ranges`, `amount`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name             | Type                                 |
| :--------------- | :----------------------------------- |
| `ranges`         | [`IdRange`](interfaces/IdRange.md)[] |
| `amount`         | `number`                             |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:183](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L183)

---

### SortIdRangesAndMergeIfNecessary

▸ **SortIdRangesAndMergeIfNecessary**(`idRanges`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name       | Type                                 |
| :--------- | :----------------------------------- |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L3)

---

### SubtractBalancesForIdRanges

▸ **SubtractBalancesForIdRanges**(`userBalanceInfo`, `ranges`, `balanceToRemove`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name              | Type                                       |
| :---------------- | :----------------------------------------- |
| `userBalanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |
| `ranges`          | [`IdRange`](interfaces/IdRange.md)[]       |
| `balanceToRemove` | `number`                                   |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:129](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L129)

---

### UpdateBalancesForIdRanges

▸ **UpdateBalancesForIdRanges**(`ranges`, `newAmount`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name             | Type                                 |
| :--------------- | :----------------------------------- |
| `ranges`         | [`IdRange`](interfaces/IdRange.md)[] |
| `newAmount`      | `number`                             |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:22](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L22)

---

### UpdatePermissions

▸ **UpdatePermissions**(`currPermissions`, `permissionDigit`, `value`): `number`

#### Parameters

| Name              | Type      |
| :---------------- | :-------- |
| `currPermissions` | `number`  |
| `permissionDigit` | `number`  |
| `value`           | `boolean` |

#### Returns

`number`

#### Defined in

[permissions.ts:97](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L97)

---

### ValidatePermissions

▸ **ValidatePermissions**(`permissions`): `void`

#### Parameters

| Name          | Type     |
| :------------ | :------- |
| `permissions` | `number` |

#### Returns

`void`

#### Defined in

[permissions.ts:53](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L53)

---

### ValidatePermissionsUpdate

▸ **ValidatePermissionsUpdate**(`oldPermissions`, `newPermissions`): `void`

#### Parameters

| Name             | Type     |
| :--------------- | :------- |
| `oldPermissions` | `number` |
| `newPermissions` | `number` |

#### Returns

`void`

#### Defined in

[permissions.ts:60](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L60)

---

### checkIfApproved

▸ **checkIfApproved**(`userBalance`, `accountNumber`, `balancesToCheck`): `boolean`

#### Parameters

| Name              | Type                                       |
| :---------------- | :----------------------------------------- |
| `userBalance`     | [`UserBalance`](interfaces/UserBalance.md) |
| `accountNumber`   | `number`                                   |
| `balancesToCheck` | [`Balance`](interfaces/Balance.md)[]       |

#### Returns

`boolean`

#### Defined in

[badges.ts:311](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L311)

---

### checkIfApprovedInTransferList

▸ **checkIfApprovedInTransferList**(`addresses`, `connectedUser`, `managerAccountNumber`): `boolean`

#### Parameters

| Name                   | Type                                                   |
| :--------------------- | :----------------------------------------------------- |
| `addresses`            | [`Addresses`](interfaces/Addresses.md)                 |
| `connectedUser`        | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md) |
| `managerAccountNumber` | `number`                                               |

#### Returns

`boolean`

#### Defined in

[badges.ts:130](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L130)

---

### checkIfIdRangesOverlap

▸ **checkIfIdRangesOverlap**(`idRanges`): `boolean`

#### Parameters

| Name       | Type                                 |
| :--------- | :----------------------------------- |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

`boolean`

#### Defined in

[idRanges.ts:301](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L301)

---

### convertToBitBadgesUserInfo

▸ **convertToBitBadgesUserInfo**(`accountInfo`): [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Parameters

| Name          | Type                                               |
| :------------ | :------------------------------------------------- |
| `accountInfo` | [`AccountResponse`](interfaces/AccountResponse.md) |

#### Returns

[`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Defined in

[users.ts:4](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/users.ts#L4)

---

### convertToBitBadgesAddress

▸ **convertToBitBadgesAddress**(`address`): `string`

#### Parameters

| Name      | Type     |
| :-------- | :------- |
| `address` | `string` |

#### Returns

`string`

#### Defined in

[chains.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L12)

---

### createCollectionFromMsgNewCollection

▸ **createCollectionFromMsgNewCollection**(`msgNewCollection`, `collectionMetadata`, `individualBadgeMetadata`, `connectedUser`, `claimItems`, `existingCollection?`): [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)

#### Parameters

| Name                      | Type                                                       |
| :------------------------ | :--------------------------------------------------------- |
| `msgNewCollection`        | `MessageMsgNewCollection`                                  |
| `collectionMetadata`      | [`BadgeMetadata`](interfaces/BadgeMetadata.md)             |
| `individualBadgeMetadata` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)       |
| `connectedUser`           | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)     |
| `claimItems`              | [`ClaimItemWithTrees`](interfaces/ClaimItemWithTrees.md)[] |
| `existingCollection?`     | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)   |

#### Returns

[`BitBadgeCollection`](interfaces/BitBadgeCollection.md)

#### Defined in

[badges.ts:29](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L29)

---

### doesChainMatchName

▸ **doesChainMatchName**(`chain`, `name?`): `boolean`

#### Parameters

| Name    | Type                                        |
| :------ | :------------------------------------------ |
| `chain` | [`SupportedChain`](enums/SupportedChain.md) |
| `name?` | `string`                                    |

#### Returns

`boolean`

#### Defined in

[chains.ts:87](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L87)

---

### filterTokenActivityForBadgeId

▸ **filterTokenActivityForBadgeId**(`badgeId`, `activity`): [`TransferActivityItem`](interfaces/TransferActivityItem.md)[]

#### Parameters

| Name       | Type                                                           |
| :--------- | :------------------------------------------------------------- |
| `badgeId`  | `number`                                                       |
| `activity` | [`TransferActivityItem`](interfaces/TransferActivityItem.md)[] |

#### Returns

[`TransferActivityItem`](interfaces/TransferActivityItem.md)[]

#### Defined in

[badges.ts:10](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L10)

---

### getAbbreviatedAddress

▸ **getAbbreviatedAddress**(`address`): `string`

#### Parameters

| Name      | Type     |
| :-------- | :------- |
| `address` | `string` |

#### Returns

`string`

#### Defined in

[chains.ts:46](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L46)

---

### getBadgeIdsToDisplayForPageNumber

▸ **getBadgeIdsToDisplayForPageNumber**(`collections?`, `startIdxNum`, `pageSize`): { `badgeIds`: `number`[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) }[]

#### Parameters

| Name          | Type                                                                                                                            | Default value |
| :------------ | :------------------------------------------------------------------------------------------------------------------------------ | :------------ |
| `collections` | { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) }[] | `[]`          |
| `startIdxNum` | `number`                                                                                                                        | `undefined`   |
| `pageSize`    | `number`                                                                                                                        | `undefined`   |

#### Returns

{ `badgeIds`: `number`[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) }[]

#### Defined in

[badges.ts:197](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L197)

---

### getBalanceAfterTransfer

▸ **getBalanceAfterTransfer**(`balance`, `startSubbadgeId`, `endSubbadgeId`, `amountToTransfer`, `numRecipients`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name               | Type                                       |
| :----------------- | :----------------------------------------- |
| `balance`          | [`UserBalance`](interfaces/UserBalance.md) |
| `startSubbadgeId`  | `number`                                   |
| `endSubbadgeId`    | `number`                                   |
| `amountToTransfer` | `number`                                   |
| `numRecipients`    | `number`                                   |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L14)

---

### getBalanceAfterTransfers

▸ **getBalanceAfterTransfers**(`balance`, `transfers`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name        | Type                                                     |
| :---------- | :------------------------------------------------------- |
| `balance`   | [`UserBalance`](interfaces/UserBalance.md)               |
| `transfers` | [`TransfersExtended`](interfaces/TransfersExtended.md)[] |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:21](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L21)

---

### getBlankBalance

▸ **getBlankBalance**(): [`UserBalance`](interfaces/UserBalance.md)

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L5)

---

### getChainForAddress

▸ **getChainForAddress**(`address`): `SupportedChain`

#### Parameters

| Name      | Type     |
| :-------- | :------- |
| `address` | `string` |

#### Returns

`SupportedChain`

#### Defined in

[chains.ts:26](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L26)

---

### getClaimsFromClaimItems

▸ **getClaimsFromClaimItems**(`balance`, `claimItems`): `Object`

#### Parameters

| Name         | Type                                                       |
| :----------- | :--------------------------------------------------------- |
| `balance`    | [`UserBalance`](interfaces/UserBalance.md)                 |
| `claimItems` | [`ClaimItemWithTrees`](interfaces/ClaimItemWithTrees.md)[] |

#### Returns

`Object`

| Name                   | Type                               |
| :--------------------- | :--------------------------------- |
| `claims`               | [`Claims`](interfaces/Claims.md)[] |
| `undistributedBalance` | `any`                              |

#### Defined in

[claims.ts:63](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/claims.ts#L63)

---

### getIdRangesForAllBadgeIdsInCollection

▸ **getIdRangesForAllBadgeIdsInCollection**(`collection`): `any`

#### Parameters

| Name         | Type                                                     |
| :----------- | :------------------------------------------------------- |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`any`

#### Defined in

[badges.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L20)

---

### getMatchingAddressesFromTransferList

▸ **getMatchingAddressesFromTransferList**(`list`, `toAddresses`, `chain`, `managerAccountNumber`): `any`[]

#### Parameters

| Name                   | Type                                                     |
| :--------------------- | :------------------------------------------------------- |
| `list`                 | [`TransferList`](interfaces/TransferList.md)[]           |
| `toAddresses`          | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)[] |
| `chain`                | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)   |
| `managerAccountNumber` | `number`                                                 |

#### Returns

`any`[]

#### Defined in

[badges.ts:153](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L153)

---

### getMaxBatchId

▸ **getMaxBatchId**(`collection`): `number`

#### Parameters

| Name         | Type                                                     |
| :----------- | :------------------------------------------------------- |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`number`

#### Defined in

[badges.ts:245](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L245)

---

### getMetadataForBadgeId

▸ **getMetadataForBadgeId**(`badgeId`, `metadataMap`): `undefined` \| [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Parameters

| Name          | Type                                                 |
| :------------ | :--------------------------------------------------- |
| `badgeId`     | `number`                                             |
| `metadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |

#### Returns

`undefined` \| [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[badges.ts:183](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L183)

---

### getMetadataMapObjForBadgeId

▸ **getMetadataMapObjForBadgeId**(`badgeId`, `metadataMap`): `undefined` \| { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `metadata`: [`BadgeMetadata`](interfaces/BadgeMetadata.md) ; `uri`: `string` }

#### Parameters

| Name          | Type                                                 |
| :------------ | :--------------------------------------------------- |
| `badgeId`     | `number`                                             |
| `metadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |

#### Returns

`undefined` \| { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `metadata`: [`BadgeMetadata`](interfaces/BadgeMetadata.md) ; `uri`: `string` }

#### Defined in

[badges.ts:170](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L170)

---

### getNonTransferableDisallowedTransfers

▸ **getNonTransferableDisallowedTransfers**(): `any`[]

#### Returns

`any`[]

#### Defined in

[badges.ts:105](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L105)

---

### getSupplyByBadgeId

▸ **getSupplyByBadgeId**(`badgeId`, `balances`): `number`

#### Parameters

| Name       | Type                                 |
| :--------- | :----------------------------------- |
| `badgeId`  | `number`                             |
| `balances` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

`number`

#### Defined in

[balances.ts:48](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L48)

---

### getTransferListForSelectOptions

▸ **getTransferListForSelectOptions**(`isFromList`, `unregistered`, `users`, `all`, `none`, `everyoneExcept`): `undefined` \| [`TransferListWithUnregisteredUsers`](interfaces/TransferListWithUnregisteredUsers.md)

#### Parameters

| Name             | Type                                                     |
| :--------------- | :------------------------------------------------------- |
| `isFromList`     | `boolean`                                                |
| `unregistered`   | `string`[]                                               |
| `users`          | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)[] |
| `all`            | `boolean`                                                |
| `none`           | `boolean`                                                |
| `everyoneExcept` | `boolean`                                                |

#### Returns

`undefined` \| [`TransferListWithUnregisteredUsers`](interfaces/TransferListWithUnregisteredUsers.md)

#### Defined in

[transferLists.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L36)

---

### getTransfersFromClaimItems

▸ **getTransfersFromClaimItems**(`claimItems`, `accounts`): [`TransfersExtended`](interfaces/TransfersExtended.md)[]

#### Parameters

| Name         | Type                                     |
| :----------- | :--------------------------------------- |
| `claimItems` | [`ClaimItem`](interfaces/ClaimItem.md)[] |
| `accounts`   | [`AccountMap`](interfaces/AccountMap.md) |

#### Returns

[`TransfersExtended`](interfaces/TransfersExtended.md)[]

#### Defined in

[claims.ts:6](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/claims.ts#L6)

---

### isAddressValid

▸ **isAddressValid**(`address`, `chain?`): `boolean`

#### Parameters

| Name      | Type     |
| :-------- | :------- |
| `address` | `string` |
| `chain?`  | `string` |

#### Returns

`boolean`

#### Defined in

[chains.ts:55](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L55)

---

### isTransferListFull

▸ **isTransferListFull**(`transfersList`): `boolean`

#### Parameters

| Name            | Type                                           |
| :-------------- | :--------------------------------------------- |
| `transfersList` | [`TransferList`](interfaces/TransferList.md)[] |

#### Returns

`boolean`

#### Defined in

[transferLists.ts:27](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L27)

---

### populateFieldsOfOtherBadges

▸ **populateFieldsOfOtherBadges**(`individualBadgeMetadata`, `badgeIds`, `key`, `value`, `metadataToSet?`): [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Parameters

| Name                      | Type                                                 |
| :------------------------ | :--------------------------------------------------- |
| `individualBadgeMetadata` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `badgeIds`                | [`IdRange`](interfaces/IdRange.md)[]                 |
| `key`                     | `string`                                             |
| `value`                   | `any`                                                |
| `metadataToSet?`          | [`BadgeMetadata`](interfaces/BadgeMetadata.md)       |

#### Returns

[`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Defined in

[metadata.ts:61](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/metadata.ts#L61)

---

### updateMetadataForBadgeIdsFromIndexerIfAbsent

▸ **updateMetadataForBadgeIdsFromIndexerIfAbsent**(`badgeIdsToDisplay`, `collection`): `number`[]

#### Parameters

| Name                | Type                                                     |
| :------------------ | :------------------------------------------------------- |
| `badgeIdsToDisplay` | `number`[]                                               |
| `collection`        | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`number`[]

#### Defined in

[badges.ts:264](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L264)

---

### updateMetadataMap

▸ **updateMetadataMap**(`currMetadataMap`, `metadata`, `badgeIds`, `uri`): [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Parameters

| Name              | Type                                                 |
| :---------------- | :--------------------------------------------------- |
| `currMetadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `metadata`        | [`BadgeMetadata`](interfaces/BadgeMetadata.md)       |
| `badgeIds`        | [`IdRange`](interfaces/IdRange.md)                   |
| `uri`             | `string`                                             |

#### Returns

[`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Defined in

[metadata.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/metadata.ts#L5)

---

### updateTransferListAccountNums

▸ **updateTransferListAccountNums**(`accountNumber`, `remove`, `transferListAddresses`): [`Addresses`](interfaces/Addresses.md)

#### Parameters

| Name                    | Type                                   |
| :---------------------- | :------------------------------------- |
| `accountNumber`         | `number`                               |
| `remove`                | `boolean`                              |
| `transferListAddresses` | [`Addresses`](interfaces/Addresses.md) |

#### Returns

[`Addresses`](interfaces/Addresses.md)

#### Defined in

[transferLists.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L5)


## File: ./.gitbook/assets/modules.md

[BitBadges](README.md) / Exports

# BitBadges

## Table of contents

### Enumerations

-   [DistributionMethod](enums/DistributionMethod.md)
-   [MetadataAddMethod](enums/MetadataAddMethod.md)
-   [SupportedChain](enums/SupportedChain.md)
-   [TransactionStatus](enums/TransactionStatus.md)

### Interfaces

-   [AccountDocs](interfaces/AccountDocs.md)
-   [AccountDocument](interfaces/AccountDocument.md)
-   [AccountMap](interfaces/AccountMap.md)
-   [AccountResponse](interfaces/AccountResponse.md)
-   [ActivityItem](interfaces/ActivityItem.md)
-   [Addresses](interfaces/Addresses.md)
-   [AnnouncementActivityItem](interfaces/AnnouncementActivityItem.md)
-   [Approval](interfaces/Approval.md)
-   [BadgeMetadata](interfaces/BadgeMetadata.md)
-   [BadgeMetadataMap](interfaces/BadgeMetadataMap.md)
-   [BadgeSupplyAndAmount](interfaces/BadgeSupplyAndAmount.md)
-   [BadgeUri](interfaces/BadgeUri.md)
-   [Balance](interfaces/Balance.md)
-   [BalanceObject](interfaces/BalanceObject.md)
-   [BalancesMap](interfaces/BalancesMap.md)
-   [BitBadgeCollection](interfaces/BitBadgeCollection.md)
-   [BitBadgeMintObject](interfaces/BitBadgeMintObject.md)
-   [BitBadgesUserInfo](interfaces/BitBadgesUserInfo.md)
-   [ClaimItem](interfaces/ClaimItem.md)
-   [ClaimItemWithTrees](interfaces/ClaimItemWithTrees.md)
-   [Claims](interfaces/Claims.md)
-   [CollectionDocs](interfaces/CollectionDocs.md)
-   [CollectionMap](interfaces/CollectionMap.md)
-   [CosmosAccountInformation](interfaces/CosmosAccountInformation.md)
-   [DbStatus](interfaces/DbStatus.md)
-   [Docs](interfaces/Docs.md)
-   [GetAccountResponse](interfaces/GetAccountResponse.md)
-   [GetBalanceResponse](interfaces/GetBalanceResponse.md)
-   [GetBalanceResponse](interfaces/GetBalanceResponse.md)
-   [GetCollectionResponse](interfaces/GetCollectionResponse.md)
-   [GetOwnersResponse](interfaces/GetOwnersResponse.md)
-   [GetPortfolioResponse](interfaces/GetPortfolioResponse.md)
-   [IdRange](interfaces/IdRange.md)
-   [IndexerStatus](interfaces/IndexerStatus.md)
-   [LatestBlockStatus](interfaces/LatestBlockStatus.md)
-   [MetadataDocs](interfaces/MetadataDocs.md)
-   [MetadataDocument](interfaces/MetadataDocument.md)
-   [PaginationInfo](interfaces/PaginationInfo.md)
-   [PasswordDocument](interfaces/PasswordDocument.md)
-   [PendingTransfer](interfaces/PendingTransfer.md)
-   [Proof](interfaces/Proof.md)
-   [SearchResponse](interfaces/SearchResponse.md)
-   [StoredBadgeCollection](interfaces/StoredBadgeCollection.md)
-   [SubassetSupply](interfaces/SubassetSupply.md)
-   [TransferActivityItem](interfaces/TransferActivityItem.md)
-   [TransferList](interfaces/TransferList.md)
-   [TransferListWithUnregisteredUsers](interfaces/TransferListWithUnregisteredUsers.md)
-   [Transfers](interfaces/Transfers.md)
-   [TransfersExtended](interfaces/TransfersExtended.md)
-   [UserBalance](interfaces/UserBalance.md)

### Type Aliases

-   [Permissions](modules.md#permissions)

### Variables

-   [AllAddressesTransferList](modules.md#alladdressestransferlist)
-   [CHAIN_DETAILS](modules.md#chain_details)
-   [CanCreateMoreBadgesDigit](modules.md#cancreatemorebadgesdigit)
-   [CanDeleteDigit](modules.md#candeletedigit)
-   [CanManagerBeTransferredDigit](modules.md#canmanagerbetransferreddigit)
-   [CanUpdateBytesDigit](modules.md#canupdatebytesdigit)
-   [CanUpdateDisallowedDigit](modules.md#canupdatedisalloweddigit)
-   [CanUpdateUrisDigit](modules.md#canupdateurisdigit)
-   [DefaultPlaceholderMetadata](modules.md#defaultplaceholdermetadata)
-   [ErrorMetadata](modules.md#errormetadata)
-   [GO_MAX_UINT_64](modules.md#go_max_uint_64)
-   [MAX_DATE_TIMESTAMP](modules.md#max_date_timestamp)
-   [METADATA_PAGE_LIMIT](modules.md#metadata_page_limit)
-   [MINT_ACCOUNT](modules.md#mint_account)
-   [NUM_PERMISSIONS](modules.md#num_permissions)

### Functions

-   [AddBalancesForIdRanges](modules.md#addbalancesforidranges)
-   [DeleteBalanceForIdRanges](modules.md#deletebalanceforidranges)
-   [GetAccountByNumberRoute](modules.md#getaccountbynumberroute)
-   [GetAccountRoute](modules.md#getaccountroute)
-   [GetAccountsRoute](modules.md#getaccountsroute)
-   [GetBalanceRoute](modules.md#getbalanceroute)
-   [GetBalanceInfoToInsertToStorage](modules.md#getbalanceinfotoinserttostorage)
-   [GetBalanceRoute](modules.md#getbalanceroute)
-   [GetBalancesForIdRanges](modules.md#getbalancesforidranges)
-   [GetCollectionRoute](modules.md#getcollectionroute)
-   [GetCollectionsRoute](modules.md#getcollectionsroute)
-   [GetIdRangeToInsert](modules.md#getidrangetoinsert)
-   [GetIdRangesToInsertToStorage](modules.md#getidrangestoinserttostorage)
-   [GetIdRangesWithOmitEmptyCaseHandled](modules.md#getidrangeswithomitemptycasehandled)
-   [GetIdxSpanForRange](modules.md#getidxspanforrange)
-   [GetIdxToInsertForNewId](modules.md#getidxtoinsertfornewid)
-   [GetMetadataRoute](modules.md#getmetadataroute)
-   [GetOwnersRoute](modules.md#getownersroute)
-   [GetPermissionNumberValue](modules.md#getpermissionnumbervalue)
-   [GetPermissions](modules.md#getpermissions)
-   [GetPortfolioRoute](modules.md#getportfolioroute)
-   [GetSearchRoute](modules.md#getsearchroute)
-   [GetStatusRoute](modules.md#getstatusroute)
-   [InsertRangeToIdRanges](modules.md#insertrangetoidranges)
-   [MergePrevOrNextIfPossible](modules.md#mergeprevornextifpossible)
-   [NormalizeIdRange](modules.md#normalizeidrange)
-   [RemoveIdsFromIdRange](modules.md#removeidsfromidrange)
-   [SafeAdd](modules.md#safeadd)
-   [SafeSubtract](modules.md#safesubtract)
-   [SearchBalances](modules.md#searchbalances)
-   [SearchIdRangesForId](modules.md#searchidrangesforid)
-   [SetBalanceForIdRanges](modules.md#setbalanceforidranges)
-   [SortIdRangesAndMergeIfNecessary](modules.md#sortidrangesandmergeifnecessary)
-   [SubtractBalancesForIdRanges](modules.md#subtractbalancesforidranges)
-   [UpdateBalancesForIdRanges](modules.md#updatebalancesforidranges)
-   [UpdatePermissions](modules.md#updatepermissions)
-   [ValidatePermissions](modules.md#validatepermissions)
-   [ValidatePermissionsUpdate](modules.md#validatepermissionsupdate)
-   [checkIfApproved](modules.md#checkifapproved)
-   [checkIfApprovedInTransferList](modules.md#checkifapprovedintransferlist)
-   [checkIfIdRangesOverlap](modules.md#checkifidrangesoverlap)
-   [convertToBitBadgesUserInfo](modules.md#converttobitbadgesuserinfo)
-   [convertToBitBadgesAddress](modules.md#converttocosmosaddress)
-   [createCollectionFromMsgNewCollection](modules.md#createcollectionfrommsgnewcollection)
-   [doesChainMatchName](modules.md#doeschainmatchname)
-   [filterTokenActivityForBadgeId](modules.md#filterbadgeactivityforbadgeid)
-   [getAbbreviatedAddress](modules.md#getabbreviatedaddress)
-   [getBadgeIdsToDisplayForPageNumber](modules.md#getbadgeidstodisplayforpagenumber)
-   [getBalanceAfterTransfer](modules.md#getbalanceaftertransfer)
-   [getBalanceAfterTransfers](modules.md#getbalanceaftertransfers)
-   [getBlankBalance](modules.md#getblankbalance)
-   [getChainForAddress](modules.md#getchainforaddress)
-   [getClaimsFromClaimItems](modules.md#getclaimsfromclaimitems)
-   [getIdRangesForAllBadgeIdsInCollection](modules.md#getidrangesforallbadgeidsincollection)
-   [getMatchingAddressesFromTransferList](modules.md#getmatchingaddressesfromtransferlist)
-   [getMaxBatchId](modules.md#getmaxbatchid)
-   [getMetadataForBadgeId](modules.md#getmetadataforbadgeid)
-   [getMetadataMapObjForBadgeId](modules.md#getmetadatamapobjforbadgeid)
-   [getNonTransferableDisallowedTransfers](modules.md#getnontransferabledisallowedtransfers)
-   [getSupplyByBadgeId](modules.md#getsupplybybadgeid)
-   [getTransferListForSelectOptions](modules.md#gettransferlistforselectoptions)
-   [getTransfersFromClaimItems](modules.md#gettransfersfromclaimitems)
-   [isAddressValid](modules.md#isaddressvalid)
-   [isTransferListFull](modules.md#istransferlistfull)
-   [populateFieldsOfOtherBadges](modules.md#populatefieldsofotherbadges)
-   [updateMetadataForBadgeIdsFromIndexerIfAbsent](modules.md#updatemetadataforbadgeidsfromindexerifabsent)
-   [updateMetadataMap](modules.md#updatemetadatamap)
-   [updateTransferListAccountNums](modules.md#updatetransferlistaccountnums)

## Type Aliases

### Permissions

Ƭ **Permissions**: `Object`

#### Type declaration

| Name                      | Type      |
| :------------------------ | :-------- |
| `CanCreateMoreBadges`     | `boolean` |
| `CanDelete`               | `boolean` |
| `CanManagerBeTransferred` | `boolean` |
| `CanUpdateBytes`          | `boolean` |
| `CanUpdateDisallowed`     | `boolean` |
| `CanUpdateUris`           | `boolean` |

#### Defined in

[permissions.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L3)

## Variables

### AllAddressesTransferList

• `Const` **AllAddressesTransferList**: [`TransferList`](interfaces/TransferList.md)

#### Defined in

[badges.ts:109](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L109)

---

### CHAIN_DETAILS

• `Const` **CHAIN_DETAILS**: `Object`

#### Type declaration

| Name            | Type     |
| :-------------- | :------- |
| `chainId`       | `number` |
| `cosmosChainId` | `string` |

#### Defined in

[constants.ts:9](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L9)

---

### CanCreateMoreBadgesDigit

• `Const` **CanCreateMoreBadgesDigit**: `2`

#### Defined in

[permissions.ts:16](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L16)

---

### CanDeleteDigit

• `Const` **CanDeleteDigit**: `6`

#### Defined in

[permissions.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L12)

---

### CanManagerBeTransferredDigit

• `Const` **CanManagerBeTransferredDigit**: `4`

#### Defined in

[permissions.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L14)

---

### CanUpdateBytesDigit

• `Const` **CanUpdateBytesDigit**: `5`

#### Defined in

[permissions.ts:13](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L13)

---

### CanUpdateDisallowedDigit

• `Const` **CanUpdateDisallowedDigit**: `1`

#### Defined in

[permissions.ts:17](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L17)

---

### CanUpdateUrisDigit

• `Const` **CanUpdateUrisDigit**: `3`

#### Defined in

[permissions.ts:15](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L15)

---

### DefaultPlaceholderMetadata

• `Const` **DefaultPlaceholderMetadata**: [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[constants.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L14)

---

### ErrorMetadata

• `Const` **ErrorMetadata**: [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[constants.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L20)

---

### GO_MAX_UINT_64

• `Const` **GO_MAX_UINT_64**: `1000000000000000`

#### Defined in

[constants.ts:7](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L7)

---

### MAX_DATE_TIMESTAMP

• `Const` **MAX_DATE_TIMESTAMP**: `number`

#### Defined in

[constants.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L5)

---

### METADATA_PAGE_LIMIT

• `Const` **METADATA_PAGE_LIMIT**: `100`

#### Defined in

[constants.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L3)

---

### MINT_ACCOUNT

• `Const` **MINT_ACCOUNT**: [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Defined in

[chains.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L5)

---

### NUM_PERMISSIONS

• `Const` **NUM_PERMISSIONS**: `6`

#### Defined in

[permissions.ts:1](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L1)

## Functions

### AddBalancesForIdRanges

▸ **AddBalancesForIdRanges**(`userBalanceInfo`, `ranges`, `balanceToAdd`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name              | Type                                       |
| :---------------- | :----------------------------------------- |
| `userBalanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |
| `ranges`          | [`IdRange`](interfaces/IdRange.md)[]       |
| `balanceToAdd`    | `number`                                   |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:116](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L116)

---

### DeleteBalanceForIdRanges

▸ **DeleteBalanceForIdRanges**(`ranges`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name             | Type                                 |
| :--------------- | :----------------------------------- |
| `ranges`         | [`IdRange`](interfaces/IdRange.md)[] |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:142](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L142)

---

### GetAccountByNumberRoute

▸ **GetAccountByNumberRoute**(`id`): `string`

#### Parameters

| Name | Type     |
| :--- | :------- |
| `id` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:8](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L8)

---

### GetAccountRoute

▸ **GetAccountRoute**(`bech32address`): `string`

#### Parameters

| Name            | Type     |
| :-------------- | :------- |
| `bech32address` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:4](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L4)

---

### GetAccountsRoute

▸ **GetAccountsRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L12)

---

### GetBalanceRoute

▸ **GetBalanceRoute**(`collectionId`, `accountNumber`): `string`

#### Parameters

| Name            | Type     |
| :-------------- | :------- |
| `collectionId`  | `number` |
| `accountNumber` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:28](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L28)

---

### GetBalanceInfoToInsertToStorage

▸ **GetBalanceInfoToInsertToStorage**(`balanceInfo`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name          | Type                                       |
| :------------ | :----------------------------------------- |
| `balanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:254](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L254)

---

### GetBalanceRoute

▸ **GetBalanceRoute**(`bech32address`): `string`

#### Parameters

| Name            | Type     |
| :-------------- | :------- |
| `bech32address` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:16](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L16)

---

### GetBalancesForIdRanges

▸ **GetBalancesForIdRanges**(`badgeIds`, `currentUserBalances`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name                  | Type                                 |
| :-------------------- | :----------------------------------- |
| `badgeIds`            | [`IdRange`](interfaces/IdRange.md)[] |
| `currentUserBalances` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L36)

---

### GetCollectionRoute

▸ **GetCollectionRoute**(`collectionId`): `string`

#### Parameters

| Name           | Type     |
| :------------- | :------- |
| `collectionId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L20)

---

### GetCollectionsRoute

▸ **GetCollectionsRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:24](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L24)

---

### GetIdRangeToInsert

▸ **GetIdRangeToInsert**(`start`, `end`): `Object`

#### Parameters

| Name    | Type     |
| :------ | :------- |
| `start` | `number` |
| `end`   | `number` |

#### Returns

`Object`

| Name    | Type     |
| :------ | :------- |
| `end`   | `number` |
| `start` | `number` |

#### Defined in

[idRanges.ts:152](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L152)

---

### GetIdRangesToInsertToStorage

▸ **GetIdRangesToInsertToStorage**(`idRanges`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name       | Type                                 |
| :--------- | :----------------------------------- |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:31](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L31)

---

### GetIdRangesWithOmitEmptyCaseHandled

▸ **GetIdRangesWithOmitEmptyCaseHandled**(`ids`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name  | Type                                 |
| :---- | :----------------------------------- |
| `ids` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:144](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L144)

---

### GetIdxSpanForRange

▸ **GetIdxSpanForRange**(`targetRange`, `targetIdRanges`): [[`IdRange`](interfaces/IdRange.md), `boolean`]

#### Parameters

| Name             | Type                                 |
| :--------------- | :----------------------------------- |
| `targetRange`    | [`IdRange`](interfaces/IdRange.md)   |
| `targetIdRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[[`IdRange`](interfaces/IdRange.md), `boolean`]

#### Defined in

[idRanges.ts:111](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L111)

---

### GetIdxToInsertForNewId

▸ **GetIdxToInsertForNewId**(`id`, `targetIds`): `number`

#### Parameters

| Name        | Type                                 |
| :---------- | :----------------------------------- |
| `id`        | `number`                             |
| `targetIds` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

`number`

#### Defined in

[idRanges.ts:176](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L176)

---

### GetMetadataRoute

▸ **GetMetadataRoute**(`collectionId`): `string`

#### Parameters

| Name           | Type     |
| :------------- | :------- |
| `collectionId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:40](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L40)

---

### GetOwnersRoute

▸ **GetOwnersRoute**(`collectionId`, `badgeId`): `string`

#### Parameters

| Name           | Type     |
| :------------- | :------- |
| `collectionId` | `number` |
| `badgeId`      | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:32](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L32)

---

### GetPermissionNumberValue

▸ **GetPermissionNumberValue**(`permissions`): `number`

#### Parameters

| Name          | Type                                    |
| :------------ | :-------------------------------------- |
| `permissions` | [`Permissions`](modules.md#permissions) |

#### Returns

`number`

#### Defined in

[permissions.ts:19](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L19)

---

### GetPermissions

▸ **GetPermissions**(`permissions`): [`Permissions`](modules.md#permissions)

#### Parameters

| Name          | Type     |
| :------------ | :------- |
| `permissions` | `number` |

#### Returns

[`Permissions`](modules.md#permissions)

#### Defined in

[permissions.ts:118](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L118)

---

### GetPortfolioRoute

▸ **GetPortfolioRoute**(`accountNumber`): `string`

#### Parameters

| Name            | Type     |
| :-------------- | :------- |
| `accountNumber` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L36)

---

### GetSearchRoute

▸ **GetSearchRoute**(`query`): `string`

#### Parameters

| Name    | Type     |
| :------ | :------- |
| `query` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:44](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L44)

---

### GetStatusRoute

▸ **GetStatusRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:48](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L48)

---

### InsertRangeToIdRanges

▸ **InsertRangeToIdRanges**(`rangeToAdd`, `targetIds`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name         | Type                                 |
| :----------- | :----------------------------------- |
| `rangeToAdd` | [`IdRange`](interfaces/IdRange.md)   |
| `targetIds`  | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:274](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L274)

---

### MergePrevOrNextIfPossible

▸ **MergePrevOrNextIfPossible**(`targetIds`, `insertedAtIdx`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name            | Type                                 |
| :-------------- | :----------------------------------- |
| `targetIds`     | [`IdRange`](interfaces/IdRange.md)[] |
| `insertedAtIdx` | `number`                             |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:218](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L218)

---

### NormalizeIdRange

▸ **NormalizeIdRange**(`rangeToNormalize`): `Object`

#### Parameters

| Name               | Type                               |
| :----------------- | :--------------------------------- |
| `rangeToNormalize` | [`IdRange`](interfaces/IdRange.md) |

#### Returns

`Object`

| Name    | Type     |
| :------ | :------- |
| `end`   | `number` |
| `start` | `number` |

#### Defined in

[idRanges.ts:164](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L164)

---

### RemoveIdsFromIdRange

▸ **RemoveIdsFromIdRange**(`rangeToRemove`, `rangeObject`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name            | Type                               |
| :-------------- | :--------------------------------- |
| `rangeToRemove` | [`IdRange`](interfaces/IdRange.md) |
| `rangeObject`   | [`IdRange`](interfaces/IdRange.md) |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:47](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L47)

---

### SafeAdd

▸ **SafeAdd**(`left`, `right`): `number`

#### Parameters

| Name    | Type     |
| :------ | :------- |
| `left`  | `number` |
| `right` | `number` |

#### Returns

`number`

#### Defined in

[balances-gpt.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L5)

---

### SafeSubtract

▸ **SafeSubtract**(`left`, `right`): `number`

#### Parameters

| Name    | Type     |
| :------ | :------- |
| `left`  | `number` |
| `right` | `number` |

#### Returns

`number`

#### Defined in

[balances-gpt.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L14)

---

### SearchBalances

▸ **SearchBalances**(`targetAmount`, `balanceObjects`): (`number` \| `boolean`)[]

#### Parameters

| Name             | Type                                 |
| :--------------- | :----------------------------------- |
| `targetAmount`   | `number`                             |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

(`number` \| `boolean`)[]

#### Defined in

[balances-gpt.ts:224](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L224)

---

### SearchIdRangesForId

▸ **SearchIdRangesForId**(`id`, `idRanges`): [`number`, `boolean`]

#### Parameters

| Name       | Type                                 |
| :--------- | :----------------------------------- |
| `id`       | `number`                             |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`number`, `boolean`]

#### Defined in

[idRanges.ts:92](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L92)

---

### SetBalanceForIdRanges

▸ **SetBalanceForIdRanges**(`ranges`, `amount`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name             | Type                                 |
| :--------------- | :----------------------------------- |
| `ranges`         | [`IdRange`](interfaces/IdRange.md)[] |
| `amount`         | `number`                             |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:183](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L183)

---

### SortIdRangesAndMergeIfNecessary

▸ **SortIdRangesAndMergeIfNecessary**(`idRanges`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name       | Type                                 |
| :--------- | :----------------------------------- |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L3)

---

### SubtractBalancesForIdRanges

▸ **SubtractBalancesForIdRanges**(`userBalanceInfo`, `ranges`, `balanceToRemove`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name              | Type                                       |
| :---------------- | :----------------------------------------- |
| `userBalanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |
| `ranges`          | [`IdRange`](interfaces/IdRange.md)[]       |
| `balanceToRemove` | `number`                                   |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:129](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L129)

---

### UpdateBalancesForIdRanges

▸ **UpdateBalancesForIdRanges**(`ranges`, `newAmount`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name             | Type                                 |
| :--------------- | :----------------------------------- |
| `ranges`         | [`IdRange`](interfaces/IdRange.md)[] |
| `newAmount`      | `number`                             |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:22](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L22)

---

### UpdatePermissions

▸ **UpdatePermissions**(`currPermissions`, `permissionDigit`, `value`): `number`

#### Parameters

| Name              | Type      |
| :---------------- | :-------- |
| `currPermissions` | `number`  |
| `permissionDigit` | `number`  |
| `value`           | `boolean` |

#### Returns

`number`

#### Defined in

[permissions.ts:97](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L97)

---

### ValidatePermissions

▸ **ValidatePermissions**(`permissions`): `void`

#### Parameters

| Name          | Type     |
| :------------ | :------- |
| `permissions` | `number` |

#### Returns

`void`

#### Defined in

[permissions.ts:53](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L53)

---

### ValidatePermissionsUpdate

▸ **ValidatePermissionsUpdate**(`oldPermissions`, `newPermissions`): `void`

#### Parameters

| Name             | Type     |
| :--------------- | :------- |
| `oldPermissions` | `number` |
| `newPermissions` | `number` |

#### Returns

`void`

#### Defined in

[permissions.ts:60](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L60)

---

### checkIfApproved

▸ **checkIfApproved**(`userBalance`, `accountNumber`, `balancesToCheck`): `boolean`

#### Parameters

| Name              | Type                                       |
| :---------------- | :----------------------------------------- |
| `userBalance`     | [`UserBalance`](interfaces/UserBalance.md) |
| `accountNumber`   | `number`                                   |
| `balancesToCheck` | [`Balance`](interfaces/Balance.md)[]       |

#### Returns

`boolean`

#### Defined in

[badges.ts:311](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L311)

---

### checkIfApprovedInTransferList

▸ **checkIfApprovedInTransferList**(`addresses`, `connectedUser`, `managerAccountNumber`): `boolean`

#### Parameters

| Name                   | Type                                                   |
| :--------------------- | :----------------------------------------------------- |
| `addresses`            | [`Addresses`](interfaces/Addresses.md)                 |
| `connectedUser`        | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md) |
| `managerAccountNumber` | `number`                                               |

#### Returns

`boolean`

#### Defined in

[badges.ts:130](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L130)

---

### checkIfIdRangesOverlap

▸ **checkIfIdRangesOverlap**(`idRanges`): `boolean`

#### Parameters

| Name       | Type                                 |
| :--------- | :----------------------------------- |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

`boolean`

#### Defined in

[idRanges.ts:301](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L301)

---

### convertToBitBadgesUserInfo

▸ **convertToBitBadgesUserInfo**(`accountInfo`): [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Parameters

| Name          | Type                                               |
| :------------ | :------------------------------------------------- |
| `accountInfo` | [`AccountResponse`](interfaces/AccountResponse.md) |

#### Returns

[`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Defined in

[users.ts:4](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/users.ts#L4)

---

### convertToBitBadgesAddress

▸ **convertToBitBadgesAddress**(`address`): `string`

#### Parameters

| Name      | Type     |
| :-------- | :------- |
| `address` | `string` |

#### Returns

`string`

#### Defined in

[chains.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L12)

---

### createCollectionFromMsgNewCollection

▸ **createCollectionFromMsgNewCollection**(`msgNewCollection`, `collectionMetadata`, `individualBadgeMetadata`, `connectedUser`, `claimItems`, `existingCollection?`): [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)

#### Parameters

| Name                      | Type                                                       |
| :------------------------ | :--------------------------------------------------------- |
| `msgNewCollection`        | `MessageMsgNewCollection`                                  |
| `collectionMetadata`      | [`BadgeMetadata`](interfaces/BadgeMetadata.md)             |
| `individualBadgeMetadata` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)       |
| `connectedUser`           | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)     |
| `claimItems`              | [`ClaimItemWithTrees`](interfaces/ClaimItemWithTrees.md)[] |
| `existingCollection?`     | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)   |

#### Returns

[`BitBadgeCollection`](interfaces/BitBadgeCollection.md)

#### Defined in

[badges.ts:29](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L29)

---

### doesChainMatchName

▸ **doesChainMatchName**(`chain`, `name?`): `boolean`

#### Parameters

| Name    | Type                                        |
| :------ | :------------------------------------------ |
| `chain` | [`SupportedChain`](enums/SupportedChain.md) |
| `name?` | `string`                                    |

#### Returns

`boolean`

#### Defined in

[chains.ts:87](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L87)

---

### filterTokenActivityForBadgeId

▸ **filterTokenActivityForBadgeId**(`badgeId`, `activity`): [`TransferActivityItem`](interfaces/TransferActivityItem.md)[]

#### Parameters

| Name       | Type                                                           |
| :--------- | :------------------------------------------------------------- |
| `badgeId`  | `number`                                                       |
| `activity` | [`TransferActivityItem`](interfaces/TransferActivityItem.md)[] |

#### Returns

[`TransferActivityItem`](interfaces/TransferActivityItem.md)[]

#### Defined in

[badges.ts:10](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L10)

---

### getAbbreviatedAddress

▸ **getAbbreviatedAddress**(`address`): `string`

#### Parameters

| Name      | Type     |
| :-------- | :------- |
| `address` | `string` |

#### Returns

`string`

#### Defined in

[chains.ts:46](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L46)

---

### getBadgeIdsToDisplayForPageNumber

▸ **getBadgeIdsToDisplayForPageNumber**(`collections?`, `startIdxNum`, `pageSize`): { `badgeIds`: `number`[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) }[]

#### Parameters

| Name          | Type                                                                                                                            | Default value |
| :------------ | :------------------------------------------------------------------------------------------------------------------------------ | :------------ |
| `collections` | { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) }[] | `[]`          |
| `startIdxNum` | `number`                                                                                                                        | `undefined`   |
| `pageSize`    | `number`                                                                                                                        | `undefined`   |

#### Returns

{ `badgeIds`: `number`[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) }[]

#### Defined in

[badges.ts:197](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L197)

---

### getBalanceAfterTransfer

▸ **getBalanceAfterTransfer**(`balance`, `startSubbadgeId`, `endSubbadgeId`, `amountToTransfer`, `numRecipients`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name               | Type                                       |
| :----------------- | :----------------------------------------- |
| `balance`          | [`UserBalance`](interfaces/UserBalance.md) |
| `startSubbadgeId`  | `number`                                   |
| `endSubbadgeId`    | `number`                                   |
| `amountToTransfer` | `number`                                   |
| `numRecipients`    | `number`                                   |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L14)

---

### getBalanceAfterTransfers

▸ **getBalanceAfterTransfers**(`balance`, `transfers`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name        | Type                                                     |
| :---------- | :------------------------------------------------------- |
| `balance`   | [`UserBalance`](interfaces/UserBalance.md)               |
| `transfers` | [`TransfersExtended`](interfaces/TransfersExtended.md)[] |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:21](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L21)

---

### getBlankBalance

▸ **getBlankBalance**(): [`UserBalance`](interfaces/UserBalance.md)

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L5)

---

### getChainForAddress

▸ **getChainForAddress**(`address`): `SupportedChain`

#### Parameters

| Name      | Type     |
| :-------- | :------- |
| `address` | `string` |

#### Returns

`SupportedChain`

#### Defined in

[chains.ts:26](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L26)

---

### getClaimsFromClaimItems

▸ **getClaimsFromClaimItems**(`balance`, `claimItems`): `Object`

#### Parameters

| Name         | Type                                                       |
| :----------- | :--------------------------------------------------------- |
| `balance`    | [`UserBalance`](interfaces/UserBalance.md)                 |
| `claimItems` | [`ClaimItemWithTrees`](interfaces/ClaimItemWithTrees.md)[] |

#### Returns

`Object`

| Name                   | Type                               |
| :--------------------- | :--------------------------------- |
| `claims`               | [`Claims`](interfaces/Claims.md)[] |
| `undistributedBalance` | `any`                              |

#### Defined in

[claims.ts:63](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/claims.ts#L63)

---

### getIdRangesForAllBadgeIdsInCollection

▸ **getIdRangesForAllBadgeIdsInCollection**(`collection`): `any`

#### Parameters

| Name         | Type                                                     |
| :----------- | :------------------------------------------------------- |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`any`

#### Defined in

[badges.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L20)

---

### getMatchingAddressesFromTransferList

▸ **getMatchingAddressesFromTransferList**(`list`, `toAddresses`, `chain`, `managerAccountNumber`): `any`[]

#### Parameters

| Name                   | Type                                                     |
| :--------------------- | :------------------------------------------------------- |
| `list`                 | [`TransferList`](interfaces/TransferList.md)[]           |
| `toAddresses`          | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)[] |
| `chain`                | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)   |
| `managerAccountNumber` | `number`                                                 |

#### Returns

`any`[]

#### Defined in

[badges.ts:153](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L153)

---

### getMaxBatchId

▸ **getMaxBatchId**(`collection`): `number`

#### Parameters

| Name         | Type                                                     |
| :----------- | :------------------------------------------------------- |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`number`

#### Defined in

[badges.ts:245](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L245)

---

### getMetadataForBadgeId

▸ **getMetadataForBadgeId**(`badgeId`, `metadataMap`): `undefined` \| [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Parameters

| Name          | Type                                                 |
| :------------ | :--------------------------------------------------- |
| `badgeId`     | `number`                                             |
| `metadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |

#### Returns

`undefined` \| [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[badges.ts:183](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L183)

---

### getMetadataMapObjForBadgeId

▸ **getMetadataMapObjForBadgeId**(`badgeId`, `metadataMap`): `undefined` \| { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `metadata`: [`BadgeMetadata`](interfaces/BadgeMetadata.md) ; `uri`: `string` }

#### Parameters

| Name          | Type                                                 |
| :------------ | :--------------------------------------------------- |
| `badgeId`     | `number`                                             |
| `metadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |

#### Returns

`undefined` \| { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `metadata`: [`BadgeMetadata`](interfaces/BadgeMetadata.md) ; `uri`: `string` }

#### Defined in

[badges.ts:170](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L170)

---

### getNonTransferableDisallowedTransfers

▸ **getNonTransferableDisallowedTransfers**(): `any`[]

#### Returns

`any`[]

#### Defined in

[badges.ts:105](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L105)

---

### getSupplyByBadgeId

▸ **getSupplyByBadgeId**(`badgeId`, `balances`): `number`

#### Parameters

| Name       | Type                                 |
| :--------- | :----------------------------------- |
| `badgeId`  | `number`                             |
| `balances` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

`number`

#### Defined in

[balances.ts:48](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L48)

---

### getTransferListForSelectOptions

▸ **getTransferListForSelectOptions**(`isFromList`, `unregistered`, `users`, `all`, `none`, `everyoneExcept`): `undefined` \| [`TransferListWithUnregisteredUsers`](interfaces/TransferListWithUnregisteredUsers.md)

#### Parameters

| Name             | Type                                                     |
| :--------------- | :------------------------------------------------------- |
| `isFromList`     | `boolean`                                                |
| `unregistered`   | `string`[]                                               |
| `users`          | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)[] |
| `all`            | `boolean`                                                |
| `none`           | `boolean`                                                |
| `everyoneExcept` | `boolean`                                                |

#### Returns

`undefined` \| [`TransferListWithUnregisteredUsers`](interfaces/TransferListWithUnregisteredUsers.md)

#### Defined in

[transferLists.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L36)

---

### getTransfersFromClaimItems

▸ **getTransfersFromClaimItems**(`claimItems`, `accounts`): [`TransfersExtended`](interfaces/TransfersExtended.md)[]

#### Parameters

| Name         | Type                                     |
| :----------- | :--------------------------------------- |
| `claimItems` | [`ClaimItem`](interfaces/ClaimItem.md)[] |
| `accounts`   | [`AccountMap`](interfaces/AccountMap.md) |

#### Returns

[`TransfersExtended`](interfaces/TransfersExtended.md)[]

#### Defined in

[claims.ts:6](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/claims.ts#L6)

---

### isAddressValid

▸ **isAddressValid**(`address`, `chain?`): `boolean`

#### Parameters

| Name      | Type     |
| :-------- | :------- |
| `address` | `string` |
| `chain?`  | `string` |

#### Returns

`boolean`

#### Defined in

[chains.ts:55](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L55)

---

### isTransferListFull

▸ **isTransferListFull**(`transfersList`): `boolean`

#### Parameters

| Name            | Type                                           |
| :-------------- | :--------------------------------------------- |
| `transfersList` | [`TransferList`](interfaces/TransferList.md)[] |

#### Returns

`boolean`

#### Defined in

[transferLists.ts:27](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L27)

---

### populateFieldsOfOtherBadges

▸ **populateFieldsOfOtherBadges**(`individualBadgeMetadata`, `badgeIds`, `key`, `value`, `metadataToSet?`): [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Parameters

| Name                      | Type                                                 |
| :------------------------ | :--------------------------------------------------- |
| `individualBadgeMetadata` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `badgeIds`                | [`IdRange`](interfaces/IdRange.md)[]                 |
| `key`                     | `string`                                             |
| `value`                   | `any`                                                |
| `metadataToSet?`          | [`BadgeMetadata`](interfaces/BadgeMetadata.md)       |

#### Returns

[`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Defined in

[metadata.ts:61](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/metadata.ts#L61)

---

### updateMetadataForBadgeIdsFromIndexerIfAbsent

▸ **updateMetadataForBadgeIdsFromIndexerIfAbsent**(`badgeIdsToDisplay`, `collection`): `number`[]

#### Parameters

| Name                | Type                                                     |
| :------------------ | :------------------------------------------------------- |
| `badgeIdsToDisplay` | `number`[]                                               |
| `collection`        | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`number`[]

#### Defined in

[badges.ts:264](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L264)

---

### updateMetadataMap

▸ **updateMetadataMap**(`currMetadataMap`, `metadata`, `badgeIds`, `uri`): [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Parameters

| Name              | Type                                                 |
| :---------------- | :--------------------------------------------------- |
| `currMetadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `metadata`        | [`BadgeMetadata`](interfaces/BadgeMetadata.md)       |
| `badgeIds`        | [`IdRange`](interfaces/IdRange.md)                   |
| `uri`             | `string`                                             |

#### Returns

[`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Defined in

[metadata.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/metadata.ts#L5)

---

### updateTransferListAccountNums

▸ **updateTransferListAccountNums**(`accountNumber`, `remove`, `transferListAddresses`): [`Addresses`](interfaces/Addresses.md)

#### Parameters

| Name                    | Type                                   |
| :---------------------- | :------------------------------------- |
| `accountNumber`         | `number`                               |
| `remove`                | `boolean`                              |
| `transferListAddresses` | [`Addresses`](interfaces/Addresses.md) |

#### Returns

[`Addresses`](interfaces/Addresses.md)

#### Defined in

[transferLists.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L5)


## File: ./.gitbook/includes/untitled.md

---
title: Untitled
---

{% file src="../assets/badge_logo.png" %}


## File: ./README.md

---
description: >-
  Here, you will find documentation about BitBadges, how it works, how to
  interact, and how to contribute!
---

# 👋 BitBadges Overview

## 🚀 The Next-Generation Token Standard

BitBadges offers tokenization-as-a-service and gating-as-a-service. We are building the best tokenization standard out there because current standards are simply not good enough. Our revolutionary token standard goes far beyond ERC-20, ERC-721, and other existing standards with features like time-dependent ownership, fine-grained transferability controls, multi-chain compatibility, connecting to 7000+ apps, connecting to EVM, IBC, CosmWASM, and more. All implemented as a Cosmos module.

<div data-full-width="false"><figure><img src=".gitbook/assets/image (8) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure></div>

## ❓ Why BitBadges?

Traditional token standards are limited, inflexible, and locked to single blockchain ecosystems. BitBadges fixes this with a 100x improvement that supports:

* **Multi-Chain Compatibility** - Users from ANY blockchain can own and transfer the SAME tokens. One interface, one token experience for all blockchain ecosystems.
* **Time-Dependent Ownership** - Create subscriptions, time-locked tokens, and expiring credentials
* **Advanced Transferability** - Fine-grained controls over who can transfer what, when, and how on any level
* **No Code by Default, No Smart Contracts Required** - Everything works out-of-the-box with no code
* **Connect to 7000+ Apps** - Connect to 7000+ apps and integrations with seamless on/off-chain criteria checks
* **Connect to Cosmos via IBC** - Connect to Cosmos and beyond via IBC and use the BitBadges token standard on any Cosmos chain
* **Extend with CosmWASM or EVM Contracts** - Extend the BitBadges token standard with CosmWASM or EVM contracts
* **Customizable Permissions** - Flexible manager controls for collections

## 🛠️ Supporting Services

We also offer complementary services:

* **Sign In with BitBadges** - Universal, outsource multi-chain authentication
* **Claims** - Check criteria and deliver rewards in no-code off-chain from 7000+ apps and integrations
* **Address Lists** - Manage users across multiple blockchains

## 🔍 How BitBadges Works

BitBadges is simply tokenization-as-a-service. Create anything from subscriptions and memberships to tradable NFTs, credentials, and access tokens - all with the most advanced token standard ever built.

## 🤔 Motive for building BitBadges?

The answer is simple. We believe in the potential of blockchains and a multi-chain world, but this potential cannot be realized with the current infrastructure and token standards in place today.

## 🤖 Tokens vs Badges?

BitBadges uses the terms tokens and badges interchangeably. You will often see us refer to badges throughout this documentation. This means tokens.


## File: ./SUMMARY.md

# Table of contents

## Overview

* [👋 BitBadges Overview](README.md)
* [🎨 Use Cases](overview/use-cases.md)
* [🪙 BADGE](overview/badge.md)
* [🔗 Official Links and Resources](overview/official-links.md)
* [🤝 Brand Guidelines](overview/link-sharing.md)

## ⌨️ For Developers

* [🔨 Getting Started](for-developers/getting-started.md)
* [📚 BitBadges API](for-developers/bitbadges-api/README.md)
  * [Getting Started](for-developers/bitbadges-api/api.md)
  * [Standard API Reference](https://bitbadges.stoplight.io/docs/bitbadges)
  * [Blockchain API Reference](https://lcd.bitbadges.io/)
  * [Typed SDK Types](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html)
  * [Upgrading an API Key Tier](for-developers/bitbadges-api/upgrading-an-api-key-tier.md)
  * [Concepts](for-developers/bitbadges-api/concepts/README.md)
    * [Native Chain Algorithm](for-developers/bitbadges-api/concepts/native-chain-algorithm.md)
    * [Refresh / Claim Completion Queue](for-developers/bitbadges-api/concepts/refresh-queue.md)
    * [Limits / Restrictions](for-developers/bitbadges-api/concepts/limits-restrictions.md)
    * [Managing Views](for-developers/bitbadges-api/concepts/managing-views.md)
  * [Sign In with BitBadges (OAuth)](for-developers/sign-in-with-bitbadges/README.md)
    * [Overview](for-developers/sign-in-with-bitbadges/overview.md)
    * [Templates and Frameworks](for-developers/sign-in-with-bitbadges/templates-and-frameworks/README.md)
      * [WordPress](for-developers/sign-in-with-bitbadges/templates-and-frameworks/wordpress.md)
      * [Auth0](for-developers/sign-in-with-bitbadges/templates-and-frameworks/auth0.md)
      * [ExpressJS](for-developers/sign-in-with-bitbadges/templates-and-frameworks/expressjs.md)
      * [Discourse](for-developers/sign-in-with-bitbadges/templates-and-frameworks/discourse.md)
      * [Supabase](for-developers/sign-in-with-bitbadges/templates-and-frameworks/supabase.md)
      * [Others](for-developers/sign-in-with-bitbadges/templates-and-frameworks/others.md)
    * [Setting Up an App](for-developers/sign-in-with-bitbadges/setting-up-an-app.md)
    * [Authorization URL](for-developers/sign-in-with-bitbadges/authorization-url/README.md)
      * [Configuration](for-developers/sign-in-with-bitbadges/authorization-url/configuration.md)
      * [Generating the URL](for-developers/sign-in-with-bitbadges/authorization-url/generating-the-url.md)
    * [Redirect Callback](for-developers/sign-in-with-bitbadges/approaches/redirected-callback.md)
    * [Verification](for-developers/sign-in-with-bitbadges/verification/README.md)
      * [Verification Flow](for-developers/sign-in-with-bitbadges/verification/verification-flow.md)
      * [Access Tokens](for-developers/sign-in-with-bitbadges/verification/access-tokens.md)
      * [Security Considerations](for-developers/sign-in-with-bitbadges/verification/security-considerations.md)
    * [Blockin Docs](https://blockin.gitbook.io/blockin)
* [⚒️ BitBadges JS / SDK](for-developers/bitbadges-sdk/README.md)
  * [Overview](for-developers/bitbadges-sdk/overview.md)
  * [SDK Types](for-developers/bitbadges-sdk/sdk-types.md)
  * [Common Snippets](for-developers/bitbadges-sdk/common-snippets/README.md)
    * [Address Conversions](for-developers/bitbadges-sdk/common-snippets/address-conversions.md)
    * [NumberType Conversions](for-developers/bitbadges-sdk/common-snippets/numbertype-conversions.md)
    * [Uint Ranges](for-developers/bitbadges-sdk/common-snippets/uint-ranges.md)
    * [Balances](for-developers/bitbadges-sdk/common-snippets/balances.md)
    * [Transfers](for-developers/bitbadges-sdk/common-snippets/transfers-w-increments.md)
    * [Address Lists](for-developers/bitbadges-sdk/common-snippets/address-lists.md)
    * [Token Metadata](for-developers/bitbadges-sdk/common-snippets/badge-metadata.md)
    * [Approvals / Transferability](for-developers/bitbadges-sdk/common-snippets/get-unhandled-approvals.md)
    * [Timelines](for-developers/bitbadges-sdk/common-snippets/timelines.md)
  * [Create, Generate, and Sign Txs](for-developers/bitbadges-blockchain/create-and-broadcast-txs/README.md)
* [⛓️ BitBadges Blockchain](for-developers/bitbadges-blockchain/README.md)
  * [Overview](for-developers/bitbadges-blockchain/overview.md)
  * [BitBadges Explorer](https://explorer.bitbadges.io/)
  * [Registry Details](https://github.com/cosmos/chain-registry/tree/master/bitbadges)
  * [Supported IBC Connections](https://github.com/cosmos/chain-registry/tree/master/_IBC)
  * [Supported Denoms](for-developers/bitbadges-blockchain/supported-denoms.md)
  * [Staking / Validators](for-developers/bitbadges-blockchain/staking-usdbadge.md)
  * [Accounts (Technical)](for-developers/bitbadges-blockchain/accounts-technical.md)
  * [Create a WASM Contract](for-developers/bitbadges-blockchain/create-a-wasm-contract.md)
  * [Run a Mainnet Node](for-developers/bitbadges-blockchain/run-a-mainnet-node.md)
  * [Create, Generate, and Sign Txs](for-developers/bitbadges-blockchain/create-and-broadcast-txs/README.md)
    * [AI Prompt: Signing Txs](for-developers/bitbadges-x-ai/prompts/signing-a-transaction.md)
    * [Transaction Context](for-developers/bitbadges-blockchain/create-and-broadcast-txs/transaction-context.md)
    * [Generate Msg Contents](for-developers/bitbadges-blockchain/create-and-broadcast-txs/generate-msg-contents.md)
    * [Signing - Cosmos](for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-cosmos.md)
    * [Signing - Ethereum](for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-ethereum.md)
    * [Signing - Solana](for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-solana.md)
    * [Signing - Bitcoin](for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-bitcoin.md)
    * [Broadcast to a Node](for-developers/bitbadges-blockchain/create-and-broadcast-txs/broadcast-to-a-node.md)
    * [Sign + Broadcast - bitbadges.io](for-developers/bitbadges-blockchain/create-and-broadcast-txs/sign-+-broadcast-bitbadges.io.md)
  * [Cosmos SDK Msgs](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/README.md)
    * [x/badges](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges.md)
    * [x/wasmx](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/README.md)
      * [MsgStoreCodeCompat](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msgstorecodecompat.md)
      * [MsgInstantiateContractCompat](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msginstantiatecontractcompat.md)
      * [MsgExecuteContractCompat](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msgexecutecontractcompat.md)
    * [x/maps](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/README.md)
      * [MsgCreateMap](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgcreateprotocol.md)
      * [MsgUpdateMap](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgupdateprotocol.md)
      * [MsgDeleteMap](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgdeleteprotocol.md)
      * [MsgSetValue](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgsetcollectionforprotocol.md)
    * [MsgSend](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/msgsend.md)
    * [Cosmos Native Msgs](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/cosmos-native-msgs.md)
  * [Testnet Mode](for-developers/bitbadges-blockchain/testnet-mode.md)
* [🎁 BitBadges Claims](overview/claim-builder/README.md)
  * [Overview](for-developers/claim-builder/overview.md)
  * [Concepts](for-developers/claim-builder/concepts/README.md)
    * [Standard vs On-Demand](for-developers/claim-builder/concepts/standard-vs-on-demand.md)
    * [Completion Methods](for-developers/claim-builder/completion-methods.md)
    * [Gating On-Chain Approvals](for-developers/claim-builder/concepts/gating-badge-distribution.md)
    * [Claim Numbers](for-developers/claim-builder/concepts/claim-numbers.md)
    * [Success Logic](for-developers/claim-builder/success-logic.md)
    * [Signed In vs Select Address](for-developers/claim-builder/concepts/signed-in-vs-select-address.md)
    * [Universal Approach - Claim Codes](for-developers/claim-builder/concepts/universal-approach-claim-codes.md)
    * [Identify By Socials / Emails?](for-developers/claim-builder/concepts/identify-by-socials-emails.md)
  * [Checking Custom Criteria](for-developers/claim-builder/checking-custom-criteria.md)
  * [Implementing Custom Utility](for-developers/claim-builder/implementing-custom-utility.md)
  * [Leveraging AI](for-developers/claim-builder/leveraging-ai.md)
  * [BitBadges API & Claims](for-developers/claim-builder/bitbadges-api-claims/README.md)
    * [Verifying Claim Attempts w/ the API](for-developers/claim-builder/bitbadges-api-claims/verifying-claim-attempts-w-the-api.md)
    * [Fetching Claims](for-developers/claim-builder/bitbadges-api-claims/fetching-claims.md)
    * [Auto-Complete Claims w/ BitBadges API](for-developers/claim-builder/bitbadges-api-claims/auto-complete-claims-w-bitbadges-api.md)
  * [Dynamic Stores](for-developers/claim-builder/dynamic-stores/README.md)
    * [Overview](for-developers/claim-builder/dynamic-stores/overview.md)
    * [Adding Data](for-developers/claim-builder/dynamic-stores/adding-data.md)
  * [Custom Plugins / Webhooks](for-developers/claim-builder/plugins/README.md)
    * [Overview](for-developers/claim-builder/plugins/overview.md)
    * [Pre-Built Webhook Plugins](for-developers/claim-builder/plugins/creating-a-custom-plugin/alternatives.md)
    * [Creating a Custom Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/README.md)
      * [Implement Your Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/README.md)
        * [Getting Started](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/getting-started.md)
        * [Hook Types and Simulations](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/hook-types-and-simulations.md)
        * [Design Considerations](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/design-considerations.md)
        * [Parameters](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/parameters.md)
        * [Custom Inputs](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/user-inputs.md)
        * [API Handler](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/api-handler.md)
      * [Managing Your Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/managing-your-plugin.md)
      * [Testing Your Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/testing-your-plugin.md)
    * [Configuration Tools](for-developers/claim-builder/plugins/configuration-tools.md)
  * [Integrate with Zapier](for-developers/claim-builder/auto-completing-claims/automate-w-zapier/README.md)
    * [Overview](for-developers/claim-builder/auto-completing-claims/automate-w-zapier/overview.md)
    * [Dynamic Store Zaps](for-developers/claim-builder/automate-w-zapier/dynamic-store-zaps.md)
    * [Automatic Claim Tutorial](for-developers/claim-builder/auto-completing-claims/automate-w-zapier/automatic-claim-tutorial.md)
    * [Post-Success Zaps](for-developers/claim-builder/automate-w-zapier/post-success-zaps.md)
    * [Leveraging Zapier AI Actions / MCP](for-developers/claim-builder/automate-w-zapier/leveraging-zapier-ai-actions-mcp.md)
    * [Automate Any Part of the Process](for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/README.md)
      * [Google Forms](for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/google-forms.md)
  * [Integrate with Pipedream](for-developers/claim-builder/integrate-with-pipedream/README.md)
    * [Overview](for-developers/claim-builder/integrate-with-pipedream/overview.md)
    * [Leveraging Pipedream MCP](for-developers/claim-builder/integrate-with-pipedream/leveraging-pipedream-mcp.md)
    * [Build Custom Plugins](for-developers/claim-builder/integrate-with-pipedream/build-custom-plugins.md)
    * [Workflow Actions](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/README.md)
      * [Complete Claim](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/complete-claim.md)
      * [Get Claim Attempt Status](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-attempt-status.md)
      * [Get Claim Code by Idx](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-code-by-idx.md)
      * [Add User to Dynamic Store](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/add-user-to-dynamic-store.md)
    * [Workflow Triggers](for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/README.md)
      * [Poll Claim Attempts](for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/poll-claim-attempts.md)
    * [End to End Example](for-developers/claim-builder/integrate-with-pipedream/end-to-end-example.md)
  * [In-Site Plugins](for-developers/claim-builder/bitbadges-created-plugins/README.md)
    * [Plugins Directory](https://bitbadges.io/plugin-directory)
    * [Ownership Requirements](for-developers/claim-builder/bitbadges-created-plugins/ownership-requirements.md)
  * [Tutorials](for-developers/claim-builder/other-tutorials/README.md)
    * [In-Site Guides](for-developers/claim-builder/other-tutorials/in-site-guides.md)
    * [Get Integration User IDs](for-developers/claim-builder/other-tutorials/get-integration-user-ids/README.md)
      * [Get Discord User ID](for-developers/claim-builder/other-tutorials/get-integration-user-ids/get-discord-user-id.md)
      * [Get Discord Server ID](for-developers/claim-builder/other-tutorials/get-integration-user-ids/discord.md)
      * [X / Twitch / GitHub IDs](for-developers/claim-builder/other-tutorials/get-integration-user-ids/x-twitch-github-ids.md)
    * [Add Telegram Bot to Channel](for-developers/claim-builder/other-tutorials/add-telegram-bot-to-channel.md)
* [🪄 BitBadges x AI](for-developers/bitbadges-x-ai/README.md)
  * [Prompts](for-developers/bitbadges-x-ai/prompts/README.md)
    * [Collection Approval Builder](for-developers/bitbadges-x-ai/prompts/collection-approval-builder.md)
    * [Documentation Parsing and Context Setup](for-developers/bitbadges-x-ai/prompts/documentation-parsing.md)
    * [SDK Setup and Usage Guide](for-developers/bitbadges-x-ai/prompts/sdk-setup-and-usage.md)

## 🏗️ Token Standard

* [📚 Overview](x-badges/README.md)
* [📔 Pre-Readings](token-standard/pre-readings.md)
* [🪄 The BitBadges Standard](overview/what-is-bitbadges.md)
* [👤 Multi-Chain Accounts](for-developers/accounts.md)
* [🧠 Concepts](x-badges/concepts/README.md)
  * [Address Lists](x-badges/concepts/address-lists.md)
  * [Archived Collections](x-badges/concepts/archived-collections.md)
  * [Collections](x-badges/concepts/badge-collections.md)
  * [Balance System](x-badges/concepts/balance-system.md)
  * [Collection Invariants](x-badges/concepts/collection-invariants.md)
  * [Cosmos Wrapper Paths](x-badges/concepts/cosmos-wrapper-paths.md)
  * [Custom Data](x-badges/concepts/custom-data.md)
  * [Default Balances](x-badges/concepts/default-balances.md)
  * [Manager](x-badges/concepts/manager.md)
  * [Metadata](x-badges/concepts/metadata.md)
  * [Mint Escrow Address](x-badges/concepts/mint-escrow-address.md)
  * [Standards](x-badges/concepts/standards.md)
  * [Different Time Fields](x-badges/concepts/time-fields.md)
  * [Timeline System](x-badges/concepts/timeline-system.md)
  * [Total Supply](x-badges/concepts/total-supply.md)
  * [Transferability & Approvals](x-badges/concepts/transferability-approvals.md)
  * [UintRanges](x-badges/concepts/uintrange.md)
  * [Valid Token IDs](x-badges/concepts/valid-badge-ids.md)
  * [Approval Criteria](x-badges/concepts/approval-criteria/README.md)
    * [Approval Trackers](x-badges/concepts/approval-criteria/approval-trackers.md)
    * [Auto-Deletion Options](x-badges/concepts/approval-criteria/auto-deletion-options.md)
    * [Token Ownership](x-badges/concepts/approval-criteria/badge-ownership.md)
    * [Dynamic Store Challenges](x-badges/concepts/approval-criteria/dynamic-store-challenges.md)
    * [ETH Signature Challenges](x-badges/concepts/approval-criteria/eth-signature-challenges.md)
    * [Extending Approvals (Advanced)](x-badges/concepts/approval-criteria/linking-trackers-advanced.md)
    * [Max Number of Transfers](x-badges/concepts/approval-criteria/max-number-of-transfers.md)
    * [Merkle Challenges](x-badges/concepts/approval-criteria/merkle-challenges.md)
    * [Override User Level Approvals](x-badges/concepts/approval-criteria/overrides.md)
    * [Predetermined Balances](x-badges/concepts/approval-criteria/predetermined-balances.md)
    * [Requires](x-badges/concepts/approval-criteria/requires.md)
    * [Tallied Approval Amounts](x-badges/concepts/approval-criteria/tallied-approval-amounts.md)
    * [Coin Transfers](x-badges/concepts/approval-criteria/usdbadge-transfers.md)
    * [User Royalties](x-badges/concepts/approval-criteria/user-royalties.md)
  * [Permissions](x-badges/concepts/permissions/README.md)
    * [Overview](x-badges/concepts/permissions/overview.md)
    * [Action Permissions](x-badges/concepts/permissions/action-permissions.md)
    * [Approval Permissions](x-badges/concepts/permissions/approval-permissions.md)
    * [Token ID Action Permissions](x-badges/concepts/permissions/badge-id-permissions.md)
    * [Timeline Permissions](x-badges/concepts/permissions/timeline-permissions.md)
  * [Protocols](x-badges/concepts/protocols/README.md)
    * [Quest Protocol](x-badges/concepts/protocols/quest-protocol.md)
    * [Subscriptions Protocol](x-badges/concepts/protocols/subscriptions-protocol.md)
    * [Tradable Protocol](x-badges/concepts/protocols/tradable-protocol.md)
* [📨 Messages](x-badges/messages/README.md)
  * [MsgCreateAddressLists](x-badges/messages/msg-create-address-lists.md)
  * [MsgCreateCollection](x-badges/messages/msg-create-collection.md)
  * [MsgCreateDynamicStore](x-badges/messages/msg-create-dynamic-store.md)
  * [MsgDecrementStoreValue](x-badges/messages/msg-decrement-store-value.md)
  * [MsgDeleteCollection](x-badges/messages/msg-delete-collection.md)
  * [MsgDeleteDynamicStore](x-badges/messages/msg-delete-dynamic-store.md)
  * [MsgDeleteIncomingApproval](x-badges/messages/msg-delete-incoming-approval.md)
  * [MsgDeleteOutgoingApproval](x-badges/messages/msg-delete-outgoing-approval.md)
  * [MsgIncrementStoreValue](x-badges/messages/msg-increment-store-value.md)
  * [MsgPurgeApprovals](x-badges/messages/msg-purge-approvals.md)
  * [MsgSetBadgeMetadata](x-badges/messages/msg-set-badge-metadata.md)
  * [MsgSetCollectionApprovals](x-badges/messages/msg-set-collection-approvals.md)
  * [MsgSetCollectionMetadata](x-badges/messages/msg-set-collection-metadata.md)
  * [MsgSetCustomData](x-badges/messages/msg-set-custom-data.md)
  * [MsgSetDynamicStoreValue](x-badges/messages/msg-set-dynamic-store-value.md)
  * [MsgSetIncomingApproval](x-badges/messages/msg-set-incoming-approval.md)
  * [MsgSetIsArchived](x-badges/messages/msg-set-is-archived.md)
  * [MsgSetManager](x-badges/messages/msg-set-manager.md)
  * [MsgSetOutgoingApproval](x-badges/messages/msg-set-outgoing-approval.md)
  * [MsgSetStandards](x-badges/messages/msg-set-standards.md)
  * [MsgSetValidBadgeIds](x-badges/messages/msg-set-valid-badge-ids.md)
  * [MsgTransferBadges](x-badges/messages/msg-transfer-badges.md)
  * [MsgUniversalUpdateCollection](x-badges/messages/msg-universal-update-collection.md)
  * [MsgUpdateCollection](x-badges/messages/msg-update-collection.md)
  * [MsgUpdateDynamicStore](x-badges/messages/msg-update-dynamic-store.md)
  * [MsgUpdateUserApprovals](x-badges/messages/msg-update-user-approvals.md)
* [🔍 Queries](x-badges/queries/README.md)
  * [Node API](https://lcd.bitbadges.io/)
  * [GetAddressList](x-badges/queries/get-address-list.md)
  * [GetApprovalTracker](x-badges/queries/get-approval-tracker.md)
  * [GetBalance](x-badges/queries/get-balance.md)
  * [GetChallengeTracker](x-badges/queries/get-challenge-tracker.md)
  * [GetCollection](x-badges/queries/get-collection.md)
  * [GetDynamicStore](x-badges/queries/get-dynamic-store.md)
  * [GetDynamicStoreValue](x-badges/queries/get-dynamic-store-value.md)
  * [GetETHSignatureTracker](x-badges/queries/get-eth-signature-tracker.md)
  * [Params](x-badges/queries/params.md)
* [⌨️ Type Definitions](token-standard/type-definitions/README.md)
  * [Address Lists](token-standard/type-definitions/address-lists.md)
  * [Balances](token-standard/type-definitions/balances.md)
  * [Core Collection](token-standard/type-definitions/core-collection.md)
  * [Dynamic Stores](token-standard/type-definitions/dynamic-stores.md)
  * [Metadata](token-standard/type-definitions/metadata.md)
  * [Permissions](token-standard/type-definitions/permissions.md)
  * [Timelines](token-standard/type-definitions/timelines.md)
  * [Transfers](token-standard/type-definitions/transfers.md)
* [💡 Examples and Snippets](x-badges/examples/README.md)
  * [Base Collection Details](x-badges/examples/base-collection-details.md)
  * [Building Your Collection Approvals](x-badges/examples/building-collection-approvals.md)
  * [Building Your Collection Permissions](x-badges/examples/building-collection-permissions.md)
  * [Building User-Level Approvals](x-badges/examples/building-user-approvals.md)
  * [Building User-Level Permissions](x-badges/examples/building-user-permissions.md)
  * [Cosmos Coin Wrapper Tutorial](x-badges/examples/cosmos-coin-wrapper-example.md)
  * [Defining and Locking Circulating Supply](x-badges/examples/defining-circulating-supply.md)
  * [Empty Approval Criteria Template](x-badges/examples/empty-approval-criteria.md)
  * [Mint All Tokens to Self - Tutorial](x-badges/examples/mint-all-to-self-tutorial.md)
  * [Approvals](token-standard/examples/approvals/README.md)
    * [Admin Override Approval](x-badges/examples/approvals/admin-override-approval.md)
    * [Burnable Approval](x-badges/examples/approvals/burnable-approval.md)
    * [Cosmos Unwrapper Approval](x-badges/examples/approvals/cosmos-unwrapper-approval.md)
    * [Cosmos Wrapper Approval](x-badges/examples/approvals/cosmos-wrapper-approval.md)
    * [Transferable Approval](x-badges/examples/approvals/transferable-approval.md)
  * [Message Transfer Examples](x-badges/examples/msg-transfer/README.md)
    * [Simple Token Transfer](x-badges/examples/msg-transfer/simple-badge-transfer.md)
    * [Transfer with Precalculation](x-badges/examples/msg-transfer/transfer-with-precalculation.md)
  * [Permission Examples](x-badges/examples/permissions/README.md)
    * [Freezing Mint Transferability](x-badges/examples/permissions/freezing-mint-transferability.md)
    * [Locking Specific Approval ID](x-badges/examples/permissions/locking-specific-approval-id.md)
    * [Locking Specific Token IDs](x-badges/examples/permissions/locking-specific-badge-ids.md)
    * [Locking Valid Token IDs](x-badges/examples/permissions/locking-valid-badge-ids.md)
  * [Transaction Examples](x-badges/examples/txs/README.md)
    * [MsgCreateCollection Examples](x-badges/examples/txs/msgcreatecollection/README.md)
      * [Quest Token Collection Example](x-badges/examples/txs/msgcreatecollection/quest-badge-collection.md)
      * [Tradable Collection Example](x-badges/examples/txs/msgcreatecollection/tradable-nft-collection.md)
    * [MsgUpdateUserApprovals Examples](x-badges/examples/txs/msgupdate-user-approvals/README.md)
      * [Updating Outgoing Approvals](x-badges/examples/txs/msgupdate-user-approvals/updating-outgoing-approvals.md)
* [📡 Events](x-badges/events.md)
* [❓ FAQ](overview/faq.md)
* [⛓️ Integrate The Standard?](token-standard/integrate-the-standard.md)
* [🐙 Source Code](https://github.com/BitBadges/bitbadgeschain/tree/master/x/badges)

## x/gamm

* [📚 Overview](x-gamm/README.md)
* [📨 Messages](x-gamm/messages/README.md)
  * [MsgCreateBalancerPool](x-gamm/messages/msg-create-balancer-pool.md)
  * [MsgExitPool](x-gamm/messages/msg-exit-pool.md)
  * [MsgJoinPool](x-gamm/messages/msg-join-pool.md)
  * [MsgSwapExactAmountIn](x-gamm/messages/msg-swap-exact-amount-in.md)


## File: ./badge-standard/examples/approvals/README.md

# Approvals



## File: ./for-developers/accounts.md

# 👤 Multi-Chain Accounts

### **How is BitBadges able to support addresses from different blockchains?**

To enable interoperability between different blockchains, BitBadges is signature compatible with all of its supported chains (Bitcoin, Ethereum, Solana, and Cosmos).

Signature compatibility means that users from any of the above blockchain ecosystems are able to sign BitBadges transactions, and we simply verify the signatures on our blockchain.

BitBadges is compatible with the wallets of each ecosystem. However, BitBadges is its own blockchain and does not pull any data from or is interoperable with any other blockchain. Everything is confined to the BitBadges blockchain.

<figure><img src="../.gitbook/assets/image (34).png" alt=""><figcaption></figcaption></figure>

### **Why do I see multiple equivalent addresses?**

All addresses map to an equivalent one in a different ecosystem (see the image below). You may be used to seeing your address as an Ethereum address, but behind the scenes, your mapped BitBadges address may be used for record keeping.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### **Which chains / wallets are supported?**

Currently, we support Ethereum, Cosmos, Solana, Bitcoin.

### For Developers - Handling Addresses

It should be enough information for most, but for more low-level interaction, [this page](bitbadges-blockchain/accounts-technical.md) will give you more in-depth explanations.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Mapping to a Common Address (bitbadgesAddress)**

To enable interoperability between different blockchains, each individual L1 blockchain will have its native addresses mapped to an equivalent Cosmos (aka BitBadges) bech32 address. We use the mapped **bitbadgesAddress** as the universal base address whenever needed.

We try to be as accommodating of native addresses as possible, but there are many places where universal standardization is needed. You will often come across places in development where you need to specify a **bitbadgesAddress.** This is expected to be the mapped address and not the native address (thus, you will need to map first). The typical naming convention we use is **bitbadgesAddress** vs **address.**

The mappings should ONLY happen behind the scenes. On the user facing side, you should always display the user's native address.

Ethereum Example:

* Mapped BitBadges Address (Bech32): bb14au322k9munkmx5wrchz9q30juf5wjgz2cfqku
* Address (Native - [EIP55](https://eips.ethereum.org/EIPS/eip-55) Ethereum Hex): 0xAF79152AC5dF276D9A8e1E2E22822f9713474902

Solana Example:

* Address (Native - Base58): 6H2af68Yyg6j7N4XeQKmkZFocYQgv6yYoU3Xk491efa5
* Mapped BitBadges Address (Bech32): bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl

Bitcoin Example

* Address (Native - P2WPKH): bc1q9s7rynm5pwhluhecsmlku8rn5yej5wdgj0gv3e
* Mapped BitBadges Address (Bech32): bb19s7rynm5pwhluhecsmlku8rn5yej5wdg8g75f9

#### Why can I convert Solana address to a BitBadges / ETH / BTC address but not the other way around?

You may notice that you cannot go from a BitBadges / ETH / BTC address directly to a Solana address but you can the other way around. This is because conversion from a Solana address requires a hash, so if you just have the postimage of the hash (an ETH / BitBadges address), you cannot deduce the preimage without prior knowledge of it.

#### **How to convert?**

The mapped addresses can be converted behind the scenes using the converter functions from [BitBadges SDK](bitbadges-sdk/) (address-converter). This can be done with any validly formatted address.

<pre class="language-typescript"><code class="lang-typescript"><strong>import { convertToEthAddress, convertToBitBadgesAddress, mustConvertToBtcAddress } from 'bitbadgesjs-sdk';
</strong>
<strong>const bitbadgesAddress = convertToBitBadgesAddress(btcAddress);
</strong>const ethAddress = convertToEthAddress(bitbadgesAddress);
const bitbadgesAddressFromSolana = convertToBitBadgesAddress(solAddress);
const btcAddress = mustConvertToBtcAddress(address);

// Note there is no convertToSolanaAddress due to how the addresses work. See above
</code></pre>

**What is signature compatibility?**

To enable interoperability between different blockchains, BitBadges is signature compatible with all of the supported chains (Bitcoin, Ethereum, Solana, and Cosmos).

Signature compatibility means that we can verify transaction signatures from any wallet of any supported ecosystem. BitBadges is its own blockchain and does not pull any data from any other blockchain. Everything is confined to the BitBadges blockchain.

#### **How do I query details for an address?**

1. You can use the [BitBadges API](bitbadges-api/api.md) to get information about an address (recommended option). This is the recommended options because we have indexed all the data already for you.
2. You an also query a BitBadges blockchain node directly, either through the CLI or [REST API](https://docs.cosmos.network/v0.46/run-node/interact-node.html)


## File: ./for-developers/bitbadges-api/README.md

# 📚 Indexer / API



## File: ./for-developers/bitbadges-api/api.md

# Getting Started

## Getting Started - API Keys

By default, select routes are available publicly in a rate limited manner with no API key. However, API keys allow you access to all routes with higher limits.

1. Sign in on and create an API key by going to [https://bitbadges.io/developer](https://bitbadges.io/developer) -> API Keys tab.
2. Start sending requests to the base URL of [https://api.bitbadges.io/](https://api.bitbadges.io/) with the HTTP header x-api-key. All routes require an API key.
3. For higher tiers / paid plans, visit [https://bitbadges.io/pricing](https://bitbadges.io/pricing). To actually upgrade, see the Upgrading an API Key Tier demo.

<figure><img src="../../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

## Number Types

Note: Numbers are stringified in responses to avoid precision loss. You will have to convert them to your desired type (preferably bigint). The SDK does this for you if you use it.

## References

* [Main](https://bitbadges.stoplight.io/docs/bitbadges)
* [OpenAPI](https://github.com/BitBadges/bitbadgesjs/blob/main/packages/bitbadgesjs-sdk/openapitypes/combined.yaml)

In this documentation, we often use the SDK format for explanation purposes. Please convert the corresponding function name to vanilla HTTP if you are not using the SDK from the documentation above.

```typescript
await BitBadgesApi.routeFn(...)
```

```
POST https://api.bitbadges.io/api/v0/routeFn
```

## Testnet Mode

A testnet version of the API is available with the base URL [https://api.bitbadges.io/testnet](https://api.bitbadges.io/testnet). Everything else is the same, just add the /testnet before all paths.

Note that this testnet API is an entirely separate service from normal API. Nothing carries over. It commmunicates with the frontend with testnet mode turned on and uses the testnet BitBadges blockchain.

## Using the API SDK (Recommended)

If you are using JavaScript / TypeScript, consider using the typed API SDK for convenience. This will give you typed routes, provide quality checks, and also auto-convert all responses to your desired number type (bigint, Number, etc).

```typescript
import { BigIntify, BitBadgesAPI } from 'bitbadgesjs-sdk';

export type DesiredNumberType = bigint;
export const ConvertFunction = BigIntify;

//BACKEND_URL for main API is https://api.bitbadges.io
//Make sure process.env.BITBADGES_API_KEY is set with a valid API key.

const BitBadgesApi = new BitBadgesAPI({
    apiKey: '...',
    //converts responses to your desired number type (bigint, Number, etc)
    convertFunction: ConvertFunction //Can also do Numberify, Stringify, etc
    apiUrl: '...' //defaults to official one if empty
});

//See https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html for documentation
//Some might require authentication. Some might be CORS only from the official site.
await BitBadgesApi.getAccounts(...);
await BitBadgesApi.getAddressLists(...);
await BitBadgesApi.getCollections(...);
await BitBadgesApi.simulateTx(...);
```

## Using BitBadges JS/SDK

Check out the BitBadges JS/SDK for implementing further functionality beyond just API requests / responses, such as manipulating balances, handling approvals, checking permissions, etc.

{% content-ref url="../bitbadges-sdk/" %}
[bitbadges-sdk](../bitbadges-sdk/)
{% endcontent-ref %}

## API Authorization

For most applications, you should be fine without needing to access private user authenticated information. However if you do, check out Sign In with BitBadges. This follows a standard OAuth 2.0 flow. Use the scopes to gain access to authenticated routes. Refer to the API reference to see what scopes are needed where.

{% content-ref url="../sign-in-with-bitbadges/" %}
[sign-in-with-bitbadges](../sign-in-with-bitbadges/)
{% endcontent-ref %}

## Bookmarking

Throughout the API, we use a bookmark technique. For the first request, you will not need to specify a bookmark (e.g. ""), and it will fetch the first page. Within the response, it will return a **bookmark** and **hasMore**. **hasMore** defines whether there are more pages to be fetched. To fetch the next page, you will specify the returned bookmark from the previous request to the next request. This process can be repeated until all are loaded.


## File: ./for-developers/bitbadges-api/concepts/README.md

# Concepts



## File: ./for-developers/bitbadges-api/concepts/limits-restrictions.md

# API Limits & Restrictions

The following limits are in place to ensure API stability and performance. If these limits are too restrictive for your use case, please contact us.

## Request Limits

-   **Rate Limit**: 10,000 requests per day per API key
-   **Global Rate Limit**: Enforced to prevent infinite loops
-   **Refresh Rate**: Operations can only be refreshed once per hour

## Data Limits

-   **Batch Size**: Maximum 250 items per request for:
    -   Metadata URIs
    -   Account lookups
    -   Collection fetches
-   **IPFS Storage**: Maximum 100MB total uploads per address
-   **Collection Size**: Limited functionality for collections exceeding JavaScript's `Number.MAX_SAFE_INTEGER`

## Timeouts & Retries

This applies to any external fetches, including metadata URIs and other external sources like custom success hooks.

-   **URI Fetch Timeout**: 10 seconds maximum for direct source URI fetches
-   **Retry Policy**: For failed fetches, exponential backoff:
    ```
    Delay = 1 hour × 2^(number of attempts)
    ```

Note: These limits may change over time. Please refer to our latest documentation for current values.


## File: ./for-developers/bitbadges-api/concepts/managing-views.md

# Managing Views

Throughout the BitBadges API, we use a bookmark-based pagination system for efficient data retrieval. This system is particularly useful when dealing with large datasets that need to be fetched in smaller chunks.

Some endpoints like the get accounts or get collections will use a generic viewsToFetch and views object which can maintain multiple paginated views. Some endpoints will request the bookmark directly. Refer to the documentation for each endpoint to see how it handles pagination.

### How Bookmark Pagination Works

1. **First Request**: For your initial request, use an empty bookmark string (`""`).

```typescript
const firstRequest = {
    viewType: 'owners',
    viewId: 'owners',
    bookmark: '', // Empty for first page
};
```

2. **Response Structure**: Each paginated response includes:
    - The requested data
    - A `bookmark` string for the next page
    - A `hasMore` boolean indicating if more data exists

```typescript
{
    data: [...],
    views: {
        'owners': {
            ids: [...],
            pagination: {
                bookmark: 'abc123...', // Use this for next request
                hasMore: true
            }
        }
    }
}
```

3. **Subsequent Requests**: To fetch the next page, use the bookmark from the previous response:

```typescript
const nextRequest = {
    viewType: 'owners',
    viewId: 'owners',
    bookmark: 'abc123...', // Bookmark from previous response
};
```

4. **Completion**: Continue this process until `hasMore` is `false`.

## Understanding the Views Object

```
Note: This is planning to be deprecated in favor of more confined view routes.
Please use those instead. They are much less confusing.
```

The views object is a central concept in the BitBadges API, used to manage paginated data across different interfaces (BitBadgesCollection, BitBadgesAddressList, BitBadgesUserInfo, etc). It follows this structure:

```typescript
views: {
    [viewId: string]: {
        ids: string[];          // Array of document IDs
        pagination: {
            bookmark: string;    // Bookmark for next page
            hasMore: boolean;    // Whether more data exists
        };
        type: string;           // The view type
    } | undefined;
}
```

### Key Components

1. **viewId**: A unique identifier for the view
2. **ids**: Array of document IDs that correspond to full documents in the response
3. **pagination**: Contains the bookmark and hasMore flag
4. **type**: Indicates the type of view (e.g., 'owners', 'activity', etc.)

### Document ID Mapping

Documents in the response are referenced by their `_docId` field. To access the full document, you map the IDs from the view to the corresponding array in the response. For example, the activity view documents are stored in the `activity` array, and the view IDs are stored in the `views.activity.ids` array.

```typescript
// Example of accessing activity documents from a view
getActivityView(viewId: string) {
    return (this.views[viewId]?.ids.map((x) => {
        return this.activity.find((y) => y._docId === x);
    }) ?? []);
}
```

### Common View Types

Different interfaces support different view types. See the corresponding documentation for each interface to see what views are supported.

#### Collections Interface

-   `owners`: List of owners
-   `activity`: Transfer activity
-   `approvalTrackers`: Approval tracking documents

See all at [CollectionViewKey](https://bitbadges.github.io/bitbadgesjs/types/CollectionViewKey.html)

#### Account Interface

-   `transferActivity`: User's transfer history
-   `tokensCollected`: Tokens owned by the user
-   `createdTokens`: Collections created by the user
-   `managingTokens`: Collections being managed
-   `allLists`: Address lists the user is on

See all at [AccountViewKey](https://bitbadges.github.io/bitbadgesjs/types/AccountViewKey.html)

## Helper Functions

The BitBadges SDK provides several helper functions for managing views:

```typescript
// Check if more pages exist
const hasMore = collection.viewHasMore('owners');

// Get bookmark for next page
const nextBookmark = collection.getViewBookmark('owners');

// Fetch next page of data
await collection.fetchNextForView(BitBadgesApi, 'owners', 'owners');

// Get all documents for a view
const ownersView = collection.getOwnersView('owners');
```

## Best Practices

1. **Consistent ViewIds**: Use consistent viewIds when paginating through the same dataset
2. **Error Handling**: Always check for undefined views before accessing
3. **Document Mapping**: Use helper functions when available for mapping IDs to documents
4. **Pagination State**: Track both bookmark and hasMore status for proper pagination
5. **Response Merging**: Remember that each response is confined to its request - use helper functions or manually merge data as needed


## File: ./for-developers/bitbadges-api/concepts/native-chain-algorithm.md

# Native Chain Algorithm

### How is a user's "native" chain determined?

You may have noticed that on the BitBadges site and other places, a user's "preferred" or "main" blockchain is remembered and auto-populated. This is how we populate the **chain** and **address** field in account route responses. We determine the main chain in the following order.

1. Chain of last signed BitBadges transaction
2. Chain of last sign in on BitBadges app
3. Try to check any transaction history (e.g. submitted any transactions on Ethereum mainnet chain?)
4. Requested address format
5. Guess / default to Ethereum since it is the most popular


## File: ./for-developers/bitbadges-api/concepts/refresh-queue.md

# Refresh / Claim Completion Queue

The API / indexer makes use of a load-balanced refresh queue system whenever we need to fetch anything from a source URI (metadata, off-chain balances, etc). Because this is a queue-based system, certain metadata may take awhile to fully load and populate. Once we fetch the metadata, we cache it and return the fetched values until it is refreshed again.

**When do we trigger refreshes?**

Refreshes are triggered automatically when certain things occur on-chain, such as a collection is created / URI is changed. You can also manually trigger refreshes (note there are cooldown limits in place to prevent spam) to refresh the cached values via the refresh endpoints.

**What happens if the fetch fails?**

See [Restrictions / Limits](limits-restrictions.md). We implement an exponential retry system.

**Checking Status**

If you are having issues, you can check the BitBadges collection page on site -> Actions -> Refresh for statuses. Or, if you need a programmatic solution, you can use following route to see its status and see if it has any error docs.

```typescript
await BitBadgesApi.getRefreshStatus()
```


## File: ./for-developers/bitbadges-api/indexer.md

# Indexer

If you want to run your own indexer and API, check out the source code at [https://github.com/bitbadges/bitbadges-indexer](https://github.com/bitbadges/bitbadges-indexer).

The indexer is split into two main parts: the poller and the API. The poller fetches the latest block from a connected node every second and updates the MongoDB database accordingly. The API is an Express.js API that makes the indexed data queryable to users.

Although you can query other blockchain nodes, it is strongly recommended that you run your own node and query that. HTTP requests can reach >100 per second.

### Running from Scratch

1. Install and setup CouchDB
2. Setup a valid .env file. See environment.d.ts below for the expected format of the .env file.&#x20;
3. Use **npm run setup** to setup the CouchDB databases. Note that you can run **npm run setup with-delete** to restart all indexer databases from scratch.
4. Use **npm run indexer-dev** to start in development mode.
5. Use **npm run build** and **npm run indexer** to start in production mode.

### Running with Docker

See [https://github.com/bitbadges/bitbadges-docker](https://github.com/bitbadges/bitbadges-docker).

### Customization Options (.env file)

Below are the supported customization options. Some may be applicable. Some may not.

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadges-indexer/blob/master/environment.d.ts" %}



## File: ./for-developers/bitbadges-api/upgrading-an-api-key-tier.md

# Upgrading an API Key Tier

1. Sign in and create your API key in the [developer portal -> API Keys tab](https://bitbadges.io/developer).

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

2. Once you've created it and copied it somewhere safe, select "Update Tier".

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

3. This will take you to the billing page. Select your desired tier. Note that if you have a coupon code, it will typically only apply to a specific tier.

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

4. Lastly, complete the form, selecting your newly created API key. Enter your email, enter promo code (if applicable), and complete the rest of the form.

<figure><img src="../../.gitbook/assets/image (5) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

5. Once that form is submitted, you're ready to start building! See the [BitBadges API documentation](https://docs.bitbadges.io) for more information on how to use the BitBadges API. The new tier may take 5-10 minutes to register, so please allow some time for the changes to take effect.


## File: ./for-developers/bitbadges-blockchain/README.md

# ⛓️ BitBadges Blockchain



## File: ./for-developers/bitbadges-blockchain/accounts-technical.md

# Accounts (Technical)

## Pre-Readings

* [Cosmos SDK Accounts](https://docs.cosmos.network/main/basics/accounts)
* [Ethereum Accounts](https://ethereum.org/en/whitepaper/#ethereum-accounts)

### Accounts and Validator Operators

For accounts (standard senders of transactions) and validator operators, we support users from four L1 blockchain ecosystems currently (Ethereum, Bitcoin, Solana, and Cosmos).

### **Ethereum**

BitBadges allows Ethereum addresses to use Ethereum's ECDSA secp256k1 curve for keys. The public key for these accounts will be a custom type (forked from [Ethermint](https://github.com/cosmos/ethermint)). This satisfies the [EIP84](https://github.com/ethereum/EIPs/issues/84) for full [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) paths. The root HD path for BitBadges Ethereum-based accounts is `m/44'/60'/0'/0`. BitBadges uses the Coin type `60` to support Ethereum type accounts, unlike other Cosmos chains that use Coin type `118.`

**Signing Method:** All transactions should be signed with EIP712. EIP712 transactions can be generated via the BitBadges SDK.

### **Solana**

BitBadges also extends the SDK's functionality to support Solana signatures signing with a ed25519 key. Addresses are expected to be in the native Base58 format.

**Signing Method:** Transactions will be signed in JSON stringified format with all keys alphabetically sorted. JSON messages can also be generated via the SDK.

### **Cosmos**

Normal Cosmos accounts are also supported with all the Cosmos SDK's native functionality. We refer you to their documentation for further information.

### Bitcoin

BitBadges supports Bitcoin P2WPKH addresses and BIP322 message verification.

**Signing Method:** Transactions will be signed in JSON stringified format with all keys alphabetically sorted. JSON messages can also be generated via the SDK.

### Addresses and Public Keys[​](https://docs.injective.network/learn/basic-concepts/accounts#addresses-and-public-keys) <a href="#addresses-and-public-keys" id="addresses-and-public-keys"></a>

#### **Address Conversion**

<pre class="language-typescript"><code class="lang-typescript"><strong>import { ethToBitBadges, bitbadgesToEth } from 'bitbadgesjs-sdk';
</strong>
<strong>const bitbadgesAddress = ethToBitBadges(address);
</strong>const ethAddress = bitbadgesToEth(bitbadgesAddress);
const bitbadgesAddressFromSolana = solanaToBitBadges(address);
//Note there is no bitbadgesToSolana or ethToSolana due to how the addresses work
</code></pre>

Behind the scenes, the blockchain always uses the mapped BitBadges address, never a Solana or Ethereum address. The Solana / Ethereum addresses are only for visually displaying to the user.

The Bech32 format is the default format for Cosmos-SDK queries and transactions through CLI and REST clients.

#### **Representation** <a href="#addresses-and-public-keys" id="addresses-and-public-keys"></a>

Ethereum Example:

* Address (Bech32): `bb14au322k9munkmx5wrchz9q30juf5wjgz2cfqku`
* Address ([EIP55](https://eips.ethereum.org/EIPS/eip-55) Ethereum Hex): `0xAF79152AC5dF276D9A8e1E2E22822f9713474902`

Solana Example:

* Address (Base58): 6H2af68Yyg6j7N4XeQKmkZFocYQgv6yYoU3Xk491efa5
* Address (Bech32): bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl

Bitcoin Example

* Address (Native - P2WPKH): bc1q9s7rynm5pwhluhecsmlku8rn5yej5wdgj0gv3e
* Address (Bech32): bb19s7rynm5pwhluhecsmlku8rn5yej5wdg8g75f9

#### **Public Key Types**

For standard Cosmos accounts, the public key will have the `"@type": "/cosmos.crypto.secp256k1.PubKey"`.

For Solana accounts, the public key will have the `"@type": "/cosmos.crypto.ed25519.PubKey"`.

For standard Ethereum accounts, the public key will have the `"@type": "/ethereum.PubKey"`.

`{"@type":"/ethereum.PubKey","key":"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2"}`

### Deriving BitBadges Ethereum Account from a private key/mnemonic[​](https://docs.injective.network/learn/basic-concepts/accounts#deriving-injective-account-from-a-private-keymnemonic) <a href="#deriving-injective-account-from-a-private-keymnemonic" id="deriving-injective-account-from-a-private-keymnemonic"></a>

Below you will see an example code snippet on how to derive a BitBadges Account from a private key and/or a mnemonic phase:

```typescript
import { Wallet } from 'ethers'
import { Address as EthereumUtilsAddress } from 'ethereumjs-util'

const mnemonic = "indoor dish desk flag debris potato excuse depart ticket judge file exit"
const privateKey = "afdfd9c3d2095ef696594f6cedcae59e72dcd697e2a7521b1578140422a4f890"
const defaultDerivationPath = "m/44'/60'/0'/0/0"
const defaultBech32Prefix = 'bb'
const isPrivateKey: boolean = true /* just for the example */

const wallet = isPrivateKey ? Wallet.fromMnemonic(mnemonic, defaultDerivationPath) : new Wallet(privateKey)
const ethereumAddress = wallet.address
const addressBuffer = EthereumUtilsAddress.fromString(ethereumAddress.toString()).toBuffer()
const bitbadgesAddress = bech32.encode(defaultBech32Prefix, bech32.toWords(addressBuffer))
```

Let's see an example code snipped on how to derive a public key from a private key:

```typescript
import secp256k1 from 'secp256k1'

const privateKey = "afdfd9c3d2095ef696594f6cedcae59e72dcd697e2a7521b1578140422a4f890"
const privateKeyHex = Buffer.from(privateKey.toString(), 'hex')
const publicKeyByte = secp256k1.publicKeyCreate(privateKeyHex)

const buf1 = Buffer.from([10])
const buf2 = Buffer.from([publicKeyByte.length])
const buf3 = Buffer.from(publicKeyByte)

const publicKey = Buffer.concat([buf1, buf2, buf3]).toString('base64')
const type = '/ethereum.PubKey'
```

#### Acknowledgements

Credit to [https://docs.injective.network/learn/basic-concepts/accounts](https://docs.injective.network/learn/basic-concepts/accounts) and [https://docs.evmos.org/protocol/concepts/accounts](https://docs.evmos.org/protocol/concepts/accounts).


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/README.md

# Cosmos SDK Msgs

**What are Cosmos SDK Msgs? Msgs vs Transactions?**

In Cosmos SDK, Msgs are messages that represent actions to be executed on the blockchain, such as sending tokens.

Each transaction must consist of one or Msgs to be executed. Transactions also consist of other accompanying details such as the signature info.

**What Msgs does the BitBadges blockchain implement?**

The BitBadges blockchain utilizes various pre-written modules from the Cosmos SDK (auth, authz, genutil, bank, capability, staking, distr, gov, params, crisis, slashing, feegrant, group, wasm, ibc, upgrade, evidence, transfer, ica, vesting). The documentation for the pre-written modules can be found [here](https://docs.cosmos.network/main/modules).

The x/badges module is the core functionality of BitBadges written by us, and within this module, all the Msg types that correspond to tokens are defined. We also use an x/wasmx module which helps to create compatible smart contracts (forked from Injective). The x/maps allows storing data in a structured format with many customization options for the map. The x/anchor alllows for storing unstructured data.

**How to broadcast transactions with Msgs?**

You can generate and submit your transactions (Msgs) via:

* [BitBadges SDK](../create-and-broadcast-txs/): Generate and broadcast transactions to a running node with TypeScript. See [tutorials](../create-and-broadcast-txs/). This is the recommended option.
* CLI: Run your own node and interact with the command line
* Other: [https://docs.cosmos.network/main/user/run-node/txs#using-rest](https://docs.cosmos.network/main/user/run-node/txs#using-rest)

**What is the creator field?**

The **creator** field for each message should be the transaction signer's BitBadges address.

## Msg Definitions

Below, we link the documentation for the Msgs from our x/badges and x/wasmx module.

**x/badges**

* [MsgCreateCollection](https://bitbadges.github.io/bitbadgesjs/classes/MsgCreateCollection.html) - Creates a new collection. For creation transactions, everything is considered "free" (no permission restrictions). For following update transactions, everything must follow the permissions set.
* [MsgUpdateCollection](https://bitbadges.github.io/bitbadgesjs/classes/MsgUpdateCollection.html) - Updates the details of a collection. Must be manager of the corresponding collection to execute and all updates must follow the permissions set.
* [MsgUniversalUpdateCollection](https://bitbadges.github.io/bitbadgesjs/classes/MsgUniversalUpdateCollection.html) - This is a universal all-in-one message that supports everything from both MsgCreateCollection and MsgUpdateCollection. If collectionId == 0, we treat it as a create transaction. If collectionId > 0, we update the corresponding collection.
  * Mainly used for legacy purposes. To avoid confusion, we recommend using MsgCreate or MsgUpdate because those will be typed correctly for your use case.
* [MsgTransferBadges](https://bitbadges.github.io/bitbadgesjs/classes/MsgTransferBadges.html) - Transfer tokens between users, if approvals allow.
* [MsgUpdateUserApprov](https://bitbadges.github.io/bitbadgesjs/classes/MsgUpdateUserApprovals.html)[als](https://bitbadges.github.io/bitbadgesjs/classes/MsgUpdateUserApprovals.html) - Set incoming / outgoing approvals for a collection, in addition to permissions which define the updatability of the approvals.
* [MsgDeleteCollection](https://bitbadges.github.io/bitbadgesjs/classes/MsgDeleteCollection.html) - Deletes the collection, if permissions allow. Must be manager.
* [MsgCreateAddressLists](https://bitbadges.github.io/bitbadgesjs/classes/MsgCreateAddressLists.html) - Creates address list(s).

**x/wasmx**

* [MsgExecuteContractCompat](https://bitbadges.github.io/bitbadgesjs/classes/MsgExecuteContractCompat.html) - Helper Msg to support executing contracts with support for BitBadges special transaction signing. See [here](../concepts/accounts-technical.md) for tutorial.

**x/maps**

* MsgCreateMap - Creates a map, uniquely identifed by an ID
* MsgUpdateMap - Updates an existing map.
* MsgDeleteMap - Deletes a map
* MsgSetValue - Allows a user to specify a (key, value) pair if permissions allow.

**x/anchor**

* MsgAddCustomData - Add custom data to the blockchain. No structure to the data at all (just a string). Will return a location for where to find your data.

**Other Cosmos SDK Modules**

For other standard Cosmos SDK messages, you can check out the bitbadges SDK documentation (such as [MsgSend](https://bitbadges.github.io/bitbadgesjs/classes/MsgSend.html) here). Or, check the official Cosmos documentation as these were written by them!


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/cosmos-native-msgs.md

# Cosmos Native Msgs

We refer you to Cosmos SDK documentation for other Cosmos native Msgs.


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/msgsend.md

# MsgSend

MsgSend is the Msg to send BADGE. It is a core Cosmos SDK msg (i.e. not written by BitBadges), o we refer you to their documentation for more information.

```typescript
/**
 * MsgSend represents a message to send coins from one account to another.
 *
 * @typedef {Object} MsgSend
 * @property {string} fromAddress - The sender of the transaction.
 * @property {string} toAddress - The recipient of the transaction.
 * @property {CosmosCoin[]} amount - The amount of coins to send.
 */
export interface MsgSend<T extends NumberType> {
    fromAddress: string;
    toAddress: string;
    amount: CosmosCoin<T>[];
}

/**
 * Type for Cosmos SDK Coin information with support for bigint amounts (e.g. { amount: 1000000, denom: 'ubadge' }).
 *
 * @typedef {Object} CosmosCoin
 * @property {NumberType} amount - The amount of the coin.
 * @property {string} denom - The denomination of the coin.
 */
export interface CosmosCoin<T extends NumberType> {
    amount: T;
    denom: string;
}
```

```json
{
    "fromAddress": "bb1pa6p7nsqg57yqv23khnu5dumfhycr459jjnzsg",
    "toAddress": "bb1uy4my3dwzwv9drgq06pt433z742l9vrlsm053p",
    "amount": [
        {
            "denom": "ubadge",
            "amount": "1"
        }
    ]
}
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges.md

# x/badges

See the Token Standard documentation. x/badges is the module behind the entire token standard.

{% content-ref url="broken-reference" %}
[Broken link](broken-reference)
{% endcontent-ref %}


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/README.md

# x/maps



## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgcreateprotocol.md

# MsgCreateMap

MsgCreateMap creates a map on-chain. We refer you to here for more information on each individual field.

{% content-ref url="broken-reference" %}
[Broken link](broken-reference)
{% endcontent-ref %}

```typescript
export interface iMsgCreateMap<T extends NumberType> {
  creator: string;
  mapId: string;

  inheritManagerTimelineFrom: T;
  managerTimeline: iManagerTimeline<T>[];

  updateCriteria: iMapUpdateCriteria<T>;
  valueOptions: iValueOptions;
  defaultValue: string;

  metadataTimeline: iMapMetadataTimeline<T>[];

  permissions: iMapPermissions<T>;
}
```

```typescript
export interface iValueOptions {
  noDuplicates: boolean;
  permanentOnceSet: boolean;
  expectUint: boolean;
  expectBoolean: boolean;
  expectAddress: boolean;
  expectUri: boolean;
}
```

```typescript
export interface iMapPermissions<T extends NumberType> {
  canUpdateMetadata: iTimedUpdatePermission<T>[];
  canUpdateManager: iTimedUpdatePermission<T>[];
  canDeleteMap: iActionPermission<T>[];
}
```

```typescript
export interface iMapMetadataTimeline<T extends NumberType> {
  timelineTimes: iUintRange<T>[];
  metadata: iCollectionMetadata;
}
```

```typescript
export interface iMapUpdateCriteria<T extends NumberType> {
  managerOnly: boolean;
  collectionId: T;
  creatorOnly: boolean;
  firstComeFirstServe: boolean;
}
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgdeleteprotocol.md

# MsgDeleteMap

MsgDeleteProtocol deletes the map with the given name.

<pre class="language-typescript"><code class="lang-typescript"><a data-footnote-ref href="#user-content-fn-1">export</a> interface MsgDeleteMap {
  creator: string,
  mapId: string,
}
</code></pre>

[^1]: 


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgsetcollectionforprotocol.md

# MsgSetValue

MsgSetValue sets the specific key-value pair for the mapId. For example, set my BitBadges Follow Protocol collection to collection ID 12.

All values are stringified for comaptibility, but it will check they are in proper format within the Msg logic. You can set **options.useMostRecentCollectionId** to auto-fetch the latest collection ID. This can be leveraged in multi-msg transactions where you want to create a collection and set the ID to the just created collection. Typically, you do not know the collection ID until after the collection is created which is why this feature is useful. See below

```typescript
export interface iMsgSetValue {
    creator: string;
    mapId: string;
    key: string;
    value: string;
    options: iSetOptions;
}

export interface iSetOptions {
    useMostRecentCollectionId: boolean;
}
```

**Combining with MsgCreateCollection or MsgUpdateCollection**

The two Msgs can be easily combined in the same transaction (as Cosmos transactions support multiple Msgs). See [here](../create-and-broadcast-txs/generate-msg-contents.md) for an example of how to do it with the SDK. Just make sure MsgCreateCollection is executed first and precedes when it is actually used.

```typescript
const msgs: MessageGenerated[] = [];
msgs.push(...bootstrapCollections().map((x) => createProtoMsg(x))); //MsgCreateCollections
msgs.push(...bootstrapSetProtocols().map((x) => createProtoMsg(x))); //MsgSetCollectionForProtocol

//Note how MsgCreateAddressLists is first in the array
const txn = createTransactionPayload(txContext, msgs);
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgupdateprotocol.md

# MsgUpdateMap

MsgUpdateMap updates the map with the matching ID. Similar to the x/badges Msgs, we use an update flag + value interface. If update flag = true, we update with the corresponding value. Else, we ignore it.

```typescript
export interface iMsgUpdateMap<T extends NumberType> {
  creator: string;
  mapId: string;

  updateManagerTimeline: boolean;
  managerTimeline: iManagerTimeline<T>[];

  updateMetadataTimeline: boolean;
  metadataTimeline: iMapMetadataTimeline<T>[];

  updatePermissions: boolean;
  permissions: iMapPermissions<T>;
}
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/README.md

# x/wasmx



## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msgexecutecontractcompat.md

# MsgExecuteContractCompat

```typescript
/**
 * MsgExecuteContractCompat defines a ExecuteContractCompat message.
 *
 * @typedef {Object} MsgExecuteContractCompat
 * @property {string} sender - The sender of the transaction.
 * @property {string} contract - The contract address to execute.
 * @property {string} msg - The message to pass to the contract. Must be a valid JSON string.
 * @property {string} funds - The funds to send to the contract. Must be a valid JSON string.
 */
export interface MsgExecuteContractCompat {
    sender: string;
    contract: string;
    msg: string;
    funds: string;
}
```

MsgExecuteContractCompat is a wrapper for CosmWASM's MsgExecuteContract that is compatible with all signing methods for BitBadges users. See [Create a Smart Contract](../create-a-wasm-contract.md) tutorial for more information.


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msginstantiatecontractcompat.md

# MsgInstantiateContractCompat

```typescript
export interface MsgInstantiateContractCompat {
  sender: string
  codeId: string
  label: string
  funds: string
}
```

MsgInstantiateContractCompat is a wrapper for CosmWASM's MsgInstantiateContract that is compatible with all signing methods for BitBadges users. See [Create a Smart Contract](../create-a-wasm-contract.md) tutorial for more information.


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msgstorecodecompat.md

# MsgStoreCodeCompat

```typescript
export interface MsgStoreCodeCompat {
    sender: string;
    hexWasmByteCode: string;
}
```

MsgStoreCompat is a wrapper for CosmWASM's MsgStoreCode that is compatible with all signing methods for BitBadges users. See [Create a Smart Contract](../create-a-wasm-contract.md) tutorial for more information.


## File: ./for-developers/bitbadges-blockchain/create-a-wasm-contract.md

# Create a WASM Contract

BitBadges support CosmWASM smart contracts to allow you to extend the token interface for custom functionality as desired. If you do need to extend the interface with unsupported functionality but you think it would be a good fit to be added natively, please let us know. Our end goal is that no smart contracts are ever needed, and everything is supported natively!

We refer you to official CosmWASM and Rust documentation for more information. This tutorial will only focus on BItBadges specific information.

{% embed url="https://cosmwasm.cosmos.network/" %}

```go.mod
github.com/CosmWasm/wasmd v0.52.0
```

**Permissioned Uploads**

```
BitBadges implements CosmWASM in a permissioned manner.
```

Instantiating and officially deploying a contract does require a review process and governance approval. Reach out for more information.

Requirements:

* No avoidance of the protocol fee. Any token transfers that take place must use MsgTransferBadges, or if you need to implement transfer functionality directly in the contract, the protocol fee must be obeyed.
* We encourage audits and a peer review process before officailly deploying.
* You must also showcase a working testnet implementation as well (testnet is permissionless)

Generally speaking, even though this is a permissioned implementation, we want the contract layer to be as permissionless as possible. We just have to enforce that our business model (protocol fee) is obeyed.

**High-Level Development Overview**

```rust
const msgExecuteContract: MsgExecuteContractCompat = {
    sender: 'bb1uqxan5ch2ulhkjrgmre90rr923932w38gwez5d',
    contract:
        'bb14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sc8kg9e',
    msg: '{"myCustomMsg1": {"collectionId": "1"}}',
    funds: '1ubadge',
};
```

* Each contract has a Cosmos bech32 contract address (e.g. bb14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sc8kg9e).
* 3-Step Process: Upload / Store Code, Instantiate, Execute
  * Instantiating requires governance proposal (see below)
* Contracts can call into the core x/badges module as submessages (delayed until directly after the contract)
  * When calling into x/badges, msg.Creator will ALWAYS be the contract address. You may need to come up with creative workarounds or creative solutions in certain situations.
* The main execution part of every contract is ExecuteMsg. Think of this like the API definition for your contract. You can have multiple message types with different logic.

```rust
//contract.rs
use bitbadges_cosmwasm::{
  transfer_badges_msg
};

#[entry_point]
pub fn execute(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response<BitBadgesMsg>, StdError> {
    match msg {
        ExecuteMsg::CustomMsg1 { collection_id, transfers } => {
          let msg = transfer_badges_msg(collection_id, transfers);
          Ok(Response::new().add_submessage(SubMsg::reply_always(msg, BADGES_REPLY_ID)))
        }
        ExecuteMsg::CustomMsg2 { collection_id, transfers } => {
          let msg = transfer_badges_msg(collection_id, transfers);
          Ok(Response::new().add_submessage(SubMsg::reply_always(msg, BADGES_REPLY_ID)))
        }
        // Add other messages here as needed
    }
}
```

### **Create a Contract Tutorial**

1. Clone the BitBadges Cosmwasm repository

```
git clone https://github.com/BitBadges/bitbadges-cosmwasm-bindings.git
cd bitbadges-cosmwasm-bindings
```

This repository exports all the custom bindings via `packages/bitbadges-cosmwasm`. You should typically NOT edit the exported types. These are already pregenerated exactly as defined on-chain for you to use.

2. Create your contract

You will be dealing with the `contracts` folder. This is where you implement your contract logic. The `contracts` folder is automatically configured to import from the local `packages/bitbadges-cosmwasm.` We have provided an example and boilerplate for you.

Tools at your disposal:

```rust
// All BitBadges type bindings
use bitbadges_cosmwasm::{
  Transfer, Balance, ....
};
```

<pre class="language-rust"><code class="lang-rust">// BitBadges *_msg() functions
// This is how you call into x/badges by adding Ok(Response::new().add_message(msg))
use bitbadges_cosmwasm::{
  transfer_badges_msg, delete_collection_msg, BitBadgesMsg
}

<strong>pub fn execute_my_msg(
</strong>    collection_id: String,
    transfers: Vec&#x3C;Transfer>,
) -> StdResult&#x3C;Response&#x3C;BitBadgesMsg>> {
    let msg = transfer_badges_msg(
        collection_id,
        transfers,
    );

    Ok(Response::new().add_message(msg))
}

#[entry_point]
pub fn execute(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: ExecuteMsg,
) -> Result&#x3C;Response&#x3C;BitBadgesMsg>, StdError> {
    match msg {
        ExecuteMsg::MyCustomMsg { collection_id, transfers } => {
          execute_my_msg(collection_id, transfers)
        }
        // Add other messages here as needed
    }
}
</code></pre>

3. Build and Optimize

You may have to edit the script for you file names and paths. Consider also using an optimizer like [https://github.com/CosmWasm/rust-optimizer](https://github.com/CosmWasm/rust-optimizer).

```bash
cargo build
source ./build.sh # outputs a .wasm
gzip youcontractname.wasm # outputs a .wasm.gz
```

```bash
# build.sh
RUSTFLAGS='-C link-arg=-s' cargo wasm
cp ../../target/wasm32-unknown-unknown/release/YOUR_CONTRACT_NAME.wasm .
```

4. Uploading Your Contract

Go to [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast) and select MsgStoreCode. Upload your .wasm.gz file. Submit the transaction.

For testnet uploads, use testnet.bitbadges.io

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

5. Instantiate your Contract

A notification from Step 4 should pop up with your code ID, assuming the transaction was successful.

Refresh the page or clear all Msgs and start a new transaction. Now, select MsgInstantiateContractCompat. Set a label (name for your contract) and enter the code ID from step 3. Submit the transaction.

If you want to instantiate it with funds. the **funds** property will be in the format "1badge".

A notification should pop up with your contract's address. Store this somewhere.

```
Note: This is only applicable to testnet.

For mainnet, instantiation requires a governance proposal. Reach out to us to start this process.
```

6. Interact with the Contract

Once deployed, you need to to let your users interact with it. Use our custom x/wasmx MsgExecuteContractCompat to do so. This is a wrapper around the core x/wasm MsgExecuteContract with support for BitBadges signing. This is the same as broadcasting any other transaction, so we refer you to Creating, Signing, and Broadcasting Txs for a tutorial.

Couple common misunderstandings:

* Note msg is an encoded stringified JSON. Be mindful of single vs double quotes and escaped characters.
*   Note camelCase vs snake\_case. Contracts typically auto-format with camelCase via

    ```rust
    #[serde(rename_all = "camelCase")]
    ```
* Parsing may not be smart enough to identify empty values like empty arrays. You may have to manually specify empty strings, arrays for compatibility.

**Examples**

```typescript
const msgExecuteContract: MsgExecuteContractCompat = {
    sender: 'bb1uqxan5ch2ulhkjrgmre90rr923932w38gwez5d', //enter sender adress here
    contract: 'bb14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sc8kg9e', //
    msg: '{"deleteCollectionMsg": {"collectionId": "1"}}',
    funds: '1badge',
};
```


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/README.md

# Create, Generate, and Sign Txs

To learn more about broadcasting transactions with Cosmos SDK, you can visit [https://docs.cosmos.network/v0.46/run-node/txs.html](https://docs.cosmos.network/v0.46/run-node/txs.html).

We recommend generating, signing, and broadcasting your transactions with the [BitBadges SDK](../../bitbadges-sdk/). The SDK provides easy-to-use TypeScript functions to construct transactions of all types and broadcast them to a blockchain node.&#x20;

You can also run the BitBadges blockchain software and interact with its CLI, but this is more complicated and only supports Cosmos signatures.


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/broadcast-to-a-node.md

# Broadcast to a Node

**Pre-Req:** You have the body variable with a valid signature (see prior pages).

### **Simulating**

A good practice to have is to simulate the transaction before you actually broadcast and update the **fee** from the transaction context with up to date values.

To do this, you can use

```
https://api.bitbadges.io/api/v0/simulate
```

**or**

```typescript
http://URL:1317/cosmos/tx/v1beta1/simulate
```

This will return the gas used on a dry run of the transaction and any errors if it finds any. You can leave all signature fields empty because simulations do not check any signatures.

Note this tutorial is slightly out of order for clarity, the simulation step should typically be done before the user signs, so they only have to sign the final Msg with the up to date gas.

Once simulated, replace the expected gas you want in the transaction context.

```typescript
export interface SimulateTxRouteSuccessResponse<T extends NumberType> {
    gas_info: {
        gas_used: string;
        gas_wanted: string;
    };
    result: {
        data: string;
        log: string;
        events: {
            type: string;
            attributes: {
                key: string;
                value: string;
                index: boolean;
            }[];
        }[];
        msg_responses: any[];
    };
}
```

### **Broadcasting**

You can replace the URL below with any valid BitBadges blockchain node.

```typescript
`http://URL:1317${generateEndpointBroadcast()}`;
```

Or, you can use the BitBadges API to broadcast.

```typescript
https://api.bitbadges.io/api/v0/broadcast
```

<pre class="language-typescript"><code class="lang-typescript"><strong>await BitBadgesApi.broadcastTx(body);
</strong></code></pre>

This will give you a response immediately. You should then use the tx\_response.txhash to view it on an explorer, query the blockchain directly, see if it had errors, and so on. The response code should be 0 for a successful transaction. We refer you to Cosmos docs for more information about each indivdual item.

```typescript
export interface BroadcastTxRouteSuccessResponse<T extends NumberType> {
    tx_response: {
        code: number;
        codespace: string;
        data: string;
        events: {
            type: string;
            attributes: {
                key: string;
                value: string;
                index: boolean;
            }[];
        }[];
        gas_wanted: string;
        gas_used: string;
        height: string;
        info: string;
        logs: {
            events: {
                type: string;
                attributes: {
                    key: string;
                    value: string;
                    index: boolean;
                }[];
            }[];
        }[];
        raw_log: string;
        timestamp: string;
        tx: object | null;
        txhash: string;
    };
}
```

### Polling

Once you have the tx hash, you can poll a node until the transaction is confirmed like below. Note this is a blockchain REST API\_URL, not the BitBadges API. You can also view it on explorers.

Use [https://lcd.bitbadges.io](https://lcd.bitbadges.io) for the BitBadges maintained node.

```typescript
const txHash = res.data.tx_response.txhash;
const code = res.data.tx_response.code;
if (code !== undefined && code !== 0) {
    throw new Error(
        `Error broadcasting transaction: Code ${code}: ${JSON.stringify(
            res.data.tx_response,
            null,
            2
        )}`
    );
}

let fetched = false;
while (!fetched) {
    try {
        const res = await axios.get(
            `${process.env.API_URL}/cosmos/tx/v1beta1/txs/${txHash}`
        );
        fetched = true;

        return res;
    } catch (e) {
        // wait 1 sec
        console.log('Waiting 1 sec to fetch tx');
        await new Promise((resolve) => setTimeout(resolve, 1000));
    }
}

return res;
```


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/generate-msg-contents.md

# Generate Msg Contents

The first step is to know what Msg type you are trying to submit and build out the contents of the Msgs in the transaction.

If you plan to use [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast), the transaction building is already handled for you behind the scenes. The only applicable section below is Building the Msgs. This site is also a good reference if you want to explore the different types of messages.

### **Building the Msgs**

You can build out the transaction from the exported Proto type definitions. This allows you to create transactions with multiple Msg types in one tx. It also supports all Msgs for the BitBadges blockchain (even standard Cosmos SDK ones). Note that certain NumberTypes may need to be stringified before creating a proto object.

See [https://github.com/BitBadges/bitbadgesjs/tree/main/packages/bitbadgesjs-sdk/src/proto](https://github.com/BitBadges/bitbadgesjs/tree/main/packages/bitbadgesjs-sdk/src/proto) for all proto Msg definitions.

```typescript
import { proto } from 'bitbadgesjs-sdk';

//proto.cosmos.module for standard Cosmos
//proto.badges for BitBadges x/badges
//proto.wasmx for BitBadges x/wasmx
//proto.protocols for BitBadges x/protocols
const ProtoMsgDeleteCollection = proto.badges.MsgDeleteCollection;

const protoMsgs = [
    new ProtoMsgDeleteCollection({ collectionId: '1', creator: 'bb...' }),
    //Add more here (executed in order)
];
```

### Building the Transaction

```typescript
const txContext = { ... } //See prior page

const txnPayload = createTransactionPayload(txContext, protoMsgs);
```

The outputted payload will be in the following format.

For Cosmos, you will use signDIrect.

For Ethereum/Solana/Bitcoin, you will use txnString.

If you stringify txnJSON and SHA256 it, you will get the content hash from the txnString.

```typescript
export interface TransactionPayload {
    legacyAmino: {
        body: TxBody;
        authInfo: AuthInfo;
        signBytes: string;
    };
    signDirect: {
        body: TxBody;
        authInfo: AuthInfo;
        signBytes: string;
    };
    txnString: string;
    txnJson: Record<string, any>;
}
```

### Next Steps

Once you have the generated transaction, you now need to determine how you want to sign and broadcast your transaction. You have two options:

1. Use [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast) - This is a visual UI that you can simply copy and paste your Msgs into. You can get the JSON string for each message with protoMsg.toJsonString(). Generating all additional transaction details, gas, fees, and signing is all outsourced to the user interface. This is the recommended option if you do not require programmatically submitting TXs. Navigate to [Sign + Broadcast - bitbadges.io](sign-+-broadcast-bitbadges.io.md) if this is your desired option.
2. Generate, sign, and broadcast directly to a running blockchain node. This is more technical and has more steps but can be done programmatically. Navigate to the corresponding Signing page if this is your desired option ([Signing - Cosmos](signing-cosmos.md), [Signing - Ethereum](signing-ethereum.md), [Signing - Solana](signing-solana.md), [Signing - Bitcoin](signing-bitcoin.md)).


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/sign-+-broadcast-bitbadges.io.md

# Sign + Broadcast - bitbadges.io

**Option 1: Copy / Paste**

To broadcast a Msg using this [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast) user interface, all you have to do is to copy and paste the Msg contents into the text box. You should have the **txn** object from prior pages in this tutorial. Or, you can start with the samples provided and customize from there.

**Option 2: Redirect**

Or, if you are wanting to redirect to this page, you can pass in the stringified URL **txsInfo** query param, which will be auto-populated. It is expected to be a JSON stringified TxInfo\[].

```typescript
export interface TxInfo {
  type: string, //'MsgCreateCollection'
  msg: object, //JSON stringified message
}
```

This transaction builder ONLY deals with the Msg contents and not anything about the transaction context (handled by the site behind the scenes). The interface will provide you with default examples. Make sure all properties align and no extra properties like account\_number, sequence, etc are pasted. These are handled behind the scenes.

If you open via a popup, such as below, it will pass back the txHash via a window callback and auto-close upon success.

```typescript
import { proto } from 'bitbadgesjs-sdk';

const MsgCreateProtocol = proto.protocols.MsgCreateProtocol;
const msgCreateProtocol = new MsgCreateProtocol({
  "name": "Test",
  "uri": "https://www.youtube.com/watch?v=5qap5aO4i9A",
  "customData": "Test",
  "isFrozen": false,
  "creator": chain.bitbadgesAddress
})
const url = 'https://bitbadges.io/dev/broadcast?txsInfo=[{ "type": "MsgCreateProtocol", "msg": ' + msgCreateProtocol.toJsonString() + ' }]';
const openedWindow = window.open(url, '_blank', 'location=yes,height=570,width=520,scrollbars=yes,status=yes');

setLoading(true);
// You can further customize the child window as needed
openedWindow?.focus();

//set listener for when the child window closes
const timer = setInterval(() => {
  if (openedWindow?.closed) {
    clearInterval(timer);
    setLoading(false);
  }
}, 1000);
```

<pre class="language-typescript"><code class="lang-typescript"><strong>// bitbadges.io code
</strong><strong>if (window.opener) {
</strong>    window.opener.postMessage({ type: 'txSuccess', txHash: txHash }, '*');
    window.close();
}
</code></pre>

```typescript
//https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage
const FRONTEND_URL = 'https://bitbadges.io';
const handleChildWindowMessage = async (event: MessageEvent) => {

  if (event.origin === FRONTEND_URL) {

    if (!event.source) {
      throw new Error('Event source is null');
    }

    const txHash = event.data.txHash;
    if (!txHash) {
      //To avoid the listening to self events if we are actually on bitbadges.io and just an overall quality check
      return
    }


    setLoading(false);
  }
};

// Add a listener to handle messages from the child window
useEffect(() => {
  window.addEventListener('message', handleChildWindowMessage);

  // Cleanup the listener when the component unmounts
  return () => {
    window.removeEventListener('message', handleChildWindowMessage);
  };
}, []);
```

<figure><img src="../../../.gitbook/assets/image (7) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-bitcoin.md

# Signing - Bitcoin

**Signing with Bitcoin - Phantom Wallet**

Using the payload / context obtained from previous steps. We use the **jsonToSign** field and sign it as a personal signMessage using phantom wallet.

```typescript
const getProvider = () => {
  if ('phantom' in window) {
    const phantomWindow = window as any;
    const provider = phantomWindow.phantom?.bitcoin;
    if (provider?.isPhantom) {
      return provider;
    }

    window.open('https://phantom.app/', '_blank');
  }
};

function bytesToBase64(bytes: Uint8Array) {
  const binString = String.fromCodePoint(...bytes);
  return btoa(binString);
}

const signTxn = async (context: ExternalTxContext, payload: TransactionPayload, messages: any[], simulate: boolean) => {
    const bitcoinProvider = getProvider();

    let sig = '';
    if (!simulate) {
      const message = payload.txnString;
      const encodedMessage = new TextEncoder().encode(message);
      const signedMessage = await bitcoinProvider.signMessage(address, encodedMessage);

      const base64Sig = bytesToBase64(signedMessage.signature);
      sig = Buffer.from(base64Sig, 'base64').toString('hex');
    }

    const txBody = createTxBroadcastBody(context, messages, sig);
    return txBody;
};
```

## Output

This will leave you with a variable which is to be submitted to a running blockchain node. See [Broadcast to a Node.](broadcast-to-a-node.md)


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-cosmos.md

# Signing - Cosmos

Pre-Requisite: You have generated the transaction context, payload, and Msgs (see prior pages).

#### Signing with Keplr

```ts
const signTxn = async (
    context: TxContext,
    payload: TransactionPayload,
    protoMsgs: any[],
    simulate: boolean
) => {
    if (!account) {
        throw new Error('Account does not exist');
    }
    const { sender } = context;
    await window.keplr?.enable(chainId);

    let signatures = [new Uint8Array(Buffer.from('0x', 'hex'))];
    if (!simulate) {
        const signResponse = await window?.keplr?.signDirect(
            chainId,
            sender.address,
            {
                bodyBytes: payload.signDirect.body.toBinary(),
                authInfoBytes: payload.signDirect.authInfo.toBinary(),
                chainId: chainId,
                accountNumber: new Long(sender.accountNumber),
            },
            {
                preferNoSetFee: true,
            }
        );

        if (!signResponse) {
            throw new Error('No signature returned from Keplr');
        }

        signatures = [
            new Uint8Array(
                Buffer.from(signResponse.signature.signature, 'base64')
            ),
        ];
    }

    const hexSig = Buffer.from(signatures[0]).toString('hex');

    const txBody = createTxBroadcastBody(context, protoMsgs, hexSig);
    return txBody;
};
```

### Output

This will leave you with a variable which is to be submitted to a running blockchain node. See [Broadcast to a Node.](broadcast-to-a-node.md)


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-ethereum.md

# Signing - Ethereum

Pre-Requisite: You have generated the transaction context, payload, and Msgs (see prior pages).

You can simply sign the **payload.txnString** with a personal\_sign. below, we use wasgmi's signMessageAsync but you can replace this with any wallet's implementation of personal\_sign.

```typescript
const signTxn = async (context: ExternalTxContext, payload: TransactionPayload, messages: any[], simulate: boolean) => {
  const sig = simulate
    ? ''
    : await signMessageAsync({
        message: payload.txnString
      });
 
  const txBody = createTxBroadcastBody(context, messages, sig);
  return txBody;
};
```

## Output

This will leave you with a variable which is to be submitted to a running blockchain node. See [Broadcast to a Node.](broadcast-to-a-node.md)


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-solana.md

# Signing - Solana

Pre-Requisite: You have generated the transaction context, payload, and Msgs (see prior pages).

**Signing with Solana - Phantom Wallet**



Phantom / Solana do not allow message signatures > \~1000 bytes. To workaround this, we allow signing the SHA256 hash of the JSON in cases where payload.jsonToSign.length > 1000.

```typescript
const getProvider = () => {
    if ('phantom' in window) {
        const phantomWindow = window as any;
        const provider = phantomWindow.phantom?.solana;
        if (provider?.isPhantom) {
            return provider;
        }

        window.open('https://phantom.app/', '_blank');
    }
};

const signTxn = async (context: ExternalTxContext, payload: TransactionPayload, messages: any[], simulate: boolean) => {
  if (!account) throw new Error('Account not found.');

  let sig = '';
  if (!simulate) {
    //Phantom has a weird error where messages must be < ~1000 bytes
    //If we are within limit, we can have user sign the JSON
    //Else, we hash the JSON and have user sign the hash
    const encodedMessage = new TextEncoder().encode(payload.txnString);

    const signedMessage = await getProvider().request({
      method: 'signMessage',
      params: {
        message: encodedMessage,
        display: 'utf8'
      }
    });
    sig = signedMessage.signature.toString('hex');
  }

  //We need to pass in solAddress manually here
  const txBody = createTxBroadcastBody(context, messages, sig, address);
  return txBody;
};
```

## Output

This will leave you with a variable which is to be submitted to a running blockchain node. See [Broadcast to a Node.](broadcast-to-a-node.md)


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/transaction-context.md

# Transaction Context

You have two options for generating, signing, and brodcasting messages.

1. Use [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast) - This is a visual UI that you can simply copy and paste your transaction Msg contents into or provide them in the URL parameters. Generating all additional transaction details, gas, fees, and signing is all outsourced to the user interface. This is the recommended option if you do not require programmatically submitting TXs.
2. Generate, sign, and broadcast directly to a running blockchain node. This is more technical and has more steps but can be done programmatically.

If you plan to use Option 1, you may proceed to the next page because generating the transaction context is already handled via the user interface.

If you plan to use option 2, see below.

### Generating Transaction Context

The first step is to fetch and identify the transaction context and the account details for who is going to sign. You will need the following information below.

Pre-Reqs: For a user who has not yet interacted with the blockchain, the fetched public key will be null and accountNumber will be -1. To get an account number, they need to receive BADGE somehow (this is also a pre-requisite to pay for any fees).

```typescript
import { createTxMsgSend, SupportedChain } from 'bitbadgesjs-sdk';

//TODO: Fetch the account details (see below)

//Pre-Reqs: Ensure users are registered (i.e. have a valid account number) or else this will fail
const txContext = {
    testnet: false,
    sender: {
        //Must be in native format ('0xabc..' vs 'bc1...' etc)
        address: account.address,
        sequence: account.sequence,
        accountNumber: account.accountNumber,
        //Public key is only needed for Cosmos native signatures (see below). '' if non-Cosmos
        publicKey: account.publicKey,
    },
    //TODO: adjust accordingly
    fee: {
        amount: `0`,
        denom: 'ubadge',
        gas: `400000`,
    },
    memo: '',
};
```

**Get Public Key - Cosmos**

For Keplr / Cosmos, you will need to specify the public key in the txContext. You can simply use getKey() then convert to base64.

Note: It will also be returned with the account details from the BitBadges API (if the user has interacted with the chain before via a signature).

```typescript
const getPublicKey = async () => {
    const account = await window?.keplr?.getKey('bitbadges-1');
    if (!account) return '';
    return Buffer.from(account.pubKey).toString('base64');
};
```

**Fee**

Generating the fee can be tricky. It should be reasonable for the current gas prices but also not too expensive. To get the **gas**, we recommend simulating the transaction right before broadcasting to see how much gas it uses on a dry run. We will walk you through how to do this in the broadcast tutorial. You can also fetch the estimated gas prices via the BitBadgesApi.getStatus() route.

**Sender Details**

To fetch a user's account details, the easiest way is to use the routes from the BitBadges API in [API Documentation](../../bitbadges-api/). You can also query a node directly.

This will return the user's BitBadges address, account ID, sequence (nonce), and public key. If the user has previously interacted with the blockchain, all this information will already be populated.

<figure><img src="../../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/bitbadges-blockchain/overview.md

# Overview

BitBadges offers an L1 delegated proof-of-stake blockchain built with [Cosmos SDK](https://docs.cosmos.network/main). The blockchain is able to attain instant transaction finality using Tendermint and natively supports users from multiple Layer 1 blockchains (Ethereum, Bitcoin, Cosmos, Solana) via IBC and account lists.

The source code can be found at [https://github.com/bitbadges/bitbadgeschain](https://github.com/bitbadges/bitbadgeschain).&#x20;

BitBadges defines its official metadata, IBC connections, and more in the Cosmos chain registry at  [https://github.com/cosmos/chain-registry](https://github.com/cosmos/chain-registry).

Other Links

[https://explorer.bitbadges.io](https://explorer.bitbadges.io/)

[https://rpc.bitbadges.io](https://rpc.bitbadges.io)

[https://lcd.bitbadges.io](https://lcd.bitbadges.io)



## File: ./for-developers/bitbadges-blockchain/run-a-mainnet-node.md

# Run a Mainnet Node

Running a node is the same as any other Cosmos SDK chain. If you encounter any issues during the setup process, you can also refer to other Cosmos SDK node documentation, such as "[Cosmos SDK - Running a Node](https://docs.cosmos.network/main/user/run-node/run-node)" or "[Cosmos Tutorials - Run in Production documentation](https://tutorials.cosmos.network/tutorials/9-path-to-prod/1-overview.html)."&#x20;

Below are some links to get you started. If you are unfamiliar with setup, I'd recommend following a guide and/or asking for help in the #validators channel of our Discord. We have plenty of great validators maintaining the network, and many have detailed guides to help you get started. LLMs are also a good resource and can help you get set up.

Note that as a validator, you are responsible for the security of the network. Take necessary precautions for uptime and security in order to avoid slashing or losing staked funds.

**Discord**

Our main communication method is via Discord:

* \#validators channel is a great resource for help. Ping @trevormil to give you the Validator role.
* \#announcements and #chain-upgrades are where we announce the latest plans to upgrade. We use the x/upgrade module from Cosmos SDK. We recommend Cosmovisor for handling upgrades.

**Guides + Setup w/ Snapshots**

* [https://docs.provewithryd.xyz/mainnet/bitbadges/network-overview](https://docs.provewithryd.xyz/mainnet/bitbadges/network-overview)
* [https://nodestake.org/bitbadges](https://nodestake.org/bitbadges)
* Note that most validators have their own guides. Choose whichever one works best for you.

**Releases / Instructions**

* [https://github.com/BitBadges/bitbadgeschain/releases](https://github.com/BitBadges/bitbadgeschain/releases)

**Genesis File**

* [https://github.com/BitBadges/bitbadgeschain/blob/master/genesis-711316.json](https://github.com/BitBadges/bitbadgeschain/blob/master/genesis-711316.json) (Note this is post 711316 hard fork)

**Explorer**

* [https://explorer.bitbadges.io/BitBadges%20Mainnet/staking](https://explorer.bitbadges.io/BitBadges%20Mainnet/staking)

**BitBadges RPC**

* https://rpc.bitbadges.io

**Running a Relayer?**

* See the official IBC connections in the Cosmos chain registry that we support.

**Configuration**

Most node parameters are flexible and you can set up according to your preferences. Here are some that should be the same as the rest of the network.&#x20;

* chain\_id: bitbadges-1
* timeout\_commit: 2s


## File: ./for-developers/bitbadges-blockchain/staking-usdbadge.md

# Staking / Validators

## **Staking**

The BitBadges blockchain is a [delegated proof-of-stake blockchain](https://101blockchains.com/proof-of-stake-vs-delegated-proof-of-stake/). Behind the scenes, this uses the [Cosmos SDK staking](https://docs.cosmos.network/main/modules/staking) module. To stake, visit [https://bitbadges.io/stake](https://bitbadges.io/stake) or our explorer.

## **Governance**

For important decisions, we use the Cosmos governance proposal module. Validators vote on decisions according to their voting power.

[https://explorer.bitbadges.io/BitBadges%20Mainnet/gov](https://explorer.bitbadges.io/BitBadges%20Mainnet/gov)


## File: ./for-developers/bitbadges-blockchain/supported-denoms.md

# Supported Denoms

BitBadges implements an allowlist for supported denominations that you can use within the token standard on its chain.

```typescript
export const MAINNET_COINS_REGISTRY: Record<string, CoinDetails> = {
  ubadge: {
    skipGoSupported: true,
    label: 'BADGE',
    symbol: 'BADGE',
    decimals: '9',
    baseDenom: 'ubadge',
    image: 'https://github.com/cosmos/chain-registry/blob/master/bitbadges/images/badge_logo.png?raw=true'
  },
  'badges:49:chaosnet': {
    skipGoSupported: false,
    label: 'CHAOS',
    symbol: 'CHAOS',
    decimals: '9',
    baseDenom: 'badges:49:chaosnet',
    image: 'https://bitbadges.io/_next/image?url=https%3A%2F%2Fbitbadges-ipfs.infura-ipfs.io%2Fipfs%2FQmdRQUvQBo6p24RQ7AS7RD6srqyUjoHJ5Cjs4p22zie9bQ&w=1920&q=75'
  },
  'ibc/F082B65C88E4B6D5EF1DB243CDA1D331D002759E938A0F5CD3FFDC5D53B3E349': {
    skipGoSupported: true,
    label: 'USDC',
    symbol: 'USDC',
    decimals: '6',
    baseDenom: 'ibc/F082B65C88E4B6D5EF1DB243CDA1D331D002759E938A0F5CD3FFDC5D53B3E349',
    image: 'https://github.com/cosmos/chain-registry/blob/master/noble/images/USDCoin.png?raw=true'
  },
  'ibc/A4DB47A9D3CF9A068D454513891B526702455D3EF08FB9EB558C561F9DC2B701': {
    skipGoSupported: true,
    label: 'ATOM',
    symbol: 'ATOM',
    decimals: '6',
    baseDenom: 'ibc/A4DB47A9D3CF9A068D454513891B526702455D3EF08FB9EB558C561F9DC2B701',
    image: 'https://github.com/cosmos/chain-registry/blob/master/cosmoshub/images/atom.png?raw=true'
  },
  'ibc/ED07A3391A112B175915CD8FAF43A2DA8E4790EDE12566649D0C2F97716B8518': {
    skipGoSupported: true,
    label: 'OSMO',
    symbol: 'OSMO',
    decimals: '6',
    baseDenom: 'ibc/ED07A3391A112B175915CD8FAF43A2DA8E4790EDE12566649D0C2F97716B8518',
    image: 'https://github.com/cosmos/chain-registry/blob/master/osmosis/images/osmo.png?raw=true'
  }
};
```


## File: ./for-developers/bitbadges-blockchain/testnet-mode.md

# Testnet Mode

Testnet mode provides a separate environment for testing purposes. Simply turn on the switch (or go to [testnet.bitbadges.io](https://testnet.bitbadges.io)). It is isolated from the production environment of BitBadges and uses its own resources, such as a testnet blockchain, database, API, and more.

<pre><code><strong>Note: Third-party integrations (e.g. claim plugins) are the exact same.
</strong></code></pre>

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Important Notes

You should treat testnet as an entirely SEPARATE service. NOTHING will carry over from normal mode (not even profiles, badges, settings, anything). Consider this before determining whether testnet mode is the correct option for you.

### Differences

* Some features available in production may not be accessible in testnet:
  * Off-chain balances managed by BitBadges are not hosted externally (via CDN)
  * Buying BADGE credits
  * Push notifications
  * And more
* Some restrictions may be more relaxed
  * No API keys required
  * Faucet may be more lenient
* Performance also may differ from the production environment

### Links

Frontend: [https://testnet.bitbadges.io](https://testnet.bitbadges.io)

Backend: [https://api.bitbadges.io/testnet](https://api.bitbadges.io/testnet) (append the normal routes to this base URL)

Testnet Node:

* RPC: [https://testnet.node.bitbadges.io/rpc](https://testnet.node.bitbadges.io/rpc)
* REST: [https://testnet.bitbadges.io/api](https://testnet.bitbadges.io/api)
* Direct Node Access: `http://138.197.10.8:YOUR_PORT`

### Feedback

If there is anything we can do to make development easier, let us know.


## File: ./for-developers/bitbadges-sdk/README.md

# ⚒ BitBadges SDK



## File: ./for-developers/bitbadges-sdk/common-snippets/README.md

# Common Snippets

In this section, we provide common snippets and examples for the SDK. Some of these were auto-generated with AI, so please let us know if there are issues.


## File: ./for-developers/bitbadges-sdk/common-snippets/address-conversions.md

# Address Conversions

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> Address Utils

```ts
import { convertToBitBadgesAddress, convertToBtcAddress, convertToEthAddress } from "bitbadgesjs-sdk"

let address = convertToBitBadgesAddress("0x14574a6DFF2Ddf9e07828b4345d3040919AF5652")
// "bb1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw"

let address = convertToEthAddress("bb1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw")
// "0x14574a6DFF2Ddf9e07828b4345d3040919AF5652"
```


## File: ./for-developers/bitbadges-sdk/common-snippets/address-lists.md

# Address Lists

AddressLists are the base type for lists. The BitBadgesAddressList class you see returned from the API extends this. Learn more about lists in the core concepts.

```typescript
const list = new AddressList({
  addresses: ['bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh'],
  whitelist: true,
  customData: '',
  uri: '',
  createdBy: 'bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh',
  listId: 'abc123',
})

const isInList = list.checkAddress('bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh') // true
const invertedList = list.toInverted()
const isInListNow = invertedList.checkAddress('bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh') // false

list.remove('bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh')
const isEmpty = list.isEmpty()


const MintList = AddressList.Reserved('Mint')
const All = AddressList.AllAddresses();
```


## File: ./for-developers/bitbadges-sdk/common-snippets/badge-metadata.md

# Token Metadata

#### Tutorial: Managing Token Metadata in TypeScript

**1. Introduction to `BadgeMetadataDetails`**

The `BadgeMetadataDetails` type captures comprehensive details about the metadata of a token. It contains fields such as token IDs (ranges), associated metadata, a URI, and custom data. This is what is used via the **cachedBadgeMetadata** field from collection responses.

**2. Removing Metadata for Specific Token IDs**

To delete metadata associated with specific token IDs:

```typescript
const currentMetadata: BadgeMetadataDetails<bigint>[] = [...]; // your current metadata array

const badgeIdsToRemove = UintRangeArray.From([
  { start: 5n, end: 10n }
];

const updatedMetadata = removeBadgeMetadata(currentMetadata, badgeIdsToRemove);
console.log(updatedMetadata); // This will show metadata without the removed token IDs.
```

**3. Updating Metadata for Tokens**

If you wish to update specific token metadata in the token metadata details:

```typescript
const currentMetadata: BadgeMetadataDetails<bigint>[] = [...]; // your current metadata array

const metadataToUpdate: BadgeMetadataDetails<bigint> = new BadgeMetadataDetails<bigint>({
  badgeIds: [{ start: 7n, end: 7n }],
  metadata: { /* your metadata details here */ },
  uri: "http://new-metadata-url.com", //Or 'Placeholder' or something else
  customData: "Some custom information",
});

const newMetadataArray = updateBadgeMetadata(currentMetadata, metadataToUpdate);
console.log(newMetadataArray); // This will show the array with the updated metadata.
```

**4. Fetch Metadata Details for a Specific Token ID**

To retrieve metadata details for a particular token ID:

```typescript
const badgeIdToFetch = 12n;

const badgeMetadataDetails = getMetadataDetailsForBadgeId(badgeIdToFetch, currentMetadata);
console.log(badgeMetadataDetails); // This will display the metadata details for the specified token ID.
```

**5. Fetch Only the Metadata for a Specific Token ID**

To only retrieve the metadata (without the surrounding details) for a particular token ID:

```typescript
const badgeIdToFetch = 15n;

const badgeMetadata = getMetadataForBadgeId(badgeIdToFetch, currentMetadata);
console.log(badgeMetadata); // This will show only the metadata for the given token ID.
```

**Conclusion**

These functions provide a robust toolkit for managing token metadata. Whether you're updating, fetching, or deleting metadata associated with tokens, you have a systematic and structured approach available.


## File: ./for-developers/bitbadges-sdk/common-snippets/balances.md

# Balances

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> Balances

### Tutorial: Using the TypeScript SDK for Balance Operations

**1. Define the Balance**

Here's how you create a balance using the provided `Balance` interface:

<pre class="language-typescript"><code class="lang-typescript"><strong>const userBalance = BalanceArray.From([{
</strong>  "amount": 5n, // example amount using the BigInt type
  "badgeIds": [{ start: 1n, end: 5n }],
  "ownershipTimes": [{ start: 1628770800000n, end: 1628857200000n }] // example timestamps using BigInt
}])
</code></pre>

Note: The `UintRange` type is assumed to be an object with `start` and `end` properties of type `bigint`. Adjust as necessary based on the actual definition.

**2. Add Balance**

To add a balance to an array of existing balances:

```typescript
const balanceToAdd = {
    amount: 3n,
    badgeIds: [{ start: 6n, end: 8n }],
    ownershipTimes: [{ start: 1628860800000n, end: 1628947200000n }],
};
userBalance.addBalances([balanceToAdd]);
```

This will add `balanceToAdd` to the list of existing balances.

**3. Subtract Balance**

To subtract a balance from an array of existing balances:

```typescript
const balanceToRemove = {
    amount: 2n,
    badgeIds: [{ start: 2n, end: 3n }],
    ownershipTimes: [{ start: 1628784400000n, end: 1628870800000n }],
};
userBalance.subtractBalances([balanceToRemove], false); //second param is to allow underflow (negatives)
```

**Conclusion**

This SDK provides a clear and structured way to manage and operate on balances. With the `addBalance` and `subtractBalance` functions, you can effortlessly update and maintain balances in your application.\
\
Given the new functions you've shared, I'll provide a tutorial snippet for each of them.

### Tutorial: Retrieving Balances Based on Token ID and Time

**1. Get Balance for a Specific ID and Time**

If you need to retrieve the balance for a specific token ID and a specific ownership time, you can use the `getBalanceForIdAndTime` function:

```typescript
const badgeIdToLookup = 3n;
const timeToLookup = 1628784400000n; // example timestamp using BigInt
const specificBalance = balances.getBalanceForIdAndTime(
    badgeIdToLookup,
    timeToLookup
);

console.log(specificBalance); // This will show the balance for the specified token ID and time, if found.
```

**2. Get Balances for a Specific Token ID**

To get all balances associated with a specific token ID:

```typescript
const badgeIdToLookup = 4n;
const balances = balances.getBalancesForId(badgeIdToLookup);

console.log(balances); // This will display all the balances for the given token ID.
```

**3. Get Balances for a Specific Time**

If you need to retrieve all balances for a specific ownership time:

```typescript
const timeToLookup = 1628784400000n;
const timeSpecificBalances = balances.getBalancesForTime(timeToLookup);

console.log(timeSpecificBalances); // This will show all the balances that have the specified ownership time.
```

Alright, given the new function `getBalancesForIds` which retrieves balances for a range of token IDs and a range of times, let's create a tutorial snippet for it:

4. **Get Balances for Specific Ranges of Token IDs and Times**

If you need to retrieve balances for a range of token IDs and a range of ownership times, you can utilize the `getBalancesForIds` function:

```typescript
// Define the range of token IDs and times you want to look up
const idRangesToLookup = [
    { start: 1n, end: 3n },
    { start: 5n, end: 7n },
];

const timeRangesToLookup = [
    { start: 1628770800000n, end: 1628857200000n }, // example timestamp range using BigInt
    { start: 1628943600000n, end: 1629030000000n }, // another timestamp range
];

// Retrieve the balances
const specificBalances = balances.getBalancesForIds(
    idRangesToLookup,
    timeRangesToLookup
);
console.log(specificBalances); // This will show the balances that fall within the specified token ID ranges and time ranges.
```

**Conclusion**

The provided functions in this SDK make it easy to retrieve specific balances based on different criteria, such as token ID and ownership time. Utilize these functions to access and display relevant data as per your application's requirements.


## File: ./for-developers/bitbadges-sdk/common-snippets/get-unhandled-approvals.md

# Approvals / Transferability

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> Approvals / Transferability

You can use the following functions to get the approval combinations that have unhandled. If unhandled, they are disapproved.

```typescript
export function getUnhandledCollectionApprovals(
  collectionApprovals: CollectionApprovalWithDetails<bigint>[],
  ignoreTrackerIds?: boolean
  doNotMerge?: boolean
)
```

```typescript
export function getUnhandledUserOutgoingApprovals(
  approvals: UserOutgoingApprovalWithDetails<bigint>[],
  userAddress: string,
  doNotMerge?: boolean
)
```

```typescript
export function getUnhandledUserIncomingApprovals(
  approvals: UserIncomingApprovalWithDetails<bigint>[],
  userAddress: string,
  doNotMerge?: boolean
)
```

Use the following functions to add the default user approvals to an existing set of approvals. For incoming, this will be: if unhandled, approve only if to == initiatedBy. For outgoing, vice versa.

```typescript
export function appendSelfInitiatedOutgoingApproval(currApprovals: UserOutgoingApprovalWithDetails<bigint>[], userAddress: string): UserOutgoingApprovalWithDetails<bigint>[]
```

```typescript
export function appendSelfInitiatedIncomingApproval(currApprovals: UserIncomingApprovalWithDetails<bigint>[], userAddress: string): UserIncomingApprovalWithDetails<bigint>[] 
```


## File: ./for-developers/bitbadges-sdk/common-snippets/numbertype-conversions.md

# NumberType Conversions

A problem with creating a JavaScript SDK for a Cosmos SDK based blockchain is that JavaScript's number primitive cannot natively handle numbers > Number.MAX\_SAFE\_INTEGER, but the blockchain allows amounts greater than that.

To combat this, we have made all TypeScript types in the SDK generic via a NumberType interface.

```typescript
export type NumberType = bigint | number | string | boolean;
```

Types that you will find in the SDK that are number-based will all be generically typed, so that you can use any of the above NumberTypes, according to your preferences.

It is recommended that you use bigint and/or stringified because these can represent all possible numbers and do not lose precision. Also, note that for almost all SDK functions, we only take bigints.

For example, the following will represent a BadgeMetadata type where all numbers are stringified (i.e. "100" or "123").

```typescript
const stringifiedMetadata: BadgeMetadata<string> = new BadgeMetadata({ uri: ... });
```

**Converting Between NumberTypes**

To convert between different number types, all types come with a converter function (**.convert()**). This allows you to convert all the stringified numbers to another format (such as JS number or JS bigint). To convert, you can simply do the following:

```typescript
import { BigIntify, BadgeMetadata, JSPrimitiveNumberType, NumberType, convertBadgeMetadata } from "bitbadgesjs-sdk";

const stringifiedMetadata: BadgeMetadata<string> = new BadgeMetadata({ uri: ... });
const bigIntifiedMetadata = stringifiedBadgeMetadata.convert(BigIntify);
```

We export the following types and converter functions for your convenience.

```typescript
export type NumberType = bigint | number | string | boolean;
export type JSPrimitiveNumberType = string | number | boolean;

export const BigIntify = (item: NumberType) => numberify(item, StringNumberStorageOptions.BigInt) as bigint;
export const Stringify = (item: NumberType) => numberify(item, StringNumberStorageOptions.String) as string;
export const Numberify = (item: NumberType) => numberify(item, StringNumberStorageOptions.Number) as number;
export const NumberifyIfPossible = (item: NumberType) => numberify(item, StringNumberStorageOptions.NumberIfPossible) as number | string;
```

**Example Application**

In our API, JS bigints cannot be natively sent over HTTP. So, we use the following execution flow:

1. Before sending to the client, stringify everything before sending over HTTP
2. The client can use the converter functions to coonvert all types to their preferred method


## File: ./for-developers/bitbadges-sdk/common-snippets/timelines.md

# Timelines

As you may have noticed, many of the collection fields are timeline-based, meaning they can be scheduled to have different values at different times. Check out the [Timeline helpers](https://bitbadges.github.io/bitbadgesjs/functions/getCurrentValuesForCollection.html) from bitbadgesjs-sdk in the SDK.

**Examples:**

If you are using the BitBadgesCollection interface, this is achievable simply with the helper functions. There is one for every timeline.

```typescript
const manager = collection.getManager(); //Can pass in a time too (defaults to now)
```

Or, you can do it manually

<pre class="language-typescript"><code class="lang-typescript"><strong>const manager = getCurrentValuesForCollection(collection).manager;
</strong></code></pre>

<pre class="language-typescript"><code class="lang-typescript"><strong>const manager = getValuesAtTimeForCollection(collection, Date.now() + 1000 * 60).manager;
</strong></code></pre>

You can also get all possible values for timelines as such. This will set all missing times with empty or default values.

```typescript
function getFullManagerTimeline(
    timeline: ManagerTimeline<bigint>[]
): ManagerTimeline<bigint>[];
```

```typescript
function getFullCollectionMetadataTimeline(
    timeline: CollectionMetadataTimeline<bigint>[]
): CollectionMetadataTimeline<bigint>[];
```

And so on for all other timelines.


## File: ./for-developers/bitbadges-sdk/common-snippets/transfers-w-increments.md

# Transfers

The `TransferWithIncrements` type provides a convenient method for handling batch transfers, especially when you need to distribute tokens sequentially or when tokens have varying ownership times. By combining this with the `getBalancesAfterTransfers` function, you can effortlessly manage and update balances in your application.

```typescript
import {
    BalanceArray,
    TransferWithIncrements,
    getAllBadgeIdsToBeTransferred,
    getAllBalancesToBeTransferred,
} from '../packages/bitbadgesjs-sdk';

const startingBalances = BalanceArray.From([
    {
        amount: 100n,
        badgeIds: [{ start: 1n, end: 100n }],
        ownershipTimes: [{ start: 1628770800000n, end: 1628857200000n }],
    },
]);

const batchTransfer = new TransferWithIncrements<bigint>({
    from: 'Mint', // replace with your address

    balances: startingBalances,

    toAddresses: [], // this will be empty because we're using `toAddressesLength`
    toAddressesLength: 100n,

    incrementBadgeIdsBy: 1n,
    incrementOwnershipTimesBy: 86400000n, // assuming this is 1 day in milliseconds in BigInt form
});

const allBadgeIds = getAllBadgeIdsToBeTransferred([batchTransfer]); // returns [{ start: 1n, end: 100n }]
const allBalancesToBeTransferred = getAllBalancesToBeTransferred([
    batchTransfer,
]); // returns [{ amount: 100n, badgeIds: [{ start: 1n, end: 100n }], ownershipTimes: [{ start: 1628770800000n, end: 1628857200000n }] }
```


## File: ./for-developers/bitbadges-sdk/common-snippets/uint-ranges.md

# Uint Ranges

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> UintRanges



#### Tutorial: Managing and Querying Unsigned Integer Ranges

**1. Introduction to `UintRange`**

The `UintRange` interface captures a range of unsigned integers using a start and end property. This is handy when representing intervals or spans of values.

**2. Sorting and Merging Ranges**

To sort a list of ranges and merge adjacent or overlapping ones:

```typescript
const ranges = UintRangeArray.From([
  { start: 10n, end: 20n },
  { start: 5n, end: 12n },
  { start: 21n, end: 25n }
]);
ranges.sortAndMerge();

console.log(ranges); // Expected: [{ start: 5n, end: 25n }]
```

**3. Searching Within Ranges**

To search for a specific ID within a list of ranges and return its index and a boolean indicating if it was found:

```typescript
const idToSearch = 15n;
const [index, isFound] = ragnes.search(idToSearch)
console.log(`Index: ${index}, Found: ${isFound}`);
```

**4. Inverting Ranges**

To invert a list of ranges between a minimum and maximum ID:

<pre class="language-typescript"><code class="lang-typescript"><strong>ranges.invert(1n, 30n);
</strong>console.log(invertedRanges); // This would show the gaps between the given ranges within the specified bounds.
</code></pre>

**5. Removing One Range From Another**

To remove one range from another and also get the removed part:

```typescript
const rangesToRemove = [{ start: 10n, end: 20n }];

ranges.remove(rangesToRemove);
console.log("Remaining:", ranges);

const [inCurrButNotOther, overlaps, inOtherButNotCurr] = ranges.getOverlapDetails(rangesToRemove)
```

**6. Checking for Overlaps**

To determine if there are overlaps within a list of ranges:

```typescript
const overlaps = ranges.overlaps([{ ...}]);
console.log(`Ranges Overlap: ${overlappingCheck}`);
```

**Conclusion**

The functions provided offer a comprehensive toolkit for managing and querying unsigned integer ranges. Whether you're checking for overlaps, inverting ranges, or removing specific integers from a range, you now have the tools to do it efficiently and systematically.



```typescript
import { GO_MAX_UINT_64, UintRange, UintRangeArray } from 'bitbadgesjs-sdk'

//Singular range functions
const range = new UintRange<bigint>({ start: 1n, end: 10n })
const size = range.size() //10n
const fullRange = UintRange.FullRange() // 1n - GO_MAX_UINT_64
const isFull = fullRange.isFull()
const inverted = range.invert() // 11n - GO_MAX_UINT_64
const overlaps = range.overlaps(inverted) // false
const doesFiveExist = range.search(5n) // true
const overlapDetails = range.getOverlapDetails(fullRange) // [[], [{ start: 1n, end: 10n }], [{ start: 11n, end: GO_MAX_UINT_64 }]]
const overlappingRanges = range.getOverlaps(fullRange) // [{ start: 1n, end: 10n }]

const rangeArr = UintRangeArray.From<bigint>([{ start: 1n, end: 10n }, { start: 11n, end: 20n }])
const rangeArrSize = rangeArr.size() // 20n
const rangeArrFull = UintRangeArray.FullRanges() // 1n - GO_MAX_UINT_64
const rangeArrIsFull = rangeArrFull.isFull()
const rangeArrInverted = rangeArr.toInverted({ start: 1n, end: GO_MAX_UINT_64 }) // 21n - GO_MAX_UINT_64

const unsortedArr = UintRangeArray.From<bigint>([{ start: 11n, end: 20n }, { start: 1n, end: 15n }])
const hasOverlaps = unsortedArr.hasOverlaps() // true
unsortedArr.sortAndMerge() // [{ start: 1n, end: 20n }]

const sortedArr = unsortedArr.clone()
const [inCurrButNotOther, overlaps, inOtherButNotCurr] = sortedArr.getOverlapDetails(unsortedArr) // [[], [{ start: 1n, end: 20n }], []]

sortedArr.remove({ start: 1n, end: 10n }) // [{ start: 11n, end: 20n }]

const [idx, found] = sortedArr.search(11n) // [0n, true]
const exists = sortedArr.searchIfExists(11n) // true
const index = sortedArr.searchIndex(11n) // 0n
```


## File: ./for-developers/bitbadges-sdk/overview.md

# Overview

The BitBadges SDK is a bundle of TypeScript libraries that provide all the tools and functions needed for you to build your own frontend or interact with the BitBadges API, blockchain, and indexer.

GitHub: [https://github.com/bitbadges/bitbadgesjs](https://github.com/bitbadges/bitbadgesjs)

Full Documentation: [https://bitbadges.github.io/bitbadgesjs/](https://bitbadges.github.io/bitbadgesjs/)

```
npm install bitbadgesjs-sdk
```

This library provides miscellaneous functionality to help you interact with BitBadges, such as types, API routes, managing metadata requests, logic with ID ranges and balances, etc.


## File: ./for-developers/bitbadges-sdk/sdk-types.md

# SDK Types

### Custom Types

All types used in the SDK are exported via two ways.&#x20;

**Classes**

The first is via a JavaScript class. These will always begin with a capital letter. This class will always have the core functions below. Other specific functions may also be implemented.

```typescript
export declare class CustomTypeClass<T extends CustomType<T>> implements CustomType<T> {
    toJson(): JsonObject;
    toJsonString(): string;
    equals<U extends CustomType<U>>(other: CustomType<U> | null | undefined, normalizeNumberTypes?: boolean | undefined): boolean;
    clone(): T;
    getNumberFieldNames(): string[]; //Used behind the scenes
    convert<U extends NumberType>(_convertFunction?: (val: NumberType) => U): CustomType<any>;
}
```

The .convert() function is especially useful when dealing with different NumberTypes (bigint -> string).

```typescript
import { Balance, Numberify } 

const balance = new Balance<bigint>({
    amount: 1n,
    badgeIds: [{ start: 1n, end: 100n }],
    ownershipTimes: [{ start: 1n, end: 100n }]
})
const convertedBalance = balance.convert(Numberify); //1, 100 instead of 1n, 100n
```

**Interfaces**

The second is a JavaScript interface. This is the same as the class version minus all functions (just the core JSON object).

```typescript
export interface iBalance<T extends NumberType> {
    amount: T;
    badgeIds: iUintRange<T>[];
    ownershipTimes: iUintRange<T>[];
}
```

**Which one to use?**

Many functions support both; however, you may have to convert between them occasionally for compatibility. We recommend using the classes, but we recognize that many developers prefer the interfaces.&#x20;

### Typed Arrays

Some types also have a typed array exported as well. Similar to a Uint8Array in Javascript, these have all the features of traditional arrays. Thus, you can use .find, .map, .filter(), etc. Plus, additional functions will be available on them (e.g. array.addBalances for the BalanceArray type).&#x20;

```typescript
//Option 1
const balances = new BalanceArray()
balances.push(...)

//Option 2
const balances = BalanceArray.From([{ ... })

balances.addBalances([{ ... }]); //adds balances in-place
```

### **Proto Types**

The blockchain behind the scenes uses the Protocol Buffer type language. Within the SDK, we auto-generate all these proto types for you, but these are typically not the ones you should use in development (only when broadcasting transactions (see [here](../bitbadges-blockchain/create-and-broadcast-txs/))).&#x20;

Some might have duplicates between the two types.

```typescript
import { Balance } from "bitbadgesjs-sdk/dist/proto/balances";
import { Balance } from "bitbadgesjs-sdk";
```

The Proto types are exported via the following

```typescript
import { proto } from "bitbadgesjs-sdk";
const MsgCreateProtocol = proto.protocols.MsgCreateProtocol;
```

If you ever end up with something like the following, this is also the proto definition. We recommend using the proto.abc.xyz method to avoid confusion.

```typescript
import { MsgUpdateCollection } from "bitbadgesjs-sdk/dist/proto/badges";
```


## File: ./for-developers/bitbadges-x-ai/README.md

# 🪄 BitBadges x AI



## File: ./for-developers/bitbadges-x-ai/prompts/README.md

# Prompts

This directory contains boilerplate prompts for AI agents to effectively work with BitBadges technology.

## Available Prompts

### [Documentation Parsing and Context Setup](documentation-parsing.md)

A comprehensive guide for AI agents to parse and understand the BitBadges documentation structure. This prompt provides:

-   Complete documentation structure overview
-   Key files to reference for different topics
-   Instructions for cross-referencing related concepts
-   Response format guidelines
-   Examples of how to use documentation effectively

### [SDK Setup and Usage Guide](sdk-setup-and-usage.md)

A detailed guide for AI agents to help users with BitBadges SDK integration. This prompt covers:

-   SDK installation and setup
-   Core SDK components (types, arrays, proto types)
-   Common patterns and best practices
-   API integration examples
-   Troubleshooting common issues
-   Framework-specific integration examples

### [Signing a Transaction](signing-a-transaction.md)

A comprehensive guide for creating, funding, and signing transactions for the BitBadges blockchain using Ethereum-compatible wallets and the BitBadges SDK.

### [Collection Approval Builder](collection-approval-builder.md)

A comprehensive step-by-step guide for building BitBadges collection approval JSON templates. This prompt provides:

-   13-step approval building process
-   Reserved address list ID explanations
-   Detailed questions for each approval component
-   Complete JSON templates and examples
-   Common approval patterns (Mint, Transferable, Burnable)
-   Important validation and best practices

## Usage Instructions

These prompts are designed to be used as system prompts or context for AI agents working with BitBadges. They provide:

1. **Structured Information**: Well-organized sections covering different aspects of BitBadges
2. **Code Examples**: Practical code snippets and patterns
3. **Best Practices**: Guidelines for effective development
4. **Troubleshooting**: Common issues and solutions
5. **Cross-References**: Links to related documentation and resources

## Customization

These prompts can be customized based on specific use cases:

-   **Documentation Focus**: Use the documentation parsing prompt for questions about BitBadges concepts and features
-   **Development Focus**: Use the SDK setup prompt for implementation and coding questions
-   **Transaction Focus**: Use the signing prompt for blockchain interaction questions

## Integration

These prompts work well with:

-   **ChatGPT**: Use as system prompts for specialized BitBadges assistance
-   **Claude**: Provide context for BitBadges development questions
-   **Custom AI Agents**: Build specialized BitBadges AI assistants
-   **Documentation Bots**: Create automated documentation helpers


## File: ./for-developers/bitbadges-x-ai/prompts/collection-approval-builder.md

# AI Prompt Script: BitBadges Collection Approval Builder

## Overview

This script helps you build complete BitBadges collection approval JSON templates by asking targeted questions about your approval requirements. The script will generate a comprehensive `CollectionApproval` object with all necessary fields and criteria.

**Disclaimer**: This script is a work in progress and may not be fully functional. It is intended to be as a reference for getting started, not an end-to-end solution.

## Instructions for AI

You are a BitBadges approval configuration expert. Your task is to help users build complete collection approval JSON templates by asking targeted questions and generating comprehensive approval objects.

**IMPORTANT**: Always generate a complete JSON object that satisfies the `CollectionApproval` interface. Fill in all required fields and set optional fields to appropriate default values (empty arrays `[]`, `false` for booleans, `undefined` for optional objects).

## Reserved Address List IDs

BitBadges provides pre-generated shorthand address list IDs that should be used for common approval patterns. These are dynamically generated without storage overhead:

### Core Reserved Lists

-   **"Mint"**: Contains only the "Mint" address (for minting operations)
-   **"All"**: Represents all addresses including Mint (universal access)
-   **"AllWithoutMint"**: Represents all addresses except Mint (post-mint transfers)
-   **"None"**: Represents no addresses (blocking all access)

### Dynamic Patterns

-   **"AllWithout<addresses>"**: Blacklist pattern (e.g., "AllWithoutMint:bb1user123")
-   **"address1:address2:address3"**: Quick whitelist with colon-separated addresses
-   **"!listId"**: Inverts the behavior of a referenced list ID

### Usage Guidelines

-   Use reserved IDs for common patterns to minimize gas costs
-   Never mix "Mint" with other addresses in `fromListId`
-   Use "Mint" for minting operations only
-   Use "!Mint" or "AllWithoutMint" for post-mint transfers
-   Use colon-separated addresses for quick, small lists

## Step-by-Step Approval Builder

### Pre-Step: Generate Approval ID

First, generate a unique approval ID using UUID v4 or a descriptive identifier:

```json
{
    "approvalId": "uuid-generated-or-descriptive-id"
}
```

### Step 1: Address Lists (fromListId, toListId, initiatedByListId)

Ask the user about the three core address list requirements:

**Question 1.1**: Who should be able to **send** tokens in this approval?

-   Options: "Mint" (for minting only), "!Mint" (everyone except Mint), "AllWithoutMint" (everyone except Mint), specific addresses (excluding Mint), or custom list ID (excluding Mint)

**IMPORTANT**: The `fromListId` should NEVER include both "Mint" and other addresses in the same list. Choose one of:

-   "Mint" - for minting operations only
-   "!Mint" or "AllWithoutMint" - for all addresses except Mint
-   Specific addresses - for particular users (excluding Mint)
-   Custom list ID - for user-created lists (excluding Mint)

**Question 1.2**: Who should be able to **receive** tokens in this approval?

-   Options: "All" (everyone), "AllWithoutMint" (everyone except Mint), specific addresses, or custom list ID

**Question 1.3**: Who should be able to **initiate** transfers in this approval?

-   Options: "All" (anyone can initiate), specific addresses, or custom list ID

**Generate**:

```json
{
    "fromListId": "user-selected-sender-list",
    "toListId": "user-selected-receiver-list",
    "initiatedByListId": "user-selected-initiator-list"
}
```

### Step 2: Transfer Times (transferTimes)

**Question 2**: When should this approval be active? (UNIX milliseconds)

-   Options: "Always" (full range), specific time period, or multiple time periods

**Generate**:

```json
{
    "transferTimes": [
        {
            "start": "1",
            "end": "18446744073709551615"
        }
    ]
}
```

### Step 3: Overall Scope - Token IDs and Ownership Times

**Question 3.1**: Which token IDs should this approval cover? (This defines the overall scope - specific amounts and limits will be set later)

-   Options: "All" (full range), specific ranges, or individual IDs

**Question 3.2**: Which ownership times should this approval cover? (This defines the overall scope - specific amounts and limits will be set later)

-   Options: "All" (full range), specific time ranges, or current ownership times

**Note**: This step defines the **overall scope** of what this approval can potentially cover. The actual transfer amounts, limits, and thresholds will be configured in Steps 5-7 (Approval Amounts, Max Transfers, and Predetermined Balances).

**Generate**:

```json
{
    "badgeIds": [
        {
            "start": "1",
            "end": "18446744073709551615"
        }
    ],
    "ownershipTimes": [
        {
            "start": "1",
            "end": "18446744073709551615"
        }
    ]
}
```

### Step 4: Coin Transfers (coinTransfers)

**Question 4.1**: Should this approval automatically transfer tokens when used?

-   Options: "No", "Yes - specify token details"

**Question 4.2** (if Yes): What type of token should be transferred?

-   Options: "BADGE (ubadge)" (standard BitBadges token)

**Question 4.3** (if Yes): How much should be transferred?

-   Options: Specify amount in smallest unit (e.g., "1000000000" for 1 BADGE)

**Question 4.4** (if Yes): Who should receive the tokens?

-   Options: "Specific address", "Initiator of the transfer", "Approver address"

**Question 4.5** (if Yes): Who should pay for the tokens?

-   Options: "Initiator of the transfer", "Approver address (mint escrow)"

**Note**: Coin transfers are executed automatically every time this approval is used. For collection approvals, you can use the mint escrow address as the source (which holds collection funds) by setting `overrideFromWithApproverAddress: true`.

**Generate**:

```json
{
    "approvalCriteria": {
        "coinTransfers": [
            {
                "to": "bb1recipient...",
                "coins": [
                    {
                        "amount": "1000000000",
                        "denom": "ubadge"
                    }
                ],
                "overrideFromWithApproverAddress": false,
                "overrideToWithInitiator": false
            }
        ]
    }
}
```

**Example Configurations**:

**Simple Transfer**: Transfer 1 BADGE to a specific address

```json
{
    "to": "bb1alice...",
    "coins": [{ "amount": "1000000000", "denom": "ubadge" }],
    "overrideFromWithApproverAddress": false,
    "overrideToWithInitiator": false
}
```

**Initiator Pays**: Transfer 0.5 BADGE from the initiator to a specific address

```json
{
    "to": "bb1bob...",
    "coins": [{ "amount": "500000000", "denom": "ubadge" }],
    "overrideFromWithApproverAddress": false,
    "overrideToWithInitiator": false
}
```

**Collection Pays**: Transfer 2 BADGE from collection funds to the initiator

```json
{
    "to": "bb1initiator...",
    "coins": [{ "amount": "2000000000", "denom": "ubadge" }],
    "overrideFromWithApproverAddress": true,
    "overrideToWithInitiator": true
}
```

### Step 5: Approval Amounts and Transfer Limits

**Question 5.1**: Do you want to limit the total amount that can be transferred through this approval?

-   Options: "No limit", "Specific amount"

**Question 5.2**: Do you want to limit transfers per sender address?

-   Options: "No limit", "Specific amount per sender"

**Question 5.3**: Do you want to limit transfers per receiver address?

-   Options: "No limit", "Specific amount per receiver"

**Question 5.4**: Do you want to limit transfers per initiator address?

-   Options: "No limit", "Specific amount per initiator"

**Note**: Use "0" to indicate no limit for any of these fields. "0" means unlimited and will not be tracked.

**Generate**:

```json
{
    "approvalCriteria": {
        "approvalAmounts": {
            "overallApprovalAmount": "0",
            "perFromAddressApprovalAmount": "0",
            "perToAddressApprovalAmount": "0",
            "perInitiatedByAddressApprovalAmount": "0",
            "amountTrackerId": "approval-id"
        }
    }
}
```

### Step 6: Maximum Number of Transfers (STRONGLY RECOMMENDED)

**Question 6**: Do you want to limit the number of transfers (not amounts) that can be made through this approval?

-   Options: "No limit", "Specific number of transfers", "Let AI set a reasonable limit"

**⚠️ CRITICAL SANITY CHECK**: This step is **STRONGLY RECOMMENDED**, especially if coin transfers are configured in Step 4. Without transfer limits, users could potentially trigger unlimited coin transfers, which could drain funds.

**AI Logic**: If user doesn't specify or chooses "Let AI set a reasonable limit":

-   If coin transfers are configured: Set `overallMaxNumTransfers: "100"` and `perInitiatedByAddressMaxNumTransfers: "10"`
-   If no coin transfers: Set `overallMaxNumTransfers: "1000"` and `perInitiatedByAddressMaxNumTransfers: "100"`
-   Always set `perFromAddressMaxNumTransfers: "0"` and `perToAddressMaxNumTransfers: "0"` (unlimited per address)

**Note**: Use "0" to indicate no limit for any of these fields. "0" means unlimited and will not be tracked.

**Generate**:

```json
{
    "approvalCriteria": {
        "maxNumTransfers": {
            "overallMaxNumTransfers": "100",
            "perFromAddressMaxNumTransfers": "0",
            "perToAddressMaxNumTransfers": "0",
            "perInitiatedByAddressMaxNumTransfers": "10",
            "amountTrackerId": "approval-id"
        }
    }
}
```

### Step 7: Predetermined Balances (Alternative to Step 5)

**Question 7.1**: Do you want to use predetermined balances instead of amount thresholds?

-   Options: "No - use amount thresholds (Step 5)", "Yes - use predetermined balances"

**Note**: Steps 5 and 7 are typically **NOT used together**. Choose either:

-   **Step 5**: Amount thresholds (can't exceed limits) - "You can transfer up to X tokens"
-   **Step 7**: Predetermined balances (exact amounts) - "You must transfer exactly X tokens"

**Question 7.2** (if Yes): How do you want to define the balances?

-   Options: "Manual balances (exact amounts)", "Incremented balances (sequential patterns)"

**Question 7.3** (if Manual): How many different transfer amounts do you want to define?

-   Options: Specify number (e.g., "3" for three different transfer amounts)

**Question 7.4** (if Incremented): What type of increment pattern do you want?

-   Options: "Sequential token IDs", "Time-based increments", "Recurring intervals", "Custom increments"

**Question 7.5** (if Incremented): How should the order be calculated?

-   Options: "Overall transfer count", "Per recipient count", "Per sender count", "Per initiator count", "Merkle challenge index"

**Generate**:

```json
{
    "approvalCriteria": {
        "predeterminedBalances": {
            "manualBalances": [
                {
                    "amount": "1",
                    "badgeIds": [{ "start": "1", "end": "1" }],
                    "ownershipTimes": [
                        { "start": "1691978400000", "end": "1723514400000" }
                    ]
                }
            ],
            "incrementedBalances": {
                "startBalances": [
                    {
                        "amount": "1",
                        "badgeIds": [{ "start": "1", "end": "1" }],
                        "ownershipTimes": [
                            { "start": "1691978400000", "end": "1723514400000" }
                        ]
                    }
                ],
                "incrementBadgeIdsBy": "1",
                "incrementOwnershipTimesBy": "0",
                "durationFromTimestamp": "0",
                "allowOverrideTimestamp": false,
                "allowOverrideWithAnyValidBadge": false,
                "recurringOwnershipTimes": {
                    "startTime": "0",
                    "intervalLength": "0",
                    "chargePeriodLength": "0"
                }
            },
            "orderCalculationMethod": {
                "useOverallNumTransfers": true,
                "usePerToAddressNumTransfers": false,
                "usePerFromAddressNumTransfers": false,
                "usePerInitiatedByAddressNumTransfers": false,
                "useMerkleChallengeLeafIndex": false,
                "challengeTrackerId": ""
            }
        }
    }
}
```

**Example Configurations**:

**Manual Balances**: Three specific transfer amounts

```json
{
    "manualBalances": [
        {
            "amount": "1",
            "badgeIds": [{ "start": "1", "end": "1" }],
            "ownershipTimes": [
                { "start": "1691978400000", "end": "1723514400000" }
            ]
        },
        {
            "amount": "5",
            "badgeIds": [{ "start": "2", "end": "6" }],
            "ownershipTimes": [
                { "start": "1691978400000", "end": "1723514400000" }
            ]
        },
        {
            "amount": "10",
            "badgeIds": [{ "start": "7", "end": "16" }],
            "ownershipTimes": [
                { "start": "1691978400000", "end": "1723514400000" }
            ]
        }
    ]
}
```

**Sequential Token IDs**: Each transfer gets the next token ID

```json
{
    "incrementedBalances": {
        "startBalances": [
            {
                "amount": "1",
                "badgeIds": [{ "start": "1", "end": "1" }],
                "ownershipTimes": [
                    { "start": "1691978400000", "end": "1723514400000" }
                ]
            }
        ],
        "incrementBadgeIdsBy": "1"
    }
}
```

**Time-Based**: 30-day ownership from transfer time

```json
{
    "incrementedBalances": {
        "startBalances": [
            {
                "amount": "1",
                "badgeIds": [{ "start": "1", "end": "1" }],
                "ownershipTimes": [
                    { "start": "1691978400000", "end": "1723514400000" }
                ]
            }
        ],
        "durationFromTimestamp": "2592000000",
        "allowOverrideTimestamp": true
    }
}
```

**Recurring**: Monthly subscription with 7-day advance charging

```json
{
    "incrementedBalances": {
        "startBalances": [
            {
                "amount": "1",
                "badgeIds": [{ "start": "1", "end": "1" }],
                "ownershipTimes": [
                    { "start": "1691978400000", "end": "1723514400000" }
                ]
            }
        ],
        "recurringOwnershipTimes": {
            "startTime": "1691978400000",
            "intervalLength": "2592000000",
            "chargePeriodLength": "604800000"
        }
    }
}
```

**Important Notes**:

-   **Exact Match Required**: Transfers must match predetermined balances EXACTLY
-   **Order Numbers**: Use transfer count to determine which balance set to use
-   **Precalculation**: Use `precalculateBalancesFromApproval` to handle race conditions
-   **Boundary Handling**: Balances must work within approval's token ID and time bounds

### Step 8: Address Relationship Requirements

**Question 8.1**: Should the recipient address equal the initiator address?

-   Options: "No", "Yes"

**Question 8.2**: Should the sender address equal the initiator address?

-   Options: "No", "Yes"

**Question 8.3**: Should the recipient address NOT equal the initiator address?

-   Options: "No", "Yes"

**Question 8.4**: Should the sender address NOT equal the initiator address?

-   Options: "No", "Yes"

**Generate**:

```json
{
    "approvalCriteria": {
        "requireToEqualsInitiatedBy": false,
        "requireFromEqualsInitiatedBy": false,
        "requireToDoesNotEqualInitiatedBy": false,
        "requireFromDoesNotEqualInitiatedBy": false
    }
}
```

### Step 9: Override Settings

**Question 9.1**: Should this approval override the sender's outgoing approvals?

-   Options: "No", "Yes"

**Question 9.2**: Should this approval override the recipient's incoming approvals?

-   Options: "No", "Yes"

**Generate**:

```json
{
    "approvalCriteria": {
        "overridesFromOutgoingApprovals": false,
        "overridesToIncomingApprovals": false
    }
}
```

### Step 10: User Royalties

**Question 10.1**: Do you want to apply percentage-based transfer fees (royalties)?

-   Options: "No", "Yes - specify royalty percentage and recipient"

**Question 10.2** (if Yes): What percentage should be charged as royalty?

-   Options: Specify percentage in basis points (e.g., "500" for 5%, "250" for 2.5%)

**Question 10.3** (if Yes): Who should receive the royalty payments?

-   Options: "Specific address", "Creator address", "Collection owner"

**Note**: Royalties are expressed in basis points (1 = 0.01%, 100 = 1%, 10000 = 100%). Only one royalty can be applied per transfer.

**Generate**:

```json
{
    "approvalCriteria": {
        "userRoyalties": {
            "percentage": "500",
            "payoutAddress": "bb1creator..."
        }
    }
}
```

**Example Configurations**:

**5% Royalty**: Standard creator royalty

```json
{
    "userRoyalties": {
        "percentage": "500",
        "payoutAddress": "bb1creator..."
    }
}
```

**2.5% Platform Fee**: Lower platform fee

```json
{
    "userRoyalties": {
        "percentage": "250",
        "payoutAddress": "bb1platform..."
    }
}
```

### Step 11: Auto-Deletion Options

**Question 11.1**: Should this approval be automatically deleted after use?

-   Options: "No", "Yes - after one use", "Yes - after max transfers reached"

**Question 11.2** (if Yes): When should it be deleted?

-   Options: "After first use", "After overall max transfers reached", "Allow counterparty to purge", "Allow others to purge if expired"

**Note**: Auto-deletion helps manage approval lifecycle and prevents accumulation of unused approvals.

**Generate**:

```json
{
    "approvalCriteria": {
        "autoDeletionOptions": {
            "afterOneUse": false,
            "afterOverallMaxNumTransfers": false,
            "allowCounterpartyPurge": false,
            "allowPurgeIfExpired": false
        }
    }
}
```

**Example Configurations**:

**Single-Use Approval**: Delete after first transfer

```json
{
    "autoDeletionOptions": {
        "afterOneUse": true,
        "afterOverallMaxNumTransfers": false
    }
}
```

**Limited-Use Approval**: Delete after max transfers reached

```json
{
    "autoDeletionOptions": {
        "afterOneUse": false,
        "afterOverallMaxNumTransfers": true
    }
}
```

**Allow Counterparty Purge**: Let counterparty delete the approval

```json
{
    "autoDeletionOptions": {
        "afterOneUse": false,
        "afterOverallMaxNumTransfers": false,
        "allowCounterpartyPurge": true
    }
}
```

### Step 12: Metadata and Custom Data

**Question 12.1**: Do you want to add metadata URI for this approval?

-   Options: "No", "Yes - specify URI"

**Question 12.2**: Do you want to add custom data string?

-   Options: "No", "Yes - specify custom data"

**Generate**:

```json
{
    "uri": "",
    "customData": ""
}
```

### Step 13: Version Control

**Question 13**: What version number should this approval have?

-   Options: "0" (new approval), or specify version number

**Generate**:

```json
{
    "version": "0"
}
```

## Final Output Template

After collecting all user responses, generate the complete JSON:

```json
{
    "approvalId": "generated-or-user-specified-id",
    "fromListId": "user-selected-sender-list",
    "toListId": "user-selected-receiver-list",
    "initiatedByListId": "user-selected-initiator-list",
    "transferTimes": [
        {
            "start": "1",
            "end": "18446744073709551615"
        }
    ],
    "badgeIds": [
        {
            "start": "1",
            "end": "18446744073709551615"
        }
    ],
    "ownershipTimes": [
        {
            "start": "1",
            "end": "18446744073709551615"
        }
    ],
    "version": "0",
    "uri": "",
    "customData": "",
    "approvalCriteria": {
        "coinTransfers": [],
        "merkleChallenges": [],
        "mustOwnBadges": [],
        "predeterminedBalances": {
            "manualBalances": [],
            "incrementedBalances": {
                "startBalances": [],
                "incrementBadgeIdsBy": "0",
                "incrementOwnershipTimesBy": "0",
                "durationFromTimestamp": "0",
                "allowOverrideTimestamp": false,
                "allowOverrideWithAnyValidBadge": false,
                "recurringOwnershipTimes": {
                    "startTime": "0",
                    "intervalLength": "0",
                    "chargePeriodLength": "0"
                }
            },
            "orderCalculationMethod": {
                "useOverallNumTransfers": false,
                "usePerToAddressNumTransfers": false,
                "usePerFromAddressNumTransfers": false,
                "usePerInitiatedByAddressNumTransfers": false,
                "useMerkleChallengeLeafIndex": false,
                "challengeTrackerId": ""
            }
        },
        "approvalAmounts": {
            "overallApprovalAmount": "0",
            "perFromAddressApprovalAmount": "0",
            "perToAddressApprovalAmount": "0",
            "perInitiatedByAddressApprovalAmount": "0",
            "amountTrackerId": "approval-id"
        },
        "maxNumTransfers": {
            "overallMaxNumTransfers": "100",
            "perFromAddressMaxNumTransfers": "0",
            "perToAddressMaxNumTransfers": "0",
            "perInitiatedByAddressMaxNumTransfers": "10",
            "amountTrackerId": "approval-id"
        },
        "autoDeletionOptions": {
            "afterOneUse": false,
            "afterOverallMaxNumTransfers": false,
            "allowCounterpartyPurge": false,
            "allowPurgeIfExpired": false
        },
        "requireToEqualsInitiatedBy": false,
        "requireFromEqualsInitiatedBy": false,
        "requireToDoesNotEqualInitiatedBy": false,
        "requireFromDoesNotEqualInitiatedBy": false,
        "overridesFromOutgoingApprovals": false,
        "overridesToIncomingApprovals": false,
        "userRoyalties": {
            "percentage": "0",
            "payoutAddress": ""
        }
    }
}
```

## Common Approval Patterns

### Mint Approval

```json
{
    "fromListId": "Mint",
    "toListId": "All",
    "initiatedByListId": "All",
    "overridesFromOutgoingApprovals": true
}
```

### Transferable Approval (Post-Mint)

```json
{
    "fromListId": "!Mint",
    "toListId": "All",
    "initiatedByListId": "All"
}
```

### Alternative Transferable Approval

```json
{
    "fromListId": "AllWithoutMint",
    "toListId": "All",
    "initiatedByListId": "All"
}
```

### Burnable Approval

```json
{
    "fromListId": "!Mint",
    "toListId": "bb1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs7gvmv",
    "initiatedByListId": "All"
}
```

## Important Notes

1. **Tracker IDs**: Use the approval ID as the `amountTrackerId` for both approval amounts and max num transfers
2. **Version Control**: Start with version "0" for new approvals
3. **Overrides**: Mint approvals should typically override outgoing approvals
4. **Ranges**: Use full ranges `[1, 18446744073709551615]` for unlimited access
5. **Defaults**: Set unused criteria to empty arrays or false values
6. **Validation**: Ensure all UintRange values are within valid bounds (1 to MaxUint64)
7. **Address List Separation**: Never mix "Mint" with other addresses in `fromListId`. Use "Mint" for minting only, or "!Mint"/"AllWithoutMint" for all other addresses
8. **Zero Values**: Use "0" to indicate no limit in approval amounts and max num transfers. "0" means unlimited and will not be tracked

## Usage Instructions

1. Ask each question sequentially
2. Collect user responses
3. Generate appropriate JSON for each section
4. Combine all sections into final complete approval
5. Validate the final JSON structure
6. Provide the complete approval object to the user


## File: ./for-developers/bitbadges-x-ai/prompts/documentation-parsing.md

# Documentation Parsing and Context Setup

## BitBadges Documentation Analysis Prompt

You are an AI assistant specialized in BitBadges blockchain technology. You have access to the complete BitBadges documentation and should use it to provide accurate, contextual answers.

#### Live Documentation Access:

The BitBadges documentation is available online with two formats:

**URL Patterns:**

-   **Pretty UI**: `https://docs.bitbadges.io/[path]` (e.g., `https://docs.bitbadges.io/for-developers/bitbadges-sdk/overview`)
-   **Markdown Format**: `https://docs.bitbadges.io/[path].md` (e.g., `https://docs.bitbadges.io/for-developers/bitbadges-sdk/overview.md`)

**When to Use Live Documentation:**

-   Verify current SDK version and API changes
-   Access the latest code examples and patterns
-   Check for recent updates to type definitions
-   Troubleshoot with current documentation
-   Access documentation not in local copy

### Documentation Structure Overview

The BitBadges documentation is organized into several main sections:

#### 1. Overview Section

-   **Learn the Basics**: Core concepts like claims, multi-chain accounts, tokens, address lists, applications (points), subscriptions
-   **Token Concepts**: Manager, total supply, time-dependent ownership, transferability, balance types, protocol fees
-   **Wallets and Sign Ins**: Supported wallets, mobile support, approved transactors
-   **Use Cases**: Real-world applications and examples
-   **FAQ**: Common questions and answers

#### 2. For Developers Section

-   **Getting Started**: Initial setup and configuration
-   **BitBadges x AI**: AI integration tools and prompts
-   **BitBadges API**: Complete API reference with typed SDK types
-   **Sign In with BitBadges**: Multi-chain authentication solution
-   **BitBadges Claims**: Claim building, custom criteria, dynamic stores, plugins
-   **BitBadges JS/SDK**: TypeScript libraries for frontend development
-   **BitBadges Blockchain**: Technical blockchain details, node operation, transaction creation

#### 3. Badge Standard Section

-   **Concepts**: Core concepts like collections, balances, metadata, approvals, permissions
-   **Messages**: All blockchain message types (MsgCreateCollection, MsgTransferBadges, etc.)
-   **Queries**: Blockchain query methods
-   **Examples**: Practical examples and tutorials
-   **Events**: Blockchain events

### Key Documentation Files to Reference

When answering questions, prioritize these core documentation files:

1. **Main Overview**: `README.md` - High-level BitBadges introduction
2. **Getting Started**: `for-developers/getting-started.md` - Developer onboarding
3. **SDK Overview**: `for-developers/bitbadges-sdk/overview.md` - SDK capabilities
4. **API Reference**: `for-developers/bitbadges-api/api.md` - API documentation
5. **Token Concepts**: `x-badges/concepts/README.md` - Core concepts
6. **Common Snippets**: `for-developers/bitbadges-sdk/common-snippets/README.md` - Code examples

### Documentation Parsing Instructions

When a user asks a question:

1. **Identify the Topic**: Determine which section of the documentation is most relevant
2. **Reference Specific Files**: Use the table of contents to find the most relevant documentation files
3. **Provide Context**: Include relevant code snippets, examples, and explanations from the documentation
4. **Cross-Reference**: When appropriate, reference related concepts from other sections
5. **Use Examples**: Leverage the extensive examples provided in the documentation

### Live Documentation Access

The BitBadges documentation is available online at https://docs.bitbadges.io

**URL Patterns:**

-   **Pretty UI**: `https://docs.bitbadges.io/[path]` (e.g., `https://docs.bitbadges.io/for-developers/getting-started`)
-   **Markdown Format**: `https://docs.bitbadges.io/[path].md` (e.g., `https://docs.bitbadges.io/for-developers/getting-started.md`)

**When to Fetch Live Documentation:**

-   When local documentation is outdated or missing
-   To verify current API endpoints and parameters
-   To get the latest examples and code snippets
-   When troubleshooting with recent changes
-   To access documentation not available in the local copy

**Fetching Strategy:**

1. **Primary**: Use local documentation for faster responses
2. **Fallback**: Fetch from live docs when local content is insufficient
3. **Verification**: Cross-reference with live docs for critical information
4. **Updates**: Check live docs for recent changes or new features

### Example Usage

For questions about collection creation:

-   Reference: `x-badges/messages/msg-create-collection.md`
-   Cross-reference: `x-badges/examples/txs/msgcreatecollection/`
-   Include: Code examples from `for-developers/bitbadges-sdk/common-snippets/`

For questions about the API:

-   Reference: `for-developers/bitbadges-api/api.md`
-   Include: Typed SDK types from the API documentation
-   Cross-reference: `for-developers/bitbadges-sdk/sdk-types.md`

For questions about claims:

-   Reference: `for-developers/claim-builder/overview.md`
-   Include: Examples from `for-developers/claim-builder/concepts/`
-   Cross-reference: `for-developers/bitbadges-api/concepts/`

### Response Format

When answering questions:

1. **Direct Answer**: Provide a clear, concise answer based on the documentation
2. **Documentation References**: Include specific file paths and sections referenced
3. **Code Examples**: Include relevant code snippets when applicable
4. **Related Topics**: Suggest related documentation sections for further reading
5. **Context**: Explain how the answer fits into the broader BitBadges ecosystem

### Special Instructions

-   Always verify information against the actual documentation content
-   Use the most recent and relevant examples from the documentation
-   When code examples are provided, ensure they follow current SDK patterns
-   Reference the full documentation structure when explaining complex concepts
-   Provide links to related documentation sections when helpful

Remember: The BitBadges documentation is comprehensive and well-organized. Use it as your primary source of truth for all BitBadges-related questions.


## File: ./for-developers/bitbadges-x-ai/prompts/sdk-setup-and-usage.md

# BitBadges SDK Setup and Usage Guide

## SDK Integration and Type System Prompt

You are an AI assistant specialized in BitBadges SDK integration and development. You should help users understand and implement BitBadges functionality using the official SDK and provide guidance on best practices.

### SDK Overview

The BitBadges SDK (`bitbadgesjs-sdk`) is a comprehensive TypeScript library that provides:

-   **Type Definitions**: Complete TypeScript types for all BitBadges concepts
-   **API Integration**: Typed API client for BitBadges API endpoints
-   **Blockchain Interaction**: Tools for creating and broadcasting transactions
-   **Utility Functions**: Helper functions for common operations
-   **Conversion Tools**: Address and number type conversions

### Installation and Setup

```bash
npm install bitbadgesjs-sdk
```

### Core SDK Components

#### 1. Type System

The SDK provides two ways to work with types:

**Classes** (Recommended):

```typescript
import { Balance, Numberify } from 'bitbadgesjs-sdk';

const balance = new Balance<bigint>({
    amount: 1n,
    badgeIds: [{ start: 1n, end: 100n }],
    ownershipTimes: [{ start: 1n, end: 100n }],
});

// Convert between number types
const convertedBalance = balance.convert(Numberify); // 1, 100 instead of 1n, 100n
```

**Interfaces**:

```typescript
import { iBalance } from 'bitbadgesjs-sdk';

const balance: iBalance<bigint> = {
    amount: 1n,
    badgeIds: [{ start: 1n, end: 100n }],
    ownershipTimes: [{ start: 1n, end: 100n }],
};
```

#### 2. Typed Arrays

Special array types with additional functionality:

```typescript
import { BalanceArray } from 'bitbadgesjs-sdk';

const balances = new BalanceArray();
balances.push(balance1, balance2);

// Use array methods
balances.addBalances([balance3, balance4]); // Adds balances in-place
const filtered = balances.filter((b) => b.amount > 0n);
```

#### 3. Proto Types

For blockchain transactions:

```typescript
import { proto } from 'bitbadgesjs-sdk';

const MsgCreateCollection = proto.badges.MsgCreateCollection;
const MsgTransferBadges = proto.badges.MsgTransferBadges;
```

### Common SDK Patterns

#### Address Conversions

```typescript
import { convertToBitBadgesAddress, bitbadgesToEth } from 'bitbadgesjs-sdk';

// Convert Ethereum address to BitBadges address
const ethAddress = '0x1234...';
const bitbadgesAddress = convertToBitBadgesAddress(ethAddress);

// Convert back
const convertedBack = bitbadgesToEth(bitbadgesAddress);
```

#### Balance Management

```typescript
import { Balance, UintRange } from 'bitbadgesjs-sdk';

// Create a balance
const balance = new Balance<bigint>({
    amount: 1n,
    badgeIds: [new UintRange<bigint>({ start: 1n, end: 100n })],
    ownershipTimes: [new UintRange<bigint>({ start: 1n, end: 100n })],
});

// Convert to JSON
const jsonBalance = balance.toJson();
const jsonString = balance.toJsonString();

// Clone and compare
const clonedBalance = balance.clone();
const isEqual = balance.equals(clonedBalance);
```

#### API Integration

```typescript
import { BitBadgesAPI } from 'bitbadgesjs-sdk';

const api = new BitBadgesAPI({
    apiKey: 'your-api-key',
    baseUrl: 'https://api.bitbadges.io',
});

// Get collection
const collection = await api.getCollection({
    collectionId: '123',
});

// Get balance
const balance = await api.getBalance({
    collectionId: '123',
    address: 'bitbadges1...',
    badgeIds: [{ start: 1n, end: 100n }],
});
```

### Key SDK Files and References

#### Core Documentation Files:

1. **SDK Overview**: `for-developers/bitbadges-sdk/overview.md`

    - High-level SDK capabilities and installation
    - Basic usage examples

2. **SDK Types**: `for-developers/bitbadges-sdk/sdk-types.md`

    - Complete type system explanation
    - Class vs Interface usage
    - Number type conversions

3. **Common Snippets**: `for-developers/bitbadges-sdk/common-snippets/README.md`

    - Address conversions
    - Balance management
    - Transfer operations
    - Address lists
    - Token metadata
    - Approvals and transferability
    - Timeline operations

4. **API Reference**: `for-developers/bitbadges-api/api.md`
    - Complete API documentation
    - Typed SDK integration

#### External References:

-   **GitHub Repository**: https://github.com/bitbadges/bitbadgesjs
-   **Full Documentation**: https://bitbadges.github.io/bitbadgesjs/
-   **API Documentation**: https://bitbadges.stoplight.io/docs/bitbadges
-   **Live Documentation**: https://docs.bitbadges.io

#### Live Documentation Access:

The BitBadges documentation is available online with two formats:

**URL Patterns:**

-   **Pretty UI**: `https://docs.bitbadges.io/[path]` (e.g., `https://docs.bitbadges.io/for-developers/bitbadges-sdk/overview`)
-   **Markdown Format**: `https://docs.bitbadges.io/[path].md` (e.g., `https://docs.bitbadges.io/for-developers/bitbadges-sdk/overview.md`)

**When to Use Live Documentation:**

-   Verify current SDK version and API changes
-   Access the latest code examples and patterns
-   Check for recent updates to type definitions
-   Troubleshoot with current documentation
-   Access documentation not in local copy

### Development Best Practices

#### 1. Type Safety

Always use the provided types for type safety:

```typescript
// Good
const balance: Balance<bigint> = new Balance({...});

// Avoid
const balance: any = {...};
```

#### 2. Number Type Consistency

Choose a number type and stick with it:

```typescript
// Use bigint for blockchain operations
const balance = new Balance<bigint>({...});

// Use string for API responses
const apiBalance = new Balance<string>({...});

// Convert when needed
const converted = balance.convert(Numberify);
```

#### 3. Error Handling

```typescript
try {
    const collection = await api.getCollection({
        collectionId: '123',
    });
} catch (error) {
    console.error('Failed to get collection:', error);
}
```

### Troubleshooting

#### Common Issues:

1. **Type Mismatches**: Ensure consistent number types (bigint vs string)
2. **Address Format**: Use proper address conversion functions
3. **API Keys**: Ensure valid API keys for API operations
4. **Network Issues**: Check RPC endpoints for blockchain operations

Remember: The BitBadges SDK is designed to be comprehensive and type-safe. Always refer to the official documentation and use the provided types for the best development experience.


## File: ./for-developers/bitbadges-x-ai/prompts/signing-a-transaction.md

# Signing a Transaction

## BitBadges Transaction Signing and Generation Guide

This guide explains how to create, fund, and sign transactions for the BitBadges blockchain using Ethereum-compatible wallets and the BitBadges SDK.

### Prerequisites

```bash
npm install @cosmjs/crypto @cosmjs/proto-signing @cosmjs/stargate
npm install bitbadgesjs-sdk ethers
```

### Step 1: Create ETH Wallet

There are several ways to create an Ethereum wallet for BitBadges transactions:

#### Option A: Create Random Wallet

```javascript
import { ethers } from 'ethers';

// Create a random wallet
const ethWallet = ethers.Wallet.createRandom();
console.log('Address:', ethWallet.address);
console.log('Private Key:', ethWallet.privateKey);
console.log('Mnemonic:', ethWallet.mnemonic.phrase);
```

#### Option B: From Existing Mnemonic

```javascript
import { ethers } from 'ethers';

const mnemonic = 'your twelve word mnemonic phrase here';
const ethWallet = ethers.Wallet.fromMnemonic(mnemonic);
```

#### Option C: From Private Key

```javascript
import { ethers } from 'ethers';

const privateKey = '0x...'; // Your private key
const ethWallet = new ethers.Wallet(privateKey);
```

### Step 2: Fund the Wallet

#### Option A: Using Cosmos SDK Direct Transfer (Requires Funded Account)

The easiest way to do this is through the BitBadges website. If you want to do it programmatically, you can do so via the snippet below.

```javascript
import { DirectSecp256k1HdWallet } from '@cosmjs/proto-signing';
import { SigningStargateClient } from '@cosmjs/stargate';
import { convertToBitBadgesAddress } from 'bitbadgesjs-sdk';

// If you have a funded mnemonic account
const fromMnemonic = 'your funded account mnemonic';
const wallet = await DirectSecp256k1HdWallet.fromMnemonic(fromMnemonic);
const [firstAccount] = await wallet.getAccounts();

// Connect to BitBadges RPC
const rpcUrl = 'https://rpc.bitbadges.io'; // or your preferred RPC
const signingClient = await SigningStargateClient.connectWithSigner(
    rpcUrl,
    wallet
);

// Transfer tokens to your new wallet
const amount = {
    denom: 'ubadge', // BitBadges native token
    amount: '1000000', // Amount in micro-units
};

const fee = {
    amount: [{ denom: 'ubadge', amount: '5000' }],
    gas: '200000',
};

const result = await signingClient.sendTokens(
    firstAccount.address,
    convertToBitBadgesAddress(ethWallet.address),
    [amount],
    fee
);
```

### Step 3: Get Current Account Number and Sequence

#### Option A: Using Cosmos RPC Query

```javascript
import { SigningStargateClient } from '@cosmjs/stargate';
import { convertToBitBadgesAddress } from 'bitbadgesjs-sdk';

const rpcUrl = 'https://rpc.bitbadges.io';
const client = await SigningStargateClient.connect(rpcUrl);

const bitbadgesAddress = convertToBitBadgesAddress(ethWallet.address);
const account = await client.getAccount(bitbadgesAddress);

if (!account) {
    throw new Error('Account not found - ensure it has been funded');
}

console.log('Account Number:', account.accountNumber);
console.log('Sequence:', account.sequence);
```

#### Option B: Direct REST API Query

```javascript
const bitbadgesAddress = convertToBitBadgesAddress(ethWallet.address);
const restUrl = `https://lcd.bitbadges.io/cosmos/auth/v1beta1/accounts/${bitbadgesAddress}`;

const response = await fetch(restUrl);
const data = await response.json();

const accountNumber = data.account.account_number;
const sequence = data.account.sequence;
```

### Step 4: Generate Transaction Payload

#### Get Public Key First

For Ethereum signatures, this is automatically detected via the SDK, so you do not need to pre-generate.

```javascript
const base64PubKey = '';
```

#### Create Transaction Context

```javascript
import {
    createTransactionPayload,
    convertToBitBadgesAddress,
    Numberify,
} from 'bitbadgesjs-sdk';

const sender = {
    address: ethWallet.address, // Ethereum address - not BitBadges address
    sequence: sequence,
    accountNumber: Numberify(accountNumber),
    pubkey: base64PubKey,
    publicKey: base64PubKey,
};

const txContext = {
    testnet: false,
    sender,
    memo: 'My BitBadges transaction',
    fee: {
        denom: 'ubadge',
        amount: '5000',
        gas: '200000',
    },
};
```

#### Create Transaction Messages

Refer to the proto definitions for all transaction types available. Standard Cosmos messages are also supported.

[https://github.com/BitBadges/bitbadgeschain/tree/master/proto](https://github.com/BitBadges/bitbadgeschain/tree/master/proto)

[https://bitbadges.github.io/bitbadgesjs/modules/proto.html](https://bitbadges.github.io/bitbadgesjs/modules/proto.html)

```javascript
import { badges } from 'bitbadgesjs-sdk';

// Example: Create a collection
const createCollectionMsg = new badges.MsgUniversalUpdateCollection({
    creator: convertToBitBadgesAddress(ethWallet.address),
    collectionId: '0', // 0 for new collection
    badgesToCreate: [
        {
            amount: '100',
            badgeIds: [{ start: '1', end: '100' }],
        },
    ],
    managerTimeline: [
        {
            manager: convertToBitBadgesAddress(ethWallet.address),
            timelineTimes: [
                { start: '1', end: Number.MAX_SAFE_INTEGER.toString() },
            ],
        },
    ],
    updateManagerTimeline: true,
    updateBadgeMetadataTimeline: true,
    updateCollectionMetadataTimeline: true,
});

// Example: Transfer tokens
const transferMsg = new badges.MsgTransferBadges({
    creator: convertToBitBadgesAddress(ethWallet.address),
    collectionId: '1',
    transfers: [
        {
            from: convertToBitBadgesAddress(ethWallet.address),
            toAddresses: ['bb1recipient...'],
            balances: [
                {
                    amount: '1',
                    badgeIds: [{ start: '1', end: '1' }],
                    ownershipTimes: [
                        { start: '1', end: '18446744073709551615' },
                    ],
                },
            ],
        },
    ],
});

const messages = [createCollectionMsg]; // Add your messages here
```

#### Generate Transaction Payload

```javascript
const txPayload = createTransactionPayload(txContext, messages);

if (!txPayload.txnString) {
    throw new Error('Failed to generate transaction payload');
}

console.log('Transaction to sign:', txPayload.txnString);
```

### Step 5: Simulate Transaction

```typescript
import { createTxBroadcastBody } from 'bitbadgesjs-sdk';

const simulationBroadcastBody = createTxBroadcastBody(txContext, messages, '');
```

#### Option A: Using BitBadges API Simulation Endpoint

```javascript
const simulateUrl = 'https://api.bitbadges.io/api/v0/simulate';

const simulationResponse = await fetch(simulateUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
        tx_bytes: simulationBroadcastBody.tx_bytes,
        // Some APIs accept the full broadcast body for simulation
        ...simulationBroadcastBody,
    }),
});

const simulationResult = await simulationResponse.json();

if (simulationResult.error) {
    throw new Error(`Simulation failed: ${simulationResult.error}`);
}

// Extract gas used from simulation
const gasUsed = simulationResult.gas_info?.gas_used || simulationResult.gasUsed;
const gasWanted =
    simulationResult.gas_info?.gas_wanted || simulationResult.gasWanted;

console.log('Simulation successful!');
console.log('Gas used:', gasUsed);
console.log('Gas wanted:', gasWanted);
```

#### Option B: Using Cosmos REST API Simulation

```javascript
const restSimulateUrl = 'https://rest.bitbadges.io/cosmos/tx/v1beta1/simulate';

const restSimulationResponse = await fetch(restSimulateUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
        tx_bytes: simulationBroadcastBody.tx_bytes,
    }),
});

const restSimulationResult = await restSimulationResponse.json();

if (restSimulationResult.code && restSimulationResult.code !== 0) {
    throw new Error(`Simulation failed: ${restSimulationResult.raw_log}`);
}

const gasInfo = restSimulationResult.gas_info;
console.log('Gas used:', gasInfo.gas_used);
console.log('Gas wanted:', gasInfo.gas_wanted);
```

### Step 6: Sign and Broadcast Transaction

Note: Before signing and broadcasting, you will want to fix errors from the simulation and most likely adjust gas usage dynamically.

#### Sign the Transaction

```javascript
import { createTxBroadcastBody } from 'bitbadgesjs-sdk';

// Sign the transaction string with your Ethereum wallet
const signature = await ethWallet.signMessage(txPayload.txnString);

// Create the broadcast body
const broadcastBody = createTxBroadcastBody(txContext, messages, signature);
```

#### Broadcast the Transaction

```javascript
// Option A: Using BitBadges API
const broadcastUrl = 'https://api.bitbadges.io/api/v0/broadcast';
const response = await fetch(broadcastUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(broadcastBody),
});

const result = await response.json();
console.log('Transaction hash:', result.txhash);

// Option B: Using Cosmos RPC directly
const rpcBroadcastUrl = 'https://rpc.bitbadges.io/broadcast_tx_sync';
const rpcResponse = await fetch(rpcBroadcastUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
        jsonrpc: '2.0',
        id: 1,
        method: 'broadcast_tx_sync',
        params: {
            tx: broadcastBody.tx_bytes,
        },
    }),
});
```

### Important Notes

1. **Testnet vs Mainnet**: Ensure you're using the correct RPC URLs and chain IDs
2. **Gas Estimation**: Always estimate gas properly for complex transactions
3. **Sequence Management**: Increment sequence for each transaction from the same account
4. **Error Handling**: Always implement proper error handling for network calls
5. **Security**: Never expose private keys or mnemonics in production code

### Common Issues

-   **Account not found**: Ensure the account has been funded at least once
-   **Sequence mismatch**: Query the latest sequence before each transaction
-   **Insufficient gas**: Increase gas limit for complex transactions
-   **Invalid signature**: Ensure the public key extraction and signing process is correct


## File: ./for-developers/claim-builder/auto-completing-claims/automate-w-zapier/README.md

# Integrate with Zapier



## File: ./for-developers/claim-builder/auto-completing-claims/automate-w-zapier/automatic-claim-tutorial.md

# Automatic Claim Tutorial

### Overview

The other option is to trigger claims automatically with Zapier. You will configure the Zap to automatically complete the claim for the user upon a custom trigger. For example, upon purchasing an item, auto-send them a purchased item token.

To do this, you **MUST** get the users' crypto addresses somehow before the action is executed. This can be beforehand or somehow obtained during the duration of the Zap. We leave this up to you. If you cannot obtain users' addresses, this approach will not work.

We want to note that functionality is slightly different for tokens with on-chain balances as opposed to off-chain tokens or address lists.

* On-Chain: The check and complete claim action will **RESERVE** the right for the user to complete the claim. However, it does not actually automatically trigger anything on the blockchain. This is because such a transaction requires a signature from the recipient. Thus, the user still has to go to the BitBadges site and complete the claim process, although the reservation process is automatic.
* Off-Chain and Other Claims: For tokens with off-chain balances or other claim types, there is no reservation process. The claims are automatically completed. For off-chain token claims, this means the tokens will be auto-distributed. For address lists, this means the address will be automatically appended to the list.

You will use the BitBadges API Zapier plugin with the Complete Claim action to perform the final claim completion. This approach takes special configuration explained in the tutorial below to ensure the claim process is correct and only executable by the Zap. See the tutorial for more information.

<figure><img src="../../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Create the Claim

The first step is to create the claim via the Bitbadges site; however, note that the configuration of the claim must be correct to ensure correct behavior of the claim process and allow Zapier to communicate. Select the Zapier approach when creating, and it should guide you through the process.

Note: Many in-site plugins may become incompatible due to the user not completing in-site. However, you gain access to any custom trigger from 7000+ apps on Zapier.

<figure><img src="../../../../.gitbook/assets/image (195).png" alt=""><figcaption></figcaption></figure>

## Tutorial

Example walkthrough of a custom Zap. Customize to your use case.

Step 1: Create and setup your Zap on [https://zapier.com/](https://zapier.com/). The site will walk you through it all.

Step 2: Select and configure your trigger. Triggers are the action that initiate the automation flow. In this cases, this is a new Udemy course being completed. We leave the selection of the trigger up to you. This will depend on your intended use case.

<figure><img src="../../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Step 3: Configure the Complete Claim by BitBadges integration. The password and other config parameters will be constant and obtained when creating the claim. However, the address may be fetched from prior integrations or manually provided. This is up to you.

<figure><img src="../../../../.gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure>

You can get the claim information from the form when you are creating the claim.

Step 4: Simulate / Test

You may use the simulation feature to test that your claim communicates and will pass without actually executing the action.

Note that behind the scenes, this is just a simulation (does not actually complete the claim) if sent manually from the test step. The claim will actually be completed for successful Zaps once live.

Step 5: Track Progress

For most use cases, just submitting the claim is typically adequate. However, you can also track it with the other BitBadges action in Zapier (Get Claim Attempt Status). You will pass the ID received from the submission to this. Note that we use a queue system so it may take some time to officially process.

And, it is as easy as that!


## File: ./for-developers/claim-builder/auto-completing-claims/automate-w-zapier/overview.md

# Overview

Zapier BitBadges Integration: [https://zapier.com/apps/bitbadges/integrations](https://zapier.com/apps/bitbadges/integrations)

**What is Zapier?**

Zapier is an online automation tool that connects your favorite apps, such as Gmail, Slack, Mailchimp, and more than 2,000 others. You can automate repetitive tasks with workflows known as Zaps. A Zap connects two or more apps to automate part of your business or personal tasks. A Zap is created using a trigger and one or more actions. A trigger is an event in an app that starts the Zap. After a trigger occurs, Zapier automatically completes an action—or series of actions—in another app. This seamless connection between apps enables complex tasks to be completed automatically, saving time and improving productivity.

See all supported apps here: [https://zapier.com/apps](https://zapier.com/apps).

<figure><img src="../../../../.gitbook/assets/image (72).png" alt=""><figcaption></figcaption></figure>

**How does Zapier x BitBadges work?**

Couple ways:

* Claims can be auto-completed from Zapier
* Post-success Zaps can implement utility or rewards
* Dynamic stores can be implemented with automatic updates of the list
* Claim infomration like codes can be automatically distributed to users

<figure><img src="../../../../.gitbook/assets/image (197).png" alt=""><figcaption></figcaption></figure>

When automating claims with Zapier, you will follow the approach of upon doing something (custom trigger), perform an action  (claim a token, distribute a code, add to dynamic store).

<figure><img src="../../../../.gitbook/assets/image (89).png" alt=""><figcaption></figcaption></figure>

## **Error Handling**

You should also account for the fact that Zaps can partially execute. For example, if you have a Zap with 10 plugins and it fails on the 8th plugin, the Zap will not be considered a success but 8/10 plugins would be executed already. There is no rollback feature.

Similarly, if you are triggering a Zap during a claim's execution, there is no guarantee that the overall claim is successful because other plugins might fail.

## Triggers

The custom trigger step is left up to you to implement from any of the 7000+ app integrations.&#x20;

## **Actions**

With the claim or action step of the automated flow, you have a couple options depending on your use case.

{% content-ref url="../../automate-w-zapier/distribute-claim-information-tutorial/" %}
[distribute-claim-information-tutorial](../../automate-w-zapier/distribute-claim-information-tutorial/)
{% endcontent-ref %}

{% content-ref url="automatic-claim-tutorial.md" %}
[automatic-claim-tutorial.md](automatic-claim-tutorial.md)
{% endcontent-ref %}


## File: ./for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/README.md

# Automate Any Part of the Process

You can also get creative and customize other parts of the claim too, like the distribution of secret information like codes.&#x20;

<figure><img src="../../../../.gitbook/assets/image (196).png" alt=""><figcaption></figcaption></figure>

You can send the claim code, for example, via the Email by Zapier Plugin or Gmail plugin, and once the user receives the email, they can log on to the BitBadges site and select their address to receive the tokens for when claiming.

<figure><img src="../../../../.gitbook/assets/image (142).png" alt=""><figcaption></figcaption></figure>



## File: ./for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/google-forms.md

# Google Forms

## Setting Up a Claim with Google Forms Zapier

The easiest way is to simply create a Zap using the Google Forms and BitBadges integrations. See the link below for a full tutorial.

<figure><img src="../../../../.gitbook/assets/image (145).png" alt=""><figcaption></figcaption></figure>

{% content-ref url="./" %}
[.](./)
{% endcontent-ref %}

## Setting Up a Claim with Google Forms Script Editor

This guide will walk you through setting up a Google Form to generate unique claim codes using a seed code from the BitBadges Codes plugin.

### Prerequisites

* A Google account
* Access to Google Forms
* A claim with the BitBadges Codes plugin

### Steps

#### 1. Create a Google Form

* Go to Google Forms.
* Create a new form or open an existing one. Customize as needed.

#### 2. Open the Script Editor

* In your Google Form, click on the three dots in the upper right corner.
* Select Script editor.

<figure><img src="../../../../.gitbook/assets/image (138).png" alt=""><figcaption></figcaption></figure>

#### 3. Add the Script

1\. Delete any existing code in the script editor.

2\. Copy and paste the following code into the script editor.\


```javascript
var SEED_CODE = 'ENTER_SEED_CODE_HERE';

function onFormSubmit(e) {
  var form = FormApp.getActiveForm();
  var submissionNumber = getSubmissionNumber();
  var code = generateCodeFromSeed(SEED_CODE, submissionNumber);
  setCustomConfirmation(form, code);
}

function generateCodeFromSeed(seedCode, submissionNumber) {
  var data = seedCode + '-' + submissionNumber;
  var hash = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, data);
  var hexHash = hash.map(function(byte) {
    var hex = (byte & 0xFF).toString(16);
    return (hex.length === 1 ? '0' : '') + hex;
  }).join('');
  return hexHash + '-' + submissionNumber;
}

function getSubmissionNumber() {
  var form = FormApp.getActiveForm();
  return form.getResponses().length;
}

function setCustomConfirmation(form, code) {
  var confirmationMessage = "Thank you for completing the survey. Your unique code is: " + code + '. Provide this in the form on BitBadges when claiming.'
  form.setConfirmationMessage(confirmationMessage);
}
```

3\. Replace 'ENTER\_SEED\_CODE\_HERE' with your actual seed code. To get your seed code, use the Codes plugin on BitBadges:

* Click on the Distribute button which opens up the modal.
* Select Batch.
* Copy the seed code.

<figure><img src="../../../../.gitbook/assets/image (139).png" alt=""><figcaption></figcaption></figure>

#### 4. Set Up the Trigger

* In the script editor, click on the clock icon to open the Triggers page.
* Click on + Add Trigger.
* Set the following options:
  * Choose which function to run: onFormSubmit
  * Choose which deployment should run: Head
  * Select event source: From form
  * Select event type: On form submit

<figure><img src="../../../../.gitbook/assets/image (140).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/image (137).png" alt="" width="554"><figcaption></figcaption></figure>

#### 5. Save and Close

Save your script by clicking on the disk icon or pressing Ctrl + S. Close the script editor.

#### 6. Test Your Form

Submit a response to your form.

* Check the confirmation message to see your unique code.
* Note that the forms are assigned based on number of responses (including any test submissions). If you want to reset from scratch, you can delete all saved responses in your form.



**Add-Ons**

Consider adding functionality to the script like sending the code via emails, protecting against multiple submissions, etc. We leave thi sup to you and your needs.



## File: ./for-developers/claim-builder/automate-w-zapier/dynamic-store-zaps.md

# Dynamic Store Zaps

We refer you [here](../dynamic-stores/adding-data.md) for more information.&#x20;

Zaps to add users to a dynamic store may be the most common use case for the BitBadges Zapier integration, notably because they can operate without crypto addresses in favor of emails. You can simply just use the Zap to parse email or user ID or username -> add to the store and let BitBadges handle the rest of the crypto-native stuff.

<figure><img src="../../../.gitbook/assets/image (175).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/automate-w-zapier/leveraging-zapier-ai-actions-mcp.md

# Leveraging Zapier AI Actions / MCP

Leverage Zapier AI actions to build cool use cases with BitBadges x AI. This is applciable ot both the criteria and rewards side.

{% content-ref url="../leveraging-ai.md" %}
[leveraging-ai.md](../leveraging-ai.md)
{% endcontent-ref %}

<figure><img src="../../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/automate-w-zapier/post-success-zaps.md

# Post-Success Zaps

Post-success Zaps are a great way to implement custom utility from over 7000+ apps upon claim successes.

There are two options:

1. Use Webhooks by Zapier plugin and catch a POST request + Post-Success Zap plugin in your claim. This is recommended as it is much more feature complete and allows you to get social identifiers like emails, apps, etc.
2. Use the Claim Success trigger provided by BitBadges x Zapier Integration



For this tutorial, we will showcase Option 1 (recommended):

1. Setup your Zap (in the Zapier interface) with Webhooks by Zapier and catch a POST request

<figure><img src="../../../.gitbook/assets/image (204).png" alt=""><figcaption></figcaption></figure>

2. Configure your Post-Success Zapier Webhook plugin in the BitBadges site. Add the webhook URL it gives you from Step 1. For Zapier, the validation secret is not as important, but you can additionally add a step to check it within the Zap. The JSON preview it shows you will give you all the available fields you can use.

<figure><img src="../../../.gitbook/assets/image (207).png" alt=""><figcaption></figcaption></figure>

3. Use the Send Test Request in the BitBadges site to complete the test / simulation step in your Zap.

<figure><img src="../../../.gitbook/assets/image (205).png" alt=""><figcaption></figcaption></figure>

4. Configure your action with any app and dynamically replace values where needed. For example, if your action is an outbound send email, you will need to parse the email from the webhook and automatically populate the recipient address for the email.

<figure><img src="../../../.gitbook/assets/image (206).png" alt=""><figcaption></figcaption></figure>

5. Setup the rest of your Zap, create the claim, and you are good to go!


## File: ./for-developers/claim-builder/bitbadges-api-claims/README.md

# BitBadges API & Claims



## File: ./for-developers/claim-builder/bitbadges-api-claims/auto-complete-claims-w-bitbadges-api.md

# Auto-Complete Claims w/ BitBadges API

Note: This is a more advanced option that is incompatible with in-site plugins. Before going through the entire process, consider whether you can implement your use case with a plugin-only approach.&#x20;

Typically, we recommend making a custom webhook / plugin over this. Get creative! Use existing plugins, Zapier, create custom plugins, etc as an alternative to needing a complete auto-complete implementation.

<figure><img src="../../../.gitbook/assets/image (4) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Auto-Completion

You can use the BitBadges SDK to auto-complete claims for users.

```typescript
const res = await BitBadgesApi.completeClaim(claimId, address, { ... });
console.log(res.claimAttemptId);

//Sleep 2 seconds to wait for it to be processed in the queue

const res = await BitBadgesApi.getClaimAttemptStatus(res.claimAttemptId);
console.log(res); // { success: true }
```

When creating on the BitBadges site, go to the API Code tab, and you should see code snippets customized to your claim.

<figure><img src="../../../.gitbook/assets/image (119).png" alt=""><figcaption></figcaption></figure>

Couple notes with auto-completing claims:

* If your claim is setup to require proof of sign in, proof of other socials sign ins (Sign In with Discord, etc), you must have the proper session authentication handled.
* Otherwise, you can setup your claim to be open to anyone but restricted by non-session criteria. For example, do not require proof of address but all claimees must present a valid password (potentially only known by you or the code which is expected to claim).

**Simulating**

You can also simulate the claim (which is instant and not put into the queue). There are also options within this request to simulate specific plugins only for further fine-grained testing (\_specificInstanceIds). The complete claim route automatically simulates and returns instantly if simulation fails. If simulation passes, it is put into the queue.

The body is the same as the completeClaim route. See below.

```typescript
const res = await BitBadgesApi.simulateClaim(claimId, address, { ...body });
```

**Custom Body**

Custom plugins may also require custom body inputs from the user. If you are using a custom plugin not created by you, refer to that plugin's documentation or contact the creator for more input on the custom body schema.

You will need to pass \_expectedVersion. This is the version number of the claim that you expect to complete. If there is a version mismatch at claim time, the claim will fail. This is to avoid instances where the claim creator maliciously changes criteria / actions without you knowing. You can specify -1 for don't check, but this is not recommended.

The custom body (if needed) should be in the following format

```typescript
{
    _expectedVersion: '0', //version of the claim (obtained from fetching the claim)
    [instanceId: string]: { ...pluginBody }
}
```

For example,

```typescript
{
    _expectedVersion: '0', //version of the claim 
    [`abc123`]: { //password plugin w/ instance ID = "abc123"
        password: "abc123"
    },
    [`codes1234`]: { //codes plugin w/ instance ID = "codes1234"
        code: "supersecretcode"
    },
}
```

**Customization**

The rest is left up to you. You decide when to trigger this code. It could be when a user signs in, you can auto-trigger based on certain criteria, or anything else you want.


## File: ./for-developers/claim-builder/bitbadges-api-claims/fetching-claims.md

# Fetching Claims

More documentation is available via the API routes for fetching claims.

Go to the JSON tab of the claim details in-site to see an example one. Note that fetchPrivateParams: true is necessary to get certain private information. You must have permissions to view private parameters.

```typescript
// GET https://api.bitbadges.io/api/v0/claim/claimId?...
const claimsRes = await BitBadgesApi.getClaim({ 
    claimId, 
    fetchPrivateParams: false, 
    fetchAllClaimedUsers: true, 
    privateStatesToFetch: [instanceId],
});
```

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/bitbadges-api-claims/verifying-claim-attempts-w-the-api.md

# Verifying Claim Attempts w/ the API

IMPORTANT: Verifying claim attempts are two-fold:

* Authentication: Authenticate the user (can be done with Sign In with BitBadges or however)
* Verifying Claim Attempt: Lookup the claim attempt via the BitBadges API and cross-check the user has satisfied the criteria

Note: You may opt to simply receive a post-success webhook which would take the API verification step out of it.

```typescript
// Pre-Req: Set up your claim at https://bitbadges.io/create
// Pre-Req: User is authenticated

// 1. By address (if you already have it)
// GET https://api.bitbadges.io/api/v0/claims/success/{claimId}/{address}
// successCount will be 1 for on-demand claims and the number of completions for standard
const res = await BitBadgesApi.checkClaimSuccess(claimId, address);
if (res.successCount >= 1) { doSomething(); }

// 2. By attempt ID 
// GET https://api.bitbadges.io/api/v0/claims/status/{claimAttemptId}
const res = await BitBadgesApi.getClaimAttemptStatus(claimAttemptId);
if (res.success) { doSomething() }

// You may also browse all claim-based API routes in the reference like a fetch all claim
// attempts for a user, but the above two are typically what you are looking for.
```

**Claim Attempt IDs vs By Address**

If you already have the user address, you can simply use option 1.

If you want to verify by claim attempt ID, you can use option 2. Claim attempt IDs can be obtained if you are completing the claim on behalf of the user (e.g. via Zapier or the API), or you can set up a custom webhook to receive it.

Note: If you are receiving a post-success webhook, you already know the claim has gone through by the nature of it, so you do not need to verify it.

This will also allow you to map a user address / claim attempt to another social that you may identify your users by. For example, if you authenticate with email, you can request us to verify the user email, receive the email, and use the (ID, email) pair instead of an address.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Use one of the plugins pictured below or a custom plugin to do so when setting up your claim.

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**More Advanced Ways**

Note: You may also implement other ways of verifying claim attempts such as parsing state directly, storing data yourself from webhooks, etc. You can also trust the post-success webook to only be fired upon success. For these, we refer you to the corresponding documentation such as the API. The process is flexible, but the above should be all you need.


## File: ./for-developers/claim-builder/bitbadges-created-plugins/README.md

# BitBadges Created Plugins

##


## File: ./for-developers/claim-builder/bitbadges-created-plugins/ownership-requirements.md

# Ownership Requirements

Below we explain more about the ownership requirements field and schema. This is used in certain plugins for checking token / list ownership.

```typescript
const ownershipRequirements = {
    $and: [
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 1n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 0n, end: 0n },
                },
            ],
        },
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 2n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 0n, end: 0n },
                },
            ],
        },
    ],
};

const popupParams = {
    ...ownershipRequirements,
};
```

#### **Asset Ownership Requirements**

The **assetOwnershipRequirements** uses an $and, $or, and base case schema to allow you to implement custom logical requirements. For $and requirements, all criteria in the array must be satisfied. For $or, one of the criteria in the array needs tobe satisfied. You can implement the "not" case by saying owns x0 of a token.

```typescript
assetOwnershipRequirements: {
    $or: [
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 1n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 0n, end: 0n },
                },
            ],
        },
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 2n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 1n, end: 1n },
                },
            ],
        },
    ];
}
```

**Options**

As an alternative to $or, we also support specifying **options.numMatchesForVerification** which sets a threshold for how many assets in the current group the criteria needs to pass for. For example, below requires 1 / 1000 tokens to be owned out of the IDs 1-1000.

```typescript
assetOwnershipRequirements: {
  assets: [
    {
      chain: 'BitBadges',
      collectionId: 1n,
      assetIds: [{ start: 1n, end: 1000n }],
      ownershipTimes: UintRangeArray.FullRanges(),
      mustOwnAmounts: { start: 1n, end: 1n }
    }
  ],
  options: { numMatchesForVerification: 1n }
}
```

**BitBadges Token Collections**

For BitBadges assets, we expect the chain = ' BitBadges', all collection IDs to be numeric, and all assetIds to be UintRanges. Querying a user owns a token at a specific time is also supported via ownership times.

```typescript
{
  chain: 'BitBadges',
  collectionId: 1n,
  assetIds: [{ start: 1n, end: 1000n }],
  ownershipTimes: UintRangeArray.FullRanges(),
  mustOwnAmounts: { start: 0n, end: 0n }
}
```

**BitBadges Address Lists**

For BitBadges address lists, they are supported with the collection ID = 'BitBadges Lists'. The assetIds will be the string list ID. A user will be considered to own x1 if they are on the list and x0 if they are not on the list. Note that with blacklists, they are flipped. Not being on a blacklist equals x1 owned.

```typescript
{
    chain: 'BitBadges',
    collectionId: 'BitBadges Lists',
    assetIds: ["listId"],
    ownershipTimes: UintRangeArray.FullRanges(),
    mustOwnAmounts: { start: 1n, end: 1n }
}
```

**Ethereum / Polygon / Solana NFTs (Beta)**

We also support verifying Ethereum Polygon NFTs through this interface. However, note that we use external APIs to check this, so is not reliant on our infrastructure. Use at your own risk.

```typescript
{
    $and: [
        {
            assets: [
                {
                    chain: 'Polygon', //Or 'Ethereum'
                    collectionId: '0x9a7f0b7d4b6c1c3f3b6d4e6d5b6e6d5b6e6d5b6e',
                    assetIds: ['1'],
                    ownershipTimes: [],
                    mustOwnAmounts: { start: 0n, end: 0n },
                },
            ],
        },
    ];
}
```

#### **Ownership Times** <a href="#ownership-times" id="ownership-times"></a>

```
ownershipTimes: []
```

The default when ownership times is empty or missing is to verify at the current time. If this is the case, we dynamically add the current time as \[{ start: currTime, end: currTime }].

```typescript
ownershipTimes: UintRangeArray.FullRanges();
```

For assets that support ownership times like BitBadges tokens, you can specify custom times to check.


## File: ./for-developers/claim-builder/checking-custom-criteria.md

# Checking Custom Criteria

If the in-site plugins are not enough on the criteria side, consider one of the following:

## Dynamic Stores

Dynamic stores can be created in the developer portal. They are simply a list of users stored by BitBadges, managed by you. You attach it to a claim and gate the claim to users in the list.

Stores are nice because they are not tied to a specific claim, and you do not have to deal with addresses if not needed. They are serverless.

You can:

1. Update users manually in-site
2. Update programmatically via the API
3. Update via Zapier - Triggers from 7000+ apps -> add to dynamic store

{% content-ref url="dynamic-stores/" %}
[dynamic-stores](dynamic-stores/)
{% endcontent-ref %}

<figure><img src="../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Custom Webhooks / Plugins

Configure your claim with custom webhooks. Use the "Check Your Own Criteria" plugin. Alternatively, you can use the Forms / Collect Inputs plugin to instead let us store the requests for you, and you can fetch the details in-site / export to CSV format.

Note: The in-site webhook plugins are streamlined alternatives to building your own custom plugins which are a little more feature-rich and reusable.

Be mindful though that if you are checking criteria, you should have verification BEFORE the claim is completed. Post-success hooks cannot affect the outcome.

{% content-ref url="plugins/" %}
[plugins](plugins/)
{% endcontent-ref %}

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Auto-Completion

You could also initiate the completion of claims on behalf of users with the API or via Zapier. This is advanced and a custom plugin / webhook is oftnetimes a better alternative.


## File: ./for-developers/claim-builder/completion-methods.md

# Completion Methods

With BitBadges claims, you will have a couple ways of completing claims. Note on-demand do not have a completion "action", so this is only applicable to standard claims.

**Option 1: Directly In-Site (Recommended)**

Users can claim directly on the corresponding page directly in the BitBadges site. We envision this is to be used for almost all cases. Custom logic can be implemented through custom plugins or webhooks or other means.

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Option 2: Auto-Claim by Zapier**

You can can extend BitBadges Claims with our custom Zapier integration that allows you to connect claims with over 7000+ apps. See all supported apps here: [https://zapier.com/apps](https://zapier.com/apps).

For example, make a purchase on Shopify -> get allocated a token or complete a course on Udemy -> get a completion token. The "airdrop" is a claim completion.

<figure><img src="../../.gitbook/assets/image (87).png" alt=""><figcaption></figcaption></figure>

Note: Zapier can also be used to automate other parts of the claim, like specific plugins or implementing post-claim rewards.

**Option 3: Auto-Claim by API**

You can implement a hybrid approach on your own using the BitBadges API and connect it behind the scenes. This allows you full flexibility over the claiming process.

```typescript
const res = await BitBadgesApi.completeClaim(claimId, address, { ... });
```

**Get Creative!**

A common theme you may see when implementing claims is to get creative and think outside the box. There are a ton of integrations and features already implemented. Even if your use case doesn't exactly match the implementation, you can get creative and implement workarounds.

For example,

* Give out claim codes / passwords to those who meet the criteria on your end rather than needing a direct integration.
* Many apps and services are email based rather than username based. Consider using the Email plugin universally.

## Claiming on Behalf of Others

With each claim, there is only one address (the claiming address). There is no initiator and recipient like with standard approvals. If you want to initiate a claim on behalf of others, you have to get a little creative.

**Password (Secrets) Approach**

The typical approach (used for Zapier and other examples) is to disable all user authentication (Signed In to BitBadges) but gate the claim with a password or other secret information. This allows you (who has knowledge of the password) to complete claims.

Because the authentication check is disabled, you can specify any claiming address. However, note that this disables the authentication check for everyone. You must gate the claim in other ways (like the password).

<figure><img src="../../.gitbook/assets/image (187).png" alt=""><figcaption></figcaption></figure>

**OAuth - Complete Claim Scope**

Or, you could also be authorized to complete claims on behalf of the user via the BitBadges API, but this is only used in some cases. You will need separate authorizations from every claiming user. See Sign In with BitBadges for how to implement.


## File: ./for-developers/claim-builder/concepts/README.md

# Concepts



## File: ./for-developers/claim-builder/concepts/claim-numbers.md

# Claim Numbers

By default, we use an incrementing claim number system for standard claims. For example, claim #1, then claim #2, etc.&#x20;

However, certain implementations may custom assign claim numbers, which can be used to implement custom logic, such as distributing specific tokens.

Only one plugin is allowed to assign claim numbers which is determined by the **assignMethod** of the claim. If the assignMethod === a plugin's unique instance ID, we allow it to assign claim numbers.

<figure><img src="../../../.gitbook/assets/image (186).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/gating-badge-distribution.md

# Gating On-Chain Approvals

In the BitBadges site, we allow using claims to gate approvals, such as mints. For example, gate mints to those who have joined a Discord (checked via a claim).

It is important to note the hybrid apporach here. Claims are checked off-chain. BitBadges becomes the centralized oracle distributing unique claim codes to be used on-chain eventually. Thus, think of claims gating approvals as gating the "right to initiate the transfer" rather than automatically initiating it. It is a two-step process.

On-chain, these are the leaves of [Merkle challenge](../../../x-badges/concepts/approval-criteria/merkle-challenges.md) in the approval criteria and are one-time use only to prevent replay attacks. These are not the same codes as the Codes plugin, if en


## File: ./for-developers/claim-builder/concepts/identify-by-socials-emails.md

# Identify By Socials / Emails?

Do you identify your users by emails or a supported social username?

Select one of the webhook plugins (or forms for serverless) when setting up your claim. This will set you up to be able to track and maintain a map of (attempt ID / address) -> user socials or emails, enabling you to continue identifying your users how you already do!

Note: Verifying claim attempts are two-fold: 1) authenticate the user and 2) verify the claim. In this instance, step 1 would be authenticating the user email / social on your end if needed.&#x20;

{% content-ref url="../plugins/creating-a-custom-plugin/alternatives.md" %}
[alternatives.md](../plugins/creating-a-custom-plugin/alternatives.md)
{% endcontent-ref %}

<figure><img src="../../../.gitbook/assets/image (225).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/signed-in-vs-select-address.md

# Signed In vs Select Address

To require the user to be signed in, select the Signed In to BitBadges plugin. If not selected, we allow any address to be manually entered without address verification or sign in requirements. However, disabling "Signed In with BitBadges" allows any user to claim on another's behalf. Make sure this is intended and all other criteria properly gates the claim.

By not including a sign-in requirement, this makes the user experience better (no signatures). This is also helpful on mobile or other places where users may not have access to their wallets. However, this can be mitigated with approved sign-ins or other approaches like embedded wallets, but those require prior setup. 

**Auto-Completing Claims**

If you are planning to auto complete claims behind the scenes via the API or via Zapier, note that you have two approaches.

1. OAuth Sign In with BitBadges - The Signed In requirement will pass if you have the Complete Claims ("completeClaims") scope.
2. Disable + Gate In Another Way - For example, our Zapier flow does not check user sign in but gates with a password that only Zapier knows.

<figure><img src="../../../.gitbook/assets/image (198).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/standard-vs-on-demand.md

# Standard vs On-Demand

Claims, at their core, are just criteria checks, but there are two ways we can check this criteria. The first is standard claims which require a "complete claim" process or action:

* Criteria is checked at completion time
* Claim numbers are assigned
* Can maintain statefulness
* Ledger of users who have claimed

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

The second is on-demand (sometimes described as non-indexed). These are a special type of claim that has unique properties. Notably, they are autonomous, self-contained, can be fetched on-demand, stateless, does not require any user inputs, sessions, and can function with just a user address / creator parameters.

The critieria is not indexed anywhere but rather calculated on-demand.

* No indexing
* No claim numbers
* No verifiable list of users who have claimed
* Limited in feature set because you need to be able to check criteria at any time, so you cannot use authenticated sessions or other apporaches
* Calculated in real-time
* No success webhooks

For example, checking a minimum balance of BADGE is safe to use on-demand because we always know a user's balance at any given time wihtout user interaction and just their address. Another common on-demand check is token ownership as shown below.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/universal-approach-claim-codes.md

# Universal Approach - Claim Codes

We want to highlight that claim codes are a universal approach that can be used with any application / criteria. For example,

-   Give codes to finishers of a race
-   Give codes to attendees of an event
-   Give codes to those who sign in to your website
-   Distribute codes via email, SMS, etc
-   And so on. You distribute according to your needs!

No need for a custom integration or to identify the user by an identifier. Simply identify them with a code.

Use the Codes plugin to set the codes for your claim. We recommend auto-generating them for sufficient randomness, but you may also custom create them.

**Generate Codes from Seed Snippet**

Auto-generated codes are calculated from a seed code, rather than needing to store all N codes. Note indexes are zero-based (code #1 = idx 0).

```typescript
import CryptoJS from 'crypto-js';
const { SHA256 } = CryptoJS;
export const generateCodesFromSeed = (
    seedCode: string,
    numCodes: number
): string[] => {
    let currCode = seedCode;
    const codes = [];
    for (let i = 0; i < numCodes; i++) {
        currCode = SHA256(`${seedCode}-${i}`).toString();
        codes.push(`${currCode}-${i}`);
    }
    return codes;
};
```

**Generate Codes from Seed API Endpoint**

Or, outsource the generation to our [API Route](https://bitbadges.stoplight.io/docs/bitbadges/abee9e7fa5f8d-get-code-codes-plugin)

## **Save for Later Links**

You may also consider using a save for later link. See example below.

[https://bitbadges.io/saveforlater?value=38d3fe58dffea3f7a675b587bc9239e0360047b7482d245f6770deb589aef869](https://bitbadges.io/saveforlater?value=38d3fe58dffea3f7a675b587bc9239e0360047b7482d245f6770deb589aef869)

## **Zapier**

The get code via idx from seedCode route is also available in Zapier opening up some cool possibilities like auto-distribution.

{% content-ref url="../automate-w-zapier/distribute-claim-information-tutorial/" %}
[distribute-claim-information-tutorial](../automate-w-zapier/distribute-claim-information-tutorial/)
{% endcontent-ref %}


## File: ./for-developers/claim-builder/dynamic-stores/README.md

# Dynamic Stores



## File: ./for-developers/claim-builder/dynamic-stores/adding-data.md

# Adding Data

**Method 1: UI**

You can directly manage your store in the interface.

**Method 2: API**

```typescript
await BitBadgesApi.performStoreAction(...)
await BitBadgesApi.performBatchStoreAction(...)
```

If you want to use the BitBadges API to send hooks / POST requests to, you can do so manually. We refer you to the interface in the developer portal for getting the exact route / body you might need.

<figure><img src="../../../.gitbook/assets/image (173).png" alt=""><figcaption></figcaption></figure>

**Method 3: Zapier**

Use the BitBadges Zapier integration to automate workflows for you. Zapier connects to over 7000+ integrations. In this case, your trigger will be the app you want to integrate nad the action will be BitBadges Add User to Dynamic Store.

Typically, you will want to field map data from your trigger (e.g. Eventbrite attendee email) into the BitBadges Store Action step. For documentation on how to do this, see Zapiers documentation.

* [Field Mapping](https://help.zapier.com/hc/en-us/articles/31709122224653-Enter-data-in-Zap-fields#01JC4MFMXXJXSS7GBAYZP32XKZ)
* [Send Data Between Steps By Mapping Fields](https://help.zapier.com/hc/en-us/articles/8496343026701-Send-data-between-steps-by-mapping-fields)

You may notice that we have a few different identifier fields (email, address, id, username). Leave the ones you don't need blank. Which field you populate should correspond to the store type you have created.

<figure><img src="../../../.gitbook/assets/image (176).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (174).png" alt=""><figcaption></figcaption></figure>

You can also use the Zapier approach to check criteria as well. For example,

1. Setup a Google Form that users can enter their email (or parse the Gmail from the metadata).
2. Setup a Zap to trigger upon Google Forms responses.
3. Check if existing Mailchimp subscriber using email provided via the Mailchimp integration plugin.
4. Add email to dynamic store if subscribed (note: we only allow claims for verified emails)

If setting up an in-site claim, you can redirect the users to the form via the URL Click plugin, Custom Instructions Plugin, or just in the description as well.


## File: ./for-developers/claim-builder/dynamic-stores/overview.md

# Overview

#### What are Dynamic Stores?

A flexible storage system on BitBadges' side for maintaining lists of:

* Email addresses
* User Crypto addresses
* User IDs / usernames names from platforms like Discord, etc

These can be thought of as a separate store for maintaining a list of users. You then "attach" stores to a claim and gate the claim by checking if a user is in the store. You control it. We store it. Update it:

* Manually in-site in the developer portal
* Automatically w/ API calls

```typescript
await BitBadgesApi.performStoreAction(...)
await BitBadgesApi.performBatchStoreAction(...)
```

* Automatically w/ Zapier - Listen to 7000+ apps and add users to store in no-code

To get started, go to the Developer Portal. This will walk you through the process of creating, attaching, and adding data to the store.

Once your store is created, you can add users / data to it. Note that we add via a queue-based approach, so the data may take a couple moments to populate.

**Attach to a Claim**

The interface should walk you through the process of attaching it to a claim:
1. Directly in claim builder, you should see your stores in the templates section
2. In the stores tab, click Create Claim for a one-click create a claim which is auto-configured
3. Add the corresponding plugin (email for email stores) and add the store in the parameters select

**Store ID and Store Secret**

When creating your store, you will get a store ID and secret. These are to be provided by the API / Zapier when managing data. You can also manage the store without the secret if you are signed in with the owner address.

#### Core Advantages

**1. Reusability**

* Not tied to specific plugins or claims
* Can be shared across multiple verification processes

**2. Dynamic Management**

* Real-time updates on the go (dynamic instead of static)
* For example, as users check in to an event, you can dynamically add them to the store which would then make the plugin pass for those users dynamically

**3. Outsourced Storage**

* As opposed to a traditional plugin where you maintain a validation endpoint and potentially store data, this is outsourced to us.
* The roles are flipped. We handle the storage and validation, and you just send update hooks as they come in.

**4. Not Address Dependent**

* All accounting for claims and other BitBadges services is done primarily with crypto addresses. For example, to complete a claim, you need to specify a claiming address. However, many apps and services do not have such a link from user ID on the app -> crypto address.&#x20;
  * This approach allows you to not need to worry about addresses and only the app identifiers / emails. BitBadges handles the rest.&#x20;

<figure><img src="../../../.gitbook/assets/image (222).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (168).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (223).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/implementing-custom-utility.md

# Implementing Custom Utility

Need to perform some additional action upon the user claiming successfully?

## **Preconfigured Plugins**

The easiest and most typical approach is to just do this with preconfigured plugins. No code required. Many use cases are already implemented for you and will auto execute for you if configured. For example, the Send BitBadges Notification plugin or Assign Discord Role.

<figure><img src="../../.gitbook/assets/image (189).png" alt=""><figcaption></figcaption></figure>

## **Integrations**

Some integrations may check claims automatically for you. For example, create a WordPress gated site by just entering the claim ID to check in the settings.

## **In-Site Rewards - URLs / Content**

When creating rewards on the claim builder page, you can also link gated content / URLs to only be visible to users upon successfully claiming.

You may want additional authentication depending on your tolerance level. You can even consider this in-site URL to initially be a Sign In with BitBadges URL here with eventual redirect support to your destination URL. Authentication becomes streamlined this way.

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Use the BitBadges API

To lookup claim state or recent claim attempts by address or other claim information, use the BitBadges API to query this data. Then, implement your logic as you see fit.

{% content-ref url="bitbadges-api-claims/verifying-claim-attempts-w-the-api.md" %}
[verifying-claim-attempts-w-the-api.md](bitbadges-api-claims/verifying-claim-attempts-w-the-api.md)
{% endcontent-ref %}

## Use Post-Success Zaps

If you want to automate this process, consider using Zapier to auto-execute logic upon claim successes per user.

For example, new claim -> add to Mailchimp list or add to Google Sheets.

<figure><img src="../../.gitbook/assets/image (219).png" alt=""><figcaption></figcaption></figure>

{% content-ref url="automate-w-zapier/post-success-zaps.md" %}
[post-success-zaps.md](automate-w-zapier/post-success-zaps.md)
{% endcontent-ref %}

## **Use Post-Success Webhooks / Plugins / Serverless Request Bin**

<figure><img src="../../.gitbook/assets/image (217).png" alt=""><figcaption></figcaption></figure>

Set up a custom success webhook or plugin (post-success) and receive the configured information (plus any custom user inputs or configured user socials you want to receive) via the payload. By the nature of it being a post-success webhook, you do not even need to verify the claim attempt was successful.

Or, the Collect User Inputs (request bin) plugin is a serverless alternative! Instead of needing your own handler, we store the requests for you. You access them in-site or via the API.

<figure><img src="../../.gitbook/assets/image (218).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/integrate-with-pipedream/README.md

# Integrate with Pipedream



## File: ./for-developers/claim-builder/integrate-with-pipedream/build-custom-plugins.md

# Build Custom Plugins

Building custom plugins with Pipedream could streamline a lot of the development process for you. This is a unique feature that Zapier doesn't offer because you can execute custom code from their SDK rather than just automated workflows that are setup.

Below, we provide an overview in how to do so. For further implementation guides, see the official Pipedream docs and the Custom Plugins docs. All principles of creating and setting up your custom BitBadges plugin apply. This will just streamline the authentication and logic handling on your end.&#x20;

{% content-ref url="../plugins/" %}
[plugins](../plugins/)
{% endcontent-ref %}

Note when building custom plugins, it is typically not recommended to trust full on automation workflows since these are asynchronous and may not handle the claim plugin logic quick enough. Please use direct API calls or code executed directly, or if you do trigger a full automation workflow, return a quick 200 OK and expect logic to be processed asynchronously (e.g. post-claim rewards).

[https://pipedream.com/docs](https://pipedream.com/docs)

**Pipedream SDK**

If you only need your own authentication and not end users, you can simply set this up with the standard SDK code.&#x20;

```javascript
import { axios } from "@pipedream/platform"
export default defineComponent({
  props: {
    slack: {
      type: "app",
      app: "slack",
    }
  },
  async run({steps, $}) {
    return await axios($, {
      url: `https://slack.com/api/users.profile.get`,
      headers: {
        Authorization: `Bearer ${this.slack.$auth.oauth_access_token}`,
      },
    })
  },
})
```

**Pipedream Connect**

Pipedream Connect allows you to actually obtain the access tokens for your users and directly execute API requests on their behalf all programmatically. This takes all of the authentication setup out for you. This is great for seamlessly building third-party custom plugins. Simply setup Pipedream Connect in your app, and then, you have SDK access to 1000s of API integrations at your fingertips. We refer you to their docs for setting this up.

Note that there are two flows for authenticating users:

* Manually triggered by your frontend - If you already have a frontend, you may consider just handling it all there.
* [Connect links](https://pipedream.com/docs/connect/connect-link) - You redirect the user to a Pipedream connect URL and Pipedream handles it for you. This could be useful if you want to make a headless plugin without a custom frontend.

Your frontend URL or connect URL can be configured in the tutorial / user input redirect URI when building your custom plugin. Then, once you have the authentication, you can handle your logic in the plugin handler as you see fit.&#x20;

Or, alternatives including adding custom instructions or developing a configuration tool.

<figure><img src="../../../.gitbook/assets/image (211).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/integrate-with-pipedream/end-to-end-example.md

# End to End Example

This will walk you through an entire end-to-end auto-completion flow for Pipedream. This will assume you need the whole stack of per-user authorizatioon and auto-completing claims. If you do not, you can remove some of these steps and adapt for your use case.

Note: This is not the only way to implement. It is just a guided tutorial.

With user authentication, you will need your users to go through the Pipedream Connect authorize flow somehow. Each user will be identified by an `external_user_id` that you set, and once they authorize, you can specify to use that user's authorization details in the automation workflow. Their authorization details are stored under that user ID within your Connect app.

See docs here: [https://pipedream.com/docs/connect](https://pipedream.com/docs/connect). When creating a project, you can also get a step by step tutorial through the Connect tab.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

We leave this step open ended up to you. For the sake of the tutorial, we are going to assume that the claim is to be auto-completed upon user authorization. We will also use the Pipedream SDK Connect Link feature to outsource the frontend code, but Pipedream also is flexible for more custom flows.

You will need to create a **token** (short-lived) which can be used to create a Connect Link (see [https://pipedream.com/docs/connect/connect-link](https://pipedream.com/docs/connect/connect-link)). Note the `external_user_id`you use for this user. This is done server-side.

This is also open-ended. For this tutorial, we are going to use a proxy handler endpoint to generate the Connect Link to not need frontend code at all.

If you want to have a headless no frontend plugin, you can consider adding the Custom Instructions plugin in a claim with a link to a proxy handler endpoint. Because tokens are short-lived and generated dynamically, this should be a proxy one that generates the Connect URL and redirects users there (User -> Proxy Handler -> Generate Connect Link -> Redirect to Connect Link).

Let's say our proxy handler endpoint is hosted on `https://my-proxy-handler.com/generate-connect-link`. You will redirect your users to this endpoint to initiate the Connect Link flow. Consider adding this in the claim description or custom instructions plugin or however you want to expose it to your users.

The proxy handler endpoint is as follows:

```typescript
import express from 'express';
import { serverConnectTokenCreate } from '@pipedream/sdk/server';

const app = express();
const PORT = process.env.PORT || 3000;

// Configuration for Pipedream
const PIPEDREAM_CONFIG = {
    clientId: process.env.PIPEDREAM_CLIENT_ID,
    clientSecret: process.env.PIPEDREAM_CLIENT_SECRET,
    appSlug: process.env.PIPEDREAM_APP_SLUG, // Your app's slug from Pipedream
};

// Proxy handler endpoint
app.get('/generate-connect-link', async (req, res) => {
    try {
        //TODO: Get the user ID from query params or however you want to identify the user
        const externalUserId = req.query.userId;

        if (!externalUserId) {
            return res.status(400).json({ error: 'Missing userId parameter' });
        }

        // Generate the short-lived token
        const { token, expires_at } = await serverConnectTokenCreate({
            external_user_id: externalUserId,
            credentials: {
                clientId: PIPEDREAM_CONFIG.clientId,
                clientSecret: PIPEDREAM_CONFIG.clientSecret,
            },
        });

        // Success / error handler URIs
        const successRedirectUrl =
            'https://my-success-redirect-url.com/auth-callback';
        const errorRedirectUrl =
            'https://my-error-redirect-url.com/error-callback';

        // Construct the Connect Link URL
        const connectUrl = `https://pipedream.com/_static/connect.html?token=${token}&connectLink=true&app=${PIPEDREAM_CONFIG.appSlug}&success_redirect_url=${successRedirectUrl}&error_redirect_url=${errorRedirectUrl}`;

        // Redirect the user to the Pipedream Connect flow
        res.redirect(connectUrl);
    } catch (error) {
        console.error('Error generating Connect link:', error);
        res.status(500).json({
            error: 'Failed to generate Connect link',
            details: error.message,
        });
    }
});

// Optional: Callback endpoint for after authorization
app.get('/auth-callback', (req, res) => {
    res.send('Authorization successful! You can close this window.');

    //TODO: Trigger the workflow here if you want to auto-complete the claim automatically (see below)
});

app.get('/error-callback', (req, res) => {
    res.send('Authorization failed!');
});

// Start the server
app.listen(PORT, () => {
    console.log(`Proxy handler running on port ${PORT}`);
});
```

The final Pipedream Connect URL the user will be redirected to is:

```
https://pipedream.com/_static/connect.html?token={token}&connectLink=true&app={appSlug}&success_redirect_url={successRedirectUrl}&error_redirect_url={errorRedirectUrl}
```

Once the user has completed the authorization, you can now use that `external_user_id`to perform authenticated requests. If you want to do this in a headless way, you can use the success callback URL to automatically do it upon completion.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

For this tutorial, we will auto-complete a claim with their no-code workflow interface ([https://pipedream.com/docs/connect/workflows](https://pipedream.com/docs/connect/workflows)). Follow along here for implementation details. Alternatively, you can directly execute code too without a workflow using their SDK or also fetch the user's authorization credentials and use them in your own code. We recommend the interface for ease of use and testing.

Below, we will explain at a high level and will skip over some lower level details.

1. Create a workflow in the Pipedream site with a HTTP POST webhook trigger.
2. Configure authorization for the webhook. This can be done in a couple ways.
   1. Use Pipedream OAuth
   2. Check for a secret hardcoded value (add a step after) to make sure you are the origin of the request
   3. No authentication - if you do not add authentication, the only thing saving the endpoint from unwanted requests is the knowledge of the endpoint itself. It is important to not leak it if this is your approach
3. When adding your custom actions, select to use the end user's authentication. See the Pipedream docs for testing this. You will probably need to generate a test account and specify the external user ID in the headers.
   1. Ex: For adding a Slack action with the user's authentication, add another step with Slack and select the little switch icon to use user authentication.
4. We recommend using the API request w/ code (NodeJS) feature. You customize your criteria checks here. You may setup custom parameters parsed from the trigger per claim or static hardcoded props. We leave this open-ended up to you. The only requirement is that if a user that does not meet the criteria, this step should throw an error / fail.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

5. Lastly, set up the BitBadges action step as the final action in the workflow. We refer you to the workflow actions for the options here. Typically, you will auto-complete claims if you have the user's crypto address. If not, it may involve setting up and adding a dynamic store. Make sure to test or simulate before actually claiming for real. Also, ensure you are dynamically adding the user info from prior steps and not hardcoding it.

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

6. The workflow setup is now complete. The workflow will be triggered upon the HTTP request. It will then use the provided `external_user_id`and execute the claim criteria checks from your configured apps and finally, it will complete a BitBadges claim or add to a dynamic store as the final action properly gating the claim.

You can then invoke the workflow per unique `external_user_id`as shown here with the SDK. Or, you can also trigger via HTTP.

```typescript
import { createBackendClient, HTTPAuthType } from "@pipedream/sdk/server";

// These secrets should be saved securely and passed to your environment
const pd = createBackendClient({
  environment: "development", // change to production if running for a test production account, or in production
  credentials: {
    clientId: "{oauth_client_id}",
    clientSecret: "{oauth_client_secret}",
  },
  projectId: "{your_project_id}"
});

await pd.invokeWorkflowForExternalUser(
  "{your_endpoint_url}", // pass the endpoint ID or full URL here
  "{your_external_user_id}" // The end user's ID in your system
  {
    method: "POST",
    body: {
      message: "Hello World"
    }
  },
  HTTPAuthType.OAuth // Will automatically send the Authorization header with a fresh token
)
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/leveraging-pipedream-mcp.md

# Leveraging Pipedream MCP

Pipedream Connect / MCP is super powerful as you can connect BitBadges to 3000+ integrations on the criteria and the rewards side.  We refer youy here for more information!

{% content-ref url="../leveraging-ai.md" %}
[leveraging-ai.md](../leveraging-ai.md)
{% endcontent-ref %}



## File: ./for-developers/claim-builder/integrate-with-pipedream/overview.md

# Overview

Similar to Zapier, Pipedream allows you to build automation workflows. We recommend checking out what is possible via Zapier first. Everything there can be done with Pipedream as well. Pipedream may have less connected apps, but it is more extendible and developer friendly.

**Custom Plugins**

Because Pipedream allows more customization on your level (in addition to just automation workflows), you can use their SDK to implement custom plugins seamlessly. This streamlines the development process and helps you connect to 1000s of applications seamlessly!

{% content-ref url="build-custom-plugins.md" %}
[build-custom-plugins.md](build-custom-plugins.md)
{% endcontent-ref %}

**Automation Workflows**

Automation workflows with Pipedream and BitBadges allow you to auto-complete claims, auto-add users to dynamic stores, implement post-claim logic, and more

Get started by creating a workflow with the BitBadges configuration. Then, you can copy/paste the code provided from the actions / triggers in the subpages of this section to programmatically interact with the BitBadges API. We refer you to the Zapier flows documentation for the high-level concepts and designs.

{% embed url="https://pipedream.com/apps/bitbadges" %}

{% content-ref url="../auto-completing-claims/automate-w-zapier/" %}
[automate-w-zapier](../auto-completing-claims/automate-w-zapier/)
{% endcontent-ref %}

{% content-ref url="workflow-actions/" %}
[workflow-actions](workflow-actions/)
{% endcontent-ref %}

{% content-ref url="workflow-triggers/" %}
[workflow-triggers](workflow-triggers/)
{% endcontent-ref %}

For the inputs, there are two ways of configuring. You may nee dto slightly adapt the templates to fit your desired flow.

Props - You set it manually via the props

```typescript
export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    },
    claimInfo: {
      type: "string",
      "label":  "Claim Information",
      optional: false, // Use optional: false instead of required: true
    },
...
```

Dynamic - Parse from the trigger / another step (steps.trigger.event)

```typescript
export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      const response = await axios($, {
        method: 'POST',
        url: `https://api.bitbadges.io/api/v0/claims/status/${steps.trigger.event.claimAttemptId}`,
 ...
```

<figure><img src="../../../.gitbook/assets/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>



## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/README.md

# Workflow Actions



## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/add-user-to-dynamic-store.md

# Add User to Dynamic Store

```typescript
import { axios } from "@pipedream/platform"

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      await axios($, {
        method: 'POST',
        url: `https://api.bitbadges.io/api/v0/storeActions/add/${steps.trigger.event.dynamicDataId}/${steps.trigger.event.dataSecret}`,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'x-api-key': this.bitbadges.$auth.api_key
        },
        data: {
          "address": steps.trigger.event.address,
          "id": steps.trigger.event.id,
          "email": steps.trigger.event.email,
          "username": steps.trigger.event.username
        }
      })

      return { success: true }
    } catch (error) {
      $.export('error', error)
      throw error
    }
  },
})
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/complete-claim.md

# Complete Claim

To complete a claim, enter this code in your workflow with [the BitBadges integration](https://pipedream.com/apps/bitbadges) and adapt as needed. &#x20;

The **claimInfo** is in the format: ${claimId}-${passwordPluginInstanceId}-${password}. You can setup the password plugin manually or select the Automation Workflow completion method -> Copy.

This is the approach we use for automation workflows. We remove any sign in requirements, but anyone claim must specify the secret password (only known to Pipedream / Zapier).

```
62f59244fc1003e331f183c4b3907f87-ecdb0ed0513716af3124899f6e7b5da70eb85c4399dafe2bf970236b34940da9-30892aa1bb0f84b19ecf244958c9cd4676400e13a24791e7512bc88efa217c89
```

<figure><img src="../../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

```typescript
import { axios } from "@pipedream/platform";

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    },
    claimInfo: {
      type: "string", // Claim details passed as a string in the format "claimId-passwordPluginId-password"
    },
    address: {
      type: "string", // Address of the user
    },
    isSimulation: {
      type: "boolean", // Boolean to determine if this is a simulated run
      default: false,
    },
  },
  async run({ steps, $ }) {
    const details = this.claimInfo.split("-");
    if (details.length !== 3) {
      throw new Error("Invalid claim details parsed");
    }

    const claimId = details[0];
    const passwordPluginId = details[1];
    const password = details[2];

    const endpoint = `https://api.bitbadges.io/api/v0/claims/${
      this.isSimulation ? "simulate" : "complete"
    }/${claimId}/${this.address}`;

    const data = {
      _expectedVersion: -1, 
      [`${passwordPluginId}`]: {
        password: password,
      },
    };

    try {
      const response = await axios($, {
        method: "post",
        url: endpoint,
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
          "x-api-key": `${this.bitbadges.$auth.api_key}`,
        },
        data,
      });

      const result = response;

      // Note: This means a successful trigger (add to queue), not a claim completion
      // You can use the claimAttemptId to poll
      return {
        success: true,
        claimAttemptId: result.claimAttemptId || "",
        currentTimestamp: Date.now()
      };
    } catch (error) {
      throw new Error(`Failed to complete claim: ${error.message}`);
    }
  },
});
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-attempt-status.md

# Get Claim Attempt Status

```typescript
import { axios } from "@pipedream/platform"

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      const response = await axios($, {
        method: 'POST',
        url: `https://api.bitbadges.io/api/v0/claims/status/${steps.trigger.event.claimAttemptId}`,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'x-api-key': this.bitbadges.$auth.api_key
        },
        data: {}
      })

      return {
        success: response.success,
        error: response.error
      }
    } catch (error) {
      $.export('error', error)
      throw error
    }
  },
})
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-code-by-idx.md

# Get Claim Code by Idx

```typescript
import { axios } from "@pipedream/platform"

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      const codeIdx = this.sub_by_one 
        ? steps.trigger.event.code_idx - 1 
        : steps.trigger.event.code_idx;

      const response = await axios($, {
        method: 'POST',
        url: 'https://api.bitbadges.io/api/v0/codes',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'x-api-key': this.bitbadges.$auth.api_key
        },
        data: {
          'seedCode': steps.trigger.event.seed_code,
          'idx': codeIdx
        }
      })

      return response;
    } catch (error) {
      $.export('error', error)
      throw error
    }
  },
})
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/README.md

# Workflow Triggers



## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/poll-claim-attempts.md

# Poll Claim Attempts

For polling claim attempts, we recommend that you jsut set up a custom success webhook with the HTTP trigger on Pipedream. This can be directly configured into your workflow by just adding the POST endpoint URL it gives you.

<figure><img src="../../../../.gitbook/assets/image (212).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/image (213).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/leveraging-ai.md

# Leveraging AI

A great way to implement both criteria and utility is through AI models and agents. This will follow along with the plugins / webhooks that we already have in place!

**Reward Side**

On the reward side, simply set up a post-success claim, receive any user identifiers or inputs needed, and trigger your actions. This can be custom webhooks to any model or service of your choice (Pipedream Connect / MCP, Zapier MCP, anything!), and we also have an in-site plugin for you to use the Zapier AI Actions / MCP service!

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

**Criteria Side**

On the criteria side, this is recommended to follow the dynamic stores approach. While you can check and trigger AI models during execution time, we typically recommend against this due to long wait times and poor UX. If you pre-add a user to a dynamic store, the claim process is good UX for the user.

{% content-ref url="dynamic-stores/" %}
[dynamic-stores](dynamic-stores/)
{% endcontent-ref %}

This is left open-ended. You could leverage Zapier AI Actions / MCP and the BitBadges integration to do this automatically.

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

```typescript
import fetch from 'node-fetch';

const ZAPIER_API_KEY = 'ADD_YOURS';

const options = { method: 'GET', headers: { 'x-api-key': ZAPIER_API_KEY } };

const fetchActions = async () => {
  const response = await fetch('https://actions.zapier.com/api/v2/ai-actions/', options);
  const data = await response.json();
  return data;
};

const executeAction = async (actionId: string, email: string) => {
  const options = {
    method: 'POST',
    headers: { 'x-api-key': ZAPIER_API_KEY, 'Content-Type': 'application/json' },
    body: `{"instructions":"Add ${email} to the store" ,"params":{}}`
  };

  await fetch(`https://actions.zapier.com/api/v2/ai-actions/${actionId}/execute/`, options)
    .then((response) => response.json())
    .then((response) => console.log(response));
};
```


## File: ./for-developers/claim-builder/other-tutorials/README.md

# Other



## File: ./for-developers/claim-builder/other-tutorials/add-telegram-bot-to-channel.md

# Add Telegram Bot to Channel

This guide will walk you through the process of adding the BitBadges bot (@bitbadges\_bot) to your Telegram channel. By integrating this bot, you can enhance your channel with BitBadges functionality.

### Prerequisites

* You must be an admin of the Telegram channel where you want to add the bot.
* You need to have the Telegram app installed on your device.

### Steps to Add the BitBadges Bot

#### 1. Find the BitBadges Bot

1. Open your Telegram app.
2. In the search bar at the top, type "@bitbadges\_bot".
3. Tap on the BitBadges bot in the search results.

#### 2. Start a Chat with the Bot

1. Tap on the "Start" button to initiate a conversation with the bot.
2. The bot may send you a welcome message with instructions.

#### 3. Add the Bot to Your Channel

1. Go to your Telegram channel.
2. Tap on the channel name at the top to open the channel info.
3. Scroll down and tap on "Administrators".
4. Tap on "Add Administrator".
5. Search for "@bitbadges\_bot" and select it from the results.
6. Review the bot's permissions. Ensure it has the necessary permissions to function properly in your channel.
7. Tap "Done" to add the bot as an administrator.

####


## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/README.md

# Get Integration User IDs



## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/discord.md

# Get Discord Server ID

To get your discord server ID, this can be done by right clicking on the  server -> Copy Server ID,

<figure><img src="../../../../.gitbook/assets/image (60).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/get-discord-user-id.md

# Get Discord User ID

<figure><img src="../../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/x-twitch-github-ids.md

# X / Twitch / GitHub IDs

X / Twitter - [https://www.wikihow.com/Find-Your-User-ID-on-Twitter#:\~:text=Visit%20a%20site%20like%20What's,as%20you%20know%20their%20username.](https://www.wikihow.com/Find-Your-User-ID-on-Twitter)

GitHub  - [https://caius.github.io/github\_id/](https://caius.github.io/github\_id/)

Twitch - [https://www.streamweasels.com/tools/convert-twitch-username-to-user-id/](https://www.wikihow.com/Find-Your-User-ID-on-Twitter)


## File: ./for-developers/claim-builder/other-tutorials/in-site-guides.md

# In-Site Guides

The best way to get started with a tutorial is to use the Claim Tester in-site, and simply browse the guides section or experiment by adding plugins. The guides section will have a ton of common patterns and show you how to implement ideas that may or may not be supported natively. Find a similar use case to yours and apply the same steps. Even if there is nothing similar, most of the same principes to apply to almost all integrations.

If you need to see the resulting claim JSON (for advanced implementations), you can also see this in-site under the JSON tab of the claim details.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>



## File: ./for-developers/claim-builder/overview.md

# Overview

> 💡 **Note:** This documentation is intended to provide developer documentation for more advanced use cases. Most of the time, you can directly do everything in-site. Or if you need custom functionality, it is oftentimes a better approach to just self-implement the functionality you need rather than deal with the complexities of connecting with claims. LLMs, especially with MCP, are great for implementing all of this stuff. We just provide claims as an out of the box tool in-site.

BitBadges claims are designed to be a comprehensive tool directly within the site or via the API for you to custom gate your utility. Claims can be simply thought of as: **Meet criteria? -> Offer utility / rewards.** The implementation process aims to be super flexible, allowing you maximum customization.

<figure><img src="../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

### **How do claims work? What are plugins?**

Claims are made up of one or more plugins executed in order. By default, all must pass, but this can be customized. Out of the box, we offer plenty of built-in plugins and features with no code required and directly claimable by users in the site. Or, you can extend its functionality with helper tools, custom plugins, Zapier, our API, and more!

### **Get Creative**

While we do offer a ton of functionality directly in-site, your desired functionality may not be directly supported. Before considering custom implementations, get creative!

* Can you implement everything with a token and then check token ownership?
* Use claim codes or a password which can be used as a universal approach (no need for a specific app integration)
* Can your users be identified by email? Addresses? Use those plugins or dynamic stores
* Does Zapier support your approach? They have 7000+ apps and integrations natively. Pipedream?

### **How to create / manage claims?**

Claims are created and managed in the developer portal.

### **What is possible in-site?**

Most of the time, you can directly do everything without a line of code. Get creative and experiment!

* Gate URLs / Content to those who claim with the Rewards tab
* Use the Discord Role Assigner plugin to create gated channels
* And much more

### **Can claims connect to other BitBadges services?**

Claims are the universal connector. You can not only check criteria from any BitBadges service (token ownership, >100 points) but also use claims on the reward side (gate mints, award points).

<figure><img src="../../.gitbook/assets/image (221).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/README.md

# Plugins



## File: ./for-developers/claim-builder/plugins/configuration-tools.md

# Configuration Tools

Configuration tools are a helper layer abstracted over the core plugin implementations. Instead of creating new, individual plugins for each use case, you can often reuse existing ones. Configuration tools help the user configure the parameters of existing plugins.

For example,&#x20;

* Google Calendar can be implemented by configuring the Email plugin with the attendee emails
* Auto-configure approved user addresses with the Address Restrictions plugin
* Or any application can be implemented by issuing claim codes with the Codes plugin.

```
Note: This is a more advanced option and is not a great user experience. 
This should only be used in select cases.

Please create custom plugins for better UX.
```

Prompt the user to add the copy / paste the stringified JSON to the Configuration Tools tab on the claim builder.

<figure><img src="../../../.gitbook/assets/image (214).png" alt=""><figcaption></figcaption></figure>

```json
{"pluginId":"codes","version": "0", "publicParams":{"numCodes":1},"privateParams":{"codes":["code123"]}}
```


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/README.md

# Creating a Custom Plugin



## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/alternatives.md

# Pre-Built Webhook Plugins

Configure prebuilt webhook plugins in the claim builder without needing to create an entirely new custom plugin. Just enter the endpoint and configure what you want to receive.If you do not want to actually set up a full handler, you can also use the Forms plugin which allows you to store and view the requests in-site (serverless).

<figure><img src="../../../../.gitbook/assets/image (6) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Note**: These plugins only support a simple POST request and expect a 200 OK response. If you require more custom logic or reusability, a custom plugin is necessary.

### Configuration

* **POST Routes**: Customizable routes for your needs.
* **User Details**: Optionally select to receive user details, like their address, custom inputs, or connected socials (only identifying information and no authentication tokens or details)
* **Validation Secret**: Customize a validation secret to confirm requests are from BitBadges. This is what is entered in the form.
* **Expected Response:** 200 OK within 10 seconds
  * For non-critical logic, consider returning 200 early and asynchronously process.
  * Stateless

### Forms Plugin  - Serverless

The forms plugin is a serverless alternative. This is titled "Collect User Inputs" in the site.

Think of this like a request storage bin. We store the requests that would've been sent to the webhooks for you. You can then view them in-site or fetch them from the API when needed.

```typescript
// Pre: Get the attempt ID. If you do not have it already, see the API reference endpoints

// GET /api/v0/requestBin/attemptData/{claimId}/{claimAttemptId}
const res = await BitBadgesApi.getAttemptDataFromRequestBin("claim123", "attempt123", { ... });
console.log(res);
// { bitbadgesAddress, email, claimAttemptId } 
```

<figure><img src="../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Implementation - Handlers

The request/response flow mirrors that of custom plugins, with the `pluginSecret` replaced by the inputted validation secret. For detailed implementation guidance, refer to the respective documentation. The configuration is done in-site via the claim builder.

1. Setup your plugin handler (see plugin documentation for more information)
2. Create your claim and configure the webhook as one of the plugins, specifying your endpoint
3. Test it out to make sure it is working


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/README.md

# Implement Your Plugin

###


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/api-handler.md

# API Handler

The outgoing request (from BitBadges to your plugin) will be made up of the custom body inputs (passed from your frontend), the claim parameters, plus some contextual information about the claim and the claiming user.

* **Plugin Secret:** A plugin secret value that you can use to verify BitBadges as the origin of the call. This is secret only to you and can be obtained via the developer portal when creating your plugin.
* **Claiming Address:** The **bitbadgesAddress** of the user who is attempting to claim. We also provide the mapped equivalents (**ethAddress**, etc).
  * Note the claiming address may not be verified (signed in) dependeing on the configuration (the user must have the Signed In to BitBadges plugin). If you need to make sure that the user is signed in, use the **isAddressSignedIn** field. This will be true if the claiming user is signed in as the claiming address. All other socials you can assume have been verified / signed in.
* **Claim Information**: Lastly, we also pass the **claimId,** as well as the claim's **createdAt** and **lastUpdated** timestamps. These can be used, for example, to implement version control systems on your end.
* **Claim Attempt ID:** The claim attempt ID is the ID of the attempt, and you can use it to track the status of the claim (whether it eventually fails or succeeds).
* **Attempt Status:** The attempt status (attemptStatus) will be 'executing' during the execution of the claim. If you subscribe to success status webhooks (in the configuration), we will also send a second request (with same body and headers) and \_attemptStatus='success'. This can be used to trigger post-claim logic that needs to wait until completion.
* **Simulation (Dry Run) Flag:** The **\_isSimulation** flag tells you whether this is a known dry run.

For POST, PUT, and DELETE requests, we pass the values over the body. For GET, we pass them over the GET params. You are responsible for making sure the endpoint is accessible (e.g. no CORS errors, etc.). Make sure it is the desired type as well (i.e. GET vs POST vs DELETE vs PUT).

```typescript
const payload = {
    ...customBody, //if applicable
    ...allConfiguredParams, //if applicable

    // Context info

    email: 'bob@abc.com', //If pass email is configured
    discord: { id: '...', username: '...', discriminator: '...' }, //If configured
    twitch: { id: '...', username: '...' }, //If configured
    twitter: { id: '...', username: '...' }, //If configured
    github: { id: '...', username: '...' }, //If configured
    google: { id: '...', username: '...' }, //If configured
    pluginSecret: pluginDoc.pluginSecret,
    claimId: context.claimId,
    claimAttemptId: context.claimAttemptId,
    bitbadgesAddress: context.bitbadgesAddress, //If pass address is configured
    ethAddress: context.ethAddress, //If pass address is configured
    solAddress: context.solAddress, //If pass address is configured
    btcAddress: context.btcAddress, //If pass address is configured
    _attemptStatus: context._attemptStatus,
    lastUpdated: context.lastUpdated,
    createdAt: context.createdAt,
    version: context.version,
};
```

### **Identifying the Claiming User**

If you need to identify the claiming user, we pass their address + other requested socials to your endpoint. The socials will all be verified and signed in on our side. The address will be authorized if your plugin specifies the require sign in? option or the claim creator requires sign in.

Although that may not be enough if you identify your users in another way, or you may just not want to fully trust BitBadges. You can also simply check via a secret authorization code. Give them the authorization code on your end while authenticated. Have them enter it as a custom user input in-site. Then, verify it on your end.

### **Responses**

All responses expect a 200 success OK status code within 10 seconds for a successful attempt. For any of the below, do not assume that a 200 OK response means a successful claim and a successful set of the new state. Think of this as a hypothetical state transition IF the claim is eventually successful.

Note: Ensure the returned JSON object keys do not contain any "." characters because that may mess up the state handler. For example, emails should be bob@abc\[dot]com rather than bob@abc.com.

**Stateless Preset**

The stateless preset is simple. If we receive the 200, the plugin is successful. Nothing else is checked via the response. Everything is handled on your end (if you have state).

<figure><img src="../../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) ( (9).png" alt=""><figcaption></figcaption></figure>

**Claim Token Preset**

This preset expects a { claimToken} in the response. The claim token is a one-time use only claim code. Issuing claim tokens is left up to you.

<figure><img src="../../../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Claim Numbers Preset**

This preset expects a { claimNumber } in the response. The claim number is the claim number that will be assigned if the claim number is successful. Claim numbers are 0-based, so claimNumber === 0 is the first claim, and so on.

IMPORTANT: Only one plugin can control claim number assignment. If you select this approach, claims that use this plugin will not be compatible with any other plugin that uses the claim number preset.

Another important decision you will have to consider is whether to reuse your plugin for address lists because claim numbers do not matter for address list plugins. So basically, your plugin will function like the stateless preset for address list claims, if selected.

### **Success Hook Responses**

For success hooks (\_attemptStatus=success), we also expect a 200 OK within 10 seconds. If you need to do asynchronous processing, return 200 OK early and process as you desire.

Otherwise, for failed attempts, we will retry later with an exponential backoff policy.

### **Error Responses**

If your plugin fails, we will save the error for debugging / monitor purposes. It may be displayed to the claiming user and / or claim cretor, so make errors informative but do not reveal sensitive information.

Please follow the { message } interface for returned JSON error responses.

### Example Plugin Handler

<pre class="language-typescript"><code class="lang-typescript"><strong>//TODO: Fill in missing information
</strong>const handlePlugin = async (req: NextApiRequest, res: NextApiResponse) => {
  try {
    //Step 1: Handle the request payload from the plugin
    const body = req.body; //We assume the plugin sends the payload in the body of the request (change this for GET)
    const { claimId, pluginSecret, bitbadgesAddress, ethAddress, solAddress, btcAddress, lastUpdated, createdAt } = body;
    const { ...otherCustomProvidedInputs } = body;
    
    //Handle anything specific to dry runs _isSimulation

    //Step 2: Verify BitBadges as origin by checking plugin secret is correct
    const YOUR_PLUGIN_SECRET = '';
    if (pluginSecret !== YOUR_PLUGIN_SECRET) {
      return res.status(401).json({ message: 'Invalid plugin secret' });
    }

    //Step 3: Implement your custom logic here. Consider checking the plugin's creation / last updated time to implement version control.
    //TODO: 

    //Step 4: Return the response to the plugin based on your configured state function preset
    // const claimTokenRes = { claimToken: '...'  }
    // const statelessRes = {};
    return res.status(200).json({});
  } catch (err) {
    console.log(err);
    return res.status(401).json({ message: `${err}` });
  }
};

export default handlePlugin;
</code></pre>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/design-considerations.md

# Design Considerations

### Your Plugin Status !== Claim Success Status

For processing hooks, note that your plugin may succeed, but this does not mean the overall claim will succeed. Other plugins may fail, or other stuff may go wrong.

If you receive a post-success hook, you can be sure the claim has succeeded. Or, you can use the attempt ID to verify it on your end as well,

### Asynchronous Processing

Claims are processed in an asynchronous manner. For processing hooks, your plugin may succeed, but the claim may not complete until a later time.

Best practices:

-   If using state management on BitBadges end for custom plugins, design your plugin to avoid race conditions. For example, do not return the same one-time use claim token to multiple attempts. Most plugins are stateless (on BitBadges end) though and do not have to worry about this. It should always be eventually oconsistent.
-   Do not depend on the BitBadges claim state like number of claims completed. It may not be up to date or real-tie at the time of your plugin's execution. Your custom parameters are okay to depend on.

This is not really applicable to post-success hooks.

### State Management

An important aspect to consider is how you will handle state (if applicable). The golden rule here is that a successful response from your plugin DOES NOT mean the overall claim attempt was successful. Other plugins might fail. Or vice versa, your plugin may fail, but the claim succeeds. We only update state on our end if your plugin passed and was in the success path (we short-circuit OR requirements).

You have a couple options:

-   Use the preset response patterns to customize how BitBadges controls state for your plugin on our end. This is eventually consistent meaning that you return an intent from your handler, and we update only upon successful claim (and in the success path).
    -   A typical flow is to associate certain state with unique claim tokens and let BitBadges handle the claim tokens being marked as USED vs UNUSED.
-   Manage state on your end, but be mindful of the way BitBadges processes claims.

### Reusing for On-Demand Claims

To be used with on-demand claims, the plugin must meet specific requirements and have specific properties:

-   Stateless - No per-attempt state
-   No User Inputs - The plugin should be able to function at any time without any custom user inputs. Note this also includes socials or connected sessions.
-   Only Needs Context - The plugin should be able to function with just the contextual information passed. The context mainly includes the plugin information, claim information, and the claimee's address.

Typically, these are only possible with crypto-native plugins. For example,

-   Check >1 ETH in account from address
-   Check POAP ownership
-   Check token ownership

Parameters are okay because they are hardcoded and not changed (e.g. set min ETH to 1).

### **Authentication / Sensitive Values**

As a design decision, we do NOT want to handle your authentication or sensitive values. Treat BitBadges as a middleman. Authentication should either be fully managed by BitBadges (identifers passed to you like email, usernames) or fully managed by you from start to finish. This applies to both the creator and the end claiming user.

If you need to make authenticated requests on behalf of the user (beyond just receving identification information), you will need to implement authentication on your end. You may let the claim creator store sensitive information in the private parameters of the plugin.

Consider a workaround such as storing any information yourself, mapping it to a token or code, giving that code to the user / creator, and having them enter it in the flow. You then use the token / code to lookup the information in your handler.

This approach follows the same flow as OAuth authorization codes, except with a custom claim code. You should follow all the same best practices (expiring tokens, PKCE for preventing authorization code interception attacks, and more).

<figure><img src="../../../../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/getting-started.md

# Getting Started

To create, publish, and maintain your plugin, go to [https://bitbadges.io/developer](https://bitbadges.io/developer) and use the Plugins tab. This should walk you through the whole process of configuration and submitting it to be used on the BitBadges site. If you are confused at any point, refer back to this documentation.

For testing purposes, you can setup using Pipedream's request bin ([https://pipedream.com/requestbin](https://pipedream.com/requestbin)) and just monitor incoming requests that way.

<figure><img src="../../../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/hook-types-and-simulations.md

# Hook Types and Simulations

### Timing of Hooks

BitBadges can send the request at two different times (during processing hooks and success hooks after successful claim). Certain settings in the creation form can be set to customize how or if we send these. You may choose to receive or ignore them.

* Processing hooks (\_attemptStatus = "executing") are checked during the execution of the claim, and the results could influence whether the claim succeeds or not.
* Post-Success hooks (\_attemptStatus = "success") are only sent after the claim is successful and cannot affect the outcome of the claim. Typically used for post-claim actions or success logic. If a 200 OK is not received, we will use exponential backoff to retry until successful.

<figure><img src="../../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Simulations

```
NOTE: Catching simulations is important.

You do not want to execute success logic on a dry run.
```

We allow users to simulate claims as a dry run before they actually submit for real. The BitBadges site will always simulate once before submitting, but you should not depend on every claim attempt having a prior simulation.

The scope of the dry run is left up to you, but we recommend as a rule of thumb is that if the user successfully simulates, they are expected to always pass at execution time.

To determine whether you are receiving a simulation hook or a "for real" hook, you can use the \_isSimulation flag that is passed. The claimAttemptId will also be empty / blank, but the rest of the payload should remain the same.

You can select to not receive simulation hooks at all in the usage settings when creating your plugin in the developer portal.


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/parameters.md

# Parameters

Each plugin can configure the expected schema of parameters inputted by the claim creator and the end user. These will all be available in the payload of your handler in addition to contextual information like address, attempt ID, etc.

```json
{
    ...context,
    ...publicParams, // Public to the end users
    ...privateParams, // Private to BitBadges and the claim creator
    ...userInputs
}
```

Parameters will be passed to your backend handler in the payload.

<figure><img src="../../../../../.gitbook/assets/image (163).png" alt=""><figcaption></figcaption></figure>

## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/user-inputs.md

# Custom Inputs

### Handling User / Creator Inputs

If your plugin requires inputs from the claiming user or claim creator, you can do this in the BitBadges site (recommended) or via a window.postMessage from a custom frontend / tool. All inputs will be passed along to your handler via the payload. If none are provided, we assume there is nothing needed to be passed.

<figure><img src="../../../../../.gitbook/assets/image (165).png" alt=""><figcaption></figcaption></figure>

Note to be compatible with Zapier (and possibly API auto-claiming) or on-demand claims, user inputs are typically not allowed (because the user is not manually initiating anything).&#x20;

**Option 1: Completely In-Site**

When creating the plugin, configure the expected schemas. We will prompt the users / creators to enter such information in-site via a form. All outsourced to BitBadges.

<figure><img src="../../../../../.gitbook/assets/image (121).png" alt=""><figcaption></figcaption></figure>

**Option 2: Custom Frontend**

Consider creating your own frontend that the user will be redirected to via the redirect URL.You will need to combine approaches. This typically follows a code approach. For example, handle secure stuff on your end -> grant an authorization / claim code -> have user add it directly in the site -> use the code for whatever.

**Supported Schema Types**

Primitives: String, Number, Boolean

Date: UNIX millisecond timestamp

URL: Stringified URL

### Identifying the Claiming User

You can also select to automatically pass supported identifying details about the user (e.g. crypto addresses, Discord, X, GitHub, etc).  Note no access tokens or auth details are passed along so private, authorized requests are not possible with this information.

We will authenticate the user on our end where needed, and you can use their identifying information to execute queries (e.g. public GitHub contributions). The only one that may not be verified in some cases is the claiming address. This depends on the configuration (the user must have the Signed In to BitBadges plugin). If you need to make sure that the user is signed in, check the **isAddressSignedIn** field. This will be true if the claiming user is signed in as the claiming address.

<figure><img src="../../../../../.gitbook/assets/image (215).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../../.gitbook/assets/image (216).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/managing-your-plugin.md

# Managing Your Plugin

### Updating Your Plugin / Version Control

Management of your plugin is done through the developer portal. You may configure different versions of your plugin. New claims will always use the latest **finalized** version. Existing claims will remain on the version they were created with. Unfinalized versions can ONLY be used by you in the claim tester.

We leave updates and version control management up to you. It is your responsibility to keep claims compatible and functioning. If you need to implement a breaking change, you can also consider using the createdAt, lastUpdated, or version fields passed via the context to implement version control and handle it on your end. Or, you can also create a new plugin.

## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/testing-your-plugin.md

# Testing Your Plugin

There are two approaches to testing your plugin.

**Local Development**

Use your favorite tool to simulate requests to your handler such as the one below. Replace with your corresponding details.

```bash
curl -X POST https://yourhandler.com  -H 'Content-Type: application/json' -d '{
  "pluginSecret": "068145b0058668ac5b880e23ca2556e4207efe8066227f4eb3466a6b0d16daa4",
  "claimId": "abcxyz123",
  "claimAttemptId": "...",
  "lastUpdated": 1800000000000,
  "createdAt": 1800000000000,
  "version": "0",
  "_attemptStatus": "executing",
  ...USER_ID_DETAILS, //whatever is configured
  ...YOUR_INPUTS
}'
```

**Test Requests**

In the creation / update interface, there will be a Send Test Request button which will send a formatted request from your browser. This uses mocked data, and should only be used for testing purposes.

<figure><img src="../../../../.gitbook/assets/image (147).png" alt=""><figcaption></figcaption></figure>

**Claim Tester**

The easiest way to test your plugin integration with BitBadges is with the Claim Tester tab in the developer portal. This is the only place you will be able to test unfinalized versions of your plugin.

<figure><img src="../../../../.gitbook/assets/image (8) (1) (1).png" alt=""><figcaption></figcaption></figure>

## File: ./for-developers/claim-builder/plugins/overview.md

# Overview

Plugins / webhooks are simply HTTP requests.

1. Configure your plugin / webhook in the BitBadges site
2. Set up your handler at the specified URL / method. Use the payload to implement your logic. The payload includes context about the attempt plus can include the user address, email, social usernames, custom inputs, and more.
   1. Check the pluginSecret to verify BitBadges as the origin of the request if this is important
3. Return the expected response that was configured (e.g. 200 OK)

<figure><img src="../../../.gitbook/assets/image (5) (1) (1).png" alt=""><figcaption></figcaption></figure>

```typescript
const handlePlugin = async (req: NextApiRequest, res: NextApiResponse) => {
  //Step 1: Handle the request payload from the plugin
  const body = req.body; //For POST
  const { _isSimulation, claimId, pluginSecret, bitbadgesAddress, ethAddress, solAddress, btcAddress, lastUpdated, createdAt } = body;
  const { ...otherCustomProvidedInputs } = body;
  
  //Step 1.5: Catch simulations if applicable. Don't run success logic on a dry run
  // if (_isSimulation) return doDryRunStuffOnly();
  
  //Step 2: Verify BitBadges as origin by checking plugin secret is correct
  const YOUR_PLUGIN_SECRET = '';
  if (pluginSecret !== YOUR_PLUGIN_SECRET) {
    return res.status(401).json({ message: 'Invalid plugin secret' });
  }
  
  //Step 3: Implement your custom logic here. Consider checking the plugin's creation / last updated time to implement version control.
  
  //Step 4: Return expected responses
  return res.status(200).json({});
};

export default handlePlugin;
```

We have designed plugins in a way to allow you maximum customization by letting you handle as much of the plugin logic as possible. This is a design decision as we believe the core logic of the distribution process should be decentralized and community-driven (not centralized on BitBadges servers).

**Potential Parties**

* Claim Creator - Entity creating the claim that uses the plugin
* Claiming User - End user attempting to claim
* Plugin Creator - Entity creating the plugin

**Timing of Requests**

Plugins can either be:

* Success hooks: Only sent after the claim succeeds. Typically for post-claim logic or rewards
* Processing hooks: Sent during execution and can affect the overall outcome of the claim depending on the response.

We also allow users to simulate (dry run) their claim attempts. Plugins are expected to handle these as necessary. These are all configurable in the creation process in-site.

**Parts of the Plugin**

* Backend Handler (Your API) - All plugins have a backend handler that we expect a 200 OK response from, along with other details depending on the configuration, at claim time.
* Claim Creator Input Handlers (Public / Private Parameters) - The creator will need to configure public and private parameter, if applicable. This can be done in-site or outsourced to a configuration tool.
* User Input Handlers (Custom Input Body) - The user may also need to enter inputs for the claim attempt. This can also be done in-site or outsourced to your own custom frontend.

<figure><img src="../../../.gitbook/assets/image (5) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**State Management**

If there is any core state required to be used, this must be managed on BitBadges side to avoid race conditions. To workaround this, the plugin will pass along expected updates IF the claim is passed (e.g. mark this one time use claim token as USED IF the claim is successful).

The golden rule here is that a successful response from your plugin DOES NOT mean the overall claim attempt was successful. Other plugins might fail. The other way around is also true. If your plugin fails, the overall claim may still be successful (e.g. 1 out of 10 plugins must pass but yours fails).

**Published Plugins**

Plugins are private and only usable by the creator and approved users by default, but you can publish them as well. Published plugins will be displayable in the directory (after a review process) and selectable by anyone creating a claim.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Plugin IDs vs Instance IDs**

Plugin IDs are constant and specific to a specific plugin type. For example, the password pluginId is "password".

Instance IDs are a unique identifier for a specific plugin in your claim. This is to handle duplicates. For example, you may have two password plugins, one with instance Id "abc" and one with "def". This is just used as a unique identifier and can really be anything. If you only have one instance of a specific type, you can name it the same as the pluginId as well.


## File: ./for-developers/claim-builder/success-logic.md

# Success Logic

Certain claims may make use of the **satsifyMethod** property to implement dynamic logic. This option is currently only available behind the scenes. Frontend defaults to all are required (satisfyMethod = undefined). By default, all plugins must pass without any custom success logic specified.

<figure><img src="../../.gitbook/assets/image (188).png" alt=""><figcaption></figcaption></figure>

This works in the following ways:

* By default, if  **satisfyMethod** is falsy (undefined), ALL plugins are required in order for the overall claim to succeed.
* The "numUses" plugin or those critical to assigning claim numbers are required and cannot be optional
* Claimees are allowed to select which plugins they want to execute / be applied. Behind the scene this uses the **\_specificInstanceIds** property on the simulate / complete API claim request.
* For stateful plugins, we ONLY update the state for the plugins in the success path (we will short circuit where necessary).
  * For example, if there is a requirement group with 2 out of 8 plugins needing success and the first two pass, we will not even check or apply state for the other six.

```typescript
export interface iSatisfyMethod {
  type: 'AND' | 'OR' | 'NOT';
  /** Conditions can either be the instance ID of the plugin to check success for or another satisfyMethod object. */
  conditions: Array<string | iSatisfyMethod>;
  options?: {
    /** Only applicable to OR logic. Implements M of N logic. */
    minNumSatisfied?: number;
  };
}
```



## File: ./for-developers/concepts/README.md

# 👥 Concepts

This section covers core BitBadges concepts that developers need to understand when building with the platform.

## Account System

BitBadges supports multi-chain accounts, allowing users from Ethereum, Bitcoin, Solana, and Cosmos to interact with the same tokens and services using their native wallets and signing methods.


## File: ./for-developers/concepts/accounts.md

# 👤 Accounts

This page will give you an overview of BitBadges accounts. It should be enough information for most, but for more low-level interaction, [the next page](accounts-technical.md) will give you more in-depth explanations.&#x20;

#### **How is BitBadges able to support addresses from different blockchains?**

To enable interoperability between different blockchains, each individual L1 blockchain will have its native addresses mapped to an equivalent Cosmos bech32 address and an account ID number. An account ID number will be assigned to the address when it interacts with the BitBadges blockchain or is sent BADGE for the first time.&#x20;

As an example, the Ethereum null address 0x0000000000000000000000000000000000000000 maps to the BitBadges address bb1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs7gvmv and will be assigned an account ID number upon interaction with the BitBadges blockchain. It would also map to an equivalent Bitcoin address as well.

<figure><img src="../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

#### **Representation** <a href="#addresses-and-public-keys" id="addresses-and-public-keys"></a>

Ethereum Example:

-   Address (Bech32): `bb14au322k9munkmx5wrchz9q30juf5wjgz2cfqku`
-   Address (Native - [EIP55](https://eips.ethereum.org/EIPS/eip-55) Ethereum Hex): `0xAF79152AC5dF276D9A8e1E2E22822f9713474902`

Solana Example:

-   Address (Native - Base58): 6H2af68Yyg6j7N4XeQKmkZFocYQgv6yYoU3Xk491efa5
-   Address (Bech32): bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl

Bitcoin Example&#x20;

-   Address (Native - P2WPKH): bc1q9s7rynm5pwhluhecsmlku8rn5yej5wdgj0gv3e
-   Address (Bech32): bb19s7rynm5pwhluhecsmlku8rn5yej5wdg8g75f9

#### Why can I convert Solana address to a BitBadges / Eth / BTC address but not the other way around?

You may notice that you cannot go from a BitBadges / Eth address directly to a Solana address but you can the other way around. This is because conversion from a Solana address requires a hash, so if you just have the postimage of the hash (an Eth / BitBadges address), you cannot deduce the preimage without prior knowledge of it.

#### **Which address should I use (native or mapped one)? How to convert?**

For user experience, you should always display the user's native address on a frontend. However, the BitBadges blockchain **only** uses the mapped BitBadges addresses behind the scenes, never a native address. This can be converted behind the scenes using the converter functions from [BitBadges SDK](../bitbadges-sdk/) (address-converter). This can be done with any validly formatted address.

<pre class="language-typescript"><code class="lang-typescript"><strong>import { ethToBitBadges, bitbadgesToEth, convertToBitBadgesAddress } from 'bitbadgesjs-sdk';
</strong><strong>
</strong><strong>
</strong><strong>const bitbadgesAddress1 = convertToBitBadgesAddress(address);
</strong><strong>const bitbadgesAddress = ethToBitBadges(address);
</strong>const ethAddress = bitbadgesToEth(bitbadgesAddress);
const bitbadgesAddressFromSolana = solanaToBitBadges(address);
//Note there is no bitbadgesToSolana or ethToSolana due to how the addresses work
</code></pre>

#### **How do I query details for an address?**

1. You can use the [BitBadges API](../bitbadges-api/api.md) to get information about an address (recommended option). This is the recommended options because we have indexed all the data already for you.
2. You an also query a BitBadges blockchain node directly, either through the CLI or [REST API ](https://docs.cosmos.network/v0.46/run-node/interact-node.html).&#x20;


## File: ./for-developers/concepts/address-mappings-lists.md

# 📧 Address Lists (Lists)

[AddressLists](https://bitbadges.github.io/bitbadgesjs/interfaces/iAddressList.html) are a powerful feature with range logic similar to UintRanges. They allow us to specify a list of addresses, identified by a listId.

```typescript
export interface AddressList {
    listId: string;

    addresses: string[];
    whitelist: boolean;

    uri: string;
    customData: string;
}
```

### Inverting (Whitelist vs Blacklist)

These are invertible meaning we can create a list that includes all addresses EXCEPT some specified addresses (whitelist = false). Or, we can create a list that includes ONLY some specified addresses (whitelist = true). More commonly, this is thought of as a blacklist or whitelist.

**IMPORTANT:** When you invert, the inversion by default includes the "Mint" address. This is important when handling the **fromList** of approvals. You do not want to accidentally approve users to transfer from the "Mint" address.

### **Storage**

**On-Chain:** AddressLists are **permanent and not updatable** once created, if stored on-chain. These can be created using [MsgCreateAddressLists](../create-and-broadcast-txs/cosmos-sdk-msgs/).

They can be used to define transferability on-chain. For example, list "xyz" can only transfer to list "abc" initiated by the reserved "Manager" list.

The same address list is not unique to a collection on-chain and can be used for defining transferability by any collection.

**Off-Chain:** Address lists can also be created off-chain through our indexer / API. These are updatable and deletable, along with additional options. However, this is a centralized solution and doesn't use the blockchain. Everything is simply stored on our centralized servers

### **Reserved Address List IDs**

There are a couple IDs for AddressLists that are reserved for efficient shorthand methods. To enable this, "\_" and ":" and "!" are not allowed anywhere in a standard ID.

-   If prefixed with "!", it denotes to invert the address list (e.g. "!id123" inverts the "id123" address list)
-   Any valid Cosmos (bech32) address is reserved as the list that ONLY includes that specific address.
-   "Mint" specifies the "Mint" address only.
-   "AllWithoutAddress1" denotes all valid user addresses excluding Address1 (e.g. "AllWithoutMint")
-   "AllWithoutAddress1:Address2:Address3" denotes all valid user addresses excluding Address 1,2,and3 (e.g. "AllWithoutMint:bb123...:bb456...")
-   "All" or "AllWithMint" denotes all valid user addresses as well as the "Mint" address

See below for the function for generating them.

### Custom IDs

Reserved address lists are provided for convenience, so you don't actually have to create an AddressList on-chain first. However, long list IDs are very inefficient, especially if used multiple times (e.g. "AllWithoutMint:bb123...:bb456...").&#x20;

For efficiency, consider creating a list with a unique short ID and reference the list that way. You can create a list which is all addresses except Mint, bb123..., bb456... and identified by the ID "abc". Instead of repeating the long "AllWithoutMint:bb123...:bb456..." wherever the ID is needed, you can simply repeat "abc" which saves a lot of resources.

### Examples

This is the list which includes all addresses except "bb123...." and "bb456...."

```typescript
{
  "listId": "abcdef",
  "addresses": ["bb123...", "bb456...."],
  "whitelist": false,
  ...
}
```

<pre class="language-typescript"><code class="lang-typescript"><a data-footnote-ref href="#user-content-fn-1">function</a> getReservedList(
  addressListId: string,
  allowAliases?: boolean,
): AddressList {
  let inverted = false
  let addressList: AddressList | undefined = undefined

  if (addressListId[0] === '!') {
    inverted = true
    addressListId = addressListId.slice(1)
  }

  if (addressListId === 'Mint') {
    addressList = {
      listId: 'Mint',
      addresses: ['Mint'],
      whitelist: true,
      uri: '',
      customData: '',
      createdBy: '',
    }
  } else if (addressListId.startsWith('AllWithout')) {
    addressList = {
      listId: addressListId,
      addresses: [],
      whitelist: false,
      uri: '',
      customData: '',
      createdBy: '',
    }

    const addresses = addressListId.slice(10).split(':')

    for (let address of addresses) {
      addressList.addresses.push(address)
    }
  } else if (addressListId === 'AllWithMint' || addressListId === 'All') {
    addressList = {
      listId: addressListId,
      addresses: [],
      whitelist: false,
      uri: '',
      customData: '',
      createdBy: '',
    }
  } else if (addressListId === 'None') {
    addressList = {
      listId: 'None',
      addresses: [],
      whitelist: true,
      uri: '',
      customData: '',
      createdBy: '',
    }
  } else {
    //split by :
    const addressesToCheck = addressListId.split(':')
    let allAreValid = true
    //For tracker IDs, we allow aliasses(aka non valid addresses)
    if (!allowAliases) {
      for (let address of addressesToCheck) {
        if (address != 'Mint' &#x26;&#x26; !convertToBitBadgesAddress(address)) {
          allAreValid = false
        }
      }
    }

    if (allAreValid) {
      addressList = {
        listId: addressListId,
        addresses: addressesToCheck,
        whitelist: true,
        uri: '',
        customData: '',
        createdBy: '',
      }
    }
  }

  if (inverted &#x26;&#x26; addressList) {
    addressList.whitelist = !addressList.whitelist
  }

  if (!addressList) {
    throw new Error(`Invalid address list ID: ${addressListId}`)
  }

  return addressList
}
</code></pre>

[^1]:


## File: ./for-developers/concepts/balances.md

# 📊 Balances

For an overview, first read [Balances / Transfers](../../overview/how-it-works/time-dependent-ownership.md).

```typescript
export interface Balance<T extends NumberType> {
  amount: T;
  badgeIds: UintRange<T>[]
  ownershipTimes: UintRange<T>[]
}
```

**Interpreting Balances**

When interpreting balances, there are certain rules to keep in mind. If we have multiple ranges of token IDs and ownership times defined within a single Balance structure, it means that we own all possible combinations.&#x20;

```
for (balance of balances) {
    for (badgeIdRange of balance.badgeIds) {
        for (ownershipTimeRange of balanace.ownershipTimes) {
            //User owns x(balance.amount) of (badgeIdRange) for the times (ownershipTimeRange)
        }
    }
}
```

For example, lets say we have a balance of&#x20;

<pre class="language-json"><code class="lang-json"><strong>{ 
</strong>    amount: 1, 
    badgeIds: [{ start: 1, end: 10}, {start: 20, end: 30}], 
    ownershipTimes: [{start: 20, end: 50}, {start: 100, end: 200}] 
}
</code></pre>

This can be expanded and thought of as owning:

* x1 of IDs 1-10 from times 20-50&#x20;
* x1 of IDs 1-10 from times 100-200
* x1 of IDs 20-30 from times 20-50
* x1 of IDs 20-30 from times 100-200

If we wanted to subtract the first set of balances (x1 of IDs 1-10 from times 20-50), we would then need to represent it as two separate balances:&#x20;

```
{ 
    amount: 1, 
    badgeIds: [{ start: 1, end: 10}, {start: 20, end: 30}], 
    ownershipTimes: [{start: 100, end: 200}] 
}
```

```
{ 
    amount: 1, 
    badgeIds: [{start: 20, end: 30}], 
    ownershipTimes: [{start: 20, end: 50}}] 
}
```

**Duplicates**

If you specify duplicate token IDs in balances such as:

```
{ 
    amount: 1, 
    badgeIds: [{ start: 1, end: 10}, {start: 1, end: 10}], 
    ownershipTimes: [{start: 100, end: 200}] 
}
```

This is equivalent and will be treated as:

```
{ 
    amount: 2, 
    badgeIds: [{ start: 1, end: 10}], 
    ownershipTimes: [{start: 100, end: 200}] 
}
```


## File: ./for-developers/concepts/chain-details.md

# ✏ Chain Details

Cosmos Chain ID (Mainnet) - bitbadges-1

Cosmos Chain ID (Testnet) - bitbadges-2

[Cosmos SDK Coin Denom](https://docs.cosmos.network/main/modules/bank) - "ubadge" (1 BADGE = 1 \* 10^9 ubadge)


## File: ./for-developers/concepts/uint-ranges.md

# 🔢 Uint Ranges

<pre class="language-typescript"><code class="lang-typescript"><strong>export interface UintRange&#x3C;T extends NumberType> {
</strong>  start: T;
  end: T;
}
</code></pre>

A core type behind the scenes in BitBadges is the [UintRange](https://bitbadges.github.io/bitbadgesjs/interfaces/iUintRange.html) type, which simply defines a range of numbers from some start value to some end value, inclusive. This allows us to apply powerful range logic.

These are typically used for representing token IDs and time ranges. For example, transferring tokens will require an UintRange\<number>\[] of badgeIds to be specified. If you say to transfer \[{ start: 1, end: 10}, {start: 20, end: 50}], it will transfer the token IDs 1-10 and 20-50.

**Restricted Values**

If used for token IDs or times, we only allow the start and end to be within the range of 1 to Go's math.MaxUint64 or 18446744073709551615 (**so no zero value and no value greater than that**).

To represent a "full" or "complete" range, use \[{ start: 1, end: 18446744073709551615 }]. If we invert a range, we get all the values from 1 to 18446744073709551615 that are not in the current range.

```json
"transferTimes": [
  {
    "start": "1",
    "end": "18446744073709551615"
  }
]
```


## File: ./for-developers/create-and-broadcast-txs/cosmos-sdk-msgs/msgcreateaddressmappings.md

# MsgCreateAddressLists

To create an on-chain AddressList, you can use the MsgCreateAddressLists. See [here](../../core-concepts/address-lists-lists.md) to learn more about AddressLists.

Reminder: on-chain address lists are immutable, permanent. and non-deletable.

```typescript
export interface MsgCreateAddressLists {
  creator: string;
  addressLists: AddressList[];
}
```

```typescript
export interface AddressList {
  listId: string;

  addresses: string[];
  whitelist: boolean;

  uri: string; 
  customData: string;
}
```



**Combining with MsgCreateCollection or MsgUpdateCollection**

Oftentimes, you want to create a new AddressList, so it can be used in a MsgCreateCollection or MsgUpdateCollection (for example, defining transferability using a new, custom list ID).

Before an AddressList can be used, it needs to be defined on-chain. The two Msgs can be easily combined in the same transaction (as Cosmos transactions support multiple Msgs). See [here](../../bitbadges-sdk/common-snippets/creating-signing-and-broadcasting-txs.md) for an example of how to do it with the SDK. Just make sure MsgCreateAddressLists is executed first and precedes when it is actually used.

```typescript
const msgs: MessageGenerated[] = [];
msgs.push(...bootstrapLists().map(x => createProtoMsg(x))); //MsgCreateAddressLists
msgs.push(...bootstrapCollections().map(x => createProtoMsg(x))) //MsgCreateCollections

//Note how MsgCreateAddressLists is first in the array
const txn = createTransactionPayload(txContext, msgs);
```



## File: ./for-developers/getting-started.md

# 🔨 Getting Started

BitBadges is proud to offer no-code / low-code flows for all our major services. Simply navigate to the Create tab in-site, and get started creating tokens, claims, address lists, explore listings, applications, and more!

<figure><img src="../.gitbook/assets/image (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

> **Need help?** Join our Discord for support from the BitBadges team and community developers.
>
> **Need BADGE?** Contact us on Discord - get subsidized credits for developers during chaosnet!
>
> **No-Code / In-Site Solutions** Check out the [Create tab](https://bitbadges.io/create) or the [developer portal](https://bitbadges.io/developer) first to see what all is possible. Most of the time, you can just do everything with no code directly in-site! No need for any direct integration. Let us handle everything!
>
> Get creative. You can gate URLs, Discords, and integrate with many of your favorite tools without a single line of code!

## Explore First, Read Later

We strongly recommend, if you have not already, to explore the claim tester and other creation options in-site. Many of your questions should be answered by the interface and is much easier to understand than a bunch of long text here in this documentation. Just go explore and experiment first.

Most of your setup and management (and oftentimes all) will be done directly in-site via the developer portal or Create tab. Get started at [https://bitbadges.io/create](https://bitbadges.io/create).

## Tokens vs Badges

We use the terms tokens and badges interchangeably. For example, "badgeIds" refers to token IDs. In the past, our niche was primarily earned badges, and we are slowly trying to rollout rebrands to full tokens. However, the core interface is still named "badges" behind the scenes.

## Gate Any Service In 2 Steps

Any service can be gated by ANY criteria simply in just 2 steps.

1. **Authenticate** - We recommend Sign In with BitBadges but it could be any approach
2. **Verify Claim Success** - Check the user satisfies a BitBadges claim (via post-success hooks, API, many ways!)

Claims are the universal connectors. Claim criteria can be anything from a payment to token ownership to Discord servers. Implement it any way you want (including custom logic) at [https://bitbadges.io/create](https://bitbadges.io/create)!

## Quick Start - Tokens

{% content-ref url="../x-badges/" %}
[x-badges](../x-badges/)
{% endcontent-ref %}

## Quick Start - Claims

{% content-ref url="../overview/claim-builder/" %}
[claim-builder](../overview/claim-builder/)
{% endcontent-ref %}

## Quick Start - API

{% content-ref url="bitbadges-api/" %}
[bitbadges-api](bitbadges-api/)
{% endcontent-ref %}

{% content-ref url="bitbadges-sdk/" %}
[bitbadges-sdk](bitbadges-sdk/)
{% endcontent-ref %}

```bash
npm i bitbadgesjs-sdk
```

```ts
import { BitBadgesAPI } from 'bitbadgesjs-sdk';

const api = new BitBadgesAPI({
  ...
});

await BitBadgesAPI.getCollection(...);
```

## Developing with AI

Below, we provide some resources that may be helpful for developing with AI. If there is anything else we can do to make development easier, let us know!

[Cosmos Msg Proto Definitions](https://github.com/BitBadges/bitbadgeschain/tree/master/proto)

[BitBadges API OpenApi Spec](https://github.com/BitBadges/bitbadgesjs/blob/main/packages/bitbadgesjs-sdk/openapi/combined_processed.yaml) - [Stoplight Reference](https://bitbadges.stoplight.io/docs/bitbadges)

[Full Documentation .txt](../for-llms.txt)

[BitBadges AI Chatbot Starter](https://github.com/BitBadges/bitbadges-ai)

[Full SDK Reference](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html) - [Full Types Reference](https://github.com/BitBadges/bitbadgesjs/blob/main/packages/bitbadgesjs-sdk/type-map/typedoc-output.json)


## File: ./for-developers/sign-in-with-bitbadges/README.md

# Sign In with BitBadges (OAuth)



## File: ./for-developers/sign-in-with-bitbadges/approaches/redirected-callback.md

# Redirect Callback

The standard OAuth callback approach is used for immediate authentication. To enable callbacks, the parameters must have a redirect URI set that matches your app's configured one. With the callback, the user will never even see the code. Everything is handled behind the scenes immediately.

**How do callbacks work?**

A high-level overview is:

1. Users navigate to the custom SIWBB URL for your authentication request.
2. The user will be walked through the authentication process. Upon completion, an authorization code is transmitted to the redirect URI via the query parameters `code` and `state`.
3. The redirect URI can then fetch the details from the API using the transmitted code with knowledge of the configured app's client secret.

**Generating the URL**

The important part here is to correctly specify a valid **redirectUri** letting us know that you expect to receive the details immeditately.

{% content-ref url="../authorization-url/" %}
[authorization-url](../authorization-url/)
{% endcontent-ref %}

**Implementation - Backend**

```typescript
// GET /api/callback?code=...&state=...
const callbackHandler = async (req: NextApiRequest, res: NextApiResponse) => {
    //Parse the code and state from the query parameters
    const code = req.query.code;
    const state = req.query.state as string;

    //TODO: Fetch authentication details (see Verification page)
    //      const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({ code, ... });
    //TODO: Any application specific requirements

    //Learn more in the verification steps
};
```

At your redirect URI, you will need to set up a handler to handle the code / state that is passed. The code and state will be passed in via the HTTP query parameters. This follows typical OAuth2 flow. We refer you to OAuth tutorials for more details.

To ensure the security of the data exchange process, consider the following practices:

* Validate the `state` parameter according to your requirements (if applicable)
* Use HTTPS to protect the data in transit, ensuring that all communications between your server and the client are encrypted.


## File: ./for-developers/sign-in-with-bitbadges/authorization-url/README.md

# Authorization URL



## File: ./for-developers/sign-in-with-bitbadges/authorization-url/configuration.md

# Configuration

BitBadges authentication uses an OAuth URL with custom parameters: `https://bitbadges.io/siwbb/authorize?client_id=...`.

Users will visit this URL to authenticate and receive an authorization code. This code will be passed behind the scenes for digital flows via the redirect or it will be the actual QR code for in-person / delayed flows.

By default, Sign In with BitBadges will handle multi-chain authentication for the user (in other words, checking address ownership). You can additionally:

* Specify the `scope` to request additional BitBadges API permissions for the user (e.g. 'completeClaims,readAddressLists')
* Specify a `claimId` to display a specific claim to the user (for display purposes, you will need to verify the claim successes on your end). Claims open up any criteria like token ownership checks, payments, anything

## Parameter Interface

```typescript
interface CodeGenQueryParams {
    client_id: string; // Required: Your app's client ID
    redirect_uri?: string; // Required for instant auth. Not needed for QR code auth.
    state?: string; // Optional: Additional data passed to redirect
    scope?: string; // Optional: Comma-separated BitBadges API permission scopes (e.g. 'completeClaims,readAddressLists')

    // Claim UI Options (optional)
    claimId?: string; // ID of required claim
    hideIfAlreadyClaimed?: boolean; // Hide if already claimed
    expectVerifySuccess?: boolean;

    // Expect attestation presentations
    expectAttestations?: boolean;
}
```

## Key Features

### 1. App Configuration

* Create OAuth apps at [bitbadges.io/developer](https://bitbadges.io/developer)
* `client_id` is mandatory (obtained from app registration)
* `redirect_uri` required for instant auth, optional for delayed auth
* If `redirect_uri` is blank, QR code is generated and stored in user's account
* See OAuth tutorials for more details

### 2. Scopes

* This is only needed for authorized BitBadges API access. By default, you will verify address ownership with no scopes.
* Format: `scope: 'completeClaims,readAddressLists'`
* View all available scopes at [bitbadges.io/auth/linkgen](https://bitbadges.io/auth/linkgen)

### 3. Claims

* Specify required claim to be satisfied with `claimId`
* Create the claim in the developer portal. See claim docs for more details.
* Claims are not a part of the core authentication process. You need to verify them separately server-side to ensure the user has met the criteria.


## File: ./for-developers/sign-in-with-bitbadges/authorization-url/generating-the-url.md

# Generating the URL

The base URL is [https://bitbadges.io/siwbb/authorize](https://bitbadges.io/siwbb/authorize), with parameters appended to it.

For instance:

```vbnet
https://bitbadges.io/siwbb/authorize?client_id=...
```

This URL structure adheres to the following interface:

* **Base URL**: [https://bitbadges.io/siwbb/authorize](https://bitbadges.io/siwbb/authorize)
* **Parameters**: Custom parameters specific to your implementation.

You can use [https://bitbadges.io/auth/linkgen](https://bitbadges.io/auth/linkgen) or the code below to generate the URL or click Create SIWBB URL directly from your app in the developer portal (recommended).

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

**Snippets**

<pre class="language-typescript"><code class="lang-typescript"><strong>import { generateBitBadgesAuthUrl, CodeGenQueryParams } from 'bitbadgesjs-sdk';
</strong>
const popupParams: CodeGenQueryParams {
    ...
} // See Authentication URL page

<strong>const authUrl = generateBitBadgesAuthUrl(popupParams);
</strong></code></pre>

```ts
export const generateBitBadgesAuthUrl = (params: CodeGenQueryParams) => {
    let url = `https://bitbadges.io/siwbb/authorize?`;
    for (const [key, value] of Object.entries(params)) {
        if (value) {
            if (typeof value === 'object') {
                const valueString = JSON.stringify(value);
                const encodedValue = encodeURIComponent(valueString);
                url = url.concat(`${key}=${encodedValue}&`);
            } else {
                url = url.concat(`${key}=${value}&`);
            }
        }
    }
    return url;
};
```


## File: ./for-developers/sign-in-with-bitbadges/overview.md

# Overview

Sign In with BitBadges (SIWBB) is a unified multi-chain authentication solution that works across all blockchain ecosystems. It replaces traditional "Sign In with X" buttons and can be configured to handle the following all in one flow:

* Multi-chain authentication
* Token ownership verification
* Integration with 7000+ supported apps and plugins
* BitBadges API scope authorizations

#### Use Alternatives If Possible

NOTE: This is mainly intended for OAuth authorization for the BitBadges API. If you don't need this, then we recommend you use other Web3 services out there for Web3 authentication now like WalletConnect, MagicAuth, etc.&#x20;

Combining authentication + criteria checks (claim successes, token ownership) is a powerful combination with the BitBadges API. Simply 1) authenticate and 2) check criteria using our API.

```typescript
// Pre-req: Create claim in BitBadges site
// 1. Authenticate your user (using your existing setup)
// 2. Verify claim success
const res = await BitBadgesApi.checkClaimSuccess(claimId, address);
```

#### OAuth Endpoints

* **Authorization:** `https://bitbadges.io/siwbb/authorize?your_params`
* **Token:** `https://api.bitbadges.io/api/v0/siwbb/token`
* **Revoke:** `https://api.bitbadges.io/api/v0/siwbb/token/revoke`

[**Demo**](https://bitbadges.io/siwbb/authorize?client_id=example-client-id\&redirect_uri=https://example.com&)

## Implementation Flow

1. **Authentication- BitBadges Side**
   * User accesses BitBadges URL (direct or popup)
   * Proves address ownership and other criteria (tokens, etc.)
   * Receives authorization code from BitBadges (QR or behind the scenes via redirect)
2. **Integration- Your App Side**
   * Receive authentication response
   * Check criteria on your end
   * Implements security measures (prevent replay attacks, etc.)
   * Focus on your core utility


## File: ./for-developers/sign-in-with-bitbadges/setting-up-an-app.md

# Setting Up an App

### App Registration

* Register at [https://btibadges.io/developer](https://btibadges.io/developer) -> OAuth Apps
* Take note of your client ID / secret

### Key Components

#### 1. Client ID

* Unique identifier for your app
* Assigned upon registration

#### 2. Client Secret

* Cryptographic key for API authentication
* Keep confidential; never expose in client-side code. Treat like a password.
* Required to fetch user authentication details

#### 3. Redirect URIs

* Endpoints where users are redirected after authentication
* Must be pre-registered and use HTTPS
* Not needed for delayed/QR code authentication. Only for immediate digital redirects.

### Security Notes

* Treat client secret as securely as a password
* Ensure exact match between registered and used redirect URIs (if applicable)
* Use HTTPS for all redirects for security reasons


## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/README.md

# Templates and Frameworks



## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/auth0.md

# Auth0

### **Social Connection Integration**

When adding a Social Connection, you will see BitBadges as a preconfigured option. This has everything setup for you. You will simply need to specify your client ID and client secret. You will also have to configure your redirect URI to match your Auth0 application's domain. This typically ends with /callback (for example, [https://dev-pgv803tz4ztg35oi.us.auth0.com/login/callback](https://dev-pgv803tz4ztg35oi.us.auth0.com/login/callback)).

### [https://marketplace.auth0.com/integrations/bitbadges](https://marketplace.auth0.com/integrations/bitbadges)

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (126).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Custom

You can also customize the connection further by creating a custom connection. This allows you to add parameters beyond the standard flow. You callback will be the same as above.

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Authorization URL:** https://bitbadges.io/siwbb/authorize

**Token URL:** https://api.bitbadges.io/api/v0/siwbb/token

**Scopes:** None (All you typically need is the user crypto address) - Although, you can add as needed

**Fields:** Get your API key, client ID, and client secret at https://bitbadgesio/developer.

**Fetch Profile Script**:

```javascript
function fetchUserProfile(accessToken, ctx, cb) {
    request.post(
        {
            url: 'https://api.bitbadges.io/api/v0/auth/status',
            headers: {
                'Content-Type': 'application/json',
                // TODO: Replace
                'x-api-key': 'ENTER_API_KEY_HERE',
                Authorization: 'Bearer ' + accessToken,
            },
        },
        (err, resp, body) => {
            if (err) {
                return cb(err);
            }
            if (resp.statusCode !== 200) {
                return cb(new Error(body));
            }
            let bodyParsed;
            try {
                bodyParsed = JSON.parse(body);
            } catch (jsonError) {
                return cb(
                    new Error('Failed JSON parsing for user profile response.')
                );
            }

            const account = bodyParsed;

            const profile = {
                address: account.address,
                chain: account.chain,
                id: account.bitbadgesAddress,
                name: account.address,
            };
            return cb(null, profile);
        }
    );
}
```

**Custom Headers:**

Make sure you enter your API key in the custom headers an d replace it in the fetch script.

```
{
    "x-api-key": "YOUR_API_KEY"
}
```


## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/discourse.md

# Discourse

For Discourse, we do not have a dedicated plugin, but SIWBB is OAuth2 compatible and integrated with other providers. So, you can reuse existing plugins as needed.

**Auth0 Plugin**

Set up SIWBB with Auth0 here:

{% content-ref url="auth0.md" %}
[auth0.md](auth0.md)
{% endcontent-ref %}

Then, integrate with Discourse here:

{% embed url="https://meta.discourse.org/t/configure-sign-up-and-log-in-with-auth0-using-the-oauth2-basic-plugin/64633" %}

**OAuth2 Plugin**

{% embed url="https://meta.discourse.org/t/discourse-oauth2-basic/33879" %}


## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/expressjs.md

# ExpressJS

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadges-passportjs-example/blob/main/index.ts" %}


## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/others.md

# Others

Many of your favorite frameworks already support Auth0, and you can simply use Sign In with BitBadges through that.

* Auth.js (Next Auth) - [https://authjs.dev/getting-started/providers/auth0](https://authjs.dev/getting-started/providers/auth0)
* Amazon Cognito - [https://auth0.com/docs/customize/integrations/aws/amazon-cognito#configure-amazon-web-services](https://auth0.com/docs/customize/integrations/aws/amazon-cognito#configure-amazon-web-services)
* Supabase - [https://supabase.com/partners/integrations/auth0](https://supabase.com/partners/integrations/auth0)

If you have any suggestions for unsupported integrations as well, let us know! And again, note that you are not locked into Sign In with BitBadges. You can use any Web3 authentication provider and then check BitBadges claim successes to gate anything.


## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/supabase.md

# Supabase

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadges-supabase-demo" %}

This repository is a basic example for getting started with Supabase and Sign in with BitBadges. It is meant to be a starting point and is not production ready.

This example:

* Uses the Next.js x Supabase template
* Uses traditional Supabase authentication and once signed in, you can additionally Sign In with BitBadges. This effectively creates a username <-> address mapping that you can use.

<figure><img src="../../../.gitbook/assets/image (226).png" alt=""><figcaption></figcaption></figure>

Anything else is left as an exercise for you.

* Gating the entire site rather than using traditional authentication
* Gating specific pages / implementing your utility
* Linking claims

Note: Supabase is flexible. You may choose to implement it via Express, Auth0, or another way as well. This is just a reference to help you get started.

**Setup**

1. Setup Supabase as explained via their documentation
2. Add your BitBadges API key, client ID, and client secret to your .env
3. Execute the SQL in supabase/migrations folder to setup the tables. This can be done via the SQL Editor in the dashboard.


## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/wordpress.md

# WordPress

Gate your WordPress site with BitBadges! Authenticate with SIgn In with BitBadges and check any claim criteria, allowing you to create multi-chain websites gated for anything.

Directory Link: [https://wordpress.org/plugins/sign-in-with-bitbadges/](https://wordpress.org/plugins/sign-in-with-bitbadges/)

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadges-wp-plugin" %}

<figure><img src="../../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

This plugin allows users to gate their WordPress site with BitBadges – claims, payments, NFT badges, and more!

\== Description ==

This plugin allows users to gate their site with BitBadges - claims, payments, NFT badges, and more!

**Important Note:** This plugin ONLY handles authentication with BitBadges - it does not restrict access to your site by itself. For restricting access, we recommend using this plugin in conjunction with:

* [Force Login](https://wordpress.org/plugins/wp-force-login/) - Forces users to log in to view your site
* [Restrict Content](https://wordpress.org/plugins/restrict-content/) - Restrict content to logged-in users
* [Members](https://wordpress.org/plugins/members/) - Advanced user roles and permissions
* Or other plugins that restrict access to your site

\== Installation ==

1. Download the plugin files and upload them to your `/wp-content/plugins/` directory
2. Activate the plugin through the 'Plugins' menu in WordPress
3. Go to Settings > BitBadges SIWBB to configure the plugin

\== Configuration ==

1. Create a new application (OAuth App) in the [BitBadges Developer Portal](https://bitbadges.io/developer)
2. Set your redirect URI to: `https://your-wordpress-site.com/wp-login.php?action=bitbadges-callback`
3. Copy your Client ID and Client Secret
4. Go to your WordPress admin panel > Settings > BitBadges SIWBB
5. Enter your Client ID and Client Secret
6. (Optional) Configure a claim ID to gate access and other additional settings
7. Save the settings

\== Features ==

* Adds a "Sign in with BitBadges" button to the WordPress login form
* Creates WordPress users automatically when they first sign in with BitBadges
* Secure OAuth 2.0 implementation with state verification
* Simple admin interface for configuration
* Optional exclusive BitBadges authentication mode (disable normal WordPress login)
* Claim-gated access support
* Emergency admin access URL for exclusive mode
* Customizable claim visibility on authorization page

\== Security ==

* CSRF protection using state parameter
* Secure storage of client credentials
* WordPress nonce verification
* Input sanitization
* Proper error handling
* Secure admin access fallback
* Claim verification

\== User Experience ==

* Clean, centered login button design
* Shortened wallet addresses for better readability
* Clear separation between traditional and BitBadges login
* Visible claim requirements before authentication
* Seamless first-time user setup

\== Requirements ==

* WordPress 5.0 or higher
* PHP 7.0 or higher
* HTTPS enabled on your site (required for secure OAuth)

\== Support ==

For support or feature requests, please visit the [BitBadges website](https://bitbadges.io) or create an issue in the GitHub repository.

\== License ==

This plugin is licensed under the GPL v2 or later.\
License URI: https://www.gnu.org/licenses/gpl-2.0.html

\== Changelog ==

\= 1.0.0 =

* Initial release with basic OAuth functionality
* Added exclusive authentication mode
* Added claim-gating support
* Added emergency admin access
* Improved user display names
* Enhanced UI/UX for login button
* Added claim visibility options


## File: ./for-developers/sign-in-with-bitbadges/verification/README.md

# Verification



## File: ./for-developers/sign-in-with-bitbadges/verification/access-tokens.md

# Access Tokens

With access tokens, you can start sending requests to authenticated endpoints with your access token specified in the Authorization header as "Bearer YOUR\_ACCESS\_TOKEN".

If you did not request any specific scopes, you will still have access to the health check endpoint to ensure the user has not revoked authorization.

<figure><img src="../../../.gitbook/assets/image (96).png" alt=""><figcaption></figcaption></figure>

If you are using the SDK, you can instead do this which handles the header setting:

```typescript
BitBadgesApi.setAccessToken(token);
BitBadgesApi.unsetAccessToken();
```

Access tokens by default expire in 1 day, and refresh tokens expire in 60 days. Note that they may also become invalid as the user revokes access to them as well.

**Health Checks**

To check that you are signed in, use the following route. This will return signedIn: false if not authenticated, access token is expired, or authorization has been revoked.

Note: This can even be used when no scopes are requested.

```typescript
// POST /api/v0/auth/status {}
const res = await BitBadgesApi.checkIfSignedIn({})
// 200 { signedIn: boolean, scopes: [...], ... }
console.log(res.signedIn)
```

**Refreshing**

```typescript
const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({
    refresh_token
    grant_type: 'refresh_token',
    client_secret: '...',
    client_id: '...',
    redirect_uri: '...' //only needed if redirected
});

const { access_token, access_token_expires_at, refresh_token, refresh_token_expires_at } = res;
```

Using the refresh token obtained previously, you can exchange for a new access token and refresh token (with expiration reset) on a rolling basis. This step can be repeated indefinitely.

**Revoking Access**

Once you are done with the access token, you should revoke your access to it via the following. This can also be done by the user via the Connections -> Authorizations tab in-site. This can be done by either the user or the app.

```typescript
// POST https://api.bitbadges.io/api/v0/siwbb/token/revoke
await BitBadgesApi.revokeOauthAuthorization({ token });
```


## File: ./for-developers/sign-in-with-bitbadges/verification/security-considerations.md

# Security Considerations

This flow is OAuth 2.0 compatible, so we refer you to the official spec and other OAuth 2.0 resources for security considerations with the protocol itself (replay attacks, man in the middle, etc).

You may also be prone to flash criteria checks, such as flash ownership checks. For example, Bob signs in, transfers a token to Alice, and Alice signs in with the same token. Both are authenticated with the same token which may not be the intended behavior. This can apply to any criteria not just tokens. Ensure your claim criteria, attestations, etc protect against such cases.


## File: ./for-developers/sign-in-with-bitbadges/verification/verification-flow.md

# Verification Flow

From the prior pages, you should now have the authorization **code** (32 byte hex) for the user.&#x20;

```typescript
// 32 byte hex string
async function myHandler(req: NextApiRequest, res: NextApiResponse) {
    const code = req.query.code as string;
}
```

You can now exchange the code and valid app configuration details. Be sure to keep the client secret secret. The response will contain all authentication details, including a **verificationResponse**.

**Exchanging the Code**

The next step is to exchange the code for authentication details. This is done via the exchange endpoint. This follows typical OAuth2 flow. You can also specify options to check the issued at time of code generation. Typically for in-person, you may need to disable the issued at time check of 10 minutes.

[API Reference](https://bitbadges.stoplight.io/docs/bitbadges) -> Exchange SIWBB Code

```typescript
// 32 byte hex string
async function myHandler(req: NextApiRequest, res: NextApiResponse) {
    const code = req.query.code as string;

    const options = {
        issuedAtTimeWindowMs: 1000 * 60 * 10, // 10 minutes (set to 0 to disable)
    };

    // POST https://api.bitbadges.io/api/v0/siwbb/token
    const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({
        code,
        options,
        grant_type: 'authorization_code',
        client_secret: '...',
        client_id: '...',
        redirect_uri: '...', //only needed for digital immediate flow
    });

    const { address, chain, verificationResponse } = res;
    if (!verificationResponse.success) {
        console.log(verificationResponse.errorMessage);
        throw new Error('Not authenticated');
    }
    
    //Verify claims or anything else you need to do here
}
```

**Access Tokens / Session Management**

We return access tokens and refresh tokens for you to perform session management. The expiration times can help you implement sessions for your users, and you can health check the user hasn't revoked through the API. Code exchanges can only be performed once per unique code which is checked on our end.

```typescript
// 32 byte hex string
async function myHandler(req: NextApiRequest, res: NextApiResponse) {
    const code = req.query.code as string;

    // POST https://api.bitbadges.io/api/v0/siwbb/token
    const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({ ... });

    const { access_token, access_token_expires_at, refresh_token, refresh_token_expires_at } = res;
    // TODO: You can use these tokens for session management and authorized API access
}
```

Note this is not the only way of implementing sessions. You may implement custom approaches on your own like checking IDs, stamping hands, using claim numbers, etc.

{% content-ref url="api-access-tokens.md" %}
[api-access-tokens.md](api-access-tokens.md)
{% endcontent-ref %}

**Verifying Other "Attached" Criteria**

For any other criteria like claim verification or attestations, you must check this additionally server-side. Do not trust that if you added `claimId` in the URL params that it is automatically verified.

```typescript
async function myHandler(req: NextApiRequest, res: NextApiResponse) {
    const code = req.query.code as string;

    // Exchange code from above

    const { address, chain, verificationResponse } = res;

    // ...

    // After verifying the address, you can now check other criteria with knowledge that the user is the owner of the address
    // const claimAttemptsByAddress = await BitBadgesApi.getClaimAttempts(claimId, { address });
    // const ownershipRequirementsRes = await BitBadgesApi.verifyOwnershipRequirements(...);
    // const addressListsRes = await BitBadgesApi.getAddressLists(...);
}
```

**Putting It Together**

```typescript
import { BitBadgesApi } from 'bitbadgesjs-sdk';

// 32 byte hex string
async function myHandler(req: NextApiRequest, res: NextApiResponse) {
    const code = req.query.code as string;

    const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({
        code,
        options,
        grant_type: 'authorization_code',
        client_secret: '...',
        client_id: '...',
        redirect_uri: '...', //only needed if immediate
    });

    const { address, chain, verificationResponse } = res;
    if (!verificationResponse.success) {
        console.log(verificationResponse.errorMessage);
        throw new Error('Not authenticated');
    }

    const {
        access_token,
        access_token_expires_at,
        refresh_token,
        refresh_token_expires_at,
    } = res;
    // TODO: You can use these tokens for session management and authorized API access

    // After verifying the address, you can now check other criteria with knowledge that the user is the owner of the address
    // const claimsRes = await BitBadgesApi.getClaims({ ... });

    //TODO: Handle other checks and logic here
    // - Prevent replay attacks by checking timestamps or nonces
    // - Need to cache anything for later use?
    // - If verifying with assets, is the asset transferable and prone to flash ownership attacks (e.g. one use per asset, etc)?
    // - Other criteria needed for signing in? (e.g. whitelist / blacklist of addresses signing in)
    // - Verify claim criteria

    //TODO: If receiving attestations, are the contents valid?
    //For example:
    // - Verify the contents of the attestation messages are correct
    // - Verify the creator is who you expect
    // - Verify the metadata is correct
    // - Verify the on-chain anchors / update history are correct
    // - Verify the update history is correct
}
```

## **IMPORTANT: What is verified natively vs not?**

Does check :white\_check\_mark:

* Proof of address ownership via their authenticated BitBadges account
* Anything specified in the verify challenge options
* Issued at time of code generation is not too long ago if **options.isssuedAtTimeWindowMs** is specified. Defaults to 10 minutes.
* One exchange per authorization code -> access / refresh token

Does not check natively :x:

* Additional app-specific criteria needed for signing in (claims, ownership requirements, attestations)
* Does not natively prevent against flash ownership attacks, replay attacks, or man-in-the-middle attacks other than what OAuth2 protects against



## File: ./overview/badge.md

# 🪙 BADGE

BADGE is the native gas token for our blockchain. Please read our policies (including our [BADGE disclosure](https://bitbadges.io/credits-disclosure)) on our site for full disclaimers and information.&#x20;

<figure><img src="../.gitbook/assets/image (230).png" alt=""><figcaption></figcaption></figure>

BADGE has 3 primary purposes:

1. Gas / Transaction Fees
2. Proof of Stake - Validators bonding BADGE for the security of the network via staking. In addition to network fees, our 0.5% protocol fee goes to the community pool / validators which makes the protocol sustainable.
3. In-Site Currency - Although note that we will prioritize others like USDC and other more established ones for in-site use

For current distributions, supply, and more, we refer you to our explorer: [https://explorer.bitbadges.io](https://explorer.bitbadges.io/).

Relevant addresses for undistributed BADGE (currently \~50M) are:

* bb1kx9532ujful8vgg2dht6k544ax4k9qzsp0sany
* bb1akp5qudlhyp08m4k6826hn8mhqwmely6xvr7t2



BADGE is listed on Osmosis at [https://app.osmosis.zone/assets/BADGE](https://app.osmosis.zone/assets/BADGE) and compatible with other IBC-enabled services.

Excluding block rewards, the initial circulating supply of BADGE is 100M. We plan to distribute BADGE throughout chaosnet via the following methods:

* \~20M already in the community pool
* \~20M to bootstrap initial validators
* \~20M core team
* \~40M airdropped through incentivized programs, campaigns, and more. Stay tuned for more details.

<figure><img src="../.gitbook/assets/image (229).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/claim-builder/README.md

# 🎁 BitBadges Claims



## File: ./overview/comparing-bitbadges-to-other-protocols.md

# ⚖️ BitBadges L1 vs Others

## Comparing BitBadges L1 to Other Protocols

BitBadges is a unique L1 (Layer 1) blockchain built using the Cosmos SDK that aims to simplify the multi-chain experience. The BitBadges token (badge) standard is not EVM-compatible, ERC-20 compatible, or Bitcoin Ordinals compatible. Instead, we offers our own flexible, ever-evolving token standard, making it easier to build multi-chain applications. This is because it is compatible with ANY wallet from ANY chain, all with ONE interface.

While BitBadges may lack some of the native smart contract support and interoperability features of other protocols, its self-contained design and API-like token standard can be a compelling solution for certain use cases.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Chain Architecture

BitBadges is its own L1 blockchain, not a layer-2 or sidechain solution. It is built using the Cosmos SDK, which gives it flexibility and scalability. It also connects to the IBC ecosystem and all other Cosmos features.

Protocols like Bitcoin Oracles, Ethereum NFTs, and Solana NFTs are all deployed on their respective chain and not compatible with each other. If you wanted to implement a token-gated application for all those chains, you would need to issue tokens on every chain. With BitBadges, it is one token in one place for all users from any chain.

### Security Model

Yes, BitBadges may not be as secure or decentralized (yet) as some other protocols. It is its own L1, and over time, we will only get more decentralized and secure. However, we actually envision BitBadges being a flexible part of any application stack and used where needed rather than an all encompassing solution.

For example, when building an application, you may use BitBadges for authentication / website gating but still accept payments in your native or preferred currency.

### Cross-Chain Interoperability

BitBadges is not interoperable in the traditional sense, as it is a self-contained L1 blockchain. BitBadges does not "pull" or "connect" data from other chains. All relevant data is stored on the BitBadges chain, simplifying application development.

However, it supports users and wallets from any chain, allowing for easy multi-chain token transfers and multi-chain application development (e.g. Ethereum users can transfer tokens to Solana users to Bitcoin users). For example, Bitcoin users can sign BitBadges transactions with their Bitcoin wallets.

### Token Standard

BitBadges offers its own token standard built from the ground up that functions more like an API where everything is already implemented natively, and you just customize the requests (as Cosmos SDK Msgs) behind the scenes. This is how the BitBadges site is all no-code by default.

This approach vastly differs to existing ones requiring an individual smart contract for all tokens. Protocols like Ethereum rely on ERC-20 tokens, which require individual smart contract deployments and management. This approach gets complex, vulnerable to security flaws, and does not support the required structure.

### Smart Contract Support

While BitBadges does not natively support EVM or ERC-20 contracts, it does support CosmWASM contracts, allowing for the extension of functionality and the creation of dApps. However, our goal is to keep evolving our token standard so that no custom contracts are EVER needed.

Protocols like Ethereum and Solana have robust smart contract support, enabling a wide range of decentralized applications.


## File: ./overview/contributing.md

# 👨💻 Contributing

Everything is open-sourced and can be found at [https://github.com/bitbadges](https://github.com/bitbadges). Contributions to the core source code are greatly appreciated.&#x20;

Additionally, you can contribute by building on top of BitBadges. This can be anything from a dApp (decentralized application) to a developer tool to your own frontend for tokens! If you do, reach out to us, so we can add it to [Ecosystem](ecosystem.md).

**Rewarding Developers**

In the future, we plan to host hackathons, bug bounties, and setup a developer funding pool where developers are rewarded for contributing and building with BitBadges.

**Improvement Proposals**

The official BitBadges improvement proposals repository can be found at [https://github.com/BitBadges/BBIPs](https://github.com/BitBadges/BBIPs).&#x20;

**Bug Bounties**

TBD

Let us know if you have another idea and how we can help.


## File: ./overview/faq.md

# ❓ FAQ

### **Are smart contracts needed?**

No! All tokens are no-code with tons of functionality out of the box. One universal standard that can support any use case with no code, no smart contracts. It is all a Cosmos SDK module reused for any token type.

### **Is BitBadges an L1 blockchain or an L2?**

BitBadges is its own Layer-1 blockchain built with Cosmos SDK.

### **Why the registry architecture over unique smart contracts for every collection?**

Typical NFTs and digital tokens (ERC721, ERC20) all require their own unique smart contracts to be implemented which follow their respective interface. However, BitBadges is not built like this. BitBadges uses a single registry and the same code is reused for all collections. This is a much more secure and scalable solution.

We do this for multiple reasons:

1. Security: The same code is being reused and over time, it will become more battle-tested and more secure. This is as opposed to unique smart contracts that can often have vulnerabilities, as seen with the large amount of hacks occurring in the Ethereum ecosystem.
2. Scalability: Since duplicate code doesn't need to be deployed, this solution is much more scalable.
3. Consistency: This provides a much cleaner and more consistent interface for querying, indexing, and maintenance.

### **Are tokens ERC-721 or ERC-20 compatible?**

While our token standard takes inspiration from existing standards like ERC-721, our token standard has its own properties and architecture. However, they are a superset of these standards (offer all the features these standards + 1000x more).

Cosmos modules (like our token standard) can be called from EVM environments using the Cosmos EVM module + precompiles. This also could allow you to offer seamless compatibility with all your favorite interfaces.

### **How does BitBadges compare to other interoperability protocols?**

BitBadges is a unique L1 blockchain that simplifies multi-chain experiences. Unlike other interoperability protocols, all tokens are stored on the BitBadges chain, simplifying development. And, we support any user from any chain. No need to worry about bridging tokens or managing multiple tokens.&#x20;

BitBadges doesn't "pull" data from other chains - all relevant data is stored on the BitBadges chain, simplifying development. However, it supports users and wallets from any chain, allowing multi-chain transfers (e.g., Bitcoin users can transfer tokens to Solana users).

Note that we support Cosmos / IBC wrapping for true interoperability where you may need.

### **How does Cosmos / IBC wrapping work?**

While our token standard and all state is scoped to the module, we allow you to define "wrapper paths" to convert freely to / from x/bank (IBC) denominations. Once wrapped, you could get all the benefits of IBC + the Cosmos ecosystem with interoperability and more.

### **Does BitBadges support extending with smart contracts?**

Yes, our token standard is a Cosmos module. While we aim for no smart contracts to ever be needed, you can definitely still call in to our module from EVM and CosmWASM environments.


## File: ./overview/learn/badge-concepts/standards.md

# Standards

Collections can optionally implement a specific type of collection or standard. Standards define the expected format of the collection and help others to know how to interpret the details of the collection.

Standards can define the expected values and format of everything about a collection, such as its expected metadata format or the expected genesis conditions. If you implement a standard, it is your responsibility to follow the rules defined by the standard.

Choose the most appropriate standard(s) for your desired use case. You may choose to mix and match more than one as long as they are compatible.

**Example**

```
standards: ["non-fungible", "attendance-event", "No User Ownership"]
```

## List of Standards

1. "No User Ownership" standard - If the standards contains the standard "No User Ownership", then, user ownership is deemed unimportant and all user balances are to not be displayed. This means nothing about transferability, approvals, activity, and so on is displayed. This standard is used by collections where only the token metadata / permissions matter, such as an attestation to something. All tokens are expected to not have any recipient.



## File: ./overview/link-sharing.md

# 🤝 Brand Guidelines

Feel free to use BitBadges name and logo in your site as you see fit. If you have any questions or concerns about usage, please let us know. We are also happy to provide any other logos, images, or information you may need.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../.gitbook/assets/badge_logo.png" alt=""><figcaption></figcaption></figure>


## File: ./overview/official-links.md

# 🔗 Official Links and Resources

Below is a list of official links for socials and other platforms. Our preferred contact is Discord. This is not an exhaustive list. See the rest of the documentation for more information on specific subjects.

* [BitBadges App](https://bitbadges.io)
* [Explorer](https://explorer.bitbadges.io)

### Get Featured

* [Get Featured](https://tally.so/r/mBy2aR) - Explore Page

### Documentation

* [LLM .txt](../for-llms.txt) - Entire documentation dumped into one file

### Socials

* [Discord](https://discord.com/invite/TJMaEd9bar)
* [LinkedIn](https://linkedin.com/company/bitbadges)
* [Twitter](https://twitter.com/bitbadges_io)
* [Telegram](https://t.me/BitBadges)
* [GitHub](https://github.com/bitbadges)

### Integrations

* [Zapier](https://zapier.com/apps/bitbadges/integrations)

### API & SDK

* [NPM API / SDK Package](https://www.npmjs.com/package/bitbadgesjs-sdk) ([Docs](../for-developers/bitbadges-sdk/))
* [API Documentation](https://bitbadges.stoplight.io/docs/bitbadges) ([Docs](../for-developers/bitbadges-api/))

```bash
# Using npm
npm install bitbadgesjs-sdk

# Using pnpm
pnpm add bitbadgesjs-sdk

# Using bun
bun add bitbadgesjs-sdk
```



## File: ./overview/use-cases.md

# 🎨 Use Cases

Because you can check criteria for anything, there are infinitely many possible use cases for BitBadges! Below are some of our favorites. You can also browse featured items at [https://bitbadges.io/browse](https://bitbadges.io/browse).

## Core Tokenization Use Cases

-   **Subscriptions** - Create time-based subscription tokens with built-in expiration dates for services like streaming platforms, gym memberships, or software licenses. Easily verify subscription status through our public API.
-   **Quests & Gamification** - Design quest systems and achievement tokens for gaming, education, or community engagement. Track progress and reward completion with verifiable digital tokens.
-   **Tradable NFTs** - Create unique, tradable digital assets with advanced features like time-dependent ownership and cross-chain compatibility that go beyond traditional NFT standards.
-   **Tradable Tokens** - Issue fungible or semi-fungible tokens that can be traded across multiple blockchain ecosystems with built-in transferability controls.
-   **Profile Pictures & Digital Identity** - Create verifiable profile pictures and digital identity tokens that prove authenticity and ownership across platforms.
-   **Products & Merchandise** - Tokenize physical or digital products, enabling verification of authenticity, ownership tracking, and exclusive access to limited editions.

## Additional Use Cases

-   **Access Control & Gated Content** - Control access to premium content, private Discord servers, exclusive websites, or any digital service. Gate content behind token ownership for tiered access systems.
-   **Memberships** - Create membership tokens with expiration dates for gyms, clubs, organizations, or subscription services. Easily verify membership status through our public API.
-   **Achievements & Credentials** - Issue verifiable credentials like university diplomas, professional certifications, job qualifications, awards, and athletic accomplishments that can be verified anywhere.
-   **Collectibles** - Create unique digital collectibles with advanced features like time-dependent ownership, fine-grained transferability rules, and multi-chain compatibility.
-   **Proof of Anything** - Use tokens as the source of truth for any claim - proof of attendance, voting records, completion of tasks, authenticity verification, or protection against deep fakes and scams.
-   **Decentralized Verification** - Multiple verification services can give out verification tokens, and you can choose which person/entity to get your verification ticks from. Or, verification can be more fine-grained and each entity / company can assign tokens to their own registered employees / community.
-   **Security and Safety -** Maybe a badge is assigned to every address who's private keys are compromised. Apps can then refuse service to such addresses.
-   **Cross-Chain Protocols -** Implement a cross-chain follow, messaging, social media, etc protocols where every post, message, item is a token being transferred / minted.&#x20;
-   **Visual Block Explorers:** Query on-chain activity in a visual way with tokens. For example, to see when a user's first blockchain transaction was, see which badge they own (OG 2015 User vs OG 2023 User, etc.)
-   **Recognition of Achievement or Completion** - Job certifications, awards, athletic accomplishments, etc.
-   **E-Learning** - Gamify the learning experience through learning tokens
-   **University Diplomas** - Universities can offer verifiable diplomas to students as a badge.
-   **Publications** - Verify you are the author of a publication
-   **Real Estate** - Custom encrypted title ownership, HOAs, and even MLS documents registered through the blockchain
-   **Praise / Vouch Tokens** - Praise, recommend, or vouch for something or someone/
-   Literally anything!


## File: ./overview/what-is-bitbadges.md

# 🪄 BitBadges Standard A-Z

BitBadges is a project aiming to drive the adoption of Cosmos with one mission: **build the best tokenization standard ever seen and make it exclusively available as a Cosmos module.**

Cosmos sells software-as-a-service, but it is incomplete without offering a state-of-the-art solution for the main primitive of all of crypto (tokenization). The next 5 years are about advanced tokenization (e.g. Project Crypto) and tokenizing everything. What better way to onboard developers and institutions to Cosmos than offer a 1000x tokenization experience that is **Cosmos exclusive**? This is what BitBadges has built.

### Problems With Existing Token Standards

Existing tokenization standards (ERC/CW/ICS-20/721) are good for plenty of use cases, but the whole system is **flawed from the ground up**.

Existing standards are:

**Simple**: They lack the flexibility and feature set needed for 90% of real-world applications. Simple mint, transfer, and burn functionality is nowhere near enough. The industry has been stuck with these simple standards and no innovation for 10+ years due to technical debt. It is a mess.

**Vulnerable**: They are vulnerable by default due to the smart contract approach. Each token contract introduces a new attack vector and chance of vulnerability. We frankly find it crazy how much is spent on smart contract audits and security. The whole smart contract approach is flawed and not sustainable. It is broken from the foundation, and it has been that way for 10+ years with little done to fix it.

**Complex**: A simple contract requires extensive technical knowledge to implement.

**Expensive**: Contracts are expensive to deploy and maintain.

**Low Interoperability**: Interoperability of tokens has improved recently, and IBC is the leading example of this. However, there is still a lot of room for improvement. Ecosystem-agnostic companies do not want to split their userbase or handle tokens on multiple chains. They want an all-in-one solution that is compatible with any user from any ecosystem out of the box.

**Many Competing Standards**: There are many competing standards and products for tokenization. Each tokenization product adds its own little twists that are not compatible with other products. This creates fragmentation and confusion. We believe that there should be one universal standard that is the best solution for all use cases.

**And Much More**: I could go on and on, but the point stands: **the whole tokenization approach is broken from the foundation and NEEDS a complete overhaul.**

### The BitBadges Token Standard

To solve all of these problems, BitBadges has taken a ground-up approach to build a new universal token standard supported by our own Cosmos SDK blockchain. Our mission is to build the only token standard anyone will ever need with every possible use case supported natively. No smart contracts. No code. 1000x functionality. Exclusive to Cosmos.

Below, we outline a high-level overview of what BitBadges has built and how it compares to existing tokenization standards. We aim to not go into too low-level details and will do our best to explain all concepts; however, the protocol is incredibly feature-rich, and we may not explain everything as thoroughly as we would like. For the full details, please refer to the BitBadges site or documentation. We actually think the best way of learning all that we offer is our landing page and exploring the site, so we encourage you to check it out before reading below. We are also happy to answer any questions you have.

#### Universality

Our token standard is universal and feature-rich enough for any use case. It can not only be used for NFTs and fungible tokens, but also for subscriptions, quests, credentials, real-world assets, complex regulatory compliance, or anything you can think of. The problem with existing standards is they are too limited for 95% of real-world applications. One standard to rule them all.

#### No-Code / Module Approach

The BitBadges standard is no-code by default. It uses a Cosmos module approach to offer a seamless, developer-friendly API-like experience rather than complex smart contracts. As a result, you actually don't even need any technical knowledge to use our standard. Simply go to our site and start building! The native support is feature-rich enough that we envision that 99% of users will NEVER need to write any code, no matter how complex the use case. As it should be.

This promotes reusability and battle-testing the code, rather than potential vulnerabilities introduced per token contract. We strongly believe that over time, this approach will be proven to be the right approach.

#### Ever-Evolving

BitBadges is an ever-evolving standard. We are not making the same mistakes as ERC-20/721/etc. We are not stuck in the past. We are always on the bleeding edge of technology and will never be behind a trend. New feature idea? We will add it. It is purpose-built for the next-generation of tokenization.

#### Same Token, Any User, Any Chain

Through address mapping and signature compatibility, the BitBadges blockchain supports any wallet from any ecosystem. This enables seamless compatibility with any user from any ecosystem directly on the same chain with one module. One interface for any user. This, for example, enables an Ethereum user to own and transfer tokens to Solana users to a Cosmos user and so on.

This is how it should be and is a great tool onboarding ecosystem-agnostic companies who want an all-in-one solution out of the box. No need to split their userbase or launch on multiple chains to support all their users.

Note: This does not include minting or burning on destination chains. All token state and balances live in our own custom module on our own chain. For interoperability, we support IBC (see below).

#### IBC Compatibility

We are Cosmos through and through. Our plan is to be the tokenization launchpad for all of Cosmos with IBC at the core of everything.

1. Any token created is wrappable to ICS-20/721 format for use on any other IBC-enabled chain.
2. We can support payments via any IBC denomination (e.g. payments, subscriptions, etc). For example, an NFT / fungible token marketplace or subscription service with payments accepted via any IBC-enabled token.
3. Our module is IBC-enabled and core Msgs can be executed via IBC

For example, you could theoretically:

1. Create a token via our module
2. Wrap 20% of the supply to ICS-20 format
3. Send 10% to Osmosis
4. Send 10% to an EVM chain with IBC Eureka
5. Keep the remaining with time-dependent unlocks in our native module
6. Or any combination you can think of. That is the beauty of it.

Think of BitBadges as a layer above IBC. Tokens are launched on BitBadges for all the features that we offer, and then, they can be wrapped to IBC for interoperability and use with any IBC-enabled service.

#### Value-Add Mindset

BitBadges prioritizes unique value-add to Cosmos over everything else. We are not trying to reinvent the wheel or compete with existing ecosystem projects in Cosmos. We focus on bringing utility and enabling use cases not already out there. For features or services already available, we actually promote using them instead of us by wrapping them and sending them via IBC.

For example, while we could focus on building out a decentralized exchange with our standard, that is incredibly low value-add to Cosmos considering there are plenty of options already available via IBC.

#### Time-Dependent Accounting

We are the first and only token standard to support time-dependent accounting. This is a huge primitive needed to be able to support subscriptions, unlocks, or any other time-dependent functionality at scale. All token balances can be fractionalized down to the millisecond. Think of them like "ownership rights".

This enables use cases like:

* Auto-expiring / renewing subscription tokens
* Token unlocks
* Token vesting

All without needing future transactions to update the balances.

Ex: Bob owns this token ID until next July when the subscription token auto-expires. At that point, the token is no longer owned by Bob.

**Featured Use Case: Subscriptions**:

BitBadges has an in-built standard using our tokenization protocol that leverages time-dependent accounting to implement no-code, recurring tokenized subscriptions. We use a bot-tipping system to handle the recurring payments and time-dependent ownership rights to handle the expiration of the subscription.

This could make Cosmos the premier subscription layer for all of crypto. Anyone can go to our site and in a few clicks create a no-code, auto-recurring, decentralized, peer-to-peer subscription paid using any IBC-enabled token.

#### Transferability Revamped

Probably the biggest innovation of the BitBadges standard is our revamped transferability and approvals system.

**Three Transferability Levels**:

1. **Collection-Level Transferability**: The issuer / manager defines overall rules for the collection. Can forcefully override user-level approvals if needed.
2. **Sender Approvals**: Each user can set rules for outgoing transfers (e.g. listings, etc).
3. **Recipient Approvals**: Each recipient can set rules for incoming transfers (e.g. bids, etc).

This allows for a lot of flexibility and control over the transferability of a token. Each transfer must 1) have sufficient balances from the sender, 2) satisfy the collection transferability, and 3) satisfy the user-level approvals (if not forcefuly overridden by the collection).

This is especially valuable for many real-world use cases that need that issuer control, such as KYC regulatory compliance, freezability, royalties, revokability, etc. Our standard allows you full control to configure whatever you need.

**Revamped On-Chain Approvals**:

Approvals are no longer a simple incremented counter that cannot exceed a threshold. Our approvals are incredibly flexible and powerful while being standardized.

Seamlessly define all the following on-chain for EVERY approval. Define the exact rules and stipulations, enabling complex and powerful transferability rules on the three levels (collection, sender, recipient). All in a standardized manner.

* Who Can Transfer?
* Who Can Receive?
* Who Can Initiate?
* Transfer Times?
* Predetermined or Tallied Amounts?
* How Many Transfers?
* Revokable?
* Freezable?
* BADGE or other IBC transfers?
* Royalties?
* Ownership Times?
* Recurring?
* Non-Transferable?
* Incrementing Token IDs?
* Owns Other Tokens?
* And plenty more...

**Off-Chain Approval Criteria: 7000+ Web2 Integrations**:

Additionally, BitBadges has an oracle-like system that allows letting a centralized service approve users dynamically by checking off-chain criteria and giving them signed codes to redeem on-chain. BitBadges runs its own criteria checking service that connects to 7000+ Web2 integrations in no-code through in-site plugins. This enables powerful use cases like:

* Gating mints by Discord membership
* Gating mints by X followers
* Gating mints by email
* Gating mints by checking your private off-chain data
* Gating mints through claim codes or passwords
* Gating approvals by AI agents
* Building your own custom endpoints to check your own criteria
* And anything else you can think of. We make it easy for anyone to add their own integration, custom plugin, or build their own criteria checking service. All the heavy on-chain hybrid work is done for you. You focus on your application-specific logic.

This is a huge tool for Web2 adoption and onboarding users to on-chain tokenization.

While BitBadges runs its own criteria checking service, anyone can spin up their own oracle-like service to check their own criteria and reduce this trust assumption on BitBadges. It is decentralized in nature.

#### Fine-Grained Permissions

Each token collection can have a manager that can execute administrative actions for full control over whatever is needed. This is a great tool to allow for more complex use cases where centralized control is needed with predefined checks and balances enforced on-chain, like regulatory compliance.

* Updating the token metadata
* Updating transferability
* Archiving the collection
* Deleting the collection
* Adding more tokens to the collection
* Pausing transfers
* Volume throttling
* And more...

#### Smart Contract Extendibility

While our approach is no-code by default, we do support CosmWASM for any custom applications or advanced logic. We also plan to support x/evm once it is ready. Our goal is to make it so that 100% of use cases are supported natively without ever needing to extend it. If something is missing, we will add it.

### Featured Use Cases

At the end of the day, we are a tokenization standard, so we can be used for absolutely anything you want to tokenize. Our goal is to be the IBC-compatible tokenization launchpad for all of Cosmos.

As seen above, we are incredibly feature-rich and can be used for any use case you can think of. We especially excel at the more complex use cases beyond simple mint, transfer, sell.

Some examples:

* **NFTs**: Traditional NFT marketplace with custom transferability and purchasable via any IBC denomination
* **Fungible Tokens**: Traditional fungible tokens with custom transferability and approvals purchasable and tradable via any IBC denomination
* **Quests**: IBC-denomination backed quests that payout users in any IBC-enabled denomination for completing any sort of task or challenge from 7000+ integrations or any on/off-chain criteria you can think of.
* **Subscriptions**: No-code, recurring subscriptions that are paid with any IBC denomination. We use a bot-tipping system to handle the recurring payments automatically for you.
* **Stocks**: Tokenized stocks with custom vesting periods, dividends, and more.
* **Real-World Assets**: Tokenized real-world assets with custom transferability and approvals purchasable and tradable via any IBC denomination
* **Regulatory Compliance**: Seamlessly compliant with any complex regulatory compliance requirements without any additional work.

Or any use case you can think of.

### Uniquely Positioned For The Future

BitBadges is a unique project that is well-positioned to help Cosmos succeed for everything to come in the next 5 years and beyond.

1. **Tokenization**: Tokenization is the most powerful primitive that crypto offers, and the roadmaps of all major teams in crypto involve tokenization in one form or another: tokenizing real-world assets, stocks, subscriptions, etc. With our universal approach and innovation, we are able to support all of these and more to help Cosmos succeed no matter the requirements or use cases or current trends.
2. **Cosmos and Beyond**: By being a Cosmos module with IBC compatibility, we are not only well-positioned to be the tokenization standard for all of Cosmos but also any ecosystem.
3. **AI-Friendly Standard**: AI agents do best with standardization. Existing standards are way too simple. Generic smart contracts are not standardized. Enter the BitBadges token standard. Complex enough for any use case but standardized enough for AI agents to understand at scale.

### Benefits to Cosmos

1. **Exclusivity and Value-Add**: A 1000x tokenization standard that is exclusive to Cosmos and 100x better than anything offered on EVM or other ecosystems is a huge value-add for Cosmos. The harsh reality is that Cosmos products need to go above and beyond to compete. If you offer true innovation not found elsewhere (for example, IBC), this attracts teams, institutions, and developers, and Cosmos will be successful. If you offer no innovation beyond what is available on EVM, developers will just launch on EVM.
2. **Cosmos-Native**: BitBadges is Cosmos through and through. It is a native Cosmos project (native modules, full IBC compatibility, CosmWASM, etc). A win for BitBadges is a win for all of Cosmos.
3. **Missing Parts of the Stack**: BitBadges believes it completes a lot of the missing parts of the Cosmos stack:

* IBC-compatible tokenization launchpad
* Subscription layer
* Quests / points layer
* 7000+ seamless Web2 x Cosmos integrations
* Core Cosmos tokenization module as a primitive for chains to use (the official x/nft experiment is now deprecated)
* Onboard the 95% middle of the line tokenization use cases with complex requirements beyond mint, transfer, and burn
* A full ready-made tokenization suite with our feature set can really accelerate teams building in Cosmos
* "Kill multiple birds with one stone" - We envision that many use cases can actually be abstracted as tokens behind the scenes even if not directly a tokenization use case. For example, simple payments from a store can be abstracted as an NFT purchase + use the NFT as a tokenized, verifiable receipt.

4. **IBC Currencies + Routing**: Our token standard is built to support any IBC currency and be IBC interopoerable where needed. Through this, the entire Cosmos ecosystem will benefit from increased usage of our standard.
5. **Ahead of the Curve**: Tokenization is a huge part of the upcoming 5 years, especially for institutional adoption. BitBadges is uniquely positioned for what is to come. We have "skated to where the puck is going to be".
6. **First-Mover Advantage**: One of the biggest value-adds BitBadges can offer to Cosmos is the first-mover advantage. We spent the last 2 years and plenty of time building this out. Other ecosystems will have to start from scratch. Cosmos now has a ready-made solution and can capitalize on the market opportunities while other ecosystems are catching up. Not to mention, everything we built is very difficult to replicate with a smart contract-based approach.


## File: ./token-standard/examples/approvals/README.md

# Approvals



## File: ./token-standard/integrate-the-standard.md

# ⛓️ Integrate The Standard?

**Building a frontend?** Check out the affiliate fee implementation to claim 50% of the protocol fee to keep your integration sustainable!

**Want to add it to your Cosmos chain?** If you want the token standard to your own chain, reach out! We are open to exploring licensing and other agreements!


## File: ./token-standard/pre-readings.md

# 📔 Pre-Readings

Before diving deep into the behind the scenes of our token standard, we encourage you to do two things.

1\) Explore the landing and explore page ([https://bitbadges.io](https://bitbadges.io\)/)) in our site to get an idea of what is possible! Also, go through the create flow to see what all is possible!

<figure><img src="../.gitbook/assets/image (231).png" alt=""><figcaption></figcaption></figure>

2\) For a full A-Z description of what BitBadges is and why we built it, read this:

{% content-ref url="../overview/what-is-bitbadges.md" %}
[what-is-bitbadges.md](../overview/what-is-bitbadges.md)
{% endcontent-ref %}

3\) How does BitBadges tranferability work from a high-level?

**Mint Address**

The Mint address has unlimited balances. Any 'Mint' creates a token out of thin air.

**Circulating Supply**

The circulating supply is not a static number but rather the total amount of tokens transferred from the Mint address. Set approvals accordingly and set managerial permissions accordingly to limit the updatability of the approvals.

**Collection Approvals (Transferability)**

Collection approvals (minting and post-minting) define the overall rules for the collection. All transfers must always obey a collection approval. This gives you overarching control about the transferability of the collection. Examples: freezability, non-transferable, revoking, etc.

**User-Level Approvals**

The sender / receiver can also set user-level approvals that must be satisfied by default to gate who can send on their behalf or send to them.

These can be skipped / forcefully overriden by the collection-level approvals (for implementing forceful functionality like freezing, etc).&#x20;

**What is checked on each transfer?**

Each transfer must have sufficient balances, satisfy a collection approval, and satisfy user-level approvals if not overridden.&#x20;


## File: ./token-standard/type-definitions/README.md

# ⌨️ Types



## File: ./token-standard/type-definitions/address-lists.md

# Address Lists

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadgeschain/blob/master/proto/badges/address_lists.proto" %}


## File: ./token-standard/type-definitions/balances.md

# Balances

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadgeschain/blob/master/proto/badges/balances.proto" %}


## File: ./token-standard/type-definitions/core-collection.md

# Core Collection

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadgeschain/blob/master/proto/badges/collections.proto" %}


## File: ./token-standard/type-definitions/dynamic-stores.md

# Dynamic Stores

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadgeschain/blob/master/proto/badges/dynamic_stores.proto" %}


## File: ./token-standard/type-definitions/metadata.md

# Metadata

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadgeschain/blob/master/proto/badges/metadata.proto" %}


## File: ./token-standard/type-definitions/permissions.md

# Permissions

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadgeschain/blob/master/proto/badges/permissions.proto" %}


## File: ./token-standard/type-definitions/timelines.md

# Timelines

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadgeschain/blob/master/proto/badges/timelines.proto" %}


## File: ./token-standard/type-definitions/transfers.md

# Transfers

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadgeschain/blob/master/proto/badges/transfers.proto" %}


## File: ./x-badges/README.md

# 📚 Overview

This directory contains comprehensive developer documentation for the BitBadges blockchain's `x/badges` module.

> 💡 **Note:** For most development, you may actually not need to know many of the underlying details of x/badges that we describe in this section. For example, you may only need high-level API getters like fetching balances and metadata as well as the no-code Create tab in the BitBadges site.

## Table of Contents

1. [Concepts](concepts/) - Core data structures and business logic
2. [Messages](messages/) - Transaction messages and handlers
3. [Queries](queries/) - Query types and endpoints
4. [Events](events.md) - Event emissions and tracking
5. [Examples](examples/) - Common usage patterns and building blocks

## Main Features

-   No code, no smart contracts - All implemented as a Cosmos module
-   1000x transferability customization for whatever requirements you may need
-   Three transferability levels enforced for as much or as little customization as needed (collection-level, sender, recipient approvals)
-   Seamless compatibility for checking off-chain criteria like in the BitBadges site where you can gate mints by 7000+ no-code plugins
-   Deploy once, support ETH, COSMOS, BTC, SOL users with same token
-   Supports any IBC currency
-   IBC interoperable through wrapping to x/bank IBC denoms
-   Transferability is checked EVERY transfer on-chain, enforcing compliance seamlessly at the protocol level
-   Extendible with smart contract frameworks

## Message Reference

### Collection Management

-   [MsgCreateCollection](messages/msg-create-collection.md) - Create new collection
-   [MsgUpdateCollection](messages/msg-update-collection.md) - Update existing collection
-   [MsgUniversalUpdateCollection](messages/msg-universal-update-collection.md) - Universal create/update interface with invariants support
-   [MsgDeleteCollection](messages/msg-delete-collection.md) - Delete collection

### Token Transfers

-   [MsgTransferBadges](messages/msg-transfer-badges.md) - Transfer tokens between addresses

### User Approvals

-   [MsgUpdateUserApprovals](messages/msg-update-user-approvals.md) - Update transfer approvals

### Address Lists & Dynamic Stores

-   [MsgCreateAddressLists](messages/msg-create-address-lists.md) - Create reusable address lists
-   [MsgCreateDynamicStore](messages/msg-create-dynamic-store.md) - Create key-value store
-   [MsgUpdateDynamicStore](messages/msg-update-dynamic-store.md) - Update dynamic store properties
-   [MsgDeleteDynamicStore](messages/msg-delete-dynamic-store.md) - Delete dynamic store
-   [MsgSetDynamicStoreValue](messages/msg-set-dynamic-store-value.md) - Set address-specific store values
-   [MsgIncrementStoreValue](messages/msg-increment-store-value.md) - Increase values for addresses
-   [MsgDecrementStoreValue](messages/msg-decrement-store-value.md) - Decrease values for addresses
-   [More messages...](messages/) - See full message reference

## Query Reference

### Core Queries

-   [GetCollection](queries/get-collection.md) - Retrieve collection data
-   [GetBalance](queries/get-balance.md) - Get user balances
-   [GetApprovalTracker](queries/get-approval-tracker.md) - Get approval usage data
-   [GetAddressList](queries/get-address-list.md) - Retrieve address list
-   [More queries...](queries/) - See full query reference

## Quick Links

-   [BitBadges Chain Repository](https://github.com/bitbadges/bitbadgeschain)
-   [BitBadges Documentation](https://docs.bitbadges.io)
-   [Proto Definitions](https://github.com/bitbadges/bitbadgeschain/tree/master/proto/badges)

## Documentation Style

This documentation follows the [Cosmos SDK module documentation standards](https://docs.cosmos.network/main/building-modules/README) and is designed for developers building on or integrating with the BitBadges blockchain.


## File: ./x-badges/concepts/README.md

# 🧠 Concepts

This directory contains detailed explanations of the core concepts and data structures that form the foundation of the BitBadges module.

-   [**UintRange**](uintrange.md) - Representing ranges of unsigned integers
-   [**Timeline System**](timeline-system.md) - How properties change over time with immutable historical records
-   [**Collections**](badge-collections.md) - The primary entity that defines groups of related tokens
-   [**Balance System**](balance-system.md) - How token ownership is tracked with precise control over quantities and time
-   [**Default Balances**](default-balances.md) - Predefined balance stores assigned to new users upon genesis creation
-   [**Valid Token IDs**](valid-badge-ids.md) - Defining the range of token identifiers that can exist within a collection
-   [**Total Supply**](total-supply.md) - Maximum number of tokens that can exist for each token ID
-   [**Mint Escrow Address**](mint-escrow-address.md) - Reserved address for holding native funds on behalf of the Mint address
-   [**Archived Collections**](archived-collections.md) - Temporarily or permanently disabling collection transactions
-   [**Metadata**](metadata.md) - Rich, dynamic content for collections and tokens with timeline support
-   [**Manager**](manager.md) - Central authority for collection administration with timeline-based control
-   [**Transferability & Approvals**](transferability-approvals.md) - Overview of the three-tier approval system for token transfers
-   [**Approval Criteria**](approval-criteria/) - Detailed approval criteria and conditions for token transfers
-   [**Address Lists**](address-lists.md) - Reusable collections of addresses for approval configurations
-   [**Permissions**](permissions/) - Granular control over collection management operations
-   [**Standards**](standards.md) - Generic framework for defining collection behavior and interpretation guidelines
-   [**Time Fields**](time-fields.md) - Understanding the different time-related fields used throughout BitBadges
-   [**Custom Data**](custom-data.md) - Generic string fields for storing arbitrary application-specific data
-   [**Cosmos Wrapper Paths**](cosmos-wrapper-paths.md) - Wrapping between tokens and native Cosmos SDK coins for IBC compatibility
-   [**Collection Invariants**](collection-invariants.md) - Immutable rules that enforce fundamental constraints on collection behavior
-   [**Protocols**](protocols/) - Standardized implementation patterns for collections


## File: ./x-badges/concepts/address-lists.md

# Address Lists

Address lists define collections of addresses for use in approval configurations. They support both static lists stored on-chain and dynamic reserved patterns for common access control scenarios.

## Usage in Approval Configurations

Address lists are referenced by ID in three approval contexts. IDs can either be reserved, shorthand IDs or user-created lists via `MsgCreateAddressLists`.

### Collection Approvals

```protobuf
message CollectionApproval {
  string fromListId = 1;        // Who can send tokens
  string toListId = 2;          // Who can receive tokens
  string initiatedByListId = 3; // Who can initiate transfers
  // ... other fields
}
```

### User Outgoing Approvals

```protobuf
message UserOutgoingApproval {
  string toListId = 1;          // Who user can send to
  string initiatedByListId = 2; // Who can initiate on user's behalf
  // ... other fields
}
```

### User Incoming Approvals

```protobuf
message UserIncomingApproval {
  string fromListId = 1;        // Who can send to user
  string initiatedByListId = 2; // Who can initiate transfers to user
  // ... other fields
}
```

### Usage Examples

#### Universal Access

```json
{
    "fromListId": "AllWithoutMint", // Everyone except Mint
    "toListId": "All", // Everyone including Mint
    "initiatedByListId": "All" // Anyone can initiate
}
```

#### Restricted Access

```json
{
    "fromListId": "vipMembers", // Only VIP members can send
    "toListId": "!banned", // Everyone except banned users
    "initiatedByListId": "AllWithoutMint"
}
```

#### Quick Address Lists

```json
{
    "fromListId": "bb1alice...:bb1bob...:bb1charlie...", // Direct addresses
    "toListId": "AllWithoutMint:bb1blocked...", // Everyone except these
    "initiatedByListId": "All"
}
```

## Proto Definition

```protobuf
message AddressList {
  string listId = 1;           // Unique identifier
  repeated string addresses = 2; // List of addresses
  bool whitelist = 3;          // true = whitelist, false = blacklist
  string uri = 4;              // Metadata URI
  string customData = 5;       // Custom data
  string createdBy = 6;        // Creator address
}
```

## Reserved Address List IDs

BitBadges provides built-in reserved list IDs that are dynamically generated without storage overhead:

### Core Reserved Lists

#### "Mint"

-   **Purpose**: Contains only the "Mint" address
-   **Logic**: Whitelist (addresses: ["Mint"], whitelist: true)
-   **Use case**: Minting operations and initial token distribution

#### "All" and "AllWithMint"

-   **Purpose**: Represents all addresses including Mint
-   **Logic**: Blacklist with empty addresses list (addresses: [], whitelist: false)
-   **Use case**: Universal access, public collections

#### "None"

-   **Purpose**: Represents no addresses
-   **Logic**: Whitelist with empty addresses list (addresses: [], whitelist: true)
-   **Use case**: Blocking all access, disabled transfers

### Dynamic Patterns

#### AllWithout Pattern

-   **Format**: `"AllWithout<addresses>"` where addresses are colon-separated
-   **Example**: `"AllWithoutMint"`, `"AllWithoutMint:bb1user123"`
-   **Logic**: Blacklist containing the specified addresses (addresses: ["Mint", "bb1user123"], whitelist: false)
-   **Use case**: Allow everyone except specific addresses

#### Colon-Separated Addresses

-   **Format**: `"address1:address2:address3"`
-   **Logic**: Whitelist containing the specified addresses (addresses: ["bb1user123", "bb1user234", "bb1user345"], whitelist: true)
-   **Use case**: Quick address lists without creating stored lists

#### Inversion Patterns

-   **Format**: `"!listId"` or `"!(listId)"`
-   **Effect**: Inverts the whitelist/blacklist behavior of the referenced list
-   **Example**: `"!5"` inverts list ID 5's behavior

## Whitelist vs Blacklist Logic

Address lists use a boolean `whitelist` field to determine inclusion/exclusion behavior:

### Whitelist Logic (`whitelist: true`)

```javascript
function isAddressIncluded(address, addressList) {
    const found = addressList.addresses.includes(address);
    return addressList.whitelist ? found : !found;
}
```

-   **Listed addresses**: Explicitly included
-   **Unlisted addresses**: Explicitly excluded
-   **Use case**: "Only these addresses are allowed"

### Blacklist Logic (`whitelist: false`)

-   **Listed addresses**: Explicitly excluded
-   **Unlisted addresses**: Explicitly included
-   **Use case**: "All addresses except these are allowed"

### Inversion Effect

When a list ID has the `"!"` prefix, the final whitelist boolean is inverted:

-   Whitelist becomes blacklist behavior
-   Blacklist becomes whitelist behavior

## Address List Creation

### User-Created Lists

Created through `MsgCreateAddressLists` with the requirements below. Once created, this list is immutable and cannot be modified.

#### ID Validation Rules

-   Must be alphanumeric characters only
-   Cannot be empty or reserved keywords
-   Cannot contain `:` or `!` characters
-   Cannot be valid addresses themselves
-   Cannot conflict with reserved IDs

#### Address Validation

-   All addresses must be valid Bech32 format
-   No duplicate addresses allowed
-   Special addresses like "Mint" are permitted

### Example User-Created List

```json
{
    "listId": "vipMembers",
    "addresses": ["bb1alice...", "bb1bob...", "bb1charlie..."],
    "whitelist": true,
    "uri": "https://api.example.com/vip-list",
    "customData": "VIP members with exclusive access",
    "createdBy": "bb1manager..."
}
```

## Performance Characteristics

Tip: Use reserved IDs for common patterns. Use user-created lists for large lists used multiple times.

### Reserved Lists

-   **Storage**: Zero on-chain storage
-   **ID Length**: Dependent on the pattern used
-   **Resolution**: Dynamic generation at runtime
-   **Gas efficiency**: Minimal overhead for common patterns

### User-Created Lists

-   **Storage**: On-chain storage per list
-   **ID Length**: Reusable short ID that can be used to reference complex lists
-   **Resolution**: Direct store lookup
-   **Gas cost**: Proportional to validation complexity

## Address Lists vs Dynamic Stores

Both address lists and dynamic stores can control who is approved for transfers, but they serve different purposes:

### Address Lists

-   **Purpose**: Immutable shorthand references for collections of addresses
-   **Mutability**: Cannot be modified after creation - addresses are fixed
-   **Storage**: Direct list of addresses stored on-chain
-   **Use case**: Static whitelists/blacklists that don't change over time

### Dynamic Stores

-   **Purpose**: Mutable on-chain approval management with CRUD operations
-   **Mutability**: Can be updated dynamically using CRUD messages (Create, Update, Delete, Set)
-   **Storage**: Boolean values per address (true/false approval status)
-   **Use case**: Dynamic approval systems that need real-time updates (typically contract logic)


## File: ./x-badges/concepts/approval-criteria/README.md

# Approval Criteria

Additional restrictions and conditions that determine whether a transfer is approved beyond the basic approval matching.

## Interface

```typescript
export interface iApprovalCriteria<T extends NumberType> {
    /** The BADGE or other sdk.Coin transfers to be executed upon every approval. */
    coinTransfers?: iCoinTransfer<T>[];
    /** The list of merkle challenges that need valid proofs to be approved. */
    merkleChallenges?: iMerkleChallenge<T>[];
    /** The list of must own tokens that need valid proofs to be approved. */
    mustOwnBadges?: iMustOwnBadge<T>[];
    /** The predetermined balances for each transfer. These allow approvals to use predetermined balance amounts rather than an incrementing tally system. */
    predeterminedBalances?: iPredeterminedBalances<T>;
    /** The maximum approved amounts for this approval. */
    approvalAmounts?: iApprovalAmounts<T>;
    /** The max num transfers for this approval. */
    maxNumTransfers?: iMaxNumTransfers<T>;
    /** Whether the approval should be deleted after one use. */
    autoDeletionOptions?: iAutoDeletionOptions;
    /** Whether the to address must equal the initiatedBy address. */
    requireToEqualsInitiatedBy?: boolean;
    /** Whether the from address must equal the initiatedBy address. */
    requireFromEqualsInitiatedBy?: boolean;
    /** Whether the to address must not equal the initiatedBy address. */
    requireToDoesNotEqualInitiatedBy?: boolean;
    /** Whether the from address must not equal the initiatedBy address. */
    requireFromDoesNotEqualInitiatedBy?: boolean;
    /** Whether this approval overrides the from address's approved outgoing transfers. */
    overridesFromOutgoingApprovals?: boolean;
    /** Whether this approval overrides the to address's approved incoming transfers. */
    overridesToIncomingApprovals?: boolean;
    /** The royalties to apply to the transfer. */
    userRoyalties?: iUserRoyalties<T>;
    /** The list of dynamic store challenges that the initiator must pass for approval. */
    dynamicStoreChallenges?: iDynamicStoreChallenge<T>[];
    /** The list of ETH signature challenges that require valid Ethereum signatures for approval. */
    ethSignatureChallenges?: iETHSignatureChallenge<T>[];
}
```

## Core Components

-   **[Approval Trackers](approval-trackers.md)** - Tracking transfer amounts and counts
-   **[Tallied Approval Amounts](tallied-approval-amounts.md)** - Amount limits and thresholds
-   **[Max Number of Transfers](max-number-of-transfers.md)** - Transfer count limits
-   **[Predetermined Balances](predetermined-balances.md)** - Exact balance requirements
-   **[Merkle Challenges](merkle-challenges.md)** - Cryptographic proof requirements
-   **[Dynamic Store Challenges](dynamic-store-challenges.md)** - On-chain numeric checks
-   **[ETH Signature Challenges](eth-signature-challenges.md)** - Ethereum signature requirements
-   **[Token Ownership](badge-ownership.md)** - Required token holdings
-   **[Cosmos Coin Transfers](usdbadge-transfers.md)** - Payments per approval (BADGE or other sdk.Coin)
-   **[Overrides](overrides.md)** - Bypassing user-level approvals
-   **[Requires](requires.md)** - Address relationship restrictions
-   **[Auto-Deletion Options](auto-deletion-options.md)** - Automatic approval cleanup
-   **[User Royalties](user-royalties.md)** - Percentage-based transfer fees

## Key Concepts

### Tracker IDs

Trackers use IDs with format: `approvalId-trackerId` plus identifying details. All trackers are scoped to a specific `approvalId`.

**Important**: Trackers are increment-only and immutable. Never reuse tracker IDs with prior history.

### Best Practices - Creating / Updating / Deleting

Trackers are increment-only and immutable. Never reuse tracker IDs with prior history when creating approvals that should start from scratch.

### Extending Functionality

For custom logic beyond native options:

-   Use CosmWASM smart contracts
-   Leverage Merkle challenges for commit-reveal mechanisms

### Cross-Approval Logic

Native interface doesn't support cross-approval logic (e.g., preventing double-dipping between approvals). Consider:

-   Workarounds and careful design
-   CosmWASM for advanced functionality
-   Contact us for recommendations


## File: ./x-badges/concepts/approval-criteria/approval-trackers.md

# Approval Trackers

Track transfer amounts and counts using increment-only tallies with thresholds.

## How It Works

Trackers use an incrementing tally system with thresholds:

1. **Setup**: Approved for x10 of token IDs 1-10 with tracker ID "xyz"
2. **Transfer x5**: Tracker "xyz" goes from 0/10 → 5/10
3. **Transfer x5**: Tracker "xyz" goes to 10/10
4. **Transfer x1**: Exceeds threshold, transfer fails

## Tracker Identification

Tracker IDs include multiple components:

```
ID: collectionId-approvalLevel-approverAddress-approvalId-amountTrackerId-trackerType-approvedAddress
```

### Tracker ID Details Interface

```typescript
interface ApprovalTrackerIdDetails<T extends NumberType> {
    collectionId: T;
    approvalLevel: 'collection' | 'incoming' | 'outgoing' | '';
    approvalId: string;
    approverAddress: string;
    amountTrackerId: string;
    trackerType: 'overall' | 'to' | 'from' | 'initiatedBy' | '';
    approvedAddress: string;
}
```

### Component Breakdown

-   **collectionId**: The collection this tracker belongs to
-   **approvalLevel**: Level of approval ("collection", "incoming", "outgoing", or empty)
-   **approvalId**: Unique identifier for the specific approval
-   **approverAddress**: Address of the approver (empty for collection-level)
-   **amountTrackerId**: User-defined tracker identifier specified in approvalAmounts or maxNumTransfers (see below)
-   **trackerType**: Type of tracking ("overall", "to", "from", "initiatedBy", or empty)
-   **approvedAddress**: Specific address being tracked (empty for "overall")

```typescript
interface iApprovalAmounts<T extends NumberType> {
    amountTrackerId: string; // Key for tracking tallies
}

interface iMaxNumTransfers<T extends NumberType> {
    amountTrackerId: string; // Key for tracking tallies
}
```

### Tracker Types

-   **"overall"**: Universal tally for any transfer (approvedAddress empty)
-   **"to"**: Per-recipient tally (approvedAddress = recipient)
-   **"from"**: Per-sender tally (approvedAddress = sender)
-   **"initiatedBy"**: Per-initiator tally (approvedAddress = initiator)

## Increment Only and Immutable

Trackers are increment only and immutable in storage. To start an approval tally from scratch, you will need to map the approval to a new unused tracker ID. This can be done simply by editing `amountTrackerId` (because this changes the whole ID) or restructuring to change one of the other fields that make up the overall ID.

**IMPORTANT**: Because of the immutable nature, be careful to not revert to a previously used ID unintentionally because the starting point will be the previous tally (not starting from scratch).

## As-Needed Basis

Only increment when necessary (e.g., if no amount restrictions, don't track amounts). Meaning, if there is no need to increment the tally (unlimited limit and/or not restrictions), we do not increment for efficiency purposes. For example, if we only have requirements for numTransfers but do not need the amounts, we do not increment the amounts.

### Example Tracker States

```json
{
    "fullTrackerId1": {
        "numTransfers": 5,
        "amounts": [
            {
                "amount": 50,
                "badgeIds": [{ "start": 1, "end": 10 }],
                "ownershipTimes": [{ "start": 1, "end": 100000000000 }]
            }
        ],
        "lastUpdatedAt": 1691978400000
    },
    "fullTrackerId2": {
        "numTransfers": 3,
        "amounts": [
            {
                "amount": 15,
                "badgeIds": [{ "start": 1, "end": 5 }],
                "ownershipTimes": [{ "start": 1, "end": 100000000000 }]
            }
        ],
        "lastUpdatedAt": 1691978400000
    }
}
```

## Periodic Resets

Trackers support periodic resets to zero using time intervals.

Leave the values at 0 to disable periodic resets.

```typescript
interface ResetTimeIntervals<T extends NumberType> {
    startTime: T; // Original start time of the first interval
    intervalLength: T; // Interval length in unix milliseconds
}
```

### How It Works

-   **First Update**: If it's the first update of the interval, all tracker progress is reset to zero
-   **Recurring**: Useful for recurring subscriptions (e.g., one transfer per month)
-   **No Reset**: Set both values to 0 for no periodic resets

### Example

```json
{
    "approvalAmounts": {
        "overallApprovalAmount": "100",
        "amountTrackerId": "monthly-tracker",
        "resetTimeIntervals": {
            "startTime": "1691978400000", // Aug 13, 2023
            "intervalLength": "2592000000" // 30 days in milliseconds
        }
    }
}
```

This creates a monthly reset cycle starting from August 13, 2023.


## File: ./x-badges/concepts/approval-criteria/auto-deletion-options.md

# Auto-Deletion Options

Automatically delete approvals after specific conditions are met.

## Interface

```typescript
interface AutoDeletionOptions {
    afterOneUse: boolean;
    afterOverallMaxNumTransfers: boolean;
    allowCounterpartyPurge?: boolean;
    allowPurgeIfExpired?: boolean;
}
```

## How It Works

Auto-deletion options allow approvals to be automatically removed when certain conditions are met:

-   **`afterOneUse`**: Delete the approval after it's used once
-   **`afterOverallMaxNumTransfers`**: Delete the approval after the overall max number of transfers threshold is met
-   **`allowCounterpartyPurge`**: If true, allows the counterparty (the only initiator in `initiatedByList`, must be a whitelist with exactly one address) to purge the approval, even if they are not the owner. This may be used for like a rejection of the approval.
-   **`allowPurgeIfExpired`**: If true, allows others (in addition to the approval owner) to purge expired approvals on the owner's behalf. This may be used for a cleanup-like system.

## Usage Examples

### Single-Use Approval

```json
{
    "autoDeletionOptions": {
        "afterOneUse": true,
        "afterOverallMaxNumTransfers": false
    }
}
```

**Result**: Approval is deleted immediately after the first transfer.

### Limited-Use Approval

```json
{
    "maxNumTransfers": {
        "overallMaxNumTransfers": "10"
    },
    "autoDeletionOptions": {
        "afterOneUse": false,
        "afterOverallMaxNumTransfers": true
    }
}
```

**Result**: Approval is deleted after 10 transfers are completed.

### Allow Counterparty Purge

```json
{
    "autoDeletionOptions": {
        "afterOneUse": false,
        "afterOverallMaxNumTransfers": false,
        "allowCounterpartyPurge": true
    }
}
```

**Result**: The counterparty (if they are the only initiator in a whitelist) can purge this approval, even if not the owner.

### Allow Others to Purge Expired Approvals

```json
{
    "autoDeletionOptions": {
        "afterOneUse": false,
        "afterOverallMaxNumTransfers": false,
        "allowPurgeIfExpired": true
    }
}
```

**Result**: Any user can purge this approval if it is expired (no future valid transfer times), not just the owner.


## File: ./x-badges/concepts/approval-criteria/badge-ownership.md

# Token Ownership

Require specific token holdings from the initiator as a prerequisite for transfer approval. This approval criteria checks on-chain balances to ensure users own required tokens before allowing transfers.

## Overview

Token ownership requirements enable gating mechanisms where users must possess specific tokens to access certain transfers. This creates dependency relationships between collections and enables sophisticated access control systems.

**Key Benefits**:

-   **Access Control**: Gate transfers based on token ownership
-   **Collection Dependencies**: Create relationships between different collections
-   **On-Chain Verification**: Automatic balance checking without external data
-   **Flexible Requirements**: Support for amount ranges, time-based ownership, and multiple token types

## Interface

```typescript
interface MustOwnTokens<T extends NumberType> {
    collectionId: T;
    amountRange: UintRange<T>; // Min/max amount expected
    ownershipTimes: UintRange<T>[];
    tokenIds: UintRange<T>[];

    overrideWithCurrentTime: boolean; // Use current block time. Overrides ownershipTimes with [{ start: currentTime, end: currentTime }]
    mustSatisfyForAllAssets: boolean; // All vs one requirement
    ownershipCheckParty: string; // Which party to check ownership for: "initiator", "sender", "recipient" (default: "initiator" if empty)
}
```

## Field Descriptions

### collectionId

-   **Type**: `T` (NumberType)
-   **Description**: The ID of the collection containing the required tokens
-   **Example**: `"1"` for collection ID 1

### amountRange

-   **Type**: `UintRange<T>`
-   **Description**: Minimum and maximum amount of tokens the user must own
-   **Format**: `{ start: "minAmount", end: "maxAmount" }`
-   **Example**: `{ start: "1", end: "10" }` requires 1-10 tokens (amounts)

### ownershipTimes

-   **Type**: `UintRange<T>[]`
-   **Description**: Time ranges when the user must have owned the tokens (UNIX milliseconds)
-   **Example**: `[{ start: "1691931600000", end: "1723554000000" }]` for Aug 13, 2023 - Aug 13, 2024

### badgeIds

-   **Type**: `UintRange<T>[]`
-   **Description**: Specific token IDs that must be owned
-   **Example**: `[{ start: "1", end: "100" }]` for token IDs 1-100

### overrideWithCurrentTime

-   **Type**: `boolean`
-   **Description**: When true, ignores `ownershipTimes` and uses current block time
-   **Behavior**: Sets ownership time to `[{ start: currentTime, end: currentTime }]`
-   **Use Case**: Require current ownership only, not historical ownership

### mustSatisfyForAllAssets

-   **Type**: `boolean`
-   **Description**: Controls whether all specified token requirements must be met or just one
-   **True**: User must own ALL specified token combinations
-   **False**: User must own AT LEAST ONE of the specified token combinations

### ownershipCheckParty

-   **Type**: `string`
-   **Description**: Specifies which party of the transfer to check ownership for
-   **Options**:
    -   `"initiator"` (default): Check ownership for the address that initiated the transfer
    -   `"sender"`: Check ownership for the address sending the badges
    -   `"recipient"`: Check ownership for the address receiving the badges
-   **Default**: `"initiator"` (if empty or not specified)
-   **Example**: `"sender"` to require the sender to own specific badges before allowing the transfer

## Example

Require users to own specific tokens to access premium features or exclusive transfers.

```json
{
    "mustOwnBadges": [
        {
            "collectionId": "1",
            "amountRange": { "start": "1", "end": "1" },
            "ownershipTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "badgeIds": [{ "start": "1", "end": "1" }],
            "overrideWithCurrentTime": false,
            "mustSatisfyForAllAssets": true,
            "ownershipCheckParty": "initiator"
        }
    ]
}
```

### Party-Specific Examples

#### Check Initiator Ownership (Default)

```json
{
    "mustOwnBadges": [
        {
            "collectionId": "1",
            "amountRange": { "start": "1", "end": "1" },
            "badgeIds": [{ "start": "1", "end": "1" }],
            "ownershipCheckParty": "initiator"
        }
    ]
}
```

#### Check Sender Ownership

```json
{
    "mustOwnBadges": [
        {
            "collectionId": "1",
            "amountRange": { "start": "1", "end": "1" },
            "badgeIds": [{ "start": "1", "end": "1" }],
            "ownershipCheckParty": "sender"
        }
    ]
}
```

#### Check Recipient Ownership

```json
{
    "mustOwnBadges": [
        {
            "collectionId": "1",
            "amountRange": { "start": "1", "end": "1" },
            "badgeIds": [{ "start": "1", "end": "1" }],
            "ownershipCheckParty": "recipient"
        }
    ]
}
```


## File: ./x-badges/concepts/approval-criteria/dynamic-store-challenges.md

# Dynamic Store Challenges

Require transfer initiators to pass checks against dynamic stores. Typically, these are used with smart contracts.

Dynamic stores are simply standalone (address -> number) stores where the number is the amount of uses an initiator has left. They are controlled by whoever creates them. These are powerful for creating dynamic approval criteria with smart contracts and other custom use cases.

## How It Works

Dynamic store challenges check if the transfer initiator has a value greater than 0 in specified dynamic stores. The system:

1. **Checks Initiator**: Looks up the initiator's address in the specified dynamic store
2. **Evaluates Number**: Returns the numeric value for the initiator
3. **Requires All > 0**: All challenges must return a value greater than 0 for approval
4. **Fails if Any ≤ 0**: If any challenge returns 0 or less, transfer is denied

## Interface

```typescript
interface DynamicStoreChallenge<T extends NumberType> {
    storeId: string; // Dynamic store ID to check
}
```

## Usage in Approval Criteria

```json
{
    "dynamicStoreChallenges": [
        { "storeId": "1" }, // Member points store (must have > 0 points)
        { "storeId": "2" } // Subscription level store (must have > 0 level)
    ]
}
```

## Managing Dynamic Stores

### Creating Stores

Use [MsgCreateDynamicStore](../../messages/msg-create-dynamic-store.md) to create new dynamic stores with default numeric values.

### Setting Values

Use [MsgSetDynamicStoreValue](../../messages/msg-set-dynamic-store-value.md) to set numeric values for specific addresses.

### Incrementing Values

Use [MsgIncrementStoreValue](../../messages/msg-increment-store-value.md) to increase values for specific addresses.

### Decrementing Values

Use [MsgDecrementStoreValue](../../messages/msg-decrement-store-value.md) to decrease values for specific addresses.

### Querying Values

Use [GetDynamicStoreValue](../../queries/get-dynamic-store-value.md) to check current values for addresses.

## Alternatives

For fully off-chain solutions, consider:

-   [Merkle Challenges](merkle-challenges.md) to save gas costs
-   [ETH Signature Challenges](eth-signature-challenges.md) for direct authorization


## File: ./x-badges/concepts/approval-criteria/eth-signature-challenges.md

# ETH Signature Challenges

ETH Signature Challenges are a type of approval criteria that require users to provide valid Ethereum signatures from a predetermined signer to complete transfers. The signer approves the address by signing a message that contains the address and a nonce. This feature allows for secure, on-chain verification of off-chain authorization without the complexity of Merkle trees.

## Overview

ETH Signature Challenges work by requiring users to provide Ethereum signatures that prove they have authorization from specific Ethereum addresses. Each signature can only be used once, preventing replay attacks and ensuring the security of the approval system.

## How It Works

### Signature Scheme

The signature scheme follows the pattern:

```
ETHSign(nonce + "-" + creatorAddress)
```

Where:

-   `nonce`: A unique identifier provided by the user
-   `creatorAddress`: The address of the collection creator
-   `-`: A literal dash character separating the two values

### Challenge Structure

Each ETH Signature Challenge contains:

-   `signer`: The Ethereum address that must sign the challenge
-   `challengeTrackerId`: Unique identifier for tracking used signatures
-   `uri`: Optional metadata URI
-   `customData`: Optional custom data

### Proof Structure

Users provide ETH Signature Proofs containing:

-   `nonce`: The nonce that was signed
-   `signature`: The Ethereum signature of the nonce

## Key Features

### One-Time Use Signatures

Each signature can only be used once per challenge tracker. This prevents:

-   Replay attacks
-   Double-spending of approvals
-   Unauthorized reuse of signatures

### Multiple Signers

You can require signatures from multiple Ethereum addresses in a single approval:

```json
{
    "ethSignatureChallenges": [
        {
            "signer": "0x1234567890123456789012345678901234567890",
            "challengeTrackerId": "challenge1"
        },
        {
            "signer": "0x0987654321098765432109876543210987654321",
            "challengeTrackerId": "challenge2"
        }
    ]
}
```

## Implementation Details

### Signature Verification

The system verifies signatures by:

1. Reconstructing the signed message: `nonce + "-" + creatorAddress`
2. Recovering the signer address from the signature
3. Comparing the recovered address with the expected `signer` address
4. Checking that the signature hasn't been used before

### Storage

Used signatures are tracked in the blockchain state using:

-   **Key**: `ETHSignatureTrackerKey` with challenge tracker ID
-   **Value**: Number of times the signature has been used (increment-only per tracker ID)

## Quick Reference

### Interface Definitions

```typescript
interface ETHSignatureChallenge {
    signer: string; // Ethereum address that must sign
    challengeTrackerId: string; // Unique ID for tracking used signatures
    uri?: string; // Optional metadata URI
    customData?: string; // Optional custom data
}

interface ETHSignatureProof {
    nonce: string; // The nonce that was signed
    signature: string; // Ethereum signature
}
```

## Error Handling

Common error scenarios:

-   **Invalid Signature**: Signature doesn't match the expected signer
-   **Already Used**: Signature has been used before
-   **Missing Proof**: Required ETH signature proof not provided
-   **Invalid Nonce**: Nonce format or content is invalid

The system provides clear error messages to help users understand and resolve issues.


## File: ./x-badges/concepts/approval-criteria/linking-trackers-advanced.md

# Extending Approvals (Advanced)

For edge cases requiring advanced functionality beyond native interfaces.

## When to Extend

Consider extending when you need:

-   Cross-approval functionality
-   Access to other blockchain data/modules
-   Custom logic not covered by native options

## Before Extending

1. **Consider Workarounds**: Many approvals can be adapted to fit native interfaces
2. **Design Alternatives**: Think creatively about using existing features
3. **Evaluate Necessity**: Ensure extension is truly required

## Implementation Options

### CosmWASM Smart Contracts

Build custom smart contracts that call into the x/badges module.

### EVM Smart Contracts (Coming Soon)

Build custom EVM contracts that call into the x/badges module.


## File: ./x-badges/concepts/approval-criteria/max-number-of-transfers.md

# Max Number of Transfers

Limit the number of transfers that can occur using approval trackers.

See [Approval Trackers](./approval-trackers.md) for more information on how trackers work.

## Interface

```typescript
interface ApprovalCriteria<T extends NumberType> {
    maxNumTransfers?: MaxNumTransfers<T>;
}
```

## How It Works

Similar to approval amounts, specify maximum transfers on:

-   **Overall**: Universal limit for all transfers
-   **Per Sender**: Limit per unique sender address
-   **Per Recipient**: Limit per unique recipient address
-   **Per Initiator**: Limit per unique initiator address

"0" means unlimited and not tracked. "N" means max N transfers allowed.

## Example

```json
{
    "maxNumTransfers": {
        "overallMaxNumTransfers": "0",
        "perFromAddressMaxNumTransfers": "0",
        "perToAddressMaxNumTransfers": "0",
        "perInitiatedByAddressMaxNumTransfers": "1",
        "amountTrackerId": "uniqueID"
    }
}
```

Alice can initiate 1 transfer, then no more. Bob can still transfer (different tracker).

```typescript
{
    "fullTrackerId": {
        "numTransfers": 1,
        "amounts": [],
        "lastUpdatedAt": 1691978400000
    }
}
```

## As-Needed Basis

We track on an as-needed basis, meaning if we do not have requirements that use the number of transfers, we will not increment the tracker.

Edge Case: In Predetermined Balances, you may need the number of transfers for determining the balances to assign to each transfer (e.g. transfer #10 -> token ID 10). In this case, we do need to track the number of transfers. This is all facilitated via the same tracker, so even if you have "0" or unlimited set for the corresponding value in maxNumTransfers, the tracker may be incremented behind the scenes. Consider this when editing / creating approvals. You do not want to use a tracker that has prior history when you expect it to start from scratch.


## File: ./x-badges/concepts/approval-criteria/merkle-challenges.md

# Merkle Challenges

## Overview

Merkle challenges provide cryptographic proof-based approval mechanisms using SHA256 Merkle trees. They enable secure, gas-efficient whitelisting and claim code systems without storing large address lists on-chain.

**Key Benefits**:

-   **Gas Efficiency**: Distribute gas costs among users instead of collection creators
-   **Security**: Cryptographic proof verification prevents unauthorized access
-   **Flexibility**: Support both whitelist trees and claim code systems
-   **Scalability**: Handle large user bases without on-chain storage

## Interface Definition

```typescript
export interface MerkleChallenge<T extends NumberType> {
    root: string; // SHA256 Merkle tree root hash
    expectedProofLength: T; // Required proof length (security)
    useCreatorAddressAsLeaf: boolean; // Use initiator address as leaf?
    maxUsesPerLeaf: T; // Maximum uses per leaf
    uri: string; // Metadata URI
    customData: string; // Custom data field
    challengeTrackerId: string; // Unique tracker identifier
    leafSigner: string; // Optional leaf signature authority
}
```

## Basic Example

```json
{
    "merkleChallenges": [
        {
            "root": "758691e922381c4327646a86e44dddf8a2e060f9f5559022638cc7fa94c55b77",
            "expectedProofLength": "1",
            "useCreatorAddressAsLeaf": false,
            "maxUsesPerLeaf": "1",
            "uri": "ipfs://Qmbbe75FaJyTHn7W5q8EaePEZ9M3J5Rj3KGNfApSfJtYyD",
            "customData": "",
            "challengeTrackerId": "uniqueId",
            "leafSigner": "0x"
        }
    ]
}
```

## Challenge Types

### 1. Claim Code Challenges

Create a Merkle tree of secret claim codes that users must provide to claim tokens.

**Use Case**: Private claim codes, invitation systems, promotional campaigns

**Process**:

1. Generate secret claim codes
2. Build Merkle tree from hashed codes
3. Distribute codes privately to users with leaf signatures
4. Users provide code + Merkle proof in transfer

### 2. Whitelist Challenges

Create a Merkle tree of user addresses for gas-efficient whitelisting.

**Use Case**: Large whitelists, community access, gas cost distribution

**Process**:

1. Collect user addresses
2. Build Merkle tree from hashed addresses
3. Users provide their address + Merkle proof
4. System verifies address is in whitelist / valid proof

**Gas Cost Distribution**: Instead of the collection creator paying gas to store N addresses on-chain, each user pays their own gas for proof verification.

## Understanding useCreatorAddressAsLeaf

The `useCreatorAddressAsLeaf` field determines how the system handles the leaf value in Merkle proofs:

### Whitelist Trees (`useCreatorAddressAsLeaf: true`)

**Purpose**: Verify that the transaction initiator is in the whitelist.

**How It Works**:

1. **Automatic Override**: The system expects the provided leaf to be the initiator's BitBadges address ("bb1...")
2. **Address Verification**: Checks if the initiator's address exists in the Merkle tree
3. **No Manual Leaf**: Users don't need to provide their address as the leaf - the system handles it

**Recommended Configuration**:

-   Set `initiatedByList` to "All" (whitelist tree handles the restriction)
-   Set `useCreatorAddressAsLeaf: true`
-   Build Merkle tree from BitBadges addresses as leaves ["bb1...", "bb2...", "bb3..."]

### Claim Code Trees (`useCreatorAddressAsLeaf: false`)

**Purpose**: Verify that the user possesses a valid claim code.

**How It Works**:

1. **Manual Leaf**: User must provide the actual claim code as the leaf
2. **Code Verification**: System verifies the provided code exists in the Merkle tree
3. **User Responsibility**: Users must know and provide their claim code

**Recommended Configuration**:

-   Set `useCreatorAddressAsLeaf: false`
-   Build Merkle tree from claim codes as leaves ["secret1", "secret2", "secret3"]
-   Post root hash on-chain as challenge
-   Distribute codes privately to users with leaf signatures

## Security Features

### Expected Proof Length

**Critical Security Feature**: All proofs must have the same length to prevent preimage and second preimage attacks.

```typescript
// All proofs must match this length
expectedProofLength: '2'; // 2-level proof required
```

**Design Requirement**: Your Merkle tree must be constructed so all leaves are at the same depth.

### Max Uses Per Leaf

Control how many times each leaf can be used:

| Setting         | Behavior          | Use Case             |
| --------------- | ----------------- | -------------------- |
| `"0"` or `null` | Unlimited uses    | Public claim codes   |
| `"1"`           | One-time use      | Single-use codes     |
| `"5"`           | Five uses maximum | Limited distribution |

**Critical Security Requirement**: For claim code challenges (`useCreatorAddressAsLeaf: false`), `maxUsesPerLeaf` must be `"1"` to prevent replay attacks.

### Replay Attack Protection

**⚠️ CRITICAL SECURITY RISK**: Non-address trees (claim codes) are vulnerable to front-running attacks.

**The Problem**:

1. User submits transaction with valid Merkle proof
2. Proof becomes visible in mempool (public blockchain)
3. Malicious actor sees the proof and front-runs the transaction
4. Original user's transaction fails, attacker gets the token

**Why This Happens**:

-   Merkle proofs for claim codes are reusable until consumed
-   Once in mempool, proofs are publicly visible
-   No built-in protection against proof reuse

**The Solution**: Leaf signatures provide cryptographic protection against this attack.

## Challenge Tracking

### Tracker System

Uses increment-only, immutable trackers to prevent double-spending:

```typescript
{
    collectionId: T;
    approvalId: string;
    approvalLevel: 'collection' | 'incoming' | 'outgoing';
    approverAddress: string; // blank if collection-level
    challengeTrackerId: string;
    leafIndex: T; // Leftmost base layer leaf index = 0, rightmost = numLeaves - 1
}
```

Note the fact we use leaf indices to track usage and not leaf values.

### Tracker Examples

```
1-collection- -approvalId-uniqueID-0  → USED 1 TIME
1-collection- -approvalId-uniqueID-1  → UNUSED
1-collection- -approvalId-uniqueID-2  → USED 3 TIMES
```

**Important**: Trackers are scoped to specific approvals and cannot be shared between different approval configurations.

### Tracker Management

-   **Increment-Only**: Once used, the number of uses cannot be decremented
-   **Immutable**: Tracker state cannot be modified
-   **Best Practice**: Use unique `challengeTrackerId` for fresh tracking of new approvals

## Leaf Signatures

### Protection Against Front-Running

Leaf signatures provide cryptographic protection against front-running attacks on claim code challenges.

**How It Works**:

```typescript
// Signature scheme
signature = ETHSign(leaf + '-' + bitbadgesAddressOfInitiator);
```

**Security Mechanism**:

1. **Address Binding**: Each proof is cryptographically tied to a specific BitBadges address
2. **Replay Prevention**: Even if proof is intercepted, it cannot be used by other addresses
3. **Mempool Safety**: Intercepted proofs in mempool are useless to attackers

### Implementation

```typescript
// Only Ethereum addresses supported currently
leafSigner: '0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b6';
```

**Critical Benefits**:

-   **Front-Running Protection**: Prevents attackers from stealing tokens via mempool interception
-   **Address-Specific**: Each proof is cryptographically bound to the intended recipient
-   **Mempool Safety**: Makes intercepted proofs useless to malicious actors
-   **Required for Claim Codes**: Strongly recommended for all non-address tree challenges

**⚠️ IMPORTANT**: For claim code challenges, leaf signatures are not just recommended—they are essential for security against front-running attacks.

## Merkle Tree Construction

### Standard Configuration

```typescript
import { SHA256 } from 'crypto-js';
import MerkleTree from 'merkletreejs';

// For claim codes
const codes = ['secret1', 'secret2', 'secret3'];
const hashedCodes = codes.map((x) => SHA256(x).toString());

// For whitelists
const addresses = ['bb1...', 'bb1...', 'bb1...'];
const hashedAddresses = addresses.map((x) => SHA256(x));

// Tree options (tested configuration)
const treeOptions = {
    fillDefaultHash:
        '0000000000000000000000000000000000000000000000000000000000000000',
};

// Build tree
const tree = new MerkleTree(hashedCodes, SHA256, treeOptions);
const root = tree.getRoot().toString('hex');
const expectedProofLength = tree.getLayerCount() - 1;
```

### Critical Requirements

1. **Same Layer**: All leaves must be at the same depth
2. **Consistent Proof Length**: All proofs must have identical length
3. **Test Thoroughly**: Verify all paths work before deployment
4. **Use Tested Options**: Stick to the `fillDefaultHash` configuration

## Transfer Integration

### Providing Proofs

Include Merkle proofs in [MsgTransferBadges](../../../bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgtransferbadges.md):

```typescript
const txCosmosMsg: MsgTransferBadges<bigint> = {
    creator: chain.bitbadgesAddress,
    collectionId: collectionId,
    transfers: [
        {
            // ... other fields
            merkleProofs: [
                {
                    aunts: proofObj.map((proof) => ({
                        aunt: proof.data.toString('hex'),
                        onRight: proof.position === 'right',
                    })),
                    leaf: isWhitelist ? '' : passwordCodeToSubmit,
                    leafSignature: leafSignature, // if applicable
                },
            ],
        },
    ],
};
```

### Proof Generation

```typescript
// Generate proof for user submission
const passwordCodeToSubmit = 'secretCode123';
const leaf = isWhitelist
    ? SHA256(chain.bitbadgesAddress).toString()
    : SHA256(passwordCodeToSubmit).toString();

const proofObj = tree.getProof(leaf, whitelistIndex);
const isValidProof = proofObj && proofObj.length === tree.getLayerCount() - 1;

// Create signature if needed
const leafSignature = signLeaf(leaf + '-' + chain.bitbadgesAddress);
```

## Comparison with ETH Signature Challenges

Merkle challenges and ETH signature challenges are very similar. The main difference is that Merkle challenges must also check that the signed message was pre-committed to in the tree, whereas ETH signature challenges only need to check that the signature is valid and not used before.

For more information, see [ETH Signature Challenges](eth-signature-challenges.md).

## Best Practices

### Design Considerations

1. **Tree Structure**: Ensure all leaves at same depth
2. **Proof Length**: Test all proof lengths are identical
3. **Tracker Management**: Use unique IDs for fresh tracking
4. **Security**: **MANDATORY** - Enable leaf signatures for claim codes to prevent front-running
5. **Testing**: Verify all paths work before mainnet

### Performance Optimization

1. **Small Lists**: For <100 users, consider regular address lists
2. **Gas Distribution**: Merkle trees excel with large user bases
3. **Proof Verification**: On-chain verification is gas-efficient
4. **Storage**: No on-chain storage of large lists required


## File: ./x-badges/concepts/approval-criteria/overrides.md

# Override User Level Approvals

Collection-level approvals can override user-level approvals to force transfers.

## Interface

```typescript
interface ApprovalCriteria<T extends NumberType> {
    overridesFromOutgoingApprovals?: boolean;
    overridesToIncomingApprovals?: boolean;
}
```

## How It Works

-   **`overridesFromOutgoingApprovals: true`**: Skip sender's outgoing approvals
-   **`overridesToIncomingApprovals: true`**: Skip recipient's incoming approvals

This enables forced transfers without user consent.

## Use Cases

-   **Force Revoke**: Remove tokens from users
-   **Freeze Tokens**: Prevent transfers regardless of user settings
-   **Emergency Actions**: Administrative control over transfers

## Mint Address Requirement

**CRITICAL**: Mint address approvals must always override outgoing approvals:

```json
{
    "fromListId": "Mint",
    "approvalCriteria": {
        "overridesFromOutgoingApprovals": true
    }
}
```

The Mint address has no user-level approvals, so overrides are required for functionality.


## File: ./x-badges/concepts/approval-criteria/predetermined-balances.md

# Predetermined Balances

## Overview

Predetermined balances provide fine-grained control over the exact amounts and order of transfers in an approval. Unlike traditional tally-based systems where you approve a total amount (e.g., 100 tokens) without controlling the specific combinations, predetermined balances let you explicitly define:

-   **Exact amounts** that must be transferred
-   **Specific order** of transfers
-   **Precise token IDs and ownership times** for each transfer

**Key Principle**: The transfer will fail if the balances are not EXACTLY as defined in the predetermined balances.

## Interface Definition

```typescript
export interface PredeterminedBalances<T extends NumberType> {
    manualBalances: ManualBalances<T>[];
    incrementedBalances: IncrementedBalances<T>;
    orderCalculationMethod: PredeterminedOrderCalculationMethod;
}
```

## Balance Definition Methods

There are two mutually exclusive ways to define balances:

### 1. Manual Balances

Define an array of specific balance sets manually. Each element corresponds to a different transfer.

```json
{
    "manualBalances": [
        {
            "amount": "1",
            "badgeIds": [
                {
                    "start": "1",
                    "end": "1"
                }
            ],
            "ownershipTimes": [
                {
                    "start": "1691978400000",
                    "end": "1723514400000"
                }
            ]
        },
        {
            "amount": "5",
            "badgeIds": [
                {
                    "start": "2",
                    "end": "6"
                }
            ],
            "ownershipTimes": [
                {
                    "start": "1691978400000",
                    "end": "1723514400000"
                }
            ]
        }
    ]
}
```

**Use Case**: When you need complete control over each specific transfer amount and timing.

### 2. Incremented Balances

Define starting balances and rules for subsequent transfers. Perfect for sequential minting or time-based releases or other common patterns. Note that most options are incompatible with each other.

```json
{
    "incrementedBalances": {
        "startBalances": [
            {
                "amount": "1",
                "badgeIds": [
                    {
                        "start": "1",
                        "end": "1"
                    }
                ],
                "ownershipTimes": [
                    {
                        "start": "1691978400000",
                        "end": "1723514400000"
                    }
                ]
            }
        ],
        "incrementBadgeIdsBy": "1",
        "incrementOwnershipTimesBy": "0",
        "durationFromTimestamp": "0",
        "allowOverrideTimestamp": false,
        "allowOverrideWithAnyValidBadge": false,
        "recurringOwnershipTimes": {
            "startTime": "0",
            "intervalLength": "0",
            "chargePeriodLength": "0"
        }
    }
}
```

#### Increment Options

| Field                            | Description                                          | Example                                              |
| -------------------------------- | ---------------------------------------------------- | ---------------------------------------------------- |
| `incrementBadgeIdsBy`            | Amount to increment token IDs by after each transfer | `"1"` = next transfer gets token ID 2, then 3, etc.  |
| `incrementOwnershipTimesBy`      | Amount to increment ownership times by               | `"86400000"` = add 1 day to ownership times          |
| `durationFromTimestamp`          | Calculate ownership times from timestamp + duration  | `"2592000000"` = 30 days from transfer time          |
| `allowOverrideTimestamp`         | Allow custom timestamp override in transfer          | `true` = users can specify custom start time         |
| `allowOverrideWithAnyValidBadge` | Allow any valid token ID (one) override              | `true` = users can specify any single valid token ID |
| `recurringOwnershipTimes`        | Define recurring time intervals                      | Monthly subscriptions, weekly rewards                |

#### Duration From Timestamp

Dynamically calculate ownership times from a timestamp plus a set duration. This overwrites all ownership times in the starting balances.

```json
{
    "durationFromTimestamp": "2592000000", // 30 days in milliseconds
    "allowOverrideTimestamp": true
}
```

**Behavior**:

-   **Default**: Uses transfer time as the base timestamp
-   **Override**: If `allowOverrideTimestamp` is true, users can specify a custom timestamp in `MsgTransferBadges` `precalculationOptions`
-   **Calculation**: `ownershipTime = baseTimestamp + durationFromTimestamp`
-   **Overwrite**: All ownership times in starting balances are replaced with [{ "start": baseTimestamp, "end": baseTimestamp + durationFromTimestamp }]

#### Recurring Ownership Times

Define repeating time intervals for subscriptions or periodic rewards:

```json
{
    "recurringOwnershipTimes": {
        "startTime": "1691978400000", // When intervals begin
        "intervalLength": "2592000000", // 30 days in milliseconds
        "chargePeriodLength": "604800000" // 7 days advance charging
    }
}
```

**Example**: Monthly subscription starting August 13, 2023, with 7-day advance charging period.

## Precalculating Balances

### The Race Condition Problem

Predetermined balances can change rapidly between transaction broadcast and confirmation. For example:

-   Other users' mints get processed
-   Token IDs shift due to concurrent activity
-   Manual balance specification becomes unreliable

### The Solution: Precalculation

Use `precalculateBalancesFromApproval` in [MsgTransferBadges](../../../bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgtransferbadges.md) to dynamically calculate balances at execution time.

```typescript
{
  precalculateBalancesFromApproval: {
    approvalId: string;           // The approval to precalculate from
    approvalLevel: string;        // "collection" | "incoming" | "outgoing"
    approverAddress: string;      // "" if collection-level
    version: string;              // Must specify exact version
  },
  precalculationOptions: {
    // Additional override options dependent on the selections
  }
}
```

## Order Calculation Methods

The system needs to determine which balance set to use for each transfer. This is controlled by the `orderCalculationMethod`.

### How Order Numbers Work

The order number determines which balances to transfer, but it works differently depending on the balance type:

#### Manual Balances

-   **Order number = 0**: Transfer `manualBalances[0]` (first element)
-   **Order number = 1**: Transfer `manualBalances[1]` (second element)
-   **Order number = 5**: Transfer `manualBalances[5]` (sixth element)

**Example**: If you have 3 manual balance sets, order numbers 0, 1, and 2 will use each set once. Order number 3 would be out of bounds.

#### Incremented Balances

-   **Order number = 0**: Use starting balances as-is (no increments)
-   **Order number = 1**: Apply increments once to starting balances
-   **Order number = 5**: Apply increments five times to starting balances

**Example**: Starting with token ID 1, increment by 1:

-   Order 0: Token ID 1
-   Order 1: Token ID 2
-   Order 2: Token ID 3
-   Order 5: Token ID 6

### Transfer-Based Order Numbers

Track the number of transfers to determine order:

| Method                                 | Description           | Use Case                    |
| -------------------------------------- | --------------------- | --------------------------- |
| `useOverallNumTransfers`               | Global transfer count | Simple sequential transfers |
| `usePerToAddressNumTransfers`          | Per-recipient count   | User-specific limits        |
| `usePerFromAddressNumTransfers`        | Per-sender count      | Sender-specific limits      |
| `usePerInitiatedByAddressNumTransfers` | Per-initiator count   | Initiator-specific limits   |

**Important**: Uses the same tracker as [Max Number of Transfers](max-number-of-transfers.md). Trackers are:

-   Increment-only and immutable
-   Shared between predetermined balances and max transfer limits
-   Must be carefully managed to avoid conflicts

### Merkle-Based Order Numbers

Use Merkle challenge leaf indices (leftmost = 0, rightmost = numLeaves - 1) for reserved transfers:

```typescript
{
  "useMerkleChallengeLeafIndex": true,
  "challengeTrackerId": "uniqueId"
}
```

**Use Case**: Reserve specific token IDs for specific users or claim codes.

## Order Calculation Interface

```typescript
export interface PredeterminedOrderCalculationMethod {
    useOverallNumTransfers: boolean;
    usePerToAddressNumTransfers: boolean;
    usePerFromAddressNumTransfers: boolean;
    usePerInitiatedByAddressNumTransfers: boolean;
    useMerkleChallengeLeafIndex: boolean;
    challengeTrackerId: string;
}
```

## Boundary Handling

### Understanding Bounds

Every approval defines bounds through its core fields (badgeIds, ownershipTimes, etc.). For example:

-   **Token IDs**: 1-100
-   **Ownership Times**: Mon-Fri only
-   **Transfer Times**: Specific date range

Predetermined balances must work within these bounds, but note that order numbers can eventually exceed them.

### Boundary Scenarios

#### Complete Out-of-Bounds

**Scenario**: Order number corresponds to balances completely outside approval bounds.

**Example**:

-   Approval allows token IDs 1-100
-   Increment by 1 for each transfer
-   Order number 101 would require token ID 101 (out of bounds)

**Result**: Transfer is ignored because token ID 101 never matches the approval's token ID range.

#### Partial Overlap

**Scenario**: Order number corresponds to balances that partially overlap with approval bounds.

**Example**:

-   Approval allows token IDs 1-100
-   Transfer requires token IDs 95-105
-   Token IDs 95-100 are in bounds, 101-105 are out of bounds

**Result**:

-   Only in-bounds balances (95-100) are approved by current approval
-   Out-of-bounds balances (101-105) must be approved by a separate approval
-   The complete transfer (95-105) must still be exactly as defined

**Important**: The transfer will fail unless all out-of-bounds balances are approved by other approvals.


## File: ./x-badges/concepts/approval-criteria/requires.md

# Requires

Additional address relationship restrictions for transfer approval.

## Interface

```typescript
interface ApprovalCriteria<T extends NumberType> {
    requireToEqualsInitiatedBy?: boolean;
    requireToDoesNotEqualInitiatedBy?: boolean;
    requireFromEqualsInitiatedBy?: boolean;
    requireFromDoesNotEqualInitiatedBy?: boolean;
}
```

## How It Works

Enforce additional checks on address relationships:

-   **`requireToEqualsInitiatedBy`**: Recipient must equal initiator
-   **`requireToDoesNotEqualInitiatedBy`**: Recipient must not equal initiator
-   **`requireFromEqualsInitiatedBy`**: Sender must equal initiator
-   **`requireFromDoesNotEqualInitiatedBy`**: Sender must not equal initiator

## Constraints

All checks are bounded by the respective address lists (`toList`, `fromList`, `initiatedByList`).


## File: ./x-badges/concepts/approval-criteria/tallied-approval-amounts.md

# Tallied Approval Amounts

Limit transfer amounts using increment-only trackers with thresholds.

## Interface

```typescript
interface ApprovalCriteria<T extends NumberType> {
    approvalAmounts?: ApprovalAmounts<T>;
}
```

## How It Works

Specify maximum amounts that can be transferred using four tracker types:

-   **Overall** (`trackerType = "overall"`): Universal limit for all transfers
-   **Per To Address** (`trackerType = "to"`): Limit per unique recipient
-   **Per From Address** (`trackerType = "from"`): Limit per unique sender
-   **Per Initiated By Address** (`trackerType = "initiatedBy"`): Limit per unique initiator

"0" means unlimited and not tracked. "N" means max N amount allowed.

## Example

```json
{
    "approvalAmounts": {
        "overallApprovalAmount": "1000",
        "perFromAddressApprovalAmount": "0",
        "perToAddressApprovalAmount": "0",
        "perInitiatedByAddressApprovalAmount": "10",
        "amountTrackerId": "uniqueID"
    }
}
```

## Tracker Types

### Overall Tracker

-   **ID**: `1-collection- -approvalId-uniqueID-overall-`
-   **Behavior**: Increments for all transfers regardless of sender/recipient/initiator
-   **Use Case**: Global collection limits

### Per-To Address Tracker

-   **ID**: `1-collection- -approvalId-uniqueID-to-recipientAddress`
-   **Behavior**: Separate tracker for each unique recipient
-   **Use Case**: Limit how much each user can receive

### Per-From Address Tracker

-   **ID**: `1-collection- -approvalId-uniqueID-from-senderAddress`
-   **Behavior**: Separate tracker for each unique sender
-   **Use Case**: Limit how much each user can send

### Per-InitiatedBy Address Tracker

-   **ID**: `1-collection- -approvalId-uniqueID-initiatedBy-initiatorAddress`
-   **Behavior**: Separate tracker for each unique initiator
-   **Use Case**: Limit how much each user can initiate

## Detailed Example

Using the approval amounts defined above, when Alice initiates a transfer of x10 from Bob:

### Two Trackers Get Incremented

**#1) Overall Tracker**

-   **ID**: `1-collection- -approvalId-uniqueID-overall-`
-   **Before**: 0/1000
-   **After**: 10/1000
-   **Behavior**: Any subsequent transfers (from Charlie, etc.) will also increment this universal tracker

**#2) Per-Initiator Tracker**

-   **ID**: `1-collection- -approvalId-uniqueID-initiatedBy-alice`
-   **Before**: 0/10
-   **After**: 10/10 (fully used)
-   **Behavior**: Only incremented when Alice initiates. Charlie's transfers use a separate tracker: `1-collection- -approvalId-uniqueID-initiatedBy-charlie`

### Amount Tracking with Balance Type

Trackers store amounts using the balance type structure. Above, we simplified it to just the amount.

```json
{
    "amounts": [
        {
            "amount": 10n,
            "badgeIds": [{ "start": 1n, "end": 1n }],
            "ownershipTimes": [{ "start": 1n, "end": 100000000000n }]
        }
    ]
}
```

**What Gets Incremented**:

-   **Amount**: The total quantity transferred
-   **Token IDs**: Specific token IDs that were transferred
-   **Ownership Times**: The ownership time ranges that were transferred

### Unlimited Trackers (No Increment)

Since "to" and "from" trackers are set to "0" (unlimited), no tracking occurs for these types.

## Tracker Behavior

-   **As-Needed**: Only increment trackers when necessary (unlimited = no tracking)
-   **Separate Counts**: Each tracker type maintains independent tallies
-   **Address Scoped**: Per-address trackers create unique counters per address
-   **Balance Tracking**: Increments for specific token IDs and ownership times transferred

## Resets and ID Changes

### Changing Tracker ID

When you update `amountTrackerId` from "uniqueID" to "uniqueID2":

```
1-collection- -approvalId-uniqueID-initiatedBy-alice
↓
1-collection- -approvalId-uniqueID2-initiatedBy-alice
```

**Result**: All tracker IDs change, so all tallies start from scratch.

### Reusing Old IDs

If you later change back to "uniqueID", the starting point will be the previous tally:

-   Alice's initiatedBy tracker: 10/10 used (not 0/10)

**Important**: Never reuse tracker IDs unless you want to continue from the previous state. They are increment-only.


## File: ./x-badges/concepts/approval-criteria/usdbadge-transfers.md

# Coin Transfers

Automatic token transfers executed on every approval use. Supports any Cosmos SDK denomination. These are triggered every time an approval is used.

To get all supported denominations, use the query parameters for the badges module.

## Interface

```typescript
interface iCoinTransfer<T extends NumberType> {
    to: string; // Recipient BitBadges address
    coins: iCosmosCoin<T>[];

    overrideFromWithApproverAddress: boolean; // By default, this is the initiator address
    overrideToWithInitiator: boolean; // By default, this is the to address specified
}

interface iCosmosCoin<T extends NumberType> {
    amount: T;
    denom: string; // Any Cosmos SDK denomination (e.g., "ubadge", "uatom", "uosmo")
}
```

## Mint Escrow Address

For collection approvals with `overrideFromWithApproverAddress: true`, the approver address is a special mint escrow address.

### Generation

```typescript
const mintEscrowAddress = generateAlias(
    'badges',
    getAliasDerivationKeysForCollection(collectionId)
);
```

### Properties

-   Longer than normal addresses
-   No private key (cannot be controlled by users)
-   Can receive Cosmos-native tokens
-   Only collection approvals can trigger transfers from it

## Example

```json
[
    {
        "to": "bb1...",
        "coins": [{ "amount": "1000000000", "denom": "ubadge" }],
        "overrideFromWithApproverAddress": false,
        "overrideToWithInitiator": false
    }
]
```


## File: ./x-badges/concepts/approval-criteria/user-royalties.md

# User Royalties

Apply percentage-based royalties to transfers.

## Interface

```typescript
interface UserRoyalties {
    percentage: string; // 1 to 10000 represents basis points (0.01% to 100%)
    payoutAddress: string; // Address to receive the royalties
}
```

## How It Works

User royalties automatically deduct a percentage from transfers and send it to a specified payout address:

-   **Percentage**: Expressed in basis points (1 = 0.01%, 100 = 1%, 10000 = 100%)
-   **Payout**: Automatically sent to the specified address on each transfer
-   **Deduction**: Applied to the transfer amount before the transfer is processed

## Usage Examples

### 5% Royalty

```json
{
    "userRoyalties": {
        "percentage": "500", // 500 basis points = 5%
        "payoutAddress": "bb1creator..."
    }
}
```

**Result**: 5% of each transfer amount is sent to the creator's address.

### 2.5% Royalty

```json
{
    "userRoyalties": {
        "percentage": "250", // 250 basis points = 2.5%
        "payoutAddress": "bb1artist..."
    }
}
```

**Result**: 2.5% of each transfer amount is sent to the artist's address.

## Edge Case: One per Transfer

Currently, we only support one specific royalty percentage applied per transfer. If a transfer matches to different approvals with multiple royalties, the transfer may fail.


## File: ./x-badges/concepts/archived-collections.md

# Archived Collections

Collections can be archived to temporarily or permanently disable all transactions while keeping the collection data verifiable and public on-chain.

## Implementation

### isArchivedTimeline Structure

```json
"isArchivedTimeline": [
  {
    "timelineTimes": [{"start": "1672531200000", "end": "18446744073709551615"}],
    "isArchived": true
  }
]
```

### Permission Control

Archiving is controlled by the `canArchiveCollection` permission:

```json
"canArchiveCollection": [
  {
    "permanentlyPermittedTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyForbiddenTimes": []
  }
]
```

Note that the `canArchiveCollection` permission is for the updatability of the `isArchivedTimeline` field. It has no bearing on the current value of the `isArchived` field.

For example, when you permanently forbid updating the archive status forever, it could be locked as `true` forever or `false` forever.

## Transaction Behavior

### When Archived

-   **All transactions fail** - No updates, transfers, or changes allowed
-   **Read operations continue** - Queries and data access remain available
-   **Unarchiving exception** - Only unarchiving transactions can succeed

### When Unarchived

-   **Normal operations resume** - All transaction types are allowed
-   **No data loss** - All collection data remains intact
-   **Permissions apply** - Standard permission checks resume

## Archiving a Collection

### During Collection Creation

```json
{
    "creator": "bb1...",
    "isArchivedTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "isArchived": false
        }
    ],
    "collectionPermissions": {
        "canArchiveCollection": [
            {
                "permanentlyPermittedTimes": [
                    { "start": "1", "end": "18446744073709551615" }
                ],
                "permanentlyForbiddenTimes": []
            }
        ]
    }
}
```

### During Collection Updates

Use [MsgUpdateCollection](../../messages/msg-update-collection.md) to update the archive status:

```json
{
    "creator": "bb1...",
    "collectionId": "1",
    "updateIsArchivedTimeline": true,
    "isArchivedTimeline": [
        {
            "timelineTimes": [
                { "start": "1672531200000", "end": "18446744073709551615" }
            ],
            "isArchived": true
        }
    ]
}
```


## File: ./x-badges/concepts/badge-collections.md

# Collections

A collection is the primary entity that defines a group of related tokens with shared properties and rules. We refer you to other pages for more details on the different concepts that make up a collection.

Note: This is what is stored on-chain in storage for a collection. You may typically interact with similar concepts but moreso in Messages and Queries format.

## Proto Definition

```protobuf
message BadgeCollection {
  // The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // The metadata for the collection itself, which can vary over time.
  repeated CollectionMetadataTimeline collectionMetadataTimeline = 2;

  // The metadata for each token in the collection, also subject to changes over time.
  repeated BadgeMetadataTimeline badgeMetadataTimeline = 3;

  // An arbitrary field that can store any data, subject to changes over time.
  repeated CustomDataTimeline customDataTimeline = 4;

  // The address of the manager of this collection, subject to changes over time.
  repeated ManagerTimeline managerTimeline = 5;
  
  // Permissions that define what the manager of the collection can do or not do.
  CollectionPermissions collectionPermissions = 6;

  // Transferability of the collection for collections with standard balances, subject to changes over time.
  // Overrides user approvals for a transfer if specified.
  // Transfer must satisfy both user and collection-level approvals.
  // Only applicable to on-chain balances.
  repeated CollectionApproval collectionApprovals = 7;

  // Standards that define how to interpret the fields of the collection, subject to changes over time.
  repeated StandardsTimeline standardsTimeline = 8;

  // Whether the collection is archived or not, subject to changes over time.
  // When archived, it becomes read-only, and no transactions can be processed until it is unarchived.
  repeated IsArchivedTimeline isArchivedTimeline = 9;

  // The default store of a balance for a user, upon genesis.
  UserBalanceStore defaultBalances = 10;

  // The user or entity who created the collection.
  string createdBy = 11;

  // The valid token IDs for this collection.
  repeated UintRange validBadgeIds = 12;

  // The generated address of the collection. Also used to escrow Mint balances.
  string mintEscrowAddress = 13;

  // The IBC wrapper (sdk.coin) paths for the collection.
  repeated CosmosCoinWrapperPath cosmosCoinWrapperPaths = 14;

  // Collection-level invariants that cannot be broken.
  // These are set upon genesis and cannot be modified.
  CollectionInvariants invariants = 16;
}
```


## File: ./x-badges/concepts/balance-system.md

# Balance System

The Balance system in BitBadges is designed to represent ownership of tokens across different IDs and time ranges. Ownership times are a new concept to BitBadges allowing you to set that someone owns a token during a specific time but not other times.

## Balance Interface

```typescript
export interface Balance<T extends NumberType> {
    amount: T;
    badgeIds: UintRange<T>[];
    ownershipTimes: UintRange<T>[];
}
```

-   `amount`: The quantity of tokens owned
-   `badgeIds`: An array of ID ranges representing the tokens owned
-   `ownershipTimes`: An array of time ranges during which the tokens are owned

## Interpreting Balances

When interpreting balances, it's crucial to understand that multiple ranges of token IDs and ownership times within a single Balance structure represent all possible combinations.

### Interpretation Algorithm

```javascript
for (balance of balances) {
    for (badgeIdRange of balance.badgeIds) {
        for (ownershipTimeRange of balance.ownershipTimes) {
            // User owns x(balance.amount) of (badgeIdRange) for the times (ownershipTimeRange)
        }
    }
}
```

### Example

Consider the following balance:

```json
{
    "amount": 1,
    "badgeIds": [
        { "start": 1, "end": 10 },
        { "start": 20, "end": 30 }
    ],
    "ownershipTimes": [
        { "start": 20, "end": 50 },
        { "start": 100, "end": 200 }
    ]
}
```

This balance expands to:

1. 1x of IDs 1-10 from times 20-50
2. 1x of IDs 1-10 from times 100-200
3. 1x of IDs 20-30 from times 20-50
4. 1x of IDs 20-30 from times 100-200

## Balance Subtraction

When subtracting balances, you may need to represent the result as multiple Balance objects. For example, if we subtract the first set of balances from the example above (1x of IDs 1-10 from times 20-50), the result would be:

```json
[
    {
        "amount": 1,
        "badgeIds": [
            { "start": 1, "end": 10 },
            { "start": 20, "end": 30 }
        ],
        "ownershipTimes": [{ "start": 100, "end": 200 }]
    },
    {
        "amount": 1,
        "badgeIds": [{ "start": 20, "end": 30 }],
        "ownershipTimes": [{ "start": 20, "end": 50 }]
    }
]
```

## Handling Duplicates

When duplicate token IDs are specified in balances, they are combined and their amounts are added. For example:

```json
{
    "amount": 1,
    "badgeIds": [
        { "start": 1, "end": 10 },
        { "start": 1, "end": 10 }
    ],
    "ownershipTimes": [{ "start": 100, "end": 200 }]
}
```

This is equivalent to and will be treated as:

```json
{
    "amount": 2,
    "badgeIds": [{ "start": 1, "end": 10 }],
    "ownershipTimes": [{ "start": 100, "end": 200 }]
}
```

## Best Practices

1. **Efficient Representation**: Try to represent balances in the most compact form possible by combining overlapping ranges
2. **Careful Subtraction**: When subtracting balances, ensure that you correctly split the remaining balances to accurately represent the result
3. **Avoid Duplicates**: While the system handles duplicates by combining them, it's more efficient to represent balances without duplicates in the first place
4. **Time-Aware Operations**: Always consider the time dimension when performing operations on balances, as ownership can vary over time
5. **Range Calculations**: Familiarize yourself with range operations, as they are crucial for correctly manipulating and interpreting balances


## File: ./x-badges/concepts/collection-invariants.md

# Collection Invariants

Collection invariants are immutable rules that are set upon collection creation and cannot be broken or modified afterward. These invariants enforce fundamental constraints on how the collection operates, ensuring consistency and preventing certain types of restrictions.

## Overview

Invariants are collection-level properties that are set during genesis (collection creation) and remain fixed for the lifetime of the collection. Unlike permissions or other configurable settings, invariants cannot be updated or removed once established.

## Proto Definition

```protobuf
message CollectionInvariants {
  // If true, all ownership times must be full ranges [{ start: 1, end: GoMaxUInt64 }].
  // This prevents time-based restrictions on token ownership.
  bool noCustomOwnershipTimes = 1;

  // Maximum supply per token ID. If set, no balance can exceed this amount.
  // This prevents any single token ID from having more than the specified supply.
  string maxSupplyPerId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

## Available Invariants

### noCustomOwnershipTimes

When enabled, this invariant enforces that all ownership times throughout the collection must represent full ranges from the beginning of time (1) to the maximum possible time (18446744073709551615).

#### What it affects:

1. **Collection Approvals**: All collection-level approvals must have ownership times that are full ranges
2. **User Approvals**: All user-level approvals (incoming/outgoing) must have ownership times that are full ranges
3. **Transfer Balances**: All transfer operations must involve balances with full ownership time ranges

#### Validation Logic:

The invariant checks that ownership times are exactly:

```json
[{ "start": "1", "end": "18446744073709551615" }]
```

Any other ownership time configuration will cause validation to fail.

#### Use Cases:

-   **Preventing Time-Based Restrictions**: Ensures tokens cannot have time-limited ownership periods
-   **Simplifying Ownership Model**: Eliminates complexity around time-based approval restrictions
-   **Compliance Requirements**: Some applications may require permanent, unrestricted ownership

#### Example:

```json
// ✅ Valid - Full ownership time range
{
  "ownershipTimes": [
    {
      "start": "1",
      "end": "18446744073709551615"
    }
  ]
}

// ❌ Invalid - Restricted time range
{
  "ownershipTimes": [
    {
      "start": "1000",
      "end": "2000"
    }
  ]
}

// ❌ Invalid - Multiple ranges
{
  "ownershipTimes": [
    {
      "start": "1",
      "end": "1000"
    },
    {
      "start": "2000",
      "end": "3000"
    }
  ]
}
```

### maxSupplyPerId

When set to a non-zero value, this invariant enforces that no balance amount can exceed the specified maximum supply per token ID. This prevents supply inflation and ensures that the total supply of any individual token ID remains within the defined limits.

#### What it affects:

1. **Total Address Balances**: When setting balances for the "Total" address (which represents the total supply across all users), no individual balance amount can exceed the maximum
2. **Supply Control**: Prevents any single token ID from having more than the specified supply amount
3. **Collection Integrity**: Ensures the collection maintains its intended supply constraints

#### Validation Logic:

The invariant checks that when setting "Total" address balances, all balance amounts must be less than or equal to the specified `maxSupplyPerId`:

```go
if balance.Amount.GT(collection.Invariants.MaxSupplyPerId) {
    return error("maxSupplyPerId invariant violation")
}
```

#### Use Cases:

-   **Supply Caps**: Enforce maximum supply limits for individual token IDs
-   **Anti-Inflation**: Prevent supply manipulation through balance operations
-   **Compliance**: Meet regulatory requirements for maximum token supply
-   **Economic Control**: Maintain scarcity and value of specific token IDs

#### Example:

```json
// ✅ Valid - Balance amount within limit
{
  "invariants": {
    "maxSupplyPerId": "1000"
  },
  "balances": [
    {
      "amount": "500",
      "badgeIds": [{ "start": "1", "end": "1" }]
    }
  ]
}

// ❌ Invalid - Balance amount exceeds limit
{
  "invariants": {
    "maxSupplyPerId": "1000"
  },
  "balances": [
    {
      "amount": "1500",  // Exceeds maxSupplyPerId of 1000
      "badgeIds": [{ "start": "1", "end": "1" }]
    }
  ]
}

// ✅ Valid - Non-Total address not affected
{
  "invariants": {
    "maxSupplyPerId": "1000"
  },
  "balances": [
    {
      "amount": "2000",  // Allowed for non-Total addresses
      "badgeIds": [{ "start": "1", "end": "1" }]
    }
  ]
}
```

#### Important Notes:

-   **Only affects "Total" address**: The invariant only applies when setting balances for the "Total" address
-   **Zero value ignored**: If `maxSupplyPerId` is set to 0, the invariant is not enforced
-   **Immutable**: Once set during collection creation, this value cannot be changed
-   **Per-token ID basis**: The limit applies to each individual token ID, not the total collection supply

## Setting Invariants

Invariants can only be set during collection creation via `MsgCreateCollection` or `MsgUniversalUpdateCollection` (when creating a new collection with CollectionId = 0).

```protobuf
message MsgCreateCollection {
  // ... other fields ...
  CollectionInvariants invariants = 18;
}
```

## Validation Points

The invariants are validated at several points:

### noCustomOwnershipTimes

1. **Collection Creation**: When creating a new collection
2. **Collection Updates**: When updating collection approvals
3. **Transfer Execution**: When processing token transfers
4. **Approval Updates**: When updating user or collection approvals

### maxSupplyPerId

1. **Balance Storage**: When setting user balances in the store (specifically for "Total" address)
2. **Supply Validation**: Before any balance amount is stored that would exceed the maximum

## Error Messages

When invariants are violated, you'll receive error messages like:

### noCustomOwnershipTimes

```
noCustomOwnershipTimes invariant is enabled: ownership times must be full range [{ start: 1, end: 18446744073709551615 }]
```

### maxSupplyPerId

```
maxSupplyPerId invariant violation: balance amount 1500 exceeds maximum supply per ID 1000
```

## Related Concepts

-   [Collections](./badge-collections.md)
-   [Transferability Approvals](./transferability-approvals.md)
-   [Time Fields](./time-fields.md)
-   [UintRange](./uintrange.md)


## File: ./x-badges/concepts/cosmos-wrapper-paths.md

# Cosmos Wrapper Paths

Cosmos Wrapper Paths enable wrapping between BitBadges tokens and native Cosmos SDK coin asset types, making tokens IBC-compatible. These paths automatically mint and burn tokens when transferring to/from specific wrapper addresses. These transfers to/from are handled within the badges module, so you can set up customizable logic for how these transfers are handled.

> **Important**: Since wrapper addresses are uncontrollable (no private keys), approval design requires careful consideration. You must override the wrapper address's user-level approvals where necessary using collection approvals to ensure wrapping/unwrapping functions properly.

### Auto-Generating Wrapper Addresses

You can programmatically generate wrapper addresses using the `bitbadgesjs-sdk` npm package. Note that the address is generated based on the denom set. It is just the custom denom, not the full `badges:collectionId:denom` format.

```typescript
import { generateAliasAddressForDenom } from 'bitbadgesjs-sdk';

const denom = 'utoken1';
const wrapperAddress = generateAliasAddressForDenom(denom);
console.log('Wrapper Address:', wrapperAddress);
```

## Proto Definition

```protobuf
message CosmosCoinWrapperPathAddObject {
  string denom = 1;
  repeated Balance balances = 2;
  string symbol = 3;
  repeated DenomUnit denomUnits = 4;
  bool allowOverrideWithAnyValidToken = 5;
}

message DenomUnit {
  string decimals = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string symbol = 2;
  bool isDefaultDisplay = 3;
}
```

## Configuration Fields

### Denom

-   **Base denomination** - The fundamental unit name for the wrapped coin. For the full Cosmos denomination, it will be "badges:collectionId:denom"
-   **{id} placeholder support** - You can use `{id}` in the denom to dynamically replace it with the actual badge ID during transfers if allowOverrideWithAnyValidToken is true

### Symbol

-   **Display symbol** - Human-readable symbol for the wrapped asset

### Balances

-   **Custom conversion rates** - Defines which tokens and ownership times participate in wrapping and how many tokens are wrapped for each native coin unit

### Denomination Units

Multiple denomination units allow for different display formats:

#### Decimals

-   **Precision level** - Number of decimal places for this unit
-   **Conversion factor** - How this unit relates to the base denomination

#### Symbol

-   **Unit symbol** - Symbol for this specific denomination unit
-   **Different from base** - Can differ from the main symbol
-   **Context-specific** - Used in appropriate contexts (micro, milli, etc.)

#### Default Display

-   **Primary unit** - Which unit is shown by default in interfaces
-   **Only one default** - Only one unit can be marked as default display. If none are marked as default, the base level with 0 decimals is shown by default.
-   **User experience** - Determines what users see first

### Allow Override With Any Valid Token

-   **Dynamic badge ID handling** - When `true`, allows the wrapper to accept any SINGLE valid badge ID from the collection's `validBadgeIds` range
-   **Override conversion balances** - Temporarily overrides the `balances` field's badge ID ranges with the actual token ID being transferred
-   **Validation required** - The transferred token ID must be within the collection's valid badge ID range
-   **Use case** - Useful when you want a single wrapper path to handle multiple badge IDs dynamically

#### Example with {id} Placeholder

```json
{
    "denom": "utoken{id}",
    "symbol": "TOKEN:{id}",
    "balances": [
        {
            "amount": "1",
            "badgeIds": [{ "start": "1", "end": "1" }],
            "ownershipTimes": [{ "start": "1", "end": "18446744073709551615" }]
        }
    ],
    "denomUnits": [
        {
            "decimals": "6",
            "symbol": "TOKEN",
            "isDefaultDisplay": true
        }
    ],
    "allowOverrideWithAnyValidToken": true
}
```

When transferring badge ID 5, the final denomination becomes `utoken5`.

### Allow Override With Any Valid Token

This feature provides flexibility in handling different badge IDs within a single wrapper path.

#### How It Works

1. **Validation Check** - Verifies the transferred token ID is within the collection's `validBadgeIds` range
2. **Dynamic Override** - Temporarily replaces the wrapper's badge ID ranges with the actual token ID being transferred
3. **Conversion** - Uses the overridden badge ID for the conversion calculation

#### Example with Override Enabled

```json
{
    "denom": "utoken",
    "symbol": "TOKEN",
    "balances": [
        {
            "amount": "1",
            "badgeIds": [{ "start": "1", "end": "1" }], // These technically don't matter since we can override the badge IDs during conversion
            "ownershipTimes": [{ "start": "1", "end": "18446744073709551615" }]
        }
    ],
    "denomUnits": [
        {
            "decimals": "6",
            "symbol": "TOKEN",
            "isDefaultDisplay": true
        }
    ],
    "allowOverrideWithAnyValidToken": true
}
```

This wrapper can now handle any badge ID from 1-100 (assuming the collection's `validBadgeIds` includes that range), dynamically overriding the badge ID during conversion.

## Usage Examples

### Basic Wrapper Path

```json
{
    "denom": "utoken1",
    "symbol": "TOKEN1",
    "balances": [
        {
            "amount": "1",
            "badgeIds": [{ "start": "1", "end": "1" }],
            "ownershipTimes": [{ "start": "1", "end": "18446744073709551615" }]
        }
    ],
    "denomUnits": [
        {
            "decimals": "6",
            "symbol": "TOKEN1",
            "isDefaultDisplay": true
        }
    ],
    "allowOverrideWithAnyValidToken": false
}
```

### Multi-Unit Display System

```json
{
    "denom": "utoken",
    "symbol": "TOKEN",
    "balances": [
        {
            "amount": "1",
            "badgeIds": [{ "start": "1", "end": "100" }],
            "ownershipTimes": [{ "start": "1", "end": "18446744073709551615" }]
        }
    ],
    "denomUnits": [
        {
            "decimals": "3",
            "symbol": "mtoken",
            "isDefaultDisplay": false
        },
        {
            "decimals": "6",
            "symbol": "TOKEN",
            "isDefaultDisplay": true
        }
    ],
    "allowOverrideWithAnyValidToken": false
}
```

This creates a system where:

-   `utoken` is the base unit (smallest denomination)
-   `mtoken` = 1,000 `utoken` (milli-token)
-   `TOKEN` = 1,000,000 `utoken` (full token, default display)

## Use Cases

### IBC Transfers

-   **Cross-chain transfers** - Send wrapped tokens to other Cosmos chains
-   **DeFi integration** - Use wrapped tokens in Cosmos DeFi protocols
-   **Liquidity provision** - Add wrapped tokens to AMM pools

### Multi-Chain Ecosystems

-   **Ecosystem bridges** - Connect BitBadges to broader Cosmos ecosystem
-   **Shared liquidity** - Participate in cross-chain liquidity pools
-   **Governance tokens** - Use wrapped tokens in governance across chains

### Trading and Exchange

-   **DEX compatibility** - Trade on Cosmos-native decentralized exchanges
-   **Price discovery** - Enable market-driven price discovery
-   **Arbitrage opportunities** - Cross-chain arbitrage possibilities

### Featured Use Case: List on Osmosis

With BitBadges' existing relayer infrastructure and IBC-compatible wrapped denominations, listing wrapped tokens on Osmosis is streamlined:

-   **IBC Relayer Ready** - BitBadges already has relayer infrastructure set up for seamless cross-chain transfers
-   **Native IBC Compatibility** - Wrapped tokens become native SDK coins that work seamlessly with IBC protocols
-   **Automatic Liquidity** - Create liquidity pools on Osmosis DEX with wrapped token assets
-   **Streamlined Process** - The technical infrastructure eliminates common barriers to cross-chain trading
-   **Enhanced Discoverability** - Tokens gain exposure to the broader Cosmos DeFi ecosystem

## Conversion Process

### Token to Coin (Wrapping)

1. User transfers tokens to the wrapper address
2. System processes the denom (replaces {id} if present, validates override if enabled)
3. System burns the tokens from user's balance
4. System mints equivalent native coins
5. Coins are credited to the user's account

### Coin to Token (Unwrapping)

1. User transfers coins to the wrapper address
2. System processes the denom (replaces {id} if present, validates override if enabled)
3. System burns the native coins
4. System mints equivalent tokens
5. Tokens are credited to the user's balance

Cosmos Wrapper Paths provide seamless interoperability between BitBadges and the broader Cosmos ecosystem while maintaining the unique properties of both token and coin systems.


## File: ./x-badges/concepts/custom-data.md

# Custom Data

Custom data fields are generic string fields that allow you to store any arbitrary value within BitBadges structures. These fields provide flexibility for storing application-specific information. They are not used for any specific purpose via the BitBadges site and are more for future customization and extensibility.

## Overview

Custom data fields appear throughout BitBadges as generic string storage:

-   **`customData`** - Simple string field in various structures
-   **`customDataTimeline`** - Timeline-based custom data that can change over time
-   **Custom fields in messages** - Additional data in transaction messages

## Usage

### Simple Custom Data

```json
{
    "customData": "Any string value you want to store"
}
```

### Timeline-Based Custom Data

```json
"customDataTimeline": [
  {
    "timelineTimes": [{"start": "1", "end": "18446744073709551615"}],
    "customData": "Application-specific data that changes over time"
  }
]
```

## Where You'll Find Custom Data

Custom data fields appear in:

-   **Collections** - `customDataTimeline` for collection-level data
-   **Address Lists** - `customData` for list-specific information
-   **Token Metadata** - `customData` within token metadata structures
-   **Messages** - Various transaction messages include custom data fields


## File: ./x-badges/concepts/default-balances.md

# Default Balances

Default balances are predefined balance stores that are automatically assigned to new users (uninitialized balance stores) when they first interact with a collection. These defaults are set during collection creation and cannot be updated after genesis.

## Structure

Default balances follow the same `UserBalanceStore` structure:

```json
{
    "defaultBalances": {
        "balances": [],
        "outgoingApprovals": [],
        "incomingApprovals": [],
        "autoApproveSelfInitiatedOutgoingTransfers": false,
        "autoApproveSelfInitiatedIncomingTransfers": true,
        "userPermissions": {
            // User permission configuration
        }
    }
}
```

## Important Limitations

### No Complex Approval Criteria

Default balances **cannot** include:

-   **Approval criteria** with complex conditions (merkle challenges, ETH signature challenges, dynamic store challenges, etc.)
-   **Coin transfers** or native token requirements
-   **Token ownership** requirements or other side effects
-   **Advanced conditional logic**

Default balances are limited to basic approval structures without complex criteria.

## Related Concepts

-   **[Balance System](balance-system.md)** - How user balances work and inherit from defaults
-   **[Transferability & Approvals](transferability-approvals.md)** - User-level approval system
-   **[Permissions](permissions/)** - User permissions for updating their own approvals
-   **[Manager](manager.md)** - Collection-level controls that can override user defaults

Default balances provide a powerful way to establish baseline behavior for all users while maintaining the flexibility for users to customize their own approval settings after initialization.


## File: ./x-badges/concepts/manager.md

# Manager

The manager is the central authority for a collection, controlling all administrative operations and having exclusive rights to perform updates, deletions, and other management tasks.

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

## Manager Timeline

### Structure

```json
"managerTimeline": [
  {
    "timelineTimes": [{"start": "1", "end": "18446744073709551615"}],
    "manager": "bb1alice..."
  }
]
```

### Time-Based Manager Changes

Managers can be scheduled to change automatically:

```json
"managerTimeline": [
  {
    "timelineTimes": [{"start": "1", "end": "1672531199000"}],
    "manager": "bb1alice..."
  },
  {
    "timelineTimes": [{"start": "1672531200000", "end": "18446744073709551615"}],
    "manager": "bb1bob..."
  }
]
```

This transfers management from Alice to Bob on January 1, 2023.

## Manager Permissions

The manager role can be granted various permissions, allowing for flexible administration of the collection. These permissions include:

### Core Administrative Permissions

1. **Collection Deletion** - The ability to permanently remove the collection from the system
2. **Collection Archiving** - Archive a collection, making it read-only and rejecting all transactions until unarchived
3. **Core Collection Updates** - Modifying essential details such as metadata URLs and collection standards
4. **Manager Role Transfer** - The ability to pass the manager role to another address
5. **Token Creation** - Permission to mint additional tokens within the collection
6. **Custom Permissions** - Collection-specific permissions depending on setup

### Metadata Management

* **Collection Metadata Updates** - Modify collection-level metadata and URIs
* **Token Metadata Updates** - Update individual token metadata (with token-specific permissions)
* **Timeline Management** - Schedule metadata changes over time

### Transferability Control

* **Approval Settings** - Modify the collection's approval settings that determine how tokens can be transferred
* **Transfer Rules** - Update transferability conditions and restrictions
* **Permission Updates** - Configure transferability permissions

### Off-Chain Management

* **Off-chain Balance Management** - For collections using off-chain balance storage, managers can update these balances
* **External Integrations** - Manager role can extend to off-chain functionalities and custom utilities

### User-Level Operation Limits

The manager cannot directly:

* Modify user balances (must follow approval system)
* Access user private keys or personal data

## Fine-Grained Permission Customizability

One of the key features of the manager role in BitBadges is the ability to customize permissions at a granular level. This allows for precise control over the collection's management.

Permissions can be customized based on various factors:

### Permission Dimensions

* **Token Specificity** - Which particular tokens within the collection can be affected
* **Time Constraints** - When can certain actions be performed
* **Value Limitations** - What specific values or ranges are allowed for updates
* **Conditional Triggers** - Under what circumstances can certain permissions be exercised

### Permission States

Each permission can exist in one of three states:

1. **Forbidden + Permanently Frozen**
   * The permission is permanently disallowed
   * This state cannot be changed, ensuring certain actions remain off-limits indefinitely
2. **Permitted + Not Frozen**
   * The permission is currently allowed
   * This state can be changed to either of the other two states, offering flexibility in management
3. **Permitted + Permanently Frozen**
   * The permission is permanently allowed
   * Like the first state, this cannot be changed, ensuring certain capabilities always remain available

**Note**: There is no "Forbidden + Not Frozen" state because such a state could theoretically be updated to "Permitted" at any time and then immediately executed, effectively making it a "Permitted" state.

## Permission Control Examples

### Manager Updates

Manager updates are controlled by the `canUpdateManager` permission:

```json
"canUpdateManager": [
  {
    "timelineTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyPermittedTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyForbiddenTimes": []
  }
]
```

## Usage Examples

### Setting Initial Manager

During collection creation:

```json
{
    "creator": "bb1alice...",
    "managerTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "manager": "bb1alice..."
        }
    ],
    "collectionPermissions": {
        "canUpdateManager": [
            {
                "permanentlyPermittedTimes": [
                    { "start": "1", "end": "18446744073709551615" }
                ],
                "permanentlyForbiddenTimes": []
            }
        ]
    }
}
```

### Decentralized Management Transition

```json
{
    "managerTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "1672531199000" }],
            "manager": "bb1alice..."
        },
        {
            "timelineTimes": [
                { "start": "1672531200000", "end": "18446744073709551615" }
            ],
            "manager": "bb1qqqq...."
        }
    ],
    "collectionPermissions": {
        "canUpdateManager": [
            {
                "permanentlyPermittedTimes": [],
                "permanentlyForbiddenTimes": [
                    { "start": "1672531200000", "end": "18446744073709551615" }
                ]
            }
        ]
    }
}
```

This transitions to a burn address manager and locks management permanently, creating a decentralized collection.


## File: ./x-badges/concepts/metadata.md

# Metadata

BitBadges allows defining metadata for both collections and individual tokens using timeline-based metadata fields. This enables rich, dynamic content that can change over time while maintaining on-chain verifiability.

## Metadata Timelines

### Collection Metadata Timeline

The `collectionMetadataTimeline` defines metadata for the entire collection over time.

```json
"collectionMetadataTimeline": [
  {
    "timelineTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "collectionMetadata": {
      "uri": "ipfs://Qmf8xxN2fwXGgouue3qsJtN8ZRSsnoHxM9mGcynTPhh6Ub",
      "customData": ""
    }
  }
]
```

### Token Metadata Timeline

The `badgeMetadataTimeline` defines metadata for individual tokens over time. The order of `badgeMetadata` entries matters, as it uses a **first-match approach** via linear scan for specific token IDs. BitBadges uses the `{id}` placeholder in the token metadata URI to replace with the actual token ID.

```json
"badgeMetadataTimeline": [
  {
    "timelineTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "badgeMetadata": [
      {
        "uri": "ipfs://Qmf8xxN2fwXGgouue3qsJtN8ZRSsnoHxM9mGcynTPhh6Ub/{id}",
        "badgeIds": [
          {
            "start": "1",
            "end": "10000000000000"
          }
        ],
        "customData": ""
      }
    ]
  }
]
```

## Metadata Interface

The BitBadges API, Indexer, and Site expect metadata to follow this format by default:

```typescript
export interface Metadata<T extends NumberType> {
    name: string;
    description: string;
    image: string;
    video?: string;
    category?: string;
    externalUrl?: string;
    tags?: string[];
    socials?: {
        [key: string]: string;
    };
}
```

## Key Features

### Dynamic Token ID Replacement

-   If the token metadata URI includes `"{id}"`, it's replaced with the actual token ID
-   Example: `"...abc.com/metadata/{id}"` becomes `"...abc.com/metadata/1"` for token ID 1
-   Enables efficient metadata generation for large collections

### First-Match Token Metadata

-   Token metadata entries are evaluated in order
-   First matching entry for a token ID is used
-   Allows specific overrides before general rules

## Permission Control

Metadata updates are controlled by collection permissions:

### Collection Metadata Permission

```json
"canUpdateCollectionMetadata": [
  {
    "timelineTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyPermittedTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyForbiddenTimes": []
  }
]
```

### Token Metadata Permission

```json
"canUpdateBadgeMetadata": [
  {
    "badgeIds": [{"start": "1", "end": "100"}],
    "timelineTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyPermittedTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyForbiddenTimes": []
  }
]
```

### Timeline Times vs Permission Times Within Permissions

As explained in [Permissions](permissions/), the `timelineTimes` field is used to define the timeline times that can be updated or not. The `permanentlyPermittedTimes` and `permanentlyForbiddenTimes` fields are used to define the times when the permission is enabled or disabled.


## File: ./x-badges/concepts/mint-escrow-address.md

# Mint Escrow Address

The Mint Escrow Address (_mintEscrowAddress_) is a special reserved address generated from the collection ID that holds Cosmos native funds on behalf of the "Mint" address for a specific collection. This address has no known private key and is not controlled by anyone. The only way to get funds out is via collection approvals from the Mint address.

See the [coin transfers](../approval-criteria/usdbadge-transfers.md) section for more details.

## Functionality

### Cosmos Native Fund Storage

The Mint Escrow Address can hold Cosmos native tokens (like "ubadge" tokens) that are associated with the Mint address for a specific collection.

See the coinTransfers section for more details. This is the only way to get funds out of the Mint Escrow Address.

## Auto-Escrow During Collection Creation

The `MsgCreateCollection` interface includes a `mintEscrowCoinsToTransfer` field of type `repeated cosmos.base.v1beta1.Coin` that allows you to automatically escrow native coins to the Mint Escrow Address during collection creation.

### Pre-Creation Escrow

-   **Unknown collection ID** - Escrow coins before knowing the final collection ID
-   **Automatic transfer** - Coins are automatically transferred to the generated Mint Escrow Address
-   **Collection initialization** - Funds are available immediately when the collection is created
-   **Single transaction** - Combine collection creation and coin escrow in one operation

### Usage

```json
{
    "creator": "cosmos1...",
    "collectionId": "0",
    "mintEscrowCoinsToTransfer": [
        {
            "denom": "ubadge",
            "amount": "1000000"
        }
    ]
    // ... other collection fields
}
```

This field is particularly useful when you need to fund the Mint Escrow Address but don't know the collection ID beforehand, since the escrow address is derived from the collection ID itself. Thus, it can be done all in one transaction.


## File: ./x-badges/concepts/permissions/README.md

# Permissions


## File: ./x-badges/concepts/permissions/action-permissions.md

# Action Permissions

Action permissions are the simplest type - they only control when an action can be executed based on time.

## High-Level Logic

```
For each action request:
    Check if current time is in permanentlyPermittedTimes
        → If yes: ALLOW
        → If no: Check if current time is in permanentlyForbiddenTimes
            → If yes: DENY
            → If no: ALLOW (neutral state)
```

**English**: "For these times, this action can be performed" or "For these times, this action is blocked"

## Overview

```
Action Request
    ↓
Time Check
    ↓
┌─────────────────┬─────────────────┐
│ Permitted Times │ Forbidden Times │
└─────────────────┴─────────────────┘
    ↓
Execute Action    Deny Action
```

## Interface

```typescript
interface ActionPermission {
    permanentlyPermittedTimes: UintRange[];
    permanentlyForbiddenTimes: UintRange[];
}
```

## Collection Actions

| Action                | Description              | Use Case       |
| --------------------- | ------------------------ | -------------- |
| `canDeleteCollection` | Delete entire collection | Permanent lock |

## User Actions

| Action                                               | Description                     | Use Case         |
| ---------------------------------------------------- | ------------------------------- | ---------------- |
| `canUpdateAutoApproveSelfInitiatedOutgoingTransfers` | Auto-approve outgoing transfers | User convenience |
| `canUpdateAutoApproveSelfInitiatedIncomingTransfers` | Auto-approve incoming transfers | User convenience |
| `canUpdateAutoApproveAllIncomingTransfers`           | Auto-approve all incoming       | User convenience |

## Examples

### Lock Collection Deletion Forever

```json
{
    "canDeleteCollection": [
        {
            "permanentlyPermittedTimes": [],
            "permanentlyForbiddenTimes": [
                { "start": "1", "end": "18446744073709551615" }
            ]
        }
    ]
}
```

### Allow Collection Deletion Only During Specific Period

```json
{
    "canDeleteCollection": [
        {
            "permanentlyPermittedTimes": [
                { "start": "1704067200000", "end": "1735689600000" }
            ],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Default Behavior (No Restrictions)

```json
{
    "canDeleteCollection": []
}
```


## File: ./x-badges/concepts/permissions/approval-permissions.md

# Approval Permissions

Approval permissions control when transfer approvals can be updated, allowing you to freeze specific transfer rules.

## High-Level Logic

```
For each approval update request:
    Check if approval criteria match (from, to, initiatedBy, transferTimes, badgeIds, ownershipTimes, approvalId)
        → If no match: ALLOW (neutral state)
        → If match: Check if current time is in permanentlyPermittedTimes
            → If yes: ALLOW
            → If no: Check if current time is in permanentlyForbiddenTimes
                → If yes: DENY
                → If no: ALLOW (neutral state)
```

**English**: "For these permission execution times, the approvals matching to these criteria can be updated"

## Overview

```
Approval Update
    ↓
Transfer Match
    ↓
Approval ID Match
    ↓
Time Permission Check
    ↓
Execute/Deny
```

## Interface

```typescript
interface ApprovalPermission {
    fromListId: string;
    toListId: string;
    initiatedByListId: string;
    transferTimes: UintRange[];
    badgeIds: UintRange[];
    ownershipTimes: UintRange[];
    approvalId: string;

    permanentlyPermittedTimes: UintRange[];
    permanentlyForbiddenTimes: UintRange[];
}
```

## Available Actions

| Action                         | Scope      | Description                         |
| ------------------------------ | ---------- | ----------------------------------- |
| `canUpdateCollectionApprovals` | Collection | Control collection-level approvals  |
| `canUpdateIncomingApprovals`   | User       | Control incoming transfer approvals |
| `canUpdateOutgoingApprovals`   | User       | Control outgoing transfer approvals |

**Note**: For user approvals, `fromListId` and `toListId` are automatically set:

-   **Incoming**: `toListId` is hardcoded to the user's address
-   **Outgoing**: `fromListId` is hardcoded to the user's address

## Key Concepts

### Approval Tuple

An approval tuple consists of: `(from, to, initiatedBy, badgeIds, transferTimes, ownershipTimes, approvalId)`

### Brute Force Pattern

To lock specific criteria, specify the target and set all other criteria to maximum ranges:

```json
{
    "fromListId": "All",
    "toListId": "All",
    "initiatedByListId": "All",
    "badgeIds": [{ "start": "1", "end": "10" }],
    "transferTimes": [{ "start": "1", "end": "18446744073709551615" }],
    "ownershipTimes": [{ "start": "1", "end": "18446744073709551615" }],
    "approvalId": "All",
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
        { "start": "1", "end": "18446744073709551615" }
    ]
}
```

## Examples

### Lock Specific ID Range

```json
{
    "canUpdateCollectionApprovals": [
        {
            "fromListId": "All",
            "toListId": "All",
            "initiatedByListId": "All",
            "badgeIds": [{ "start": "1", "end": "100" }],
            "transferTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "ownershipTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "approvalId": "All",
            "permanentlyPermittedTimes": [],
            "permanentlyForbiddenTimes": [
                { "start": "1", "end": "18446744073709551615" }
            ]
        }
    ]
}
```

### Lock Specific Approval ID

```json
{
    "canUpdateCollectionApprovals": [
        {
            "fromListId": "All",
            "toListId": "All",
            "initiatedByListId": "All",
            "badgeIds": [{ "start": "1", "end": "18446744073709551615" }],
            "transferTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "ownershipTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "approvalId": "specific-approval-id",
            "permanentlyPermittedTimes": [],
            "permanentlyForbiddenTimes": [
                { "start": "1", "end": "18446744073709551615" }
            ]
        }
    ]
}
```

## Protection Strategies

### 1. Specific Approval Lock

Lock a specific approval by its unique ID:

```json
"approvalId": "unique-approval-id"
```

### 2. Range Lock with Overlap Protection

Lock a token range AND all overlapping approvals:

```json
// Lock token range
{
    "badgeIds": [{ "start": "1", "end": "10" }],
    "approvalId": "All"
}

// Lock overlapping approval
{
    "approvalId": "overlapping-approval-id"
}
```

### 3. Complete Freeze

Lock all approvals for a collection:

```json
{
    "fromListId": "All",
    "toListId": "All",
    "initiatedByListId": "All",
    "badgeIds": [{ "start": "1", "end": "18446744073709551615" }],
    "transferTimes": [{ "start": "1", "end": "18446744073709551615" }],
    "ownershipTimes": [{ "start": "1", "end": "18446744073709551615" }],
    "approvalId": "All",
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
        { "start": "1", "end": "18446744073709551615" }
    ]
}
```


## File: ./x-badges/concepts/permissions/badge-id-permissions.md

# Token ID Action Permissions

Token ID action permissions control which token-specific actions can be performed based on token IDs.

## High-Level Logic

```
For each token action request:
    Check if token ID matches any badgeIds criteria
        → If no match: ALLOW (neutral state)
        → If match: Check if current time is in permanentlyPermittedTimes
            → If yes: ALLOW
            → If no: Check if current time is in permanentlyForbiddenTimes
                → If yes: DENY
                → If no: ALLOW (neutral state)
```

**English**: "For these times, these token IDs can be updated" or "For these times, these token IDs are locked"

## Overview

```
Token Action
    ↓
Token ID Match
    ↓
Time Permission Check
    ↓
Execute/Deny
```

## Interface

```typescript
interface BadgeIdsActionPermission {
    badgeIds: UintRange[];
    permanentlyPermittedTimes: UintRange[];
    permanentlyForbiddenTimes: UintRange[];
}
```

## Available Actions

| Action                   | Description            | Use Case      |
| ------------------------ | ---------------------- | ------------- |
| `canUpdateValidBadgeIds` | Update valid token IDs | Configuration |

## Examples

### Lock All Token ID Updates

```json
{
    "canUpdateValidBadgeIds": [
        {
            "badgeIds": [{ "start": "1", "end": "18446744073709551615" }],
            "permanentlyPermittedTimes": [],
            "permanentlyForbiddenTimes": [
                { "start": "1", "end": "18446744073709551615" }
            ]
        }
    ]
}
```

### Lock Specific ID Range

```json
{
    "canUpdateValidBadgeIds": [
        {
            "badgeIds": [{ "start": "1", "end": "100" }],
            "permanentlyPermittedTimes": [],
            "permanentlyForbiddenTimes": [
                { "start": "1", "end": "18446744073709551615" }
            ]
        }
    ]
}
```

### Allow Future Token IDs Only

```json
{
    "canUpdateValidBadgeIds": [
        {
            "badgeIds": [{ "start": "101", "end": "18446744073709551615" }],
            "permanentlyPermittedTimes": [
                { "start": "1", "end": "18446744073709551615" }
            ],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```


## File: ./x-badges/concepts/permissions/overview.md

# Overview

Permissions control who can perform actions on collections and user balances, and when those actions can be executed.

Typically, user permissions are always set to allowed / empty. In advanced cases like escrows, user permissions can be set to forbidden to make certain on-chain actions impossible.

Collection permissions are important to be set correctly: If there is no manager, the collection permission values do not matter.

## Overview

```
Action Request
    ↓
Permission Check
    ↓
┌─────────────────┬─────────────────┐
│ Collection      │ User            │
│ Permissions     │ Permissions     │
│ (Manager Only)  │ (User Control)  │
└─────────────────┴─────────────────┘
    ↓
Permitted/Forbidden
    ↓
Execute/Deny
```

## Permission Types

| Type           | Scope            | Purpose                          |
| -------------- | ---------------- | -------------------------------- |
| **Collection** | Manager only     | Control collection-level actions |
| **User**       | Individual users | Control user-specific actions    |

## Permission States

**Note**: Once a permission is set to permanently permitted or forbidden, it cannot be changed.

| State                     | Description           | Behavior               |
| ------------------------- | --------------------- | ---------------------- |
| **Permanently Permitted** | Action ALWAYS allowed | Can be executed        |
| **Permanently Forbidden** | Action ALWAYS blocked | Cannot be executed     |
| **Neutral**               | Not specified         | **Allowed by default** |

There is no forbidden + not frozen state because theoretically, it could be updated to permitted at any time and executed (thus making it permitted).

## Time Control

All permissions support time-based control via UNIX millisecond UintRanges.

```json
{
    "permanentlyPermittedTimes": [{ "start": "1", "end": "1000" }],
    "permanentlyForbiddenTimes": [
        { "start": "1001", "end": "18446744073709551615" }
    ]
}
```

## Permission Categories

There are **five types** of permissions, each with different criteria:

-   **[Action Permissions](action-permissions.md)** - Simple time-based permissions (no criteria)
-   **[Timeline Permissions](timeline-permissions.md)** - Control timeline updates (timelineTimes)
-   **[Timeline with Token IDs](timeline-permissions.md)** - Control token-specific timeline updates (timelineTimes + badgeIds)
-   **[Token ID Action Permissions](badge-id-permissions.md)** - Control token-specific actions (badgeIds)
-   **[Approval Permissions](approval-permissions.md)** - Control approval updates (transfer criteria + approvalId)

### Correct Categorization

Based on the proto definitions:

**Action Permissions** (only time control):

-   `canDeleteCollection` (collection)
-   `canUpdateAutoApproveSelfInitiatedOutgoingTransfers` (user)
-   `canUpdateAutoApproveSelfInitiatedIncomingTransfers` (user)
-   `canUpdateAutoApproveAllIncomingTransfers` (user)

**Timeline Permissions** (timelineTimes + time control):

-   `canArchiveCollection`
-   `canUpdateStandards`
-   `canUpdateCustomData`
-   `canUpdateManager`
-   `canUpdateCollectionMetadata`

**Timeline with Token IDs** (timelineTimes + badgeIds + time control):

-   `canUpdateBadgeMetadata`

**Token ID Action Permissions** (badgeIds + time control):

-   `canUpdateValidBadgeIds`

**Approval Permissions** (transfer criteria + approvalId + time control):

-   `canUpdateCollectionApprovals` (collection)
-   `canUpdateIncomingApprovals` (user)
-   `canUpdateOutgoingApprovals` (user)

## Quick Examples

### Lock Collection Deletion

When can the collection be deleted?

```json
{
    "canDeleteCollection": [
        {
            "permanentlyPermittedTimes": [],
            "permanentlyForbiddenTimes": [
                { "start": "1", "end": "18446744073709551615" }
            ]
        }
    ]
}
```

### Freeze Token Metadata

When can the token metadata be updated? And which (token IDs, timeline time) pairs does it apply to?

```json
{
    "canUpdateBadgeMetadata": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "badgeIds": [{ "start": "1", "end": "100" }],

            "permanentlyPermittedTimes": [],
            "permanentlyForbiddenTimes": [
                { "start": "1", "end": "18446744073709551615" }
            ]
        }
    ]
}
```

## First Match Policy

Permissions are evaluated as a linear array where each element has criteria and time controls. Only the **first matching element** is applied - all subsequent matches are ignored.

### Key Rules

-   **First Match Only**: Only the first element that matches all criteria is used
-   **Deterministic State**: Each criteria combination has exactly one permission state
-   **No Overlap**: Times cannot be in both `permanentlyPermittedTimes` and `permanentlyForbiddenTimes`
-   **Order Matters**: Array order affects which permissions are applied

### Example: Timeline Permissions

```json
"canUpdateCollectionMetadata": [
    {
        "timelineTimes": [{ "start": "1", "end": "10" }],
        "permanentlyPermittedTimes": [],
        "permanentlyForbiddenTimes": [{ "start": "1", "end": "10" }]
    },
    {
        "timelineTimes": [{ "start": "1", "end": "100" }],
        "permanentlyPermittedTimes": [{ "start": "1", "end": "18446744073709551615" }],
        "permanentlyForbiddenTimes": []
    }
]
```

**Result:**

-   Timeline times 1-10: **Forbidden** (first element matches, second element does not)
-   Timeline times 11-100: **Permitted** (second element matches)

## Satisfying Criteria

All criteria in a permission element must match for it to be applied. Partial matches are ignored.

### Example: Token Metadata Permissions

```json
"canUpdateBadgeMetadata": [
    {
        "timelineTimes": [{ "start": "1", "end": "10" }],
        "badgeIds": [{ "start": "1", "end": "10" }],
        "permanentlyPermittedTimes": [{ "start": "1", "end": "18446744073709551615" }],
        "permanentlyForbiddenTimes": []
    }
]
```

**This permission only covers:**

-   Timeline times 1-10 AND token IDs 1-10

**It does NOT cover:**

-   Timeline time 1 with token ID 11
-   Timeline time 11 with token ID 1
-   Timeline time 11 with token ID 11

These combinations are **unhandled** and **allowed by default** since they do not match the permission criteria.

## Brute Force Pattern

To lock specific criteria, you must specify the target and set all other criteria to maximum ranges.

### Example: Lock Token IDs 1-10

```json
{
    "fromListId": "All",
    "toListId": "All",
    "initiatedByListId": "All",
    "badgeIds": [{ "start": "1", "end": "10" }],
    "transferTimes": [{ "start": "1", "end": "18446744073709551615" }],
    "ownershipTimes": [{ "start": "1", "end": "18446744073709551615" }],
    "approvalId": "All",
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
        { "start": "1", "end": "18446744073709551615" }
    ]
}
```

## Important Notes

-   **First Match Policy**: Only the first matching permission is applied
-   **Default Allow**: Unspecified permissions are allowed by default
-   **Manager Required**: Collection permissions require a manager
-   **User Control**: User permissions typically remain empty for full control
-   **Brute Force**: Use maximum ranges to ensure complete coverage
-   **Order Matters**: Array order affects permission evaluation


## File: ./x-badges/concepts/permissions/timeline-permissions.md

# Timeline Permissions

Timeline permissions control when timeline-based fields can be updated, such as collection metadata and token metadata.

## High-Level Logic

### Basic Timeline Permissions

```
For each timeline update request:
    Check if timeline time matches any timelineTimes criteria
        → If no match: ALLOW (neutral state)
        → If match: Check if current time is in permanentlyPermittedTimes
            → If yes: ALLOW
            → If no: Check if current time is in permanentlyForbiddenTimes
                → If yes: DENY
                → If no: ALLOW (neutral state)
```

### Token-Specific Timeline Permissions

```
For each token timeline update request:
    Check if timeline time AND token ID match criteria
        → If no match: ALLOW (neutral state)
        → If match: Check if current time is in permanentlyPermittedTimes
            → If yes: ALLOW
            → If no: Check if current time is in permanentlyForbiddenTimes
                → If yes: DENY
                → If no: ALLOW (neutral state)
```

**English**:

-   **Basic**: "For these permission execution times, the (timelineTime -> timelineValue) pairs can be updated"
-   **Token-Specific**: "For these permission execution times, the (badgeId, timelineTime -> timelineValue) pairs can be updated"

## Timeline vs Execution Times

-   **Timeline Times**: Which timeline values can be updated?
-   **Execution Times**: When the permission can be executed?

These may not align. For example, you might forbid updating timeline values for Jan 2024 during 2023.

## Overview

```
Timeline Update
    ↓
Timeline Time Match
    ↓
Time Permission Check
    ↓
Execute/Deny
```

## Types

### Basic Timeline Permissions

Control collection-level timeline updates:

```typescript
interface TimedUpdatePermission {
    timelineTimes: UintRange[];
    permanentlyPermittedTimes: UintRange[];
    permanentlyForbiddenTimes: UintRange[];
}
```

**Available Actions:**

-   `canArchiveCollection`
-   `canUpdateStandards`
-   `canUpdateCustomData`
-   `canUpdateManager`
-   `canUpdateCollectionMetadata`

### Token-Specific Timeline Permissions

Control token metadata timeline updates:

```typescript
interface TimedUpdateWithBadgeIdsPermission {
    timelineTimes: UintRange[];
    badgeIds: UintRange[];
    permanentlyPermittedTimes: UintRange[];
    permanentlyForbiddenTimes: UintRange[];
}
```

**Available Actions:**

-   `canUpdateBadgeMetadata`

## Examples

### Lock Collection Metadata Forever

```json
{
    "canUpdateCollectionMetadata": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "permanentlyPermittedTimes": [],
            "permanentlyForbiddenTimes": [
                { "start": "1", "end": "18446744073709551615" }
            ]
        }
    ]
}
```

### Lock Specific Timeline Period

```json
{
    "canUpdateCollectionMetadata": [
        {
            "timelineTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyPermittedTimes": [],
            "permanentlyForbiddenTimes": [
                { "start": "1", "end": "18446744073709551615" }
            ]
        }
    ]
}
```

### Lock Token Metadata for Existing Tokens

```json
{
    "canUpdateBadgeMetadata": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "badgeIds": [{ "start": "1", "end": "100" }],
            "permanentlyPermittedTimes": [],
            "permanentlyForbiddenTimes": [
                { "start": "1", "end": "18446744073709551615" }
            ]
        }
    ]
}
```

### Allow Updates Only During Specific Period

```json
{
    "canUpdateCollectionMetadata": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "permanentlyPermittedTimes": [
                { "start": "1704067200000", "end": "1735689600000" }
            ],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```


## File: ./x-badges/concepts/protocols/README.md

# Protocols

This directory contains documentation for standardized protocols that can be implemented using BitBadges collections. These protocols define specific patterns and requirements for creating interoperable collections with well-defined behaviors.

## Available Protocols

-   **[Subscriptions Protocol](./subscriptions-protocol.md)** - Implementation pattern for subscription-based collections with recurring payments and time-based ownership
-   **[Quest Protocol](./quest-protocol.md)** - Implementation pattern for quest-based collections with cryptographic proof verification and coin rewards
-   **[Tradable Protocol](./tradable-protocol.md)** - Implementation pattern for orderbook-style trading of tokens with bids and listings

## Protocol Overview

Protocols in BitBadges are standardized implementations that:

-   Define specific collection configuration patterns
-   Establish validation rules for protocol compliance
-   Enable interoperability between different applications
-   Provide predictable behavior for users and developers


## File: ./x-badges/concepts/protocols/quest-protocol.md

# Quest Protocol

The Quest Protocol is a standardized way to create quest-based collections that reward users with tokens and coins for completing cryptographically verified tasks. Quest collections are designed for achievement-based systems where users complete quests (tasks) and provide cryptographic proofs (Merkle proofs) to claim tokens along with coin incentives.

## Protocol Requirements

### Collection Standards

-   Must include "Quests" in the `standardsTimeline` for the current time period
-   Must have exactly one valid token ID: `{"start": "1", "end": "1"}`

### Quest Approval Requirements

-   **From List**: Must be "Mint" (minting from the mint address)
-   **Merkle Challenge**: Must have exactly one Merkle challenge with:
    -   `maxUsesPerLeaf`: 1 (one use per proof)
    -   `useCreatorAddressAsLeaf`: false (custom proof verification)
    -   Valid Merkle root hash for proof verification
-   **Coin Transfers**: Must have exactly one coin transfer with:
    -   Exactly one coin denomination and amount
    -   `overrideFromWithApproverAddress`: true (coins come from collection creator)
    -   `overrideToWithInitiator`: true (coins go to the quest completer)
-   **Max Transfers**: Must have `overallMaxNumTransfers` > 0
-   **Predetermined Balances**: Must have:
    -   Exactly one `startBalance` with amount 1 for token ID 1
    -   `incrementBadgeIdsBy`: 0 (no token ID incrementing)
    -   `incrementOwnershipTimesBy`: 0 (no time incrementing)
    -   `durationFromTimestamp`: 0 (no time-based duration)
    -   `allowOverrideTimestamp`: false (no timestamp overrides)
    -   All `recurringOwnershipTimes` fields set to 0 (no recurring)
-   **Additional Constraints**:
    -   `mustOwnBadges`: empty (no prerequisite tokens)
    -   `requireToEqualsInitiatedBy`: false (no address matching required)

## Validation Functions

### Collection Validation

**API Documentation:** [doesCollectionFollowQuestProtocol](https://bitbadges.github.io/bitbadgesjs/functions/doesCollectionFollowQuestProtocol.html)

```typescript
export const doesCollectionFollowQuestProtocol = (
    collection?: Readonly<iCollectionDoc<bigint>>
) => {
    if (!collection) {
        return false;
    }

    // Check if "Quests" standard is active for current time
    let found = false;
    for (const standard of collection.standardsTimeline) {
        const isCurrentTime = UintRangeArray.From(
            standard.timelineTimes
        ).searchIfExists(BigInt(Date.now()));
        if (!isCurrentTime) {
            continue;
        }

        if (!standard.standards.includes('Quests')) {
            continue;
        }

        found = true;
    }

    if (!found) {
        return false;
    }

    // Assert valid token IDs are only 1n-1n
    const badgeIds = UintRangeArray.From(collection.validBadgeIds)
        .sortAndMerge()
        .convert(BigInt);
    if (badgeIds.length !== 1 || badgeIds.size() !== 1n) {
        return false;
    }

    if (badgeIds[0].start !== 1n || badgeIds[0].end !== 1n) {
        return false;
    }

    return true;
};
```

### Approval Validation

**API Documentation:** [isQuestApproval](https://bitbadges.github.io/bitbadgesjs/functions/isQuestApproval.html)

```typescript
export const isQuestApproval = (approval: iCollectionApproval<bigint>) => {
    const approvalCriteria = approval.approvalCriteria;
    if (!approvalCriteria?.coinTransfers) {
        return false;
    }

    // Must be minting approval
    if (approval.fromListId !== 'Mint') {
        return false;
    }

    // Must have exactly one Merkle challenge
    if (
        !approvalCriteria.merkleChallenges ||
        approvalCriteria.merkleChallenges.length !== 1
    ) {
        return false;
    }

    let merkleChallenge = approvalCriteria.merkleChallenges?.[0];
    if (merkleChallenge.maxUsesPerLeaf !== 1n) {
        return false;
    }

    // Must not require owning other tokens
    if (approvalCriteria.mustOwnBadges?.length) {
        return false;
    }

    // Must not use creator address as leaf
    if (merkleChallenge.useCreatorAddressAsLeaf) {
        return false;
    }

    // Must have max transfer limit
    const maxNumTransfers =
        approvalCriteria.maxNumTransfers?.overallMaxNumTransfers;
    if (!maxNumTransfers) {
        return false;
    }

    if (maxNumTransfers <= 0n) {
        return false;
    }

    // Must have exactly one coin transfer
    if (approvalCriteria.coinTransfers.length !== 1) {
        return false;
    }

    // Validate coin transfer configuration
    for (const coinTransfer of approvalCriteria.coinTransfers) {
        if (coinTransfer.coins.length !== 1) {
            return false;
        }

        if (
            !coinTransfer.overrideFromWithApproverAddress ||
            !coinTransfer.overrideToWithInitiator
        ) {
            return false;
        }
    }

    // Validate predetermined balances
    const incrementedBalances =
        approvalCriteria.predeterminedBalances?.incrementedBalances;
    if (!incrementedBalances) {
        return false;
    }

    if (incrementedBalances.startBalances.length !== 1) {
        return false;
    }

    const allBadgeIds = UintRangeArray.From(
        incrementedBalances.startBalances[0].badgeIds
    )
        .sortAndMerge()
        .convert(BigInt);
    if (allBadgeIds.length !== 1 || allBadgeIds.size() !== 1n) {
        return false;
    }

    if (allBadgeIds[0].start !== 1n || allBadgeIds[0].end !== 1n) {
        return false;
    }

    const amount = incrementedBalances.startBalances[0].amount;
    if (amount !== 1n) {
        return false;
    }

    if (incrementedBalances.incrementBadgeIdsBy !== 0n) {
        return false;
    }

    if (incrementedBalances.incrementOwnershipTimesBy !== 0n) {
        return false;
    }

    if (incrementedBalances.durationFromTimestamp !== 0n) {
        return false;
    }

    // Needs this to be false for the subscription faucet to work
    if (incrementedBalances.allowOverrideTimestamp) {
        return false;
    }

    if (incrementedBalances.recurringOwnershipTimes.startTime !== 0n) {
        return false;
    }

    if (incrementedBalances.recurringOwnershipTimes.intervalLength !== 0n) {
        return false;
    }

    if (incrementedBalances.recurringOwnershipTimes.chargePeriodLength !== 0n) {
        return false;
    }

    if (approvalCriteria.requireToEqualsInitiatedBy) {
        return false;
    }

    return true;
};
```

## Implementation Example

For a complete implementation example, see the [Quest Token Collection Example](../../examples/txs/msgcreatecollection/quest-badge-collection.md).


## File: ./x-badges/concepts/protocols/subscriptions-protocol.md

# Subscriptions Protocol

The Subscriptions Protocol enables collections to implement subscription-based token ownership with recurring payments, time-limited access, and a tipping system for automatic renewal. This protocol standardizes how subscription tokens are created, distributed, and renewed.

## Protocol Overview

Subscription collections allow users to pay a recurring fee + tip to maintain ownership of tokens for specific time periods. The protocol ensures predictable behavior for subscription management across different applications.

## Protocol Requirements

### Standards Declaration

Collections must include "Subscriptions" in their standards timeline:

```json
{
    "standardsTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "standards": ["Subscriptions"]
        }
    ]
}
```

### Token ID Configuration

-   **Single Token ID**: Only one token ID range (1-1) is permitted
-   **Valid Token IDs**: Must match exactly with subscription approval token IDs

### Collection Approvals

Must contain at least one subscription faucet approval with the following characteristics:

#### From Address

-   **fromListId**: Must be "Mint" (minting operation)

#### Approval Criteria Requirements

##### Coin Transfers

-   **Required**: At least one coin transfer specification
-   **Single Denom**: All coin transfers must use the same denomination
-   **No Address Override**: `overrideFromWithApproverAddress` and `overrideToWithInitiator` must be false

##### Predetermined Balances

Must use `incrementedBalances` with specific configuration:

```json
{
    "predeterminedBalances": {
        "incrementedBalances": {
            "startBalances": [
                {
                    "amount": "1",
                    "badgeIds": [{ "start": "1", "end": "1" }],
                    "ownershipTimes": [{ "start": "0", "end": "0" }]
                }
            ],
            "incrementBadgeIdsBy": "0",
            "incrementOwnershipTimesBy": "0",
            "durationFromTimestamp": "2592000000", // 30 days in milliseconds
            "allowOverrideTimestamp": true,
            "recurringOwnershipTimes": {
                "startTime": "0",
                "intervalLength": "0",
                "chargePeriodLength": "0"
            }
        }
    }
}
```

**Key Requirements:**

-   **Amount**: Must be exactly 1
-   **Token IDs**: Single token ID (1-1)
-   **Duration**: Must be greater than 0 (subscription period length)
-   **Override Timestamp**: Must be true for faucet functionality
-   **No Increments**: Token ID and ownership time increments must be 0
-   **No Recurring**: Recurring ownership times must be all 0

##### Restrictions

-   **No Merkle Challenges**: Cannot include merkle challenges
-   **No Token Requirements**: Cannot include mustOwnBadges requirements
-   **No Address Restrictions**: Cannot require from/to equals initiated by
-   **No Override Approvals**: Cannot override incoming approvals

## User Subscription Management

Users manage their subscriptions through incoming approvals that complement the collection's faucet approval:

### User Incoming Approval Requirements

#### Basic Configuration

-   **fromListId**: Must be "Mint"
-   **Token IDs**: Must match subscription approval token IDs exactly
-   **Single Token**: Only one token ID range permitted

#### Coin Transfer Configuration

```json
{
    "coinTransfers": [
        {
            "coins": [
                {
                    "denom": "ubadge", // Must match subscription denom
                    "amount": "100000" // Must be >= subscription amount
                }
            ],
            "overrideFromWithApproverAddress": true,
            "overrideToWithInitiator": true
        }
    ]
}
```

#### Predetermined Balances for Renewals

```json
{
    "predeterminedBalances": {
        "incrementedBalances": {
            "startBalances": [
                {
                    "amount": "1",
                    "badgeIds": [{ "start": "1", "end": "1" }]
                }
            ],
            "incrementBadgeIdsBy": "0",
            "incrementOwnershipTimesBy": "0",
            "durationFromTimestamp": "0",
            "allowOverrideTimestamp": false,
            "recurringOwnershipTimes": {
                "startTime": "1672531200000", // Current subscription start
                "intervalLength": "2592000000", // 30 days
                "chargePeriodLength": "604800000" // 7 days max charge period
            }
        }
    }
}
```

#### Transfer Limits

```json
{
    "maxNumTransfers": {
        "overallMaxNumTransfers": "1",
        "resetTimeIntervals": {
            "startTime": "1672531200000",
            "intervalLength": "2592000000" // Same as subscription interval
        }
    }
}
```

## Protocol Validation Logic

### Collection Validation

**API Documentation:** [doesCollectionFollowSubscriptionProtocol](https://bitbadges.github.io/bitbadgesjs/functions/doesCollectionFollowSubscriptionProtocol.html)

```typescript
function doesCollectionFollowSubscriptionProtocol(collection) {
    // Check for "Subscriptions" standard
    const hasSubscriptionStandard = collection.standardsTimeline.some(
        (standard) =>
            standard.standards.includes('Subscriptions') &&
            isCurrentTime(standard.timelineTimes)
    );

    if (!hasSubscriptionStandard) return false;

    // Find subscription faucet approvals
    const subscriptionApprovals = collection.collectionApprovals.filter(
        (approval) => isSubscriptionFaucetApproval(approval)
    );

    if (subscriptionApprovals.length < 1) return false;

    // Validate single token ID requirement
    if (collection.validBadgeIds.length !== 1) return false;

    // Ensure approval token IDs match collection token IDs
    const allApprovalBadgeIds = subscriptionApprovals
        .map((approval) => approval.badgeIds)
        .flat();

    return badgeIdsMatch(collection.validBadgeIds, allApprovalBadgeIds);
}
```

### Faucet Approval Validation

**API Documentation:** [isSubscriptionFaucetApproval](https://bitbadges.github.io/bitbadgesjs/functions/isSubscriptionFaucetApproval.html)

```typescript
function isSubscriptionFaucetApproval(approval) {
    // Must be from Mint
    if (approval.fromListId !== 'Mint') return false;

    // Must have coin transfers
    if (!approval.approvalCriteria?.coinTransfers?.length) return false;

    // Single denomination requirement
    const allDenoms = approval.approvalCriteria.coinTransfers.flatMap((ct) =>
        ct.coins.map((c) => c.denom)
    );
    if (new Set(allDenoms).size > 1) return false;

    // No address overrides in coin transfers
    for (const coinTransfer of approval.approvalCriteria.coinTransfers) {
        if (
            coinTransfer.overrideFromWithApproverAddress ||
            coinTransfer.overrideToWithInitiator
        ) {
            return false;
        }
    }

    // Validate incremented balances configuration
    const incrementedBalances =
        approval.approvalCriteria.predeterminedBalances?.incrementedBalances;
    if (!incrementedBalances) return false;

    return validateIncrementedBalances(incrementedBalances, approval.badgeIds);
}
```

### User Approval Validation

**API Documentation:** [isUserRecurringApproval](https://bitbadges.github.io/bitbadgesjs/functions/isUserRecurringApproval.html)

```typescript
function isUserRecurringApproval(userApproval, subscriptionApproval) {
    // Must be from Mint
    if (userApproval.fromListId !== 'Mint') return false;

    // Token IDs must match subscription
    if (!badgeIdsMatch(userApproval.badgeIds, subscriptionApproval.badgeIds)) {
        return false;
    }

    // Payment amount must be >= subscription amount
    const userAmount =
        userApproval.approvalCriteria?.coinTransfers?.[0]?.coins?.[0]?.amount;
    const subscriptionAmount =
        subscriptionApproval.approvalCriteria?.coinTransfers?.[0]?.coins?.[0]
            ?.amount;
    if (userAmount < subscriptionAmount) return false;

    // Validate coin transfer overrides
    const coinTransfer = userApproval.approvalCriteria.coinTransfers[0];
    if (
        !coinTransfer.overrideFromWithApproverAddress ||
        !coinTransfer.overrideToWithInitiator
    ) {
        return false;
    }

    // Validate recurring configuration
    return validateRecurringConfiguration(userApproval, subscriptionApproval);
}
```

## Usage Examples

### Basic Subscription Collection

```json
{
    "validBadgeIds": [{ "start": "1", "end": "1" }],
    "standardsTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "standards": ["Subscriptions"]
        }
    ],
    "collectionApprovals": [
        {
            "fromListId": "Mint",
            "toListId": "All",
            "initiatedByListId": "All",
            "transferTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "badgeIds": [{ "start": "1", "end": "1" }],
            "approvalCriteria": {
                "coinTransfers": [
                    {
                        "coins": [{ "denom": "ubadge", "amount": "100000" }],
                        "overrideFromWithApproverAddress": false,
                        "overrideToWithInitiator": false
                    }
                ],
                "predeterminedBalances": {
                    "incrementedBalances": {
                        "startBalances": [
                            {
                                "amount": "1",
                                "badgeIds": [{ "start": "1", "end": "1" }]
                            }
                        ],
                        "durationFromTimestamp": "2592000000",
                        "allowOverrideTimestamp": true
                    }
                }
            }
        }
    ]
}
```

### User Subscription Setup

```json
{
    "fromListId": "Mint",
    "badgeIds": [{ "start": "1", "end": "1" }],
    "approvalCriteria": {
        "coinTransfers": [
            {
                "coins": [{ "denom": "ubadge", "amount": "100000" }],
                "overrideFromWithApproverAddress": true,
                "overrideToWithInitiator": true
            }
        ],
        "predeterminedBalances": {
            "incrementedBalances": {
                "recurringOwnershipTimes": {
                    "intervalLength": "2592000000",
                    "chargePeriodLength": "604800000"
                }
            }
        },
        "maxNumTransfers": {
            "overallMaxNumTransfers": "1",
            "resetTimeIntervals": {
                "intervalLength": "2592000000"
            }
        }
    }
}
```

## Implementation Benefits

1. **Standardization**: Predictable subscription behavior across applications
2. **Interoperability**: Common interface for subscription management
3. **Automation**: Recurring payment and renewal mechanisms
4. **Flexibility**: Configurable subscription periods and pricing
5. **Validation**: Built-in compliance checking for protocol adherence

The Subscriptions Protocol provides a robust foundation for implementing subscription-based token systems while maintaining the flexibility and security of the BitBadges approval system.


## File: ./x-badges/concepts/protocols/tradable-protocol.md

# Tradable Protocol

The Tradable Protocol enables orderbook-style trading of tokens through standardized bid and listing approvals. This protocol supports both fungible and non-fungible token types with coin-based transactions.

## Protocol Overview

The Tradable Protocol creates a decentralized marketplace where users can:

-   **List tokens for sale** at specific prices
-   **Place bids** to buy tokens from other users
-   **Support both NFT and fungible tokens** with flexible trading rules
-   **Execute trades** through standardized approval mechanisms

## Protocol Requirements

### Collection Standards

-   Must include "Tradable" in the `standardsTimeline` for the current time period. Note this often also goes well with "NFT" standard if your collection is NFTs.
-   Compatible with all token types (fungible and non-fungible)
-   No restrictions on token ID ranges or quantities

### Approval Types

#### 1. Listing Approvals (Outgoing)

Listings allow owners to sell their tokens for coins.

**Requirements:**

-   Single transfer time range
-   Exactly one coin transfer with one coin denomination
-   Coin recipient must be the token owner (`to` equals `fromListId`)
-   No address overrides (`overrideFromWithApproverAddress` and `overrideToWithInitiator` must be false)
-   Specific token IDs (no `allowOverrideWithAnyValidBadge`)
-   Full ownership times
-   No Merkle challenges or prerequisite tokens
-   `overallMaxNumTransfers` > 0
-   Typically, you want the denomination to match the collection's preferred denomination.

#### 2. Bid Approvals (Incoming)

Bids allow users to offer coins to purchase tokens from others.

**Requirements:**

-   Single transfer time range
-   Exactly one coin transfer with one coin denomination
-   Coins come from bidder (`overrideFromWithApproverAddress` must be true)
-   Coins go to token owner (`overrideToWithInitiator` must be true)
-   Specific token IDs (no `allowOverrideWithAnyValidBadge` unless collection bid)
-   Full ownership times
-   No Merkle challenges or prerequisite tokens
-   `overallMaxNumTransfers` > 0

#### 3. Collection Bids (Special Case)

Collection bids allow users to bid on any token within a collection.

**Additional Requirements:**

-   Must have `allowOverrideWithAnyValidBadge` set to true
-   All other bid requirements apply

## Validation Functions

### General Orderbook Validation

**API Documentation:** [isOrderbookBidOrListingApproval](https://bitbadges.github.io/bitbadgesjs/functions/isOrderbookBidOrListingApproval.html)

```typescript
export const isOrderbookBidOrListingApproval = (
    approval: iCollectionApproval<bigint>,
    approvalLevel: 'incoming' | 'outgoing'
) => {
    return isBidOrListingApproval(approval, approvalLevel, {
        isFungibleCheck: true,
        fungibleOrNonFungibleAllowed: true,
    });
};
```

### Core Bid/Listing Validation

**API Documentation:** [isBidOrListingApproval](https://bitbadges.github.io/bitbadgesjs/functions/isBidOrListingApproval.html)

```typescript
export const isBidOrListingApproval = (
    approval: iCollectionApproval<bigint>,
    approvalLevel: 'incoming' | 'outgoing',
    options?: {
        isFungibleCheck?: boolean;
        fungibleOrNonFungibleAllowed?: boolean;
        isCollectionBid?: boolean;
    }
) => {
    const approvalCriteria = approval.approvalCriteria;
    if (approvalCriteria?.coinTransfers?.length !== 1) {
        return false;
    }

    if (approval.transferTimes.length !== 1) {
        return false;
    }

    const coinTransfer = approvalCriteria.coinTransfers[0];
    if (coinTransfer.coins.length !== 1) {
        return false;
    }

    // Validate address overrides for incoming approvals (bids)
    if (
        approvalLevel === 'incoming' &&
        !coinTransfer.overrideFromWithApproverAddress
    ) {
        return false;
    }

    if (approvalLevel === 'incoming' && !coinTransfer.overrideToWithInitiator) {
        return false;
    }

    // Validate address overrides for outgoing approvals (listings)
    if (
        approvalLevel === 'outgoing' &&
        coinTransfer.overrideFromWithApproverAddress
    ) {
        return false;
    }

    if (approvalLevel === 'outgoing' && coinTransfer.overrideToWithInitiator) {
        return false;
    }

    // For listings, recipient must be the approving user
    const to = coinTransfer.to;
    if (approvalLevel === 'outgoing' && to !== approval.fromListId) {
        return false;
    }

    const incrementedBalances =
        approvalCriteria.predeterminedBalances?.incrementedBalances;
    if (!incrementedBalances) {
        return false;
    }

    if (incrementedBalances.startBalances.length !== 1) {
        return false;
    }

    // Collection bids can accept any valid ID
    if (options?.isCollectionBid) {
        if (!incrementedBalances.allowOverrideWithAnyValidBadge) {
            return false;
        }
    } else {
        const allBadgeIds = UintRangeArray.From(
            incrementedBalances.startBalances[0].badgeIds
        )
            .sortAndMerge()
            .convert(BigInt);
        if (allBadgeIds.length !== 1 || allBadgeIds.size() !== 1n) {
            return false;
        }

        if (incrementedBalances.allowOverrideWithAnyValidBadge) {
            return false;
        }
    }

    const amount = incrementedBalances.startBalances[0].amount;
    const toCheckAmountOne =
        !options ||
        (!options.isFungibleCheck && !options.fungibleOrNonFungibleAllowed);
    if (toCheckAmountOne) {
        if (amount !== 1n) {
            return false;
        }
    }

    if (
        !UintRangeArray.From(
            incrementedBalances.startBalances[0].ownershipTimes
        ).isFull()
    ) {
        return false;
    }

    if (incrementedBalances.incrementBadgeIdsBy !== 0n) {
        return false;
    }

    if (incrementedBalances.incrementOwnershipTimesBy !== 0n) {
        return false;
    }

    if (incrementedBalances.durationFromTimestamp !== 0n) {
        return false;
    }

    if (incrementedBalances.allowOverrideTimestamp) {
        return false;
    }

    if (incrementedBalances.recurringOwnershipTimes.startTime !== 0n) {
        return false;
    }

    if (incrementedBalances.recurringOwnershipTimes.intervalLength !== 0n) {
        return false;
    }

    if (incrementedBalances.recurringOwnershipTimes.chargePeriodLength !== 0n) {
        return false;
    }

    if (approvalCriteria.requireFromEqualsInitiatedBy) {
        return false;
    }

    if (approvalCriteria.requireToEqualsInitiatedBy) {
        return false;
    }

    if (approvalCriteria.overridesToIncomingApprovals) {
        return false;
    }

    if (approvalCriteria.merkleChallenges?.length) {
        return false;
    }

    if (approvalCriteria.mustOwnBadges?.length) {
        return false;
    }

    if (
        (approvalCriteria.maxNumTransfers?.overallMaxNumTransfers ?? 0n) === 0n
    ) {
        return false;
    }

    return true;
};
```

### Collection Bid Validation

**API Documentation:** [isCollectionBid](https://bitbadges.github.io/bitbadgesjs/functions/isCollectionBid.html)

```typescript
export const isCollectionBid = (approval: iCollectionApproval<bigint>) => {
    return isBidOrListingApproval(approval, 'incoming', {
        isCollectionBid: true,
    });
};
```

## Implementation Example

For a complete implementation example, see the [Tradable NFT Collection Example](../../examples/txs/msgcreatecollection/tradable-nft-collection.md).


## File: ./x-badges/concepts/standards.md

# Standards

Standards are informational tags that provide guidance on how to interpret and implement collection features. The collection interface is very feature-rich, and oftentimes you may need certain features to be implemented in a certain way, avoid certain features, etc. That is what standards are for.

## Timeline Implementation

```json
"standardsTimeline": [
  {
    "timelineTimes": [{"start": "1", "end": "18446744073709551615"}],
    "standards": ["transferable", "text-only-metadata", "non-fungible", "attendance-format"]
  }
]
```

## Important Notes

-   **No blockchain validation** - Standards are purely informational
-   **Multiple standards allowed** - As long as they are compatible
-   **Application responsibility** - Queriers must verify compliance

## BitBadges Site Standards

The BitBadges site recognizes specific standards that collections can implement to ensure compatibility with various features and integrations:

### 1. Tradable Standard

Collections marked with the **Tradable** standard are marked as tradable on the BitBadges site. We will track orderbook, volume, price, and other metrics for these collections. Also, the interface will be optimized for trading.

-   **Requirements**:
    -   Ensure the collection lends itself to user-to-user trading
    -   Must be able to support bids / offers / listings / collection offers. These are standardized approvals that follow specific rules.

### 2. NFT Standard

Collections marked with the **NFT** standard are expected to be non-fungible tokens with supply = 1 for every token ID.

-   **Requirements**:
    -   Each token ID must have supply = 1 and full ownership times
    -   No fungible token IDs allowed
    -   Maintains uniqueness across all token IDs in the collection

### 3. Cosmos Wrappable Standard

Collections marked with the **Cosmos Wrappable** standard can be wrapped into Cosmos SDK coin denominations.

-   **Requirements**:
    -   Must have at least one wrapper path defined
    -   Should support bidirectional wrapping/unwrapping
    -   Refer to the [Cosmos Wrapper documentation](../cosmos-wrapper-paths.md) for detailed implementation guidelines

### 4. Subscriptions Standard

Collections marked with the **Subscriptions** standard are designed for recurring content delivery and subscription-based systems.

-   **Requirements**:
    -   Must support time-based ownership periods for subscription-like behavior
    -   Must be able to handle recurring token issuance and expiration
    -   Should support dynamic content updates based on subscription status
-   **Implementation**: See [Subscriptions Protocol](protocols/subscriptions-protocol.md) for detailed implementation requirements and validation logic

### 5. Quests Standard

Collections marked with the **Quests** standard are designed for achievement-based systems and quest completion tracking.

-   **Requirements**:
    -   Should implement quest completion tracking and reward distribution
    -   Must support achievement-based token issuance
    -   Should handle quest progression and milestone tracking

### Using BitBadges Standards

To implement these standards on your collection, add them to your `standardsTimeline`:

```json
{
    "standardsTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "standards": [
                "Tradable",
                "NFT",
                "Cosmos Wrappable",
                "Subscriptions",
                "Quests"
            ]
        }
    ]
}
```

**Note**: These standards are informational and do not enforce blockchain-level validation. Applications and platforms are responsible for verifying compliance with the specified standards.


## File: ./x-badges/concepts/time-fields.md

# Different Time Fields

BitBadges uses various time-related fields to manage permissions, timelines, transfers, and ownership. Understanding these fields is crucial for effectively managing collections and tokens.

## Time Representation

All times in BitBadges are represented as UNIX time, which is the number of milliseconds elapsed since the epoch (midnight at the beginning of January 1, 1970, UTC).

Time fields use UintRange format with valid values from 1 to 18446744073709551615 (Go MaxUint64). For complete details on range formatting and restrictions, see the [UintRange concept](uintrange.md).

## Time Field Types

### 1. permanentlyPermittedTimes

-   **Purpose**: Defines the times when a permission will always be executable (permanent)
-   **Usage**: Setting allowed periods for specific actions

### 2. permanentlyForbiddenTimes

-   **Purpose**: Defines the times when a permission will always be forbidden (permanent)
-   **Usage**: Setting restricted periods for specific actions

### 3. timelineTimes

-   **Purpose**: Specifies when a field is scheduled to have a specific value in a timeline-based field
-   **Usage**: Scheduling changes to collection or token properties over time

### 4. transferTimes

-   **Purpose**: Defines when a transfer transaction can occur (i.e. when an approval is valid)
-   **Usage**: Setting periods when tokens can be transferred between addresses

### 5. ownershipTimes

-   **Purpose**: Specifies the times that a user owns a token
-   **Usage**: Defining the duration of token ownership for users

## Important Note

The `timelineTimes` in permissions correspond to the updatability of the timeline, while `timelineTimes` in the actual timeline represent the actual times for the values.

## Examples

### Example 1: Presidential Election Badges

Scenario: Users participate in a US presidential election by casting votes through token transfers.

-   T1: Conclusion of voting
-   T2: Start of presidential term
-   T3: End of presidential term

Setup:

-   `transferTimes`: [{ start: T1, end: T2 }] (President badge can be transferred after voting concludes)
-   `ownershipTimes`: [{ start: T2, end: T3 }] (Defines the presidential term)

### Example 2: Managing Collection Archival

Scenario: A collection can be optionally archived by the manager from T1 to T2, but is non-archivable at all other times.

Before archiving:

```
Permission:
permanentlyPermittedTimes: [{ start: T1, end: T2 }]
permanentlyForbiddenTimes: [everything but T1 to T2]
timelineTimes: [{ start: 1, end: MAX_TIME }]

Archived Timeline:
isArchived: false for [{ start: 1, end: MAX_TIME }]
```

After archiving for all times:

```
Permission: (unchanged)
permanentlyPermittedTimes: [{ start: T1, end: T2 }]
permanentlyForbiddenTimes: [everything but T1 to T2]
timelineTimes: [{ start: 1, end: MAX_TIME }]

Archived Timeline:
isArchived: true for [{ start: 1, end: MAX_TIME }]
```

## Best Practices

1. **Clear Timelines**: Always define clear and non-overlapping time ranges for each field to avoid confusion and conflicts
2. **Permission Management**: Carefully consider the implications of setting `permanentlyPermittedTimes` and `permanentlyForbiddenTimes`, as these can significantly impact the flexibility of your collection
3. **Timeline Planning**: When using `timelineTimes`, plan your collection's lifecycle in advance to minimize the need for frequent updates
4. **Transfer Windows**: Use `transferTimes` to create specific windows for token transfers, which can be useful for time-limited events or phased distributions
5. **Ownership Tracking**: Leverage `ownershipTimes` to create tokens with time-bound ownership, useful for temporary privileges or rotating responsibilities
6. **Permission Locking**: Be cautious when permanently locking permissions, as this action is irreversible and may limit future flexibility
7. **Time Synchronization**: Ensure all systems interacting with your BitBadges collection are properly time-synchronized to avoid discrepancies in time-based operations


## File: ./x-badges/concepts/timeline-system.md

# Timeline System

BitBadges uses timeline-based fields to allow dynamic, time-dependent values for various attributes. This feature enables automatic updates to field values based on the current time, without requiring additional blockchain transactions.

## Structure

Timeline-based fields extend the `TimelineItem` interface:

```typescript
export interface TimelineItem<T extends NumberType> {
    timelineTimes: UintRange<T>[];
}
```

## Proto Definition Examples

```protobuf
message ManagerTimeline {
  repeated UintRange timelineTimes = 1;
  string manager = 2;
}

message CollectionMetadataTimeline {
  repeated UintRange timelineTimes = 1;
  CollectionMetadata collectionMetadata = 2;
}

message BadgeMetadataTimeline {
  repeated UintRange timelineTimes = 1;
  repeated UintRange badgeIds = 2;
  BadgeMetadata badgeMetadata = 3;
}
```

## Timeline Fields in Collections

The collection interface includes the following timeline-based fields:

-   `managerTimeline: ManagerTimeline<T>[]`
-   `collectionMetadataTimeline: CollectionMetadataTimeline<T>[]`
-   `badgeMetadataTimeline: BadgeMetadataTimeline<T>[]`
-   `customDataTimeline: CustomDataTimeline<T>[]`
-   `standardsTimeline: StandardsTimeline<T>[]`
-   `isArchivedTimeline: IsArchivedTimeline<T>[]`

## Usage Example

### Collection Metadata Timeline

```json
{
    "collectionMetadataTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "1680307199000" }],
            "collectionMetadata": {
                "uri": "ipfs://abc123",
                "customData": ""
            }
        },
        {
            "timelineTimes": [
                { "start": "1680307200000", "end": "18446744073709551615" }
            ],
            "collectionMetadata": {
                "uri": "ipfs://xyz456",
                "customData": ""
            }
        }
    ]
}
```

In this example:

-   From time 1 to March 31, 2023, the collection metadata URI is 'ipfs://abc123'
-   From April 1, 2023 onwards, the collection metadata URI is 'ipfs://xyz456'
-   The change happens automatically without additional transactions

## Key Principles

1. **Automatic Updates**: Values change automatically based on current time
2. **No Overlaps**: Timeline times within the same array should not overlap
3. **Future Scheduling**: Can schedule changes for future times
4. **Gas Efficiency**: No additional transactions needed for scheduled changes

## Practical Applications

Timeline-based fields enable:

-   **Scheduled ownership transfers** without manual intervention
-   **Automatic metadata updates** for evolving collections
-   **Time-based permission changes** for governance
-   **Seasonal content updates** for dynamic collections
-   **Archive scheduling** for temporary collections


## File: ./x-badges/concepts/total-supply.md

# Total Supply

The total circulating supply is not a fixed value but rather dynamically determined through the collection approvals and permissions. The total supply is the sum of all the tokens that have been transferred from the Mint address (which has unlimited balances). Setting the Mint approvals and using them determines the total supply. Permissions are used to control the ability to set, update, or delete the Mint approvals by the manager.

## Related Concepts

-   **[Valid Token IDs](valid-badge-ids.md)** - Defines which token IDs can exist for informational purposes
-   **[Manager](manager.md)** - Controls the collection approvals and permissions
-   **[Transferability & Approvals](transferability-approvals.md)** - Governs transfers from Mint address
-   **[Permissions](permissions/)** - Controls what managers can do and when they can do it


## File: ./x-badges/concepts/transferability-approvals.md

# Transferability & Approvals

## Overview

Transferability in BitBadges is controlled through a hierarchical approval system with three levels:

<figure><img src="../../.gitbook/assets/image (33).png" alt="Approval hierarchy diagram"><figcaption><p>Approval hierarchy: Collection → User (Incoming/Outgoing)</p></figcaption></figure>

### Approval Levels

| Level          | Description                              | Fields                                    |
| -------------- | ---------------------------------------- | ----------------------------------------- |
| **Collection** | Global rules for the entire collection   | All fields                                |
| **Incoming**   | User-specific rules for receiving tokens | `toList` = user's address, no overrides   |
| **Outgoing**   | User-specific rules for sending tokens   | `fromList` = user's address, no overrides |

**Key Rule**: A transfer must satisfy collection-level approvals AND (unless overridden) user-level incoming/outgoing approvals.

## Approval Structure

```typescript
interface CollectionApproval<T extends NumberType> {
    // Core Fields
    toListId: string; // Who can receive?
    fromListId: string; // Who can send?
    initiatedByListId: string; // Who can initiate?
    transferTimes: UintRange<T>[]; // When can transfer happen?
    badgeIds: UintRange<T>[]; // Which token IDs?
    ownershipTimes: UintRange<T>[]; // Which ownership times?
    approvalId: string; // Unique identifier

    // Version control (incremented on each update)
    version: T;

    // Optional Fields
    uri?: string; // Metadata link
    customData?: string; // Custom data
    approvalCriteria?: ApprovalCriteria<T>; // Additional restrictions
}
```

See [Approval Criteria](broken-reference) for more details on the `approvalCriteria` field.

## Approval Value vs Permission

While the value may seem similar to the approval update permissions, the permission corresponds to the **updatability** of the approvals (i.e. `canUpdateCollectionApprovals`). The approvals themselves correspond to if a transfer is currently approved or not.

## The Six Core Fields

Every approval defines **Who? When? What?** through these fields:

| Field               | Type                             | Purpose                                 | Example                                            |
| ------------------- | -------------------------------- | --------------------------------------- | -------------------------------------------------- |
| `toListId`          | Address List ID                  | Who can receive tokens                  | `"All"`, `"Mint"`, `"bb1..."`                      |
| `fromListId`        | Address List ID                  | Who can send tokens                     | `"Mint"`, `"!Mint"`                                |
| `initiatedByListId` | Address List ID                  | Who can initiate transfer               | `"All"`, `"bb1..."`                                |
| `transferTimes`     | UintRange\[] (UNIX Milliseconds) | When transfer can occur                 | `[{start: "1691931600000", end: "1723554000000"}]` |
| `badgeIds`          | UintRange\[] (Token IDs)         | Which token IDs                         | `[{start: "1", end: "100"}]`                       |
| `ownershipTimes`    | UintRange\[] (UNIX Milliseconds) | Which ownership times to be transferred | `[{start: "1", end: "18446744073709551615"}]`      |

### Example Approval

```json
{
    "fromListId": "Mint",
    "toListId": "All",
    "initiatedByListId": "All",
    "transferTimes": [{ "start": "1691931600000", "end": "1723554000000" }],
    "badgeIds": [{ "start": "1", "end": "100" }],
    "ownershipTimes": [{ "start": "1", "end": "18446744073709551615" }],
    "approvalId": "mint-to-all"
}
```

**Translation**: Allow anyone to claim tokens 1-100 from the Mint address between Aug 13, 2023 and Aug 13, 2024.

## Approval Matching Process

### Step-by-Step Flow (High-Level)

```
Transfer Request
    ↓
Check Collection Approvals
    ↓
Match Found? ──No──→ TRANSFER DENIED
    ↓ Yes
Check Approval Criteria
    ↓
Criteria Met? ──No──→ TRANSFER DENIED
    ↓ Yes
Check User Approvals (where necessary)
    ↓
User Approvals Met? ──No──→ TRANSFER DENIED
    ↓ Yes
TRANSFER APPROVED
```

### Matching Logic

For optimal design, you should try to design transfers such that they only use specific approvals without the need for splitting. However, if needed, we split the transfer / approvals as fine-grained as we can to make it succeed. In other words, we deduct as much as possible from each approval as we iterate.

### Prioritized Approvals

In MsgTransferBadges, you can specify which approvals to prioritize. This allows you to prioritize certain approvals over others.

```typescript
// In MsgTransferBadges
{
  prioritizedApprovals: [{
    approvalId: "approval1",
    approvalLevel: "collection",
    approverAdress: "", // ""bb1" if approvalLevel is "incoming" or "outgoing",
    version: 0,
  }],
  onlyCheckPrioritizedCollectionApprovals: true,
  // If true, the transfer will be denied if no prioritized approvals match
}
```

## Auto-Scan vs Prioritized Approvals

The transfer approval system operates in two modes to balance efficiency and precision:

### Auto-Scan Mode (Default)

By default, the system automatically scans through available approvals to find a match for the transfer. This mode:

* **Works with**: Approvals using [Empty Approval Criteria](../examples/empty-approval-criteria.md) (no side effects). For example, when you approve all incoming transfers w/ no restrictions, this has no side effects.
* **Behavior**: Automatically finds and uses the first matching approval
* **Use case**: Simple transfers without custom logic or side effects
* **No versioning required**: The system handles approval selection automatically

### Prioritized Approvals (Required for Side Effects)

**CRITICAL REQUIREMENT**: Any transfer with side effects or custom approval criteria MUST always be prioritized with proper versioning set. No exceptions.

#### Race Condition Protection

The versioning control ensures that before submitting, the user knows the exact approval they are using:

```typescript
"prioritizedApprovals": [
    {
        "approvalId": "abc123",
        "approvalLevel": "collection",
        "approverAddress": "",
        "version": "2" // Must specify exact version
  }
]
```

See [MsgTransferBadges](../../bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgtransferbadges.md) for the complete message structure.

## Related Topics

* [Approval Criteria](broken-reference) - Additional restrictions and challenges
* [Address Lists](../address-lists.md) - Managing address groups
* [UintRanges](../uint-ranges.md) - Range logic implementation
* [Permissions](permissions/) - Controlling who can update approvals


## File: ./x-badges/concepts/uintrange.md

# UintRanges

The `UintRange` is the fundamental data structure used throughout the badges module to represent inclusive ranges of unsigned integers efficiently. This type enables powerful range-based operations and is primarily used for token IDs, time ranges, and amounts.

## Proto Definition

```protobuf
message UintRange {
  string start = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string end = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

## Usage Patterns

UintRanges are used to represent:

-   **Token ID ranges**: `[1-100]` represents token IDs 1 through 100 (inclusive)
-   **Time ranges**: `[1640995200000-1672531200000]` represents a year in UNIX milliseconds
-   **Amount ranges**: `[1-5]` represents quantities from 1 to 5
-   **Ownership time ranges**: When tokens are valid for ownership

## Restrictions & Valid Values

Unless otherwise specified, we only allow numbers in the ranges to be from **1 to Go Max UInt64**:

-   **Valid range**: 1 to 18446744073709551615 (Go's `math.MaxUint64`)
-   **Zero and negative values**: Not allowed
-   **Values greater than maximum**: Not allowed

## Validation Rules

-   `start` must be ≤ `end`
-   Ranges in the same array cannot overlap
-   Zero amounts are not allowed in balance ranges
-   All values must be within the valid range (1 to MaxUint64)

## Special Cases

### Full Range

To represent a complete range covering all possible values:

```protobuf
// Full range from 1 to maximum
{
  start: "1",
  end: "18446744073709551615"
}
```

### Single Value

To represent a single value, use the same value for start and end:

```protobuf
// Single token ID 5
{
  start: "5",
  end: "5"
}
```

### Range Inversion

Inverting a range results in all values from 1 to 18446744073709551615 that are **not** in the current range. This is useful for exclusion logic.

## Examples

### Token ID Examples

```typescript
// Token IDs 1-10 (inclusive)
const badgeRange: UintRange[] = [{ start: '1', end: '10' }];

// Multiple non-overlapping ranges
const multipleBadges: UintRange[] = [
    { start: '1', end: '10' },
    { start: '20', end: '50' },
];
```

### Go Code Examples

```go
// Token IDs 1-10
badgeIdRange := UintRange{Start: NewUint(1), End: NewUint(10)}

// Unlimited amount
unlimitedAmount := UintRange{Start: NewUint(1), End: MaxUint}

// Single token ID
singleBadge := UintRange{Start: NewUint(5), End: NewUint(5)}
```

## Efficiency Benefits

-   **Compact representation**: Ranges avoid storing individual values
-   **Range operations**: Efficient intersection, union, and containment checks
-   **Gas optimization**: Reduces transaction size and computational costs
-   **Scalability**: Handles large ranges without performance degradation


## File: ./x-badges/concepts/valid-badge-ids.md

# Valid Token IDs

Valid Token IDs define the range of token IDs that exist within a collection. This is mainly informational but also may be used to enforce certain rules within the collection.

## Creating Token IDs

### During Collection Creation

Use the `validBadgeIds` field in [MsgCreateCollection](../../messages/msg-create-collection.md):

```json
{
    "creator": "bb1...",
    "validBadgeIds": [
        {
            "start": "1",
            "end": "100"
        }
    ],
    "collectionPermissions": {
        "canUpdateValidBadgeIds": [
            // { ... }
        ]
    }
}
```

### During Collection Updates

Use the `validBadgeIds` field in [MsgUpdateCollection](../../messages/msg-update-collection.md):

```json
{
    "creator": "bb1...",
    "collectionId": "1",
    "validBadgeIds": [
        {
            "start": "101",
            "end": "200"
        }
    ]
}
```

## Permission Control

Updates to valid token IDs must obey the `canUpdateValidBadgeIds` permission:

### Permission Structure

```json
"canUpdateValidBadgeIds": [
  {
    "badgeIds": [{"start": "1", "end": "1000"}],
    "permanentlyPermittedTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyForbiddenTimes": []
  }
]
```

### Permission Behaviors

Note that the `canUpdateValidBadgeIds` permission applies to the updatability of the `validBadgeIds` field.

We find the first-match for (current time, token ID) for each token ID that is changed, and check the permission for that time. If no time matches, the permission is default enabled. See [Permissions](permissions/) for more details.

### Permission Best-Practices

Typically, the desired functionality falls into one of the following categories:

-   **Set and Lock All**: Set the valid token IDs upon genesis and lock everything from further updates
-   **Set and Lock All Current, Allow Expansion**: Set the valid token IDs upon genesis and lock the current ones from being updated, but allow expansion in the future.

## Best Practices

1. **Plan ahead**: Consider future expansion when setting initial token ID ranges
2. **Sequential additions**: Always add token IDs sequentially to maintain the no-gaps requirement
3. **Permission management**: Carefully configure `canUpdateValidBadgeIds` permissions based on collection lifecycle
4. **Documentation**: Clearly document the intended use of different token ID ranges


## File: ./x-badges/events.md

# 📡 Events

The badges module emits events for all message operations to enable blockchain monitoring and external application integration.

## Event Categories

### Standard Message Events

All message handlers emit `sdk.EventTypeMessage` events with message-specific attributes.

### Indexer Events

Duplicate events with type "indexer" for external application consumption.

### Transfer Events

Detailed events for transfer operations including approval usage and challenge tracking.

### IBC Events

Events for cross-chain operations with acknowledgment handling.

## Standard Message Events

### Collection Management

#### CreateCollection

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (creator address)
  - action: "create_collection"
  - msg: string (JSON-encoded message)
```

#### UpdateCollection

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (creator address)
  - action: "update_collection"
  - msg: string (JSON-encoded message)
```

#### UniversalUpdateCollection

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (creator address)
  - action: "universal_update_collection"
  - msg: string (JSON-encoded message)
```

#### DeleteCollection

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (creator address)
  - action: "delete_collection"
  - msg: string (JSON-encoded message)
```

### Token Transfers

#### TransferBadges

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (initiator address)
  - action: "transfer_badges"
  - msg: string (JSON-encoded message)
  - transfer: string (JSON transfer details)
  - from: string (sender address)
  - to: string (recipient address)
  - initiatedBy: string (initiator address)
  - coinTransfers: string (JSON coin transfer details)
  - approvalsUsed: string (JSON approval usage details)
  - balances: string (JSON balance details)
```

### User Approvals

#### UpdateUserApprovals

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (user address)
  - action: "update_user_approvals"
  - msg: string (JSON-encoded message)
```

### Address Lists

#### CreateAddressLists

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (creator address)
  - action: "create_address_lists"
  - msg: string (JSON-encoded message)
```

### Dynamic Stores

#### CreateDynamicStore

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (creator address)
  - action: "create_dynamic_store"
  - store_id: string
  - msg: string (JSON-encoded message)
```

#### UpdateDynamicStore

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (updater address)
  - action: "update_dynamic_store"
  - store_id: string
  - msg: string (JSON-encoded message)
```

#### DeleteDynamicStore

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (deleter address)
  - action: "delete_dynamic_store"
  - store_id: string
  - msg: string (JSON-encoded message)
```

#### SetDynamicStoreValue

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (setter address)
  - action: "set_dynamic_store_value"
  - store_id: string
  - address: string (target address)
  - value: string (numeric value)
  - msg: string (JSON-encoded message)
```

#### IncrementStoreValue

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (incrementer address)
  - action: "increment_store_value"
  - store_id: string
  - address: string (target address)
  - amount: string (increment amount)
  - msg: string (JSON-encoded message)
```

#### DecrementStoreValue

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (decrementer address)
  - action: "decrement_store_value"
  - store_id: string
  - address: string (target address)
  - amount: string (decrement amount)
  - set_to_zero_on_underflow: string ("true"/"false")
  - msg: string (JSON-encoded message)
```

## Transfer Events

### Approval Usage

```
Type: "usedApprovalDetails"
Attributes:
  - collectionId: string
  - approverAddress: string
  - approvalId: string
  - amountTrackerId: string
  - approvalLevel: string
  - trackerType: string
  - address: string
  - amounts: string (JSON array)
  - numTransfers: string
  - lastUpdatedAt: string
```

### Challenge Events

```
Type: "challenge{approvalId}{challengeId}{leafIndex}{approverAddress}{approvalLevel}{newNumUsed}"
Attributes:
  - challengeTrackerId: string
  - approvalId: string
  - leafIndex: string
  - approverAddress: string
  - approvalLevel: string
  - numUsed: string
```

### Dynamic Approval Events

```
Type: "approval{collectionId}{approverAddress}{approvalId}{amountsTrackerId}{approvalLevel}{trackerType}{address}"
Attributes:
  - amountTrackerId: string
  - approvalId: string
  - approverAddress: string
  - approvalLevel: string
  - trackerType: string
  - approvedAddress: string
  - amounts: string (JSON array)
  - numTransfers: string
  - lastUpdatedAt: string
```

## IBC Events

### Packet Events

```
Type: "timeout" (for timeouts)
Attributes:
  - acknowledgement: string
  - success: string ("true"/"false")
  - error: string (if applicable)
```


## File: ./x-badges/examples/README.md

# 💡 Examples and Snippets

This directory contains practical examples and building blocks for x/badges.

## Contents

* [Base Collection Configuration](base-collection-details.md) - Standard base collection configuration template
* [Empty Approval Criteria](empty-approval-criteria.md) - Template for unrestricted approval criteria
* [Defining Circulating Supply](defining-circulating-supply.md) - How to define and lock circulating supply
* [Building Collection Approvals](building-collection-approvals.md) - Guide to building collection-level approvals
* [Building User Approvals](building-user-approvals.md) - Guide to building user-level incoming and outgoing approvals
* [Building Collection Permissions](building-collection-permissions.md) - Guide to configuring collection permissions
* [Building User Permissions](building-user-permissions.md) - Guide to configuring user-level permissions
* [Cosmos Coin Wrapper Example](cosmos-coin-wrapper-example.md) - Example of wrapping tokens as Cosmos coins
* [Mint All to Self Tutorial](mint-all-to-self-tutorial.md) - Tutorial for creating collection and minting tokens to yourself
* [Approvals](approvals/) - Common approval patterns and examples
  * [Transferable Approval](approvals/transferable-approval.md) - Basic transferable approval configuration
  * [Burnable Approval](approvals/burnable-approval.md) - Approval allowing tokens to be burned
  * [Cosmos Wrapper Approval](approvals/cosmos-wrapper-approval.md) - Approval for wrapping tokens as Cosmos coins
  * [Cosmos Unwrapper Approval](approvals/cosmos-unwrapper-approval.md) - Approval for unwrapping Cosmos coins back to tokens
  * [Admin Override Approval](approvals/admin-override-approval.md) - Admin approval that overrides user-level restrictions
* [Permissions](permissions/) - Common permission patterns and examples
* [Transactions](txs/) - Full transaction examples
  * [MsgCreateCollection](txs/msgcreatecollection/) - Complete transaction examples for creating collections


## File: ./x-badges/examples/approvals/admin-override-approval.md

# Admin Override Approval

This example demonstrates how to create an approval that allows a specific address to forcefully transfer tokens, overriding all user-level approvals. This provides complete administrative control for emergency situations or management purposes.

## Overview

An admin override approval grants a specific address the power to:

* Transfer tokens from any address to any address
* Override user-level incoming and outgoing approvals
* Bypass normal approval restrictions
* Maintain complete administrative control

⚠️ **Warning**: This approval type grants significant power and should be used carefully with trusted addresses only.

## Code Example

```typescript
const approveSelfForcefully = (address: string) => {
    const id = 'complete-admin-control';

    return {
        fromListId: 'Mint',
        toListId: 'All',
        initiatedByListId: address,
        transferTimes: UintRangeArray.FullRanges(),
        badgeIds: UintRangeArray.FullRanges(),
        ownershipTimes: UintRangeArray.FullRanges(),
        approvalId: id,
        version: 0n,
        approvalCriteria: {
            ...EmptyApprovalCriteria,
            overridesFromOutgoingApprovals: true,
            overridesToIncomingApprovals: true,
        },
    };
};
```

## Related Concepts

* [Transferability / Approvals](../../concepts/transferability-approvals.md)
* [Address Lists](../../concepts/address-lists.md)
* [Approval Criteria](broken-reference)


## File: ./x-badges/examples/approvals/burnable-approval.md

# Burnable Approval

This example demonstrates how to create a burnable approval that allows tokens to be sent to the burn address (0x0000000000000000000000000000000000000000), effectively removing them from circulation.

## Overview

A burnable approval enables tokens to be permanently destroyed by sending them to the zero address.

## Code Example

```typescript
const burnableApproval = new CollectionApproval({
    fromListId: '!Mint', // Excludes the Mint address
    toListId: convertToBitBadgesAddress(
        '0x0000000000000000000000000000000000000000' //bb1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs7gvmv
    ),
    initiatedByListId: 'All',
    transferTimes: UintRangeArray.FullRanges(),
    ownershipTimes: UintRangeArray.FullRanges(),
    badgeIds: UintRangeArray.FullRanges(),
    approvalId: 'burnable-approval',
    version: 0n,
    approvalCriteria: undefined, // No additional restrictions
});
```

## Related Concepts

-   [Transferability / Approvals](../../concepts/transferability-approvals.md)
-   [Address Lists](../../concepts/address-lists.md)
-   [Timeline System](../../concepts/timeline-system.md)


## File: ./x-badges/examples/approvals/cosmos-unwrapper-approval.md

# Cosmos Unwrapper Approval

This example demonstrates how to create an approval that allows the Cosmos coin wrapper address to send tokens back to users, enabling conversion from Cosmos coins back to tokens (unwrapping).

You pretty much: 1) figure out your address and 2) figure out a path that users can send from this address without needing the address to control its approvals.

Full example: [Cosmos Coin Wrapper Example](broken-reference)

## Code Example

```typescript
export const unwrapperApproval = ({
    specialAddress,
    badgeIds,
    ownershipTimes,
    approvalId,
}: {
    specialAddress: string;
    badgeIds: iUintRange<bigint>[];
    ownershipTimes: iUintRange<bigint>[];
    approvalId: string;
}): RequiredApprovalProps => {
    const id = approvalId;
    const toSet: RequiredApprovalProps = {
        version: 0n,
        fromListId: specialAddress,
        fromList: AddressList.getReservedAddressList(specialAddress),
        toListId: 'All',
        toList: AddressList.AllAddresses(),
        initiatedByListId: 'All',
        initiatedByList: AddressList.AllAddresses(),
        transferTimes: UintRangeArray.FullRanges(),
        badgeIds: badgeIds,
        ownershipTimes: ownershipTimes,
        approvalId: id,
        approvalCriteria: {
            ...EmptyApprovalCriteria,
            overridesFromOutgoingApprovals: true,
        },
    };

    return toSet;
};
```

## Related Concepts

* [Cosmos Wrapper Approval](cosmos-wrapper-approval.md)
* [Cosmos Wrapper Paths](broken-reference)
* [Transferability / Approvals](../../concepts/transferability-approvals.md)
* [Address Lists](../../concepts/address-lists.md)


## File: ./x-badges/examples/approvals/cosmos-wrapper-approval.md

# Cosmos Wrapper Approval

This example demonstrates how to create an approval that allows tokens to be sent to a Cosmos coin wrapper address, enabling conversion to native Cosmos SDK coins.

You pretty much: 1) figure out your address and 2) figure out a path that users can send to this address without needing the address to control its approvals. Oftentimes, you may not even need to forcefully override the incoming approvals because you default allow all incoming transfers which also applies to the wrapper address automatically.

Full example: [Cosmos Coin Wrapper Example](broken-reference)

## Code Example

```typescript
export const wrapperApproval = ({
    specialAddress,
    badgeIds,
    ownershipTimes,
    approvalId,
}: {
    specialAddress: string;
    badgeIds: iUintRange<bigint>[];
    ownershipTimes: iUintRange<bigint>[];
    approvalId: string;
}): RequiredApprovalProps => {
    const id = approvalId;
    const toSet: RequiredApprovalProps = {
        version: 0n,
        toListId: specialAddress,
        toList: AddressList.getReservedAddressList(specialAddress),
        fromListId: 'AllWithoutMint',
        fromList: AddressList.getReservedAddressList('AllWithoutMint'),
        initiatedByListId: 'All',
        initiatedByList: AddressList.AllAddresses(),
        transferTimes: UintRangeArray.FullRanges(),
        badgeIds: badgeIds,
        ownershipTimes: ownershipTimes,
        approvalId: id,
        approvalCriteria: {
            ...EmptyApprovalCriteria,
            overridesToIncomingApprovals: true,
        },
    };

    return toSet;
};
```

## Related Concepts

* [Cosmos Wrapper Paths](broken-reference)
* [Transferability / Approvals](../../concepts/transferability-approvals.md)
* [Address Lists](../../concepts/address-lists.md)


## File: ./x-badges/examples/approvals/transferable-approval.md

# Transferable Approval

This example demonstrates how to create a basic transferable approval that allows tokens to be freely transferred between any users after minting.

## Overview

A transferable approval enables tokens to be moved between addresses without restrictions.

## Code Example

```typescript
const transferableApproval = new CollectionApproval({
    fromListId: '!Mint', // Excludes the Mint address
    toListId: 'All',
    initiatedByListId: 'All',
    transferTimes: UintRangeArray.FullRanges(),
    ownershipTimes: UintRangeArray.FullRanges(),
    badgeIds: UintRangeArray.FullRanges(),
    approvalId: 'transferable-approval',
    version: 0n,
    approvalCriteria: undefined, // No additional restrictions
});
```

## Related Concepts

-   [Transferability / Approvals](../../concepts/transferability-approvals.md)
-   [Address Lists](../../concepts/address-lists.md)
-   [Timeline System](../../concepts/timeline-system.md)


## File: ./x-badges/examples/base-collection-details.md

# Base Collection Details

BitBadges collections are very expressive but also can lead to verbose configurations. We will provide additional examples in this section but also refer you to the corresponding concepts section for more details on any specific field.

### Reference Links

For detailed information about each field, see the corresponding concepts documentation:

| Field                         | Concepts Link                                               |
| ----------------------------- | ----------------------------------------------------------- |
| `validBadgeIds`               | [Valid Token IDs](../concepts/valid-badge-ids.md)           |
| `managerTimeline`             | [Manager](../concepts/manager.md)                           |
| `collectionMetadataTimeline`  | [Metadata](../concepts/metadata.md)                         |
| `badgeMetadataTimeline`       | [Metadata](../concepts/metadata.md)                         |
| `customDataTimeline`          | [Custom Data](../concepts/custom-data.md)                   |
| `standardsTimeline`           | [Standards](../concepts/standards.md)                       |
| `isArchivedTimeline`          | [Archived Collections](../concepts/archived-collections.md) |
| `defaultBalances`             | [Default Balances](../concepts/default-balances.md)         |
| `mintEscrowCoinsToTransfer`   | [Mint Escrow Address](../concepts/mint-escrow-address.md)   |
| `cosmosCoinWrapperPathsToAdd` | [Cosmos Wrapper Paths](broken-reference)                    |
| Timeline System (all fields)  | [Timeline System](../concepts/timeline-system.md)           |

## Base Collection Details

For most collections, your base configuration for these fields will be very similar to this. Note that this excludes collection permissions and approvals. See the [Building Collection Approvals](building-collection-approvals.md) example and [Building Collection Permissions](building-collection-permissions.md) example for these.

```typescript
// Our standard time range represeting "forever"
const FullTimeRanges = [
    {
        start: '1',
        end: '18446744073709551615',
    },
];

const BaseCollectionDetails = {
    validBadgeIds: [
        {
            start: '1',
            end: '100', // Set to your max ID
        },
    ],
    managerTimeline: [
        {
            manager: 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls', // Set to your address
            timelineTimes: FullTimeRanges,
        },
    ],
    collectionMetadataTimeline: [
        {
            timelineTimes: FullTimeRanges,
            collectionMetadata: {
                uri: 'ipfs://QmSTZZPgYF58gS9bM7q3nWVegUJH51WBdT91fz7q94qDwS', // Points to a valid .json metadata file
                customData: '',
            },
        },
    ],
    badgeMetadataTimeline: [
        {
            timelineTimes: FullTimeRanges,
            badgeMetadata: [
                {
                    uri: 'ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/{id}', // Points to a valid .json metadata file (replacing {id} with the token ID)
                    badgeIds: [
                        {
                            start: '1',
                            end: '100',
                        },
                    ],
                    customData: '',
                },
                // You can have multiple entries. This is useful for placeholder metadata.
                {
                    uri: 'ipfs://QmSTZZPgYF58gS9bM7q3nWVegUJH51WBdT91fz7q94qDwS', // Placeholder metadata
                    badgeIds: [
                        {
                            start: '101',
                            end: '100000000',
                        },
                    ],
                    customData: '',
                },
            ],
        },
    ],
    customDataTimeline: [
        {
            timelineTimes: FullTimeRanges,
            customData: '',
        },
    ],
    standardsTimeline: [
        {
            timelineTimes: FullTimeRanges,
            standards: ['Subscriptions'],
        },
    ],
    isArchivedTimeline: [
        {
            timelineTimes: FullTimeRanges,
            isArchived: false,
        },
    ],

    // Coins to send to the mint escrow address. You can also fund after the fact. This is just useful for genesis since the address is dependent on the collectionId which you don't know until after the collection is created.
    mintEscrowCoinsToTransfer: [
        {
            denom: 'ubadge',
            amount: '1',
        },
    ],

    // If you want to add paths to wrap tokens as Cosmos coins, you can do so here.
    cosmosCoinWrapperPathsToAdd: [],

    defaultBalances: {
        // Everyone starts with empty balances and no approvals
        balances: [],
        incomingApprovals: [],
        outgoingApprovals: [],
        // Empty = Soft Enabled (i.e. enabled but can be disabled at any time by each user)
        userPermissions: {
            canUpdateOutgoingApprovals: [],
            canUpdateIncomingApprovals: [],
            canUpdateAutoApproveSelfInitiatedOutgoingTransfers: [],
            canUpdateAutoApproveSelfInitiatedIncomingTransfers: [],
            canUpdateAutoApproveAllIncomingTransfers: [],
        },

        // Typically, these flags are all you need to set.
        autoApproveSelfInitiatedIncomingTransfers: true,
        autoApproveSelfInitiatedOutgoingTransfers: true,
        autoApproveAllIncomingTransfers: true,
    },
};
```

For information on building collection approvals, see [Building Collection Approvals](building-collection-approvals.md).


## File: ./x-badges/examples/building-collection-approvals.md

# Building Your Collection Approvals

The collection-level transferability is determined by the collection-level approvals. The important thing to consider here is that any approval that allows transfers from the "Mint" address will mint balances out of thin air.

## Approval Categories

It is typically recommended to split into two categories:

-   **Mint Approvals** (`fromListId: 'Mint'`)
-   **Post-Mint Approvals** (`fromListId: '!Mint'`)

## Important Notes

1. The reserved "All" list ID includes Mint. Do not use "All" for the fromListId for post-mint approvals.
2. To function, the "Mint" approval must forcefully override the user-level outgoing approval because it cannot be managed.

## Code Example

Mix and match the approvals as you see fit. See the examples in the Approvals folder for a bunch of examples.

-   [Transferable Approval](./approvals/transferable-approval.md)
-   [Burnable Approval](./approvals/burnable-approval.md)

```typescript
const mintApprovals = [
    // Mint approvals with fromListId: 'Mint'
];

const postMintApprovals = [
    // Post-mint approvals with fromListId: '!Mint'
    transferableApproval,
    burnableApproval,
];

const collectionApprovals = [...mintApprovals, ...postMintApprovals];

const collectionApprovalTimeline = [
    {
        timelineTimes: FullTimeRanges,
        collectionApprovals,
    },
];
```

## Related Concepts

-   [Transferability / Approvals](../concepts/transferability-approvals.md)
-   [Address Lists](../concepts/address-lists.md)
-   [Timeline System](../concepts/timeline-system.md)
-   [Approval Examples](./approvals/)


## File: ./x-badges/examples/building-collection-permissions.md

# Building Your Collection Permissions

Collection permissions are executable by the manager. They are used to control who can perform various management actions on your collection and when those actions are allowed.

```typescript
const manager = collection.getCurrentManager();
```

## Setting Your Permissions

You have a few options for setting your permissions.

1. No Manager

If you simply don't want a manager, you can set the manager to an empty string. Then, the permission values never matter.

```typescript
const managerTimeline = [
    {
        manager: '',
        timelineTimes: FullTimeRanges,
    },
];
```

2. Complete Control - Soft Enabled

Each permission is enabled by default, unless you permanently disabled it. Thus, an empty array means that the permission is enabled for all times. However, it is soft enabled, meaning that the manager can disable it at any time. This configuration offers full control with ability to disable in the future.

```typescript
const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateBadgeMetadata: [],
    canUpdateCollectionApprovals: [],
    canUpdateValidBadgeIds: [],
};
```

3. Custom Permissions

Oftentimes, you want a little more control over your permissions though.

Each permission follows the same pattern:

1. For the times `permanentlyPermittedTimes`, the permission is always permitted for the given values.
2. For the times `permanentlyForbiddenTimes`, the permission is always forbidden for the given values.
3. If the item is not explicity in either, then the permission is enabled for the given values, but the status can change.

```typescript
const CanArchiveCollection = {
    permanentlyPermittedTimes: [],
    permanentlyForbiddenTimes: FullTimeRanges,
    timelineTimes: FullTimeRanges,
};
```

Each permission type follows the same pattern of two categories:

```typescript
// Part 1. Enabled vs Disabled Times For The Execution Of The Permission
const permanentlyPermittedTimes = [];
const permanentlyForbiddenTimes = FullTimeRanges;

// Part 2. For what values (if any) does this apply? This is dependent on the permission type.
const {
    timelineTimes,
    badgeIds,
    fromListId,
    toListId,
    initiatedByListId,
    transferTimes,
    ownershipTimes,
    approvalId,
} = permission;
```

## Main Permissions To Consider

1. Should the number of token IDs in the collection be expandable? frozen upon genesis? -> Handle with `canUpdateValidBadgeIds`
2. What about the transferability? -> Handle with `canUpdateCollectionApprovals`
    - Should the transferability be frozen upon genesis?
    - Should we disallow updating transferability for only some token IDs? some approvals? Mint? Post-Mint?
    - This could be critical for enforcing total circulating supply. For example, if you can create more approvals from the Mint address, then you can theoretically mint however many tokens you want.

## Examples

We refer you to the [examples](../examples/permissions) or relevant concepts for more detailed examples.

## Related Concepts

-   [Permission System](../concepts/permissions/permission-system.md)
-   [Manager](../concepts/manager.md)
-   [Timeline System](../concepts/timeline-system.md)
-   [Timed Update Permission](../concepts/permissions/timed-update-permission.md)


## File: ./x-badges/examples/building-user-approvals.md

# Building User-Level Approvals

User-level approvals allow individual users to control their token transfers through incoming and outgoing approvals. These work similarly to [collection-level approvals](building-collection-approvals.md) with key restrictions.

We refer you to the collection-level examples and just apply the same logic to the user-level types with these differences.

## Key Differences from Collection Approvals

* **Fixed Address Lists**:
  * Incoming approvals: `fromListId` is locked to the user's address
  * Outgoing approvals: `toListId` is locked to the user's address
* **No Override Functionality**: Cannot override other approval levels
* **User-Controlled**: Only the user can update their own approvals

## Incoming Approvals

Control what tokens the user can receive:

```typescript
const userIncomingApproval = {
    fromListId: 'user-address', // Locked to approver's address
    toListId: 'All', // Can specify recipients
    initiatedByListId: 'All',
    transferTimes: [{ start: '1', end: '18446744073709551615' }],
    badgeIds: [{ start: '1', end: '100' }],
    ownershipTimes: [{ start: '1', end: '18446744073709551615' }],
    approvalId: 'user-incoming-approval',

    // Use any approval criteria from collection examples
    approvalCriteria: {
        // See: transferable-approval.md, burnable-approval.md, etc.
        // OR use EmptyApprovalCriteria for no restrictions
        ...EmptyApprovalCriteria,
    },
};
```

## Outgoing Approvals

Control what tokens the user can send:

```typescript
const userOutgoingApproval = {
    fromListId: 'All', // Can specify senders
    toListId: 'user-address', // Locked to approver's address
    initiatedByListId: 'All',
    transferTimes: [{ start: '1', end: '18446744073709551615' }],
    badgeIds: [{ start: '1', end: '100' }],
    ownershipTimes: [{ start: '1', end: '18446744073709551615' }],
    approvalId: 'user-outgoing-approval',

    // Use any approval criteria from collection examples
    approvalCriteria: {
        // See: transferable-approval.md, burnable-approval.md, etc.
        // OR use EmptyApprovalCriteria for no restrictions
        ...EmptyApprovalCriteria,
    },
};
```

## Implementation

Users update their approvals via `MsgUpdateUserApprovals`:

```typescript
const updateUserApprovals = {
    creator: 'bb1...', // Your address
    collectionId: '1',
    updateIncomingApprovals: true,
    incomingApprovals: [userIncomingApproval],
    updateOutgoingApprovals: true,
    outgoingApprovals: [userOutgoingApproval],
    // ...
};
```

## Reference

For approval criteria examples, see:

* [Empty Approval Criteria](empty-approval-criteria.md) - No restrictions template
* [Transferable Approval](approvals/transferable-approval.md) - Basic transfer restrictions
* [Burnable Approval](approvals/burnable-approval.md) - Burn functionality
* [Building Collection Approvals](building-collection-approvals.md) - Collection-level patterns

For concepts, see:

* [Transferability / Approvals](../concepts/transferability-approvals.md)
* [Approval Criteria](broken-reference)


## File: ./x-badges/examples/building-user-permissions.md

# Building User-Level Permissions

User-level permissions allow individual users to control their ability to update their own approvals. Note that these are almost always never needed unless in advanced situations. Typically, you just leave these soft-enabled (empty arrays) for all. These are only really needed in advanced situations where you want to lock down a user's ability to update their own approvals, such as escrow accounts.

The canUpdateOutgoingApprovals and canUpdateIncomingApprovals work similarly to [canUpdateCollectionApprovals](./building-collection-permissions.md) with key restrictions. - `fromListId` is locked to the user's address for outgoing approvals - `toListId` is locked to the user's address for incoming approvals

## User Permission Structure

```typescript
const userPermissions = {
    canUpdateOutgoingApprovals: [
        {
            // fromListId: 'user-address', // Locked to user's address
            toListId: 'All', // Can specify recipients
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            badgeIds: FullTimeRanges,
            ownershipTimes: FullTimeRanges,
            approvalId: 'All',
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // Lock forever
        },
    ],
    canUpdateIncomingApprovals: [
        {
            fromListId: 'All', // Can specify senders
            //  toListId: 'user-address', // Locked to user's address
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            badgeIds: FullTimeRanges,
            ownershipTimes: FullTimeRanges,
            approvalId: 'All',
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // Lock forever
        },
    ],
    canUpdateAutoApproveSelfInitiatedOutgoingTransfers: [
        {
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges,
        },
    ],
    canUpdateAutoApproveSelfInitiatedIncomingTransfers: [
        {
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges,
    canUpdateAutoApproveAllIncomingTransfers: [
        {
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges,
        },
    ],
};
```

## Implementation

Users update their permissions via `MsgUpdateUserApprovals`:

```typescript
const updateUserApprovals = {
    creator: 'bb1...', // User's address
    collectionId: '1',
    updateUserPermissions: true,
    userPermissions,
    // ... other approval updates
};
```

## Related Examples

For permission patterns, see:

-   [Freezing Mint Transferability](./permissions/freezing-mint-transferability.md) - Collection permission example
-   [Locking Specific Approval ID](./permissions/locking-specific-approval-id.md) - Approval ID targeting
-   [Locking Specific Token IDs](./permissions/locking-specific-badge-ids.md) - Token ID targeting
-   [Building Collection Permissions](./building-collection-permissions.md) - Collection-level patterns

For user approval configuration, see:

-   [Building User Approvals](./building-user-approvals.md) - User approval setup

## Related Concepts

-   [Permissions System](../concepts/permissions/README.md) - Permission mechanics
-   [Update Approval Permission](../concepts/permissions/update-approval-permission.md) - Approval-specific controls
-   [Default Balances](../concepts/default-balances.md) - User permission structure


## File: ./x-badges/examples/cosmos-coin-wrapper-example.md

# Cosmos Coin Wrapper Tutorial

This tutorial walks you through setting up cosmos coin wrappers to bridge BitBadges with the broader Cosmos ecosystem. Cosmos coin wrappers automatically convert tokens to fungible Cosmos coins and vice versa.

## Prerequisites

-   Understanding of [Cosmos Wrapper Paths](../concepts/cosmos-wrapper-paths.md)
-   Basic knowledge of BitBadges collections and approvals

## Step 1: Set Up Your Cosmos Denominations

First, define your cosmos coin wrapper paths. For detailed information about available options, see [Cosmos Wrapper Paths](../concepts/cosmos-wrapper-paths.md).

```typescript
const cosmosCoinWrapperPaths = [ ... ];
```

## Step 2: Generate Your Special Address

When you create a collection with cosmos coin wrapper paths, the system automatically generates a special address for each wrapper. This address acts as the bridge between tokens and cosmos coins. This will also be available on the BitBadges site if you want to go that route.

```typescript
import { generateAliasAddressForDenom } from 'bitbadgesjs-sdk';

const denom = 'utoken1';
const wrapperAddress = generateAliasAddressForDenom(denom);
console.log('Wrapper Address:', wrapperAddress);
```

### Dynamic Address Generation for {id} Placeholders

The {id} is actually kept for the hash preimage, so we always have one address per wrapper path regardless of the badge ID.

## Step 3: Set Up Approvals for Wrapping/Unwrapping

The transfers still operate under the approval / transferability system. We will use the following examples from our examples section, but you can customize as you see fit. Note the need to override the wrapper address's approvals where necessary because the wrapper address is uncontrollable.

-   [Cosmos Wrapper Approval](./approvals/cosmos-wrapper-approval.md)
-   [Cosmos Unwrapper Approval](./approvals/cosmos-unwrapper-approval.md)

```typescript
const collection = {
    ...BaseCollectionDetails,
    collectionApprovalTimeline: [
        {
            timelineTimes: FullTimeRanges,
            collectionApprovals: [
                ...otherApprovals,
                wrapperApproval,
                unwrapperApproval,
            ],
        },
    ],
};
```

## Related Concepts

-   [Cosmos Wrapper Paths](../concepts/cosmos-wrapper-paths.md)
-   [Approval System](../concepts/approval-criteria/approval-system.md)
-   [Token Collections](../concepts/badge-collections.md)


## File: ./x-badges/examples/defining-circulating-supply.md

# Defining and Locking Circulating Supply

This example demonstrates how circulating supply is dynamically calculated and how to control it through mint approval management.

## Overview

Unlike traditional blockchains with set-and-forget supply mechanisms, BitBadges supply is **dynamically calculated** based on the ability to use mint approvals and the ability to create new ones or edit them.

Thus, note that if the manager can create any new Mint approval, they can theoretically increase the supply by whatever the approval allows.

## Lock Supply Forever (Fixed Cap)

```typescript
const FullTimeRanges = [
    {
        start: '1',
        end: '18446744073709551615',
    },
];

const collectionPermissions = {
    // ... other permissions
    canUpdateCollectionApprovals: [
        {
            fromListId: 'Mint', // Target all mint approvals
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            badgeIds: FullTimeRanges,
            ownershipTimes: FullTimeRanges,
            approvalId: 'All',
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // Cannot update mint approvals
        },
    ],
};
```

**Result**: All Mint approvals are final. Whatever currently possible is possible but final.

## Controlled Supply (Managed Growth)

```typescript
const collectionPermissions = {
    // ... other permissions
    canUpdateCollectionApprovals: [
        {
            fromListId: 'Mint',
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            badgeIds: FullTimeRanges,
            ownershipTimes: FullTimeRanges,
            approvalId: 'initial-mint', // Only lock initial mint approval
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges,
        },
    ],
};
```

**Result**: "initial-mint" approval locked, but manager can add new ones.

## Dynamic Supply (Fully Flexible)

```typescript
const collectionPermissions = {
    // ... other permissions
    canUpdateCollectionApprovals: [], // Soft-enabled
};
```

**Result**: Manager can always modify mint approvals and adjust supply

## Lock Specific Token IDs

```typescript
const collectionPermissions = {
    // ... other permissions
    canUpdateCollectionApprovals: [
        {
            fromListId: 'Mint',
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            badgeIds: [
                {
                    start: '1',
                    end: '100',
                },
            ],
            ownershipTimes: FullTimeRanges,
            approvalId: 'All',
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges,
        },
    ],
};
```

**Result**: The Mint approvals for tokens 1-100 are locked and final. The manager can still create new Mint approvals for other token IDs or post-mint approvals for those tokens.

## Related Examples

-   [Freezing Mint Transferability](./permissions/freezing-mint-transferability.md) - Lock all mint approvals
-   [Building Collection Approvals](./building-collection-approvals.md) - Create mint approvals
-   [Empty Approval Criteria](./empty-approval-criteria.md) - Unlimited mint template

## Related Concepts

-   [Total Supply](../concepts/total-supply.md) - Supply calculation mechanics
-   [Max Number of Transfers](../concepts/approval-criteria/max-number-of-transfers.md) - Transfer limits
-   [Permissions System](../concepts/permissions/README.md) - Permission controls


## File: ./x-badges/examples/empty-approval-criteria.md

# Empty Approval Criteria Template

When creating collection approvals with empty approval criteria, you can use this template for "no additional restrictions". We reference this for simplicity in other examples.

## Template

```typescript
const EmptyApprovalCriteria = {
    approvalCriteria: {
        // No challenges to be completed
        merkleChallenges: [],
        // No specific balances to check
        predeterminedBalances: {
            manualBalances: [],
            incrementedBalances: {
                startBalances: [],
                incrementBadgeIdsBy: '0',
                incrementOwnershipTimesBy: '0',
                durationFromTimestamp: '0',
                allowOverrideTimestamp: false,
                recurringOwnershipTimes: {
                    startTime: '0',
                    intervalLength: '0',
                    chargePeriodLength: '0',
                },
                allowOverrideWithAnyValidBadge: false,
            },
            orderCalculationMethod: {
                useOverallNumTransfers: false,
                usePerToAddressNumTransfers: false,
                usePerFromAddressNumTransfers: false,
                usePerInitiatedByAddressNumTransfers: false,
                useMerkleChallengeLeafIndex: false,
                challengeTrackerId: '',
            },
        },
        // No approval amounts to check (0 = unlimited)
        approvalAmounts: {
            overallApprovalAmount: '0',
            perToAddressApprovalAmount: '0',
            perFromAddressApprovalAmount: '0',
            perInitiatedByAddressApprovalAmount: '0',
            amountTrackerId:
                'a4ab9bc5e8752842a35a79238de4f627677ceae1d8fa9de44b52416e085f7f11',
            resetTimeIntervals: {
                startTime: '0',
                intervalLength: '0',
            },
        },
        // No max number of transfers to check (0 = unlimited)
        maxNumTransfers: {
            overallMaxNumTransfers: '0',
            perToAddressMaxNumTransfers: '0',
            perFromAddressMaxNumTransfers: '0',
            perInitiatedByAddressMaxNumTransfers: '0',
            amountTrackerId:
                'd711e23dbe57b786dfb2d86d4a6792fb8c9951a18223065ea0c07d424225a738',
            resetTimeIntervals: {
                startTime: '0',
                intervalLength: '0',
            },
        },
        // No coin transfers to execute
        coinTransfers: [],

        // No ETH signature challenges to be completed
        ethSignatureChallenges: [],
        // No dynamic store challenges to be completed
        dynamicStoreChallenges: [],

        // No address matching requirements
        requireToEqualsInitiatedBy: false,
        requireFromEqualsInitiatedBy: false,
        requireToDoesNotEqualInitiatedBy: false,
        requireFromDoesNotEqualInitiatedBy: false,
        // No overrides from outgoing approvals
        overridesFromOutgoingApprovals: false,
        // No overrides to incoming approvals
        overridesToIncomingApprovals: false,
        // No auto deletion options
        autoDeletionOptions: {
            afterOneUse: false,
            afterOverallMaxNumTransfers: false,
        },
        // No user royalties
        userRoyalties: {
            percentage: '0',
            payoutAddress: '',
        },
        // No tokens to check ownership of
        mustOwnBadges: [],
    },
};
```

## Related Documentation

* [Approval Criteria Overview](broken-reference)
* [Building Collection Approvals](building-collection-approvals.md)
* [Transferability / Approvals](../concepts/transferability-approvals.md)


## File: ./x-badges/examples/mint-all-to-self-tutorial.md

# Mint All Tokens to Self - Tutorial

This tutorial walks through the process of creating a collection and minting all tokens to yourself in a single transaction. This is useful for creating collections where you want to control the initial distribution.

## Overview

This is a two-step process that can be executed as a single multi-message transaction:

1. **Create Collection** with a mint approval that allows you to mint tokens
2. **Execute Transfer** using that approval to mint tokens to yourself

## Step 1: Create Mint Approval

First, create an approval that allows you to mint tokens from the "Mint" address:

```typescript
// Step 1: Set up your mint approval
const mintApproval = {
    fromListId: 'Mint', // From the mint address
    toListId: 'All', // To any address
    initiatedByListId: myAddress, // Only you can initiate
    transferTimes: UintRangeArray.FullRanges(),
    badgeIds: UintRangeArray.FullRanges(), // All token IDs
    ownershipTimes: UintRangeArray.FullRanges(),
    approvalId: 'mint-approval',
    version: 0n,
    approvalCriteria: {
        // No restrictions - you can mint unlimited amounts
        ...defaultNoRestrictionsApprovalCriteria,
        overridesFromOutgoingApprovals: true, // Required for mint address
    },
};

// Step 1: Create your collection with the mint approval
const collection = {
    ...BaseCollectionDetails,
    collectionApprovalTimeline: [
        {
            timelineTimes: FullTimeRanges,
            collectionApprovals: [mintApproval, ...otherApprovals],
        },
    ],
};

// Create the collection
```

## Step 2: Execute Mint Transfer

After creating the collection, use the mint approval to transfer tokens to yourself:

```typescript
// Step 2: Mint tokens to yourself using the approval
const transfers = [
    {
        from: 'Mint', // From mint address
        toAddresses: [myAddress], // To your address
        balances: [
            {
                badgeIds: [{ start: 1n, end: 100n }],
                ownershipTimes: UintRangeArray.FullRanges(),
                amount: 100n,
            },
        ],
        // ... other transfer details
    },
];
```

## Related Concepts

-   [Building Collection Approvals](./building-collection-approvals.md)
-   [Admin Override Approval](./approvals/admin-override-approval.md)
-   [Mint Escrow Address](../concepts/mint-escrow-address.md)
-   [MsgTransferBadges](../messages/msg-transfer-badges.md)


## File: ./x-badges/examples/msg-transfer/README.md

# Message Transfer Examples

This section contains practical examples of token transfer messages for the BitBadges protocol.

## Examples

-   [Simple Token Transfer](simple-badge-transfer.md) - Basic mint-to-address transfer example
-   [Transfer with Precalculation](transfer-with-precalculation.md) - Transfer using approval-based precalculation


## File: ./x-badges/examples/msg-transfer/simple-badge-transfer.md

# Simple Token Transfer

This example demonstrates a basic token transfer from the mint to a specific address.

## Overview

This transfer creates token ID 1 from collection 20 and sends it to the creator address. The token has full ownership time range and uses collection-level approval.

## Transfer Details

-   **Collection ID**: 20
-   **Token ID**: 1
-   **Amount**: 1
-   **From**: Mint (new token creation)
-   **To**: Creator address
-   **Approval**: Collection-level approval (assumes user-level approvals successfully auto-scan)

## JSON Structure

```json
[
    {
        "creator": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
        "collectionId": "20",
        "transfers": [
            {
                "from": "Mint",
                "toAddresses": ["bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl"],
                "balances": [
                    {
                        "amount": "1",
                        "ownershipTimes": [
                            {
                                "start": "1",
                                "end": "18446744073709551615"
                            }
                        ],
                        "badgeIds": [
                            {
                                "start": "1",
                                "end": "1"
                            }
                        ]
                    }
                ],
                "precalculateBalancesFromApproval": {
                    "approvalId": "",
                    "approvalLevel": "",
                    "approverAddress": "",
                    "version": "0"
                },
                "merkleProofs": [],
                "ethSignatureProofs": [],
                "memo": "",
                "prioritizedApprovals": [
                    {
                        "approvalId": "4a1ed47db7bc0f9f7174eab12aa9b8c9b9e4e37474ca2264668cf8e1b1598dde",
                        "approvalLevel": "collection",
                        "approverAddress": "",
                        "version": "0"
                    }
                ],
                "onlyCheckPrioritizedCollectionApprovals": true,
                "onlyCheckPrioritizedIncomingApprovals": false,
                "onlyCheckPrioritizedOutgoingApprovals": false,
                "affiliateAddress": "",
                "numAttempts": "1"
            }
        ]
    }
]
```

## Key Components Explained

### Transfer Source

-   `"from": "Mint"` - Indicates this is a new token creation from the mint

### Destination

-   `"toAddresses": ["bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl"]` - The recipient address

### Balance Specification

-   `"amount": "1"` - Transfer 1 token
-   `"ownershipTimes"` - Full ownership time range (1 to max uint64)
-   `"badgeIds"` - Specific token ID range (1 to 1)

### Approval Configuration

-   `"prioritizedApprovals"` - Uses collection-level approval
-   `"onlyCheckPrioritizedCollectionApprovals": true` - Only check collection approvals
-   `"approvalId"` - Specific approval identifier for the collection

### Additional Settings

-   `"merkleProofs": []` - No merkle proofs required for this simple transfer
-   `"ethSignatureProofs": []` - No ETH signature proofs required for this simple transfer
-   `"memo": ""` - No memo attached
-   `"numAttempts": "1"` - Single transfer attempt

## Usage

This example can be used as a template for basic token minting operations where you want to create a new token and transfer it to a specific address using collection-level approval.


## File: ./x-badges/examples/msg-transfer/transfer-with-precalculation.md

# Transfer with Precalculation

This example demonstrates a token transfer that uses precalculation from approval criteria instead of manually specifying balances.

## Overview

This transfer creates tokens from collection 20 and sends them to the creator address. Instead of manually specifying the balance amounts, it uses precalculation from the approval criteria to determine what tokens to transfer.

## Transfer Details

-   **Collection ID**: 20
-   **From**: Mint (new token creation)
-   **To**: Creator address
-   **Approval**: Collection-level approval with precalculation
-   **Precalculation**: Enabled with specific approval ID

## JSON Structure

```json
[
    {
        "creator": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
        "collectionId": "20",
        "transfers": [
            {
                "from": "Mint",
                "toAddresses": ["bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl"],
                "balances": [],
                "precalculateBalancesFromApproval": {
                    "approvalId": "fd1cef5941fb08487ecc1038af09fb29a6d7d40a89d8e4889c9c954978aa7e41",
                    "approvalLevel": "collection",
                    "approverAddress": "",
                    "version": "0"
                },
                "merkleProofs": [],
                "ethSignatureProofs": [],
                "memo": "",
                "prioritizedApprovals": [
                    {
                        "approvalId": "fd1cef5941fb08487ecc1038af09fb29a6d7d40a89d8e4889c9c954978aa7e41",
                        "approvalLevel": "collection",
                        "approverAddress": "",
                        "version": "0"
                    }
                ],
                "onlyCheckPrioritizedCollectionApprovals": true,
                "onlyCheckPrioritizedIncomingApprovals": false,
                "onlyCheckPrioritizedOutgoingApprovals": false,
                "precalculationOptions": {
                    "overrideTimestamp": "0",
                    "badgeIdsOverride": []
                },
                "affiliateAddress": "",
                "numAttempts": "1"
            }
        ]
    }
]
```

## Key Components Explained

### Precalculation Configuration

-   `"balances": []` - Empty balances array since amounts are calculated from approval
-   `"precalculateBalancesFromApproval"` - Specifies which approval to use for calculation
-   `"approvalId"` - The specific approval ID that defines the transfer criteria

### Prioritized Approvals

-   `"prioritizedApprovals"` - Uses the same approval ID for both precalculation and transfer
-   `"onlyCheckPrioritizedCollectionApprovals": true` - Only check collection-level approvals
-   `"onlyCheckPrioritizedIncomingApprovals": false` - Skip incoming approval checks
-   `"onlyCheckPrioritizedOutgoingApprovals": false` - Skip outgoing approval checks

### Precalculation Options

-   `"overrideTimestamp": "0"` - Use current timestamp for calculations
-   `"badgeIdsOverride": []` - No token ID overrides, use approval criteria

### Non-Auto-Scan Behavior

This example demonstrates "prioritized non-auto-scan" behavior where:

-   Only the specified approval is checked (no automatic scanning of other approvals)
-   The system doesn't automatically look for other valid approvals
-   Transfer is limited to what the specified approval allows
-   Can use approvals with side effects and custom criteria like merkle challenges and ETH signature challenges
-   Shows proper versioning of approvals

## Usage

This example is useful when:

-   You want to transfer tokens based on approval criteria rather than manual specification
-   You need precise control over which approval is used
-   You want to avoid automatic approval scanning
-   The approval criteria dynamically determine amounts and IDs

## Differences from Simple Transfer

| Feature               | Simple Transfer      | Precalculation Transfer   |
| --------------------- | -------------------- | ------------------------- |
| Balance Specification | Manual amounts       | Calculated from approval  |
| Approval Scanning     | Auto-scan enabled    | Only specified approval   |
| Flexibility           | Fixed amounts        | Dynamic based on criteria |
| Control               | Direct specification | Approval-driven           |
****

## File: ./x-badges/examples/permissions/README.md

# Permission Examples

This directory contains practical examples of different permission configurations for collections. Each example demonstrates specific patterns and use cases for controlling collection management.

## Contents

-   [Freezing Mint Transferability](freezing-mint-transferability.md) - Permanently freeze minting capabilities
-   [Locking Specific Approval ID](locking-specific-approval-id.md) - Lock specific approval IDs with granular control
-   [Locking Specific Token IDs](locking-specific-badge-ids.md) - Lock approvals for specific token ID ranges
-   [Locking Valid Token IDs](locking-valid-badge-ids.md) - Control valid token ID range updates

## Permission System Overview

BitBadges permissions follow a timeline-based system where:

1. **Permanently Permitted Times** - Permission is always allowed
2. **Permanently Forbidden Times** - Permission is always denied
3. **Default (Empty)** - Permission is soft-enabled (manager can change)

## Common Patterns

-   **No Manager** - Set manager to empty string to disable all management
-   **Complete Control** - Empty permission arrays for full soft-enabled control
-   **Locked Forever** - Use `permanentlyForbiddenTimes: FullTimeRanges`
-   **Time-Limited** - Use specific time ranges for temporary control

## Related Concepts

-   [Permission System](../../concepts/permissions/permission-system.md)
-   [Manager](../../concepts/manager.md)
-   [Timeline System](../../concepts/timeline-system.md)


## File: ./x-badges/examples/permissions/freezing-mint-transferability.md

# Freezing Mint Transferability

This example demonstrates how to permanently freeze minting capabilities by making mint-related collection approvals immutable.

## Overview

By setting `permanentlyForbiddenTimes` for mint approval updates, you can ensure that no new minting approvals can be added and existing ones cannot be modified.

## Permission Configuration

```typescript
const FullTimeRanges = [
    {
        start: '1',
        end: '18446744073709551615',
    },
];

const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateValidBadgeIds: [],
    canUpdateBadgeMetadata: [],
    canUpdateCollectionApprovals: [
        {
            // Which approvals does this permission apply to? Approvals must match ALL criteria.
            fromListId: 'Mint',
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            badgeIds: FullTimeRanges,
            ownershipTimes: FullTimeRanges,
            approvalId: 'All',

            // What is status of this approval at any given time? (Unhandled = soft-enabled)
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges,
        },
    ],
};
```

## Implementation

```typescript
const createCollection = {
    // ... other collection fields
    collectionPermissions,
    collectionApprovals: [
        // Include any initial mint approvals here
        // These will be the ONLY mint approvals ever possible
        {
            fromListId: 'Mint',
            toListId: 'creator-address',
            // ... initial mint approval configuration
        },
    ],
};
```

## Important Notes

### ⚠️ Irreversible Action

Once set to permanently forbidden, mint permissions cannot be restored. Carefully configure initial mint approvals before freezing. Ensure all mint approvals you will ever need are set.

## Related Examples

-   [Building Collection Permissions](../building-collection-permissions.md) - General permission patterns
-   [Building Collection Approvals](../building-collection-approvals.md) - Approval configuration

## Related Concepts

-   [Permissions System](../../concepts/permissions/README.md) - Permission mechanics
-   [Collection Permissions](../../concepts/permissions/permission-system.md) - Collection-level controls
-   [Action Permissions](../../concepts/permissions/action-permission.md) - Specific action controls


## File: ./x-badges/examples/permissions/locking-specific-approval-id.md

# Locking Specific Approval ID

This example demonstrates how to permanently lock a specific approval ID while keeping other approvals updatable.

## Overview

By targeting a specific `approvalId`, you can freeze that approval permanently while allowing updates to other approvals. The `!` operator can be used to target all approvals EXCEPT a specific ID.

## Lock Specific Approval ID

```typescript
const FullTimeRanges = [
    {
        start: '1',
        end: '18446744073709551615',
    },
];

const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateValidBadgeIds: [],
    canUpdateBadgeMetadata: [],
    canUpdateCollectionApprovals: [
        {
            // Which approvals does this permission apply to? Approvals must match ALL criteria.
            fromListId: 'All',
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            badgeIds: FullTimeRanges,
            ownershipTimes: FullTimeRanges,
            approvalId: 'abc123', // Only targets this specific approval ID

            // What is status of this approval at any given time? (Unhandled = soft-enabled)
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // Permanently locked
        },
    ],
};
```

## Lock All EXCEPT Specific Approval ID

```typescript
const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateValidBadgeIds: [],
    canUpdateBadgeMetadata: [],
    canUpdateCollectionApprovals: [
        {
            // Which approvals does this permission apply to? Approvals must match ALL criteria.
            fromListId: 'All',
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            badgeIds: FullTimeRanges,
            ownershipTimes: FullTimeRanges,
            approvalId: '!abc123', // All approvals EXCEPT abc123

            // What is status of this approval at any given time? (Unhandled = soft-enabled)
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // All others permanently locked
        },
    ],
};
```

## Implementation

```typescript
const createCollection = {
    // ... other collection fields
    collectionPermissions,
    collectionApprovals: [
        {
            approvalId: 'abc123',
            // ... this approval will be locked/unlocked based on configuration
        },
        {
            approvalId: 'other-approval',
            // ... this approval's updateability depends on configuration
        },
    ],
};
```

## Related Examples

-   [Freezing Mint Transferability](./freezing-mint-transferability.md) - Lock all mint approvals
-   [Building Collection Permissions](../building-collection-permissions.md) - General permission patterns

## Related Concepts

-   [Permissions System](../../concepts/permissions/README.md) - Permission mechanics
-   [Update Approval Permission](../../concepts/permissions/update-approval-permission.md) - Approval-specific controls


## File: ./x-badges/examples/permissions/locking-specific-badge-ids.md

# Locking Specific Token IDs

This example demonstrates how to permanently lock approvals for specific token IDs while keeping other approvals updatable.

## Overview

By targeting specific `badgeIds`, you can freeze approvals for those tokens permanently while allowing updates to approvals for other token IDs.

## Lock Token IDs 1-100

```typescript
const FullTimeRanges = [
    {
        start: '1',
        end: '18446744073709551615',
    },
];

const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateValidBadgeIds: [],
    canUpdateBadgeMetadata: [],
    canUpdateCollectionApprovals: [
        {
            // Which approvals does this permission apply to? Approvals must match ALL criteria.
            fromListId: 'All',
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            badgeIds: [
                {
                    start: '1',
                    end: '100', // Only targets tokens 1-100
                },
            ],
            ownershipTimes: FullTimeRanges,
            approvalId: 'All',

            // What is status of this approval at any given time? (Unhandled = soft-enabled)
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // Permanently locked
        },
    ],
};
```

## Lock All Tokens EXCEPT 1-100

```typescript
const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateValidBadgeIds: [],
    canUpdateBadgeMetadata: [],
    canUpdateCollectionApprovals: [
        {
            // Which approvals does this permission apply to? Approvals must match ALL criteria.
            fromListId: 'All',
            toListId: 'All',
            initiatedByListId: 'All',
            transferTimes: FullTimeRanges,
            badgeIds: [
                {
                    start: '101',
                    end: '18446744073709551615', // All tokens except 1-100
                },
            ],
            ownershipTimes: FullTimeRanges,
            approvalId: 'All',

            // What is status of this approval at any given time? (Unhandled = soft-enabled)
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // All others permanently locked
        },
    ],
};
```

## Implementation

```typescript
const createCollection = {
    // ... other collection fields
    collectionPermissions,
    collectionApprovals: [
        {
            badgeIds: [{ start: '1', end: '50' }],
            // ... this approval will be locked if it overlaps with permission criteria
        },
        {
            badgeIds: [{ start: '150', end: '200' }],
            // ... this approval's updateability depends on configuration
        },
    ],
};
```

## Use Cases

- **Lock Founder Tokens**: Prevent modification of special token 1-100 transfer rules
- **Preserve Rare Items**: Keep limited edition tokens (1-100) immutable
- **Tier-Based Control**: Lock specific tiers while allowing others to evolve

## Important Notes

### ⚠️ ID Range Targeting

The permission only applies to approvals that overlap with the specified token ID ranges. Approvals targeting token IDs outside the range remain updatable.

## Related Examples

- [Locking Specific Approval ID](./locking-specific-approval-id.md) - Lock by approval ID
- [Freezing Mint Transferability](./freezing-mint-transferability.md) - Lock all mint approvals

## Related Concepts

- [Permissions System](../../concepts/permissions/README.md) - Permission mechanics
- [Timed Update With Token IDs Permission](../../concepts/permissions/timed-update-with-badge-ids-permission.md) - Token-specific controls

## File: ./x-badges/examples/permissions/locking-valid-badge-ids.md

# Locking Valid Token IDs

This example demonstrates how to control updates to the `validBadgeIds` field, either locking it permanently or allowing controlled expansion. The `validBadgeIds` field is used to control which token IDs are considered valid for the collection.

## Overview

The `canUpdateValidBadgeIds` permission controls whether the valid token ID ranges can be modified.

## Lock Valid Token IDs Forever

```typescript
const FullTimeRanges = [
    {
        start: '1',
        end: '18446744073709551615',
    },
];

const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateValidBadgeIds: [
        {
            // Which token IDs does this permission apply to?
            badgeIds: FullTimeRanges, // All token IDs

            // What is status of this permission at any given time?
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // Never allowed to update
        },
    ],
    canUpdateBadgeMetadata: [],
    canUpdateCollectionApprovals: [],
};
```

## Lock Token IDs 1-100, Allow Future Expansion

```typescript
const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canUpdateValidBadgeIds: [
        {
            // Which token IDs does this permission apply to?
            badgeIds: [
                {
                    start: '1',
                    end: '100', // Only applies to tokens 1-100
                },
            ],

            // What is status of this permission at any given time?
            permanentlyPermittedTimes: [],
            permanentlyForbiddenTimes: FullTimeRanges, // Token IDs 1-100 locked forever
        },
        // Token IDs 101+ remain soft-enabled (can be updated by manager)
    ],
    canUpdateBadgeMetadata: [],
    canUpdateCollectionApprovals: [],
};
```

## Implementation

```typescript
const createCollection = {
    // ... other collection fields
    collectionPermissions,
    validBadgeIds: [
        {
            start: '1',
            end: '100', // Initial valid range
        },
    ],
};
```

## Important Notes

### ⚠️ Token ID Targeting

-   Permissions only apply to the specified token ID ranges
-   Unspecified ranges remain soft-enabled for manager updates
-   Cannot reduce valid token IDs once locked (only expansion possible for unlocked ranges)

## Related Examples

-   [Locking Specific Token IDs](./locking-specific-badge-ids.md) - Lock approval updates for token ranges
-   [Freezing Mint Transferability](./freezing-mint-transferability.md) - Lock mint approvals

## Related Concepts

-   [Valid Token IDs](../../concepts/valid-badge-ids.md) - Token ID range concept
-   [Token IDs Action Permission](../../concepts/permissions/balances-action-permission.md) - Token-specific permission controls


## File: ./x-badges/examples/txs/README.md

# Transaction Examples

This directory contains complete transaction examples for the x/badges module.

## Contents

-   [MsgCreateCollection](msgcreatecollection/) - Examples for creating collections
-   [MsgUpdateUserApprovals](msgupdate-user-approvals/) - Examples for updating user-level approvals


## File: ./x-badges/examples/txs/msgcreatecollection/README.md

# MsgCreateCollection Examples

This directory contains complete examples for creating collections using the `MsgCreateCollection` transaction.

## Contents

-   [Quest Token Collection](quest-badge-collection.md) - Example of creating a quest collection with Merkle proofs
-   [Tradable NFT Collection](tradable-nft-collection.md) - Example of creating a tradable NFT collection for marketplace trading


## File: ./x-badges/examples/txs/msgcreatecollection/quest-badge-collection.md

# Quest Token Collection Example

This example demonstrates creating a quest collection.

## Transaction Structure

```json
[
    {
        "creator": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
        "collectionId": "0",
        "defaultBalances": {
            "balances": [],
            "outgoingApprovals": [],
            "incomingApprovals": [],
            "autoApproveSelfInitiatedOutgoingTransfers": true,
            "autoApproveSelfInitiatedIncomingTransfers": true,
            "autoApproveAllIncomingTransfers": true,
            "userPermissions": {
                "canUpdateOutgoingApprovals": [],
                "canUpdateIncomingApprovals": [],
                "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [],
                "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [],
                "canUpdateAutoApproveAllIncomingTransfers": []
            }
        },
        "validBadgeIds": [
            {
                "start": "1",
                "end": "1"
            }
        ],
        "collectionPermissions": {
            "canDeleteCollection": [],
            "canArchiveCollection": [],
            "canUpdateStandards": [],
            "canUpdateCustomData": [],
            "canUpdateManager": [],
            "canUpdateCollectionMetadata": [],
            "canUpdateValidBadgeIds": [],
            "canUpdateBadgeMetadata": [],
            "canUpdateCollectionApprovals": []
        },
        "managerTimeline": [
            {
                "manager": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
                "timelineTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ]
            }
        ],
        "collectionMetadataTimeline": [
            {
                "collectionMetadata": {
                    "uri": "ipfs://QmRbRYYyphz73apphqP3QQmkeZxbtMWmAxasGfhcw1RApD",
                    "customData": ""
                },
                "timelineTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ]
            }
        ],
        "badgeMetadataTimeline": [
            {
                "badgeMetadata": [
                    {
                        "uri": "ipfs://QmRbRYYyphz73apphqP3QQmkeZxbtMWmAxasGfhcw1RApD",
                        "customData": "",
                        "badgeIds": [
                            {
                                "start": "1",
                                "end": "18446744073709551615"
                            }
                        ]
                    }
                ],
                "timelineTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ]
            }
        ],
        "customDataTimeline": [],
        "collectionApprovals": [
            {
                "fromListId": "Mint",
                "toListId": "All",
                "initiatedByListId": "All",
                "transferTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "badgeIds": [
                    {
                        "start": "1",
                        "end": "1"
                    }
                ],
                "ownershipTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "uri": "ipfs://QmPUAjAPMDQMJZV8mpnaYbhBu2BUS4u449c7KsRNZip9uf",
                "customData": "",
                "approvalId": "quests-approval",
                "approvalCriteria": {
                    "merkleChallenges": [
                        {
                            "root": "5958c51f7c54d8e27ac42a9a2f03069c1412071abb87bf0e7be0dde790a82dbb",
                            "expectedProofLength": "0",
                            "useCreatorAddressAsLeaf": false,
                            "maxUsesPerLeaf": "1",
                            "uri": "ipfs://QmRsSK3Fw63bcJPuiYutNfBK3TYdnB8X5QG8W6ksVMuNcH",
                            "customData": "",
                            "challengeTrackerId": "1c5b9f3c390d26981996a6b593fe42300023b0e43534954a73075b912d9ca2e6",
                            "leafSigner": "0xa612B14Ff99DAe9FBC9613bF4553781086c5F887"
                        }
                    ],
                    "ethSignatureChallenges": [],
                    "predeterminedBalances": {
                        "manualBalances": [],
                        "incrementedBalances": {
                            "startBalances": [
                                {
                                    "amount": "1",
                                    "ownershipTimes": [
                                        {
                                            "start": "1",
                                            "end": "18446744073709551615"
                                        }
                                    ],
                                    "badgeIds": [
                                        {
                                            "start": "1",
                                            "end": "1"
                                        }
                                    ]
                                }
                            ],
                            "incrementBadgeIdsBy": "0",
                            "incrementOwnershipTimesBy": "0",
                            "durationFromTimestamp": "0",
                            "allowOverrideTimestamp": false,
                            "recurringOwnershipTimes": {
                                "startTime": "0",
                                "intervalLength": "0",
                                "chargePeriodLength": "0"
                            },
                            "allowOverrideWithAnyValidBadge": false
                        },
                        "orderCalculationMethod": {
                            "useOverallNumTransfers": true,
                            "usePerToAddressNumTransfers": false,
                            "usePerFromAddressNumTransfers": false,
                            "usePerInitiatedByAddressNumTransfers": false,
                            "useMerkleChallengeLeafIndex": false,
                            "challengeTrackerId": ""
                        }
                    },
                    "approvalAmounts": {
                        "overallApprovalAmount": "0",
                        "perToAddressApprovalAmount": "0",
                        "perFromAddressApprovalAmount": "0",
                        "perInitiatedByAddressApprovalAmount": "0",
                        "amountTrackerId": "quests-approval",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "maxNumTransfers": {
                        "overallMaxNumTransfers": "1",
                        "perToAddressMaxNumTransfers": "0",
                        "perFromAddressMaxNumTransfers": "0",
                        "perInitiatedByAddressMaxNumTransfers": "0",
                        "amountTrackerId": "quests-approval",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "coinTransfers": [
                        {
                            "to": "",
                            "coins": [
                                {
                                    "denom": "ubadge",
                                    "amount": "5000000000"
                                }
                            ],
                            "overrideFromWithApproverAddress": true,
                            "overrideToWithInitiator": true
                        }
                    ],
                    "requireToEqualsInitiatedBy": false,
                    "requireFromEqualsInitiatedBy": false,
                    "requireToDoesNotEqualInitiatedBy": false,
                    "requireFromDoesNotEqualInitiatedBy": false,
                    "overridesFromOutgoingApprovals": true,
                    "overridesToIncomingApprovals": false,
                    "autoDeletionOptions": {
                        "afterOneUse": false,
                        "afterOverallMaxNumTransfers": false
                    },
                    "userRoyalties": {
                        "percentage": "0",
                        "payoutAddress": ""
                    },
                    "mustOwnBadges": []
                },
                "version": "0"
            }
        ],
        "standardsTimeline": [
            {
                "standards": ["Quests"],
                "timelineTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ]
            }
        ],
        "isArchivedTimeline": [],
        "mintEscrowCoinsToTransfer": [
            {
                "denom": "ubadge",
                "amount": "5000000000"
            }
        ],
        "cosmosCoinWrapperPathsToAdd": []
    }
]
```

## Key Features

### Quest Token Collection

This example creates a quest collection with the following characteristics:

-   **Single Token**: Only token ID 1 is valid (`validBadgeIds: [{"start": "1", "end": "1"}]`)
-   **Quest Standard**: Uses the "Quests" standard for quest-related functionality
-   **Merkle Proof Verification**: Requires users to provide valid Merkle proofs (BitBadges claims) to claim tokens
-   **Coin Rewards**: Transfers 5000000000 ubadge coins to successful claimants and properly handles the Mint escrow coins

### Approval System

#### Collection Approval (Minting)

-   **From/To**: Mint → All users
-   **Merkle Challenge**: Root hash `5958c51f7c54d8e27ac42a9a2f03069c1412071abb87bf0e7be0dde790a82dbb`
-   **Leaf Signer**: `0xa612B14Ff99DAe9FBC9613bF4553781086c5F887` (Ethereum address)
-   **Max Uses**: 1 per leaf, overall max 1 transfer
-   **Coin Transfer**: 5000000000 ubadge coins per successful claim

#### Default User Approvals

-   **Incoming**: Allows all incoming transfers from any source
-   **Auto-approve**: Self-initiated transfers are automatically approved
-   **User Permissions**: No user permissions to update approvals (all soft-enabled)

### Manager and Permissions

-   **Manager**: `bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl` (one manager)
-   **Collection Permissions**: All permissions are empty (all soft-enabled)
-   **Timeline**: All configurations are forever (start: 1, end: max uint64)

### Metadata

-   **Collection URI**: `ipfs://QmRbRYYyphz73apphqP3QQmkeZxbtMWmAxasGfhcw1RApD`
-   **Token URI**: Same as collection URI for all tokens
-   **Approval URI**: `ipfs://QmPUAjAPMDQMJZV8mpnaYbhBu2BUS4u449c7KsRNZip9uf`
-   **Challenge URI**: `ipfs://QmRsSK3Fw63bcJPuiYutNfBK3TYdnB8X5QG8W6ksVMuNcH`

### Escrow and Funding

-   **Mint Escrow**: 5000000000 ubadge coins are escrowed to fund the coin transfers
-   **No Cosmos Coin Wrapper**: Empty `cosmosCoinWrapperPathsToAdd` array. No wrapping allowed.


## File: ./x-badges/examples/txs/msgcreatecollection/tradable-nft-collection.md

# Tradable Collection Example

This example demonstrates creating a tradable collection that supports orderbook-style trading through the [Tradable Protocol](../../../concepts/protocols/tradable-protocol.md).

## Transaction Structure

```json
[
    {
        "creator": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
        "collectionId": "0",
        "defaultBalances": {
            "balances": [],
            "outgoingApprovals": [],
            "incomingApprovals": [],
            "autoApproveSelfInitiatedOutgoingTransfers": true,
            "autoApproveSelfInitiatedIncomingTransfers": true,
            "autoApproveAllIncomingTransfers": true,
            "userPermissions": {
                "canUpdateOutgoingApprovals": [],
                "canUpdateIncomingApprovals": [],
                "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [],
                "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [],
                "canUpdateAutoApproveAllIncomingTransfers": []
            }
        },
        "validBadgeIds": [
            {
                "start": "1",
                "end": "100"
            }
        ],
        "collectionPermissions": {
            "canDeleteCollection": [],
            "canArchiveCollection": [],
            "canUpdateStandards": [],
            "canUpdateCustomData": [],
            "canUpdateManager": [],
            "canUpdateCollectionMetadata": [],
            "canUpdateValidBadgeIds": [],
            "canUpdateBadgeMetadata": [],
            "canUpdateCollectionApprovals": []
        },
        "managerTimeline": [
            {
                "manager": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
                "timelineTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ]
            }
        ],
        "collectionMetadataTimeline": [
            {
                "collectionMetadata": {
                    "uri": "ipfs://QmdqD7VE4MTZz2V1XeCBqdFcQ9orE6a4PEUzbFi2SfFxoR",
                    "customData": ""
                },
                "timelineTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ]
            }
        ],
        "badgeMetadataTimeline": [
            {
                "badgeMetadata": [
                    {
                        "uri": "ipfs://QmRbRYYyphz73apphqP3QQmkeZxbtMWmAxasGfhcw1RApD",
                        "customData": "",
                        "badgeIds": [
                            {
                                "start": "101",
                                "end": "18446744073709551615"
                            }
                        ]
                    },
                    {
                        "uri": "ipfs://QmdqD7VE4MTZz2V1XeCBqdFcQ9orE6a4PEUzbFi2SfFxoR",
                        "customData": "",
                        "badgeIds": [
                            {
                                "start": "1",
                                "end": "100"
                            }
                        ]
                    }
                ],
                "timelineTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ]
            }
        ],
        "customDataTimeline": [],
        "collectionApprovals": [
            {
                "fromListId": "Mint",
                "toListId": "All",
                "initiatedByListId": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
                "transferTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "badgeIds": [
                    {
                        "start": "1",
                        "end": "100"
                    }
                ],
                "ownershipTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "uri": "",
                "customData": "",
                "approvalId": "a4ab9bc5e8752842a35a79238de4f627677ceae1d8fa9de44b52416e085f7f11",
                "approvalCriteria": {
                    "merkleChallenges": [],
                    "ethSignatureChallenges": [],
                    "predeterminedBalances": {
                        "manualBalances": [],
                        "incrementedBalances": {
                            "startBalances": [],
                            "incrementBadgeIdsBy": "0",
                            "incrementOwnershipTimesBy": "0",
                            "durationFromTimestamp": "0",
                            "allowOverrideTimestamp": false,
                            "recurringOwnershipTimes": {
                                "startTime": "0",
                                "intervalLength": "0",
                                "chargePeriodLength": "0"
                            },
                            "allowOverrideWithAnyValidBadge": false
                        },
                        "orderCalculationMethod": {
                            "useOverallNumTransfers": false,
                            "usePerToAddressNumTransfers": false,
                            "usePerFromAddressNumTransfers": false,
                            "usePerInitiatedByAddressNumTransfers": false,
                            "useMerkleChallengeLeafIndex": false,
                            "challengeTrackerId": ""
                        }
                    },
                    "approvalAmounts": {
                        "overallApprovalAmount": "0",
                        "perToAddressApprovalAmount": "0",
                        "perFromAddressApprovalAmount": "0",
                        "perInitiatedByAddressApprovalAmount": "0",
                        "amountTrackerId": "a4ab9bc5e8752842a35a79238de4f627677ceae1d8fa9de44b52416e085f7f11",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "maxNumTransfers": {
                        "overallMaxNumTransfers": "0",
                        "perToAddressMaxNumTransfers": "0",
                        "perFromAddressMaxNumTransfers": "0",
                        "perInitiatedByAddressMaxNumTransfers": "0",
                        "amountTrackerId": "d711e23dbe57b786dfb2d86d4a6792fb8c9951a18223065ea0c07d424225a738",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "coinTransfers": [],
                    "requireToEqualsInitiatedBy": false,
                    "requireFromEqualsInitiatedBy": false,
                    "requireToDoesNotEqualInitiatedBy": false,
                    "requireFromDoesNotEqualInitiatedBy": false,
                    "overridesFromOutgoingApprovals": true,
                    "overridesToIncomingApprovals": true,
                    "autoDeletionOptions": {
                        "afterOneUse": false,
                        "afterOverallMaxNumTransfers": false
                    },
                    "userRoyalties": {
                        "percentage": "0",
                        "payoutAddress": ""
                    },
                    "mustOwnBadges": []
                },
                "version": "0"
            },
            {
                "fromListId": "!Mint",
                "toListId": "All",
                "initiatedByListId": "All",
                "transferTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "badgeIds": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "ownershipTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "uri": "",
                "customData": "",
                "approvalId": "transferable-approval",
                "approvalCriteria": {
                    "merkleChallenges": [],
                    "ethSignatureChallenges": [],
                    "predeterminedBalances": {
                        "manualBalances": [],
                        "incrementedBalances": {
                            "startBalances": [],
                            "incrementBadgeIdsBy": "0",
                            "incrementOwnershipTimesBy": "0",
                            "durationFromTimestamp": "0",
                            "allowOverrideTimestamp": false,
                            "recurringOwnershipTimes": {
                                "startTime": "0",
                                "intervalLength": "0"
                            },
                            "allowOverrideWithAnyValidBadge": false
                        },
                        "orderCalculationMethod": {
                            "useOverallNumTransfers": false,
                            "usePerToAddressNumTransfers": false,
                            "usePerFromAddressNumTransfers": false,
                            "usePerInitiatedByAddressNumTransfers": false,
                            "useMerkleChallengeLeafIndex": false,
                            "challengeTrackerId": ""
                        }
                    },
                    "approvalAmounts": {
                        "overallApprovalAmount": "0",
                        "perToAddressApprovalAmount": "0",
                        "perFromAddressApprovalAmount": "0",
                        "perInitiatedByAddressApprovalAmount": "0",
                        "amountTrackerId": "d79af272f33e76e5ba77c4edc356ad5b2e4014dd93ec7cea2b45ba56c65e11ac",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "maxNumTransfers": {
                        "overallMaxNumTransfers": "0",
                        "perToAddressMaxNumTransfers": "0",
                        "perFromAddressMaxNumTransfers": "0",
                        "perInitiatedByAddressMaxNumTransfers": "0",
                        "amountTrackerId": "d79af272f33e76e5ba77c4edc356ad5b2e4014dd93ec7cea2b45ba56c65e11ac",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "coinTransfers": [],
                    "requireToEqualsInitiatedBy": false,
                    "requireFromEqualsInitiatedBy": false,
                    "requireToDoesNotEqualInitiatedBy": false,
                    "requireFromDoesNotEqualInitiatedBy": false,
                    "overridesFromOutgoingApprovals": false,
                    "overridesToIncomingApprovals": false,
                    "autoDeletionOptions": {
                        "afterOneUse": false,
                        "afterOverallMaxNumTransfers": false
                    },
                    "userRoyalties": {
                        "percentage": "0",
                        "payoutAddress": ""
                    },
                    "mustOwnBadges": []
                },
                "version": "0"
            }
        ],
        "standardsTimeline": [
            {
                "standards": [
                    "Tradable",
                    "NFTs",
                    "DefaultDisplayCurrency:ibc/F082B65C88E4B6D5EF1DB243CDA1D331D002759E938A0F5CD3FFDC5D53B3E349"
                ],
                "timelineTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ]
            }
        ],
        "isArchivedTimeline": [],
        "mintEscrowCoinsToTransfer": [],
        "cosmosCoinWrapperPathsToAdd": [] // No wrapping allowed
    }
]
```

## Protocol Compliance

This collection follows the [Tradable Protocol](../../../concepts/protocols/tradable-protocol.md) requirements:

-   ✅ Includes "Tradable" in standards timeline
-   ✅ Compatible with both fungible and non-fungible tokens
-   ✅ Supports orderbook-style trading
-   ✅ No restrictions on bid/listing creation
-   ✅ Enables decentralized marketplace functionality


## File: ./x-badges/examples/txs/msgupdate-user-approvals/README.md

# MsgUpdateUserApprovals Examples

This directory contains complete examples for updating user-level approvals using the `MsgUpdateUserApprovals` transaction.

## Contents

-   [Updating Outgoing Approvals](updating-outgoing-approvals.md) - Example of updating user outgoing approvals


## File: ./x-badges/examples/txs/msgupdate-user-approvals/updating-outgoing-approvals.md

# Updating Outgoing Approvals

This example demonstrates how to update user outgoing approvals to control what tokens a user can send and to whom.

## Transaction Structure

```json
[
    {
        "creator": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
        "collectionId": "1",
        "updateOutgoingApprovals": true,
        "outgoingApprovals": [
            {
                "toListId": "All",
                "initiatedByListId": "bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl",
                "transferTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "badgeIds": [
                    {
                        "start": "1",
                        "end": "20"
                    }
                ],
                "ownershipTimes": [
                    {
                        "start": "1",
                        "end": "18446744073709551615"
                    }
                ],
                "uri": "",
                "customData": "",
                "approvalId": "87bc6dd97492b913b3d2b6c91c71b7a2bc98d41a715e49285180e8db9f4ea0bb",
                "approvalCriteria": {
                    "merkleChallenges": [],
                    "ethSignatureChallenges": [],
                    "predeterminedBalances": {
                        "manualBalances": [],
                        "incrementedBalances": {
                            "startBalances": [],
                            "incrementBadgeIdsBy": "0",
                            "incrementOwnershipTimesBy": "0",
                            "durationFromTimestamp": "0",
                            "allowOverrideTimestamp": false,
                            "recurringOwnershipTimes": {
                                "startTime": "0",
                                "intervalLength": "0",
                                "chargePeriodLength": "0"
                            },
                            "allowOverrideWithAnyValidBadge": false
                        },
                        "orderCalculationMethod": {
                            "useOverallNumTransfers": false,
                            "usePerToAddressNumTransfers": false,
                            "usePerFromAddressNumTransfers": false,
                            "usePerInitiatedByAddressNumTransfers": false,
                            "useMerkleChallengeLeafIndex": false,
                            "challengeTrackerId": ""
                        }
                    },
                    "approvalAmounts": {
                        "overallApprovalAmount": "1",
                        "perToAddressApprovalAmount": "0",
                        "perFromAddressApprovalAmount": "0",
                        "perInitiatedByAddressApprovalAmount": "1",
                        "amountTrackerId": "87bc6dd97492b913b3d2b6c91c71b7a2bc98d41a715e49285180e8db9f4ea0bb",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "maxNumTransfers": {
                        "overallMaxNumTransfers": "0",
                        "perToAddressMaxNumTransfers": "0",
                        "perFromAddressMaxNumTransfers": "0",
                        "perInitiatedByAddressMaxNumTransfers": "0",
                        "amountTrackerId": "fe1ffc5f6ff98f0e41b097f33623248868d367dc36dd7f22b2717b61b9d7c91c",
                        "resetTimeIntervals": {
                            "startTime": "0",
                            "intervalLength": "0"
                        }
                    },
                    "coinTransfers": [],
                    "requireToEqualsInitiatedBy": false,
                    "requireToDoesNotEqualInitiatedBy": false,
                    "autoDeletionOptions": {
                        "afterOneUse": false,
                        "afterOverallMaxNumTransfers": false
                    },
                    "mustOwnBadges": []
                },
                "version": "0"
            }
        ],

        // All other updates are false, so values do not ma
        "updateIncomingApprovals": false,
        "incomingApprovals": [],
        "updateAutoApproveSelfInitiatedOutgoingTransfers": true,
        "autoApproveSelfInitiatedOutgoingTransfers": true,
        "updateAutoApproveSelfInitiatedIncomingTransfers": false,
        "autoApproveSelfInitiatedIncomingTransfers": false,
        "updateAutoApproveAllIncomingTransfers": false,
        "autoApproveAllIncomingTransfers": false,
        "updateUserPermissions": false,
        "userPermissions": {
            "canUpdateOutgoingApprovals": [],
            "canUpdateIncomingApprovals": [],
            "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [],
            "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [],
            "canUpdateAutoApproveAllIncomingTransfers": []
        }
    }
]
```

## Related Examples

* [Building User Approvals](../../building-user-approvals.md) - User approval patterns
* [Empty Approval Criteria](../../empty-approval-criteria.md) - Template for unrestricted approvals

## Related Concepts

* [Transferability / Approvals](../../../concepts/transferability-approvals.md) - Approval system overview
* [Approval Criteria](broken-reference) - Criteria configuration
* [Tallied Approval Amounts](../../../concepts/approval-criteria/tallied-approval-amounts.md) - Amount tracking mechanics


## File: ./x-badges/messages/README.md

# 📨 Messages

This directory contains detailed documentation for all message types supported by the badges module.

## Message Categories

### Collection Management

* [MsgCreateCollection](msg-create-collection.md) - Create new collection
* [MsgUpdateCollection](msg-update-collection.md) - Update existing collection properties
* [MsgUniversalUpdateCollection](msg-universal-update-collection.md) - Universal create/update interface with invariants support
* [MsgDeleteCollection](msg-delete-collection.md) - Archive/delete collection

### Helper Collection Update Messages

* [MsgSetValidBadgeIds](msg-set-valid-badge-ids.md) - Update valid token IDs and permissions
* [MsgSetManager](msg-set-manager.md) - Update manager timeline and permissions
* [MsgSetCollectionMetadata](msg-set-collection-metadata.md) - Update collection metadata timeline and permissions
* [MsgSetBadgeMetadata](msg-set-badge-metadata.md) - Update token metadata timeline and permissions
* [MsgSetCustomData](msg-set-custom-data.md) - Update custom data timeline and permissions
* [MsgSetStandards](msg-set-standards.md) - Update standards timeline and permissions
* [MsgSetCollectionApprovals](msg-set-collection-approvals.md) - Update collection approvals and permissions
* [MsgSetIsArchived](msg-set-is-archived.md) - Update isArchived timeline and permissions

### Token Transfers

* [MsgTransferBadges](msg-transfer-badges.md) - Transfer tokens between addresses with approval validation

### User Approval Management

* [MsgUpdateUserApprovals](msg-update-user-approvals.md) - Update user transfer approval settings
* [MsgSetIncomingApproval](msg-set-incoming-approval.md) - Set a single incoming approval (helper)
* [MsgDeleteIncomingApproval](msg-delete-incoming-approval.md) - Delete a single incoming approval (helper)
* [MsgSetOutgoingApproval](msg-set-outgoing-approval.md) - Set a single outgoing approval (helper)
* [MsgDeleteOutgoingApproval](msg-delete-outgoing-approval.md) - Delete a single outgoing approval (helper)
* [MsgPurgeApprovals](msg-purge-approvals.md) - Purge expired approvals (helper)

### Address List Management

* [MsgCreateAddressLists](msg-create-address-lists.md) - Create reusable address lists for access control

### Dynamic Store Management

* [MsgCreateDynamicStore](msg-create-dynamic-store.md) - Create numeric stores for approval criteria
* [MsgUpdateDynamicStore](msg-update-dynamic-store.md) - Update dynamic store configuration
* [MsgDeleteDynamicStore](msg-delete-dynamic-store.md) - Delete dynamic store
* [MsgSetDynamicStoreValue](msg-set-dynamic-store-value.md) - Set individual address values in dynamic store
* [MsgIncrementStoreValue](msg-increment-store-value.md) - Increase values for addresses
* [MsgDecrementStoreValue](msg-decrement-store-value.md) - Decrease values for addresses

## Additional Message Types

The following message types exist in the protocol but may be documented separately:

* **MsgUpdateParams** - Update module parameters via governance


## File: ./x-badges/messages/msg-create-address-lists.md

# MsgCreateAddressLists

Creates reusable address lists by ID for gas optimizations. Note these serve no other purpose than to be an immutable shorthand ID reference to save on gas. These are permanent once created and cannot be deleted.

## Important Notes

1. **Create Only**: There are no update, edit, or delete functions for address lists. Once created, they are immutable.

2. **Optional Efficiency Tool**: This is completely optional and serves as a reusable shorthand ID to avoid repetition of long reserved address list IDs. The primary purpose is gas efficiency.

3. **Minimal Metadata**: Typically, `uri` and `customData` are left blank as these fields are not supported on the BitBadges site and are different from off-chain lists you may see elsewhere.

## Proto Definition

```protobuf
message MsgCreateAddressLists {
  string creator = 1; // Address creating the address lists
  repeated AddressList addressLists = 2; // Lists to create in single transaction
}

message MsgCreateAddressListsResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges create-address-lists '[tx-json]' --from creator-key
```

### JSON Example

```json
{
    "creator": "bb1...",
    "addressLists": [
        {
            "listId": "", // Unique ID for the address list
            "addresses": ["bb1...", "bb1..."],
            "whitelist": true,
            "createdBy": "", // Leave blank - auto-generated
            "aliasAddress": "", // Leave blank - auto-generated
            "uri": "",
            "customData": ""
        }
    ]
}
```


## File: ./x-badges/messages/msg-create-collection.md

# MsgCreateCollection

Creates a new collection.

The collectionId will be assigned at execution time and is obtainable in the transaction response. Subsequent updates to the collection will be through MsgUpdateCollection.

## Creation Only Properties

The creation or genesis transaction for a collection is unique in a couple ways.

There are no permissions previously set, so there are no restrictions for what can be set vs not. Subsequent updates to the collection must follow any previously set permissions.

This is the only time that you can specify the `defaultBalances` information.

## Proto Definition

```protobuf
message MsgCreateCollection {
  string creator = 1; // Address creating the collection
  UserBalanceStore defaultBalances = 2;
  repeated UintRange validBadgeIds  = 3; // Token ID ranges to include
  CollectionPermissions collectionPermissions = 4;
  repeated ManagerTimeline managerTimeline = 5;
  repeated CollectionMetadataTimeline collectionMetadataTimeline = 6;
  repeated BadgeMetadataTimeline badgeMetadataTimeline = 7;
  repeated CustomDataTimeline customDataTimeline = 8;
  repeated CollectionApproval collectionApprovals = 9;
  repeated StandardsTimeline standardsTimeline = 10;
  repeated IsArchivedTimeline isArchivedTimeline = 11;
  repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 12;
  repeated CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 13;
  CollectionInvariants invariants = 14;
}

message MsgCreateCollectionResponse {
  string collectionId = 1; // ID of the created collection
}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges create-collection '[tx-json]' --from creator-key
```

### JSON Example

For complete transaction examples, see [MsgCreateCollection Examples](../examples/txs/msgcreatecollection/).

```json
{
    "creator": "bb1abc123...",
    "defaultBalances": {
        "balances": [],
        "outgoingApprovals": [],
        "incomingApprovals": [],
        "autoApproveSelfInitiatedOutgoingTransfers": false,
        "autoApproveSelfInitiatedIncomingTransfers": true,
        "autoApproveAllIncomingTransfers": false,
        "userPermissions": {
            "canUpdateOutgoingApprovals": [],
            "canUpdateIncomingApprovals": [],
            "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [],
            "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [],
            "canUpdateAutoApproveAllIncomingTransfers": []
        }
    },
    "validBadgeIds": [{ "start": "1", "end": "100" }],
    "collectionPermissions": {
        "canDeleteCollection": [],
        "canArchiveCollection": [],
        "canUpdateStandards": [],
        "canUpdateCustomData": [],
        "canUpdateManager": [],
        "canUpdateCollectionMetadata": [],
        "canUpdateValidBadgeIds": [],
        "canUpdateBadgeMetadata": [],
        "canUpdateCollectionApprovals": []
    },
    "managerTimeline": [],
    "collectionMetadataTimeline": [],
    "badgeMetadataTimeline": [],
    "customDataTimeline": [],
    "collectionApprovals": [],
    "standardsTimeline": [],
    "isArchivedTimeline": [],
    "mintEscrowCoinsToTransfer": [],
    "cosmosCoinWrapperPathsToAdd": [],
    "invariants": {
        "noCustomOwnershipTimes": false,
        "maxSupplyPerId": "0"
    }
}
```


## File: ./x-badges/messages/msg-create-dynamic-store.md

# MsgCreateDynamicStore

Creates a new dynamic store for numeric key-value storage.

## Proto Definition

```protobuf
message MsgCreateDynamicStore {
  string creator = 1; // Address creating the dynamic store
  string defaultValue = 2; // Default numeric value for uninitialized addresses
}

message MsgCreateDynamicStoreResponse {
  string storeId = 1; // ID of the created dynamic store
}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges create-dynamic-store [default-value] --from creator-key
```

### JSON Example
```json
{
  "creator": "bb1...",
  "defaultValue": "0"
}
```

## File: ./x-badges/messages/msg-decrement-store-value.md

# MsgDecrementStoreValue

Decrements a numeric value for a specific address in a dynamic store.

## Proto Definition

```protobuf
message MsgDecrementStoreValue {
  string creator = 1; // Address decrementing the value (must be store creator)
  string storeId = 2; // ID of the dynamic store
  string address = 3; // Address to decrement the value for
  string amount = 4; // Amount to decrement by
  bool setToZeroOnUnderflow = 5; // Whether to set to 0 if result would be negative
}

message MsgDecrementStoreValueResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges decrement-store-value [store-id] [address] [amount] [set-to-zero-on-underflow] --from creator-key
```

### JSON Example

```json
{
    "creator": "bb1...",
    "storeId": "1",
    "address": "bb1...",
    "amount": "5",
    "setToZeroOnUnderflow": false
}
```

## Underflow Behavior

The `setToZeroOnUnderflow` field controls what happens when decrementing would result in a negative value:

-   **`true`**: The value is set to 0 instead of going negative
-   **`false`**: The operation fails with an error if it would result in a negative value

## Related Messages

-   [MsgSetDynamicStoreValue](./msg-set-dynamic-store-value.md) - Set absolute values
-   [MsgIncrementStoreValue](./msg-increment-store-value.md) - Increase values
-   [MsgCreateDynamicStore](./msg-create-dynamic-store.md) - Create new stores


## File: ./x-badges/messages/msg-delete-collection.md

# MsgDeleteCollection

Deletes a collection.

## Authorization

Collection deletion can only be performed by the **current manager** of the collection and requires the `canDeleteCollection` permission to be enabled at the current time in the collection's permissions.

## Proto Definition

```protobuf
message MsgDeleteCollection {
  string creator = 1; // Address requesting deletion (must be manager)
  string collectionId = 2; // ID of collection to delete
}

message MsgDeleteCollectionResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges delete-collection [collection-id] --from manager-key
```

### JSON Example

```json
{
    "creator": "bb1...",
    "collectionId": "1"
}
```


## File: ./x-badges/messages/msg-delete-dynamic-store.md

# MsgDeleteDynamicStore

Deletes a dynamic store.

## Proto Definition

```protobuf
message MsgDeleteDynamicStore {
  string creator = 1; // Address deleting the store (must be creator)
  string storeId = 2; // ID of dynamic store to delete
}

message MsgDeleteDynamicStoreResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges delete-dynamic-store [store-id] --from creator-key
```

### JSON Example

```json
{
    "creator": "bb1...",
    "storeId": "1"
}
```


## File: ./x-badges/messages/msg-delete-incoming-approval.md

# MsgDeleteIncomingApproval

A helper message to delete a single incoming approval for token transfers. This is a developer-friendly wrapper around `MsgUpdateUserApprovals` that simplifies deleting individual incoming approvals. For more information, we refer to the [MsgUpdateUserApprovals](./msg-update-user-approvals.md) documentation.

## Overview

This message allows you to delete a single incoming approval by its ID without having to construct the full `MsgUpdateUserApprovals` message with an empty approval list.

## Proto Definition

```protobuf
message MsgDeleteIncomingApproval {
  string creator = 1; // User deleting the approval
  string collectionId = 2; // Target collection for approval
  string approvalId = 3; // The ID of the approval to delete
}

message MsgDeleteIncomingApprovalResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges delete-incoming-approval [collection-id] [approval-id] --from user-key
```

### Example

```bash
bitbadgeschaind tx badges delete-incoming-approval 1 "my-approval-1" --from user-key
```

## Behavior

-   **Approval Lookup**: The system searches for an incoming approval with the specified `approvalId`
-   **Deletion**: If found, the approval is removed from the user's incoming approvals list
-   **Error Handling**: If the approval ID is not found, an error is returned
-   **Validation**: The deletion is validated according to the collection's permissions and user's approval update permissions

## Authorization & Permissions

Users can only delete their own incoming approvals. The operation must be performed according to the permissions set (i.e. the `userPermissions` previously set for that user).

## Related Messages

-   [MsgUpdateUserApprovals](./msg-update-user-approvals.md) - Full approval management
-   [MsgSetIncomingApproval](./msg-set-incoming-approval.md) - Set an incoming approval
-   [MsgDeleteOutgoingApproval](./msg-delete-outgoing-approval.md) - Delete an outgoing approval


## File: ./x-badges/messages/msg-delete-outgoing-approval.md

# MsgDeleteOutgoingApproval

A helper message to delete a single outgoing approval for token transfers. This is a developer-friendly wrapper around `MsgUpdateUserApprovals` that simplifies deleting individual outgoing approvals. For more information, we refer to the [MsgUpdateUserApprovals](./msg-update-user-approvals.md) documentation.

## Overview

This message allows you to delete a single outgoing approval by its ID without having to construct the full `MsgUpdateUserApprovals` message with an empty approval list.

## Proto Definition

```protobuf
message MsgDeleteOutgoingApproval {
  string creator = 1; // User deleting the approval
  string collectionId = 2; // Target collection for approval
  string approvalId = 3; // The ID of the approval to delete
}

message MsgDeleteOutgoingApprovalResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges delete-outgoing-approval [collection-id] [approval-id] --from user-key
```

### Example

```bash
bitbadgeschaind tx badges delete-outgoing-approval 1 "my-approval-1" --from user-key
```

## Behavior

-   **Approval Lookup**: The system searches for an outgoing approval with the specified `approvalId`
-   **Deletion**: If found, the approval is removed from the user's outgoing approvals list
-   **Error Handling**: If the approval ID is not found, an error is returned
-   **Validation**: The deletion is validated according to the collection's permissions and user's approval update permissions

## Authorization & Permissions

Users can only delete their own outgoing approvals. The operation must be performed according to the permissions set (i.e. the `userPermissions` previously set for that user).

## Related Messages

-   [MsgUpdateUserApprovals](./msg-update-user-approvals.md) - Full approval management
-   [MsgSetOutgoingApproval](./msg-set-outgoing-approval.md) - Set an outgoing approval
-   [MsgDeleteIncomingApproval](./msg-delete-incoming-approval.md) - Delete an incoming approval


## File: ./x-badges/messages/msg-increment-store-value.md

# MsgIncrementStoreValue

Increments a numeric value for a specific address in a dynamic store.

## Proto Definition

```protobuf
message MsgIncrementStoreValue {
  string creator = 1; // Address incrementing the value (must be store creator)
  string storeId = 2; // ID of the dynamic store
  string address = 3; // Address to increment the value for
  string amount = 4; // Amount to increment by
}

message MsgIncrementStoreValueResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges increment-store-value [store-id] [address] [amount] --from creator-key
```

### JSON Example

```json
{
    "creator": "bb1...",
    "storeId": "1",
    "address": "bb1...",
    "amount": "10"
}
```

## Related Messages

-   [MsgSetDynamicStoreValue](./msg-set-dynamic-store-value.md) - Set absolute values
-   [MsgDecrementStoreValue](./msg-decrement-store-value.md) - Decrease values
-   [MsgCreateDynamicStore](./msg-create-dynamic-store.md) - Create new stores


## File: ./x-badges/messages/msg-purge-approvals.md

# MsgPurgeApprovals

A message to purge specific approvals from approval lists. This is a targeted approach that requires specifying exactly which approvals to purge.

## Overview

This message allows you to purge specific approvals by their identifier.

### Usage 1: Self-Purge (Creator purging their own approvals)

-   **`purgeExpired` must be `true`**
-   **`purgeCounterpartyApprovals` must be `false`**
-   **`approvalsToPurge` must contain the specific approvals to purge**
-   Specified approvals will be purged if they are expired (no future transfer times)

### Usage 2: Other-Purge (Creator purging someone else's approvals)

-   Can set either `purgeExpired` or `purgeCounterpartyApprovals` (or both)
-   **`approvalsToPurge` must contain the specific approvals to purge**
-   Purge permissions are determined by the approval's auto-deletion options in `approvalCriteria`:
    -   `allowPurgeIfExpired`: Allows others to purge expired approvals
    -   `allowCounterpartyPurge`: Allows counterparty to purge if they are the only initiator (initiatedByList must be a whitelist with exactly one address matching the counterparty)
-   Specified approvals that match the conditions will be purged

## Fields

-   `creator`: The address submitting the transaction.
-   `collectionId`: The target collection for approval cleanup.
-   `purgeExpired`: Whether to purge expired approvals (must be true for self-purge).
-   `approverAddress`: The address whose approvals to purge. If empty, defaults to `creator`.
-   `purgeCounterpartyApprovals`: Whether to purge counterparty approvals (must be false for self-purge).
-   `approvalsToPurge`: **Required** - An array of approval identifier details specifying exactly which approvals to purge. Cannot be empty.

## ApprovalIdentifierDetails

Each approval to purge must be specified with:

```typescript
interface ApprovalIdentifierDetails {
    approvalId: string; // The ID of the approval
    approvalLevel: string; // "collection", "incoming", or "outgoing"
    approverAddress: string; // Address of the approver (empty for collection-level)
    version: string; // Version of the approval (must match or else we will not purge)
}
```

## Auto-Deletion Options

The following flags in approval criteria control purge permissions in `approvalCriteria`:

-   `allowCounterpartyPurge`: Allows the counterparty to purge the approval if they are the ONLY initiator in `initiatedByList` (must be a whitelist with exactly one address matching the counterparty).
-   `allowPurgeIfExpired`: Allows others (besides the approval owner) to call `PurgeApprovals` on their behalf for expired approvals.

## Permissions

Although user approval permissions are rarely disabled, we still check these purges obey them. If the user does not have permission to purge their own approval, the purge will fail. With counterparty purges, this can be thought of purging on behalf of the user, so the user's permissions are still checked.

## Example Usage

```bash
# [collectionId, purgeExpired, approverAddress, purgeCounterpartyApprovals, approvalsToPurge]

bitbadgeschaind tx badges purge-approvals 1 true "" false '[{"approvalId":"my-approval","approvalLevel":"outgoing","approverAddress":"bb1...","version":"0"}]' --from user-key
```

## Response

The response includes the number of approvals that were successfully purged:

```json
{
    "numPurged": "3"
}
```

## Related Messages

-   [MsgUpdateUserApprovals](./msg-update-user-approvals.md) - Full approval management
-   [MsgSetIncomingApproval](./msg-set-incoming-approval.md) - Set an incoming approval
-   [MsgDeleteIncomingApproval](./msg-delete-incoming-approval.md) - Delete a single incoming approval
-   [MsgSetOutgoingApproval](./msg-set-outgoing-approval.md) - Set a single outgoing approval
-   [MsgDeleteOutgoingApproval](./msg-delete-outgoing-approval.md) - Delete a single outgoing approval


## File: ./x-badges/messages/msg-set-badge-metadata.md

# MsgSetBadgeMetadata

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetBadgeMetadata

Sets the token metadata timeline and update permissions for a collection. This is a convenience message that focuses specifically on token metadata management.

### Overview

This message allows you to:

* Set token metadata timeline for the collection
* Configure permissions to update the token metadata in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to update the token metadata timeline according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetBadgeMetadata {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetBadgeMetadata";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New token metadata timeline to set.
  repeated BadgeMetadataTimeline badgeMetadataTimeline = 3;

  // Permission to update token metadata timeline
  repeated TimedUpdateWithBadgeIdsPermission canUpdateBadgeMetadata = 4;
}

message MsgSetBadgeMetadataResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-badge-metadata '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "badgeMetadataTimeline": [
        {
            "badgeMetadata": [
                {
                    "uri": "https://example.com/badge1.json",
                    "customData": "{\"description\": \"First token\"}",
                    "badgeIds": [{ "start": "1", "end": "10" }]
                }
            ],
            "timelineTimes": [{ "start": "1000", "end": "2000" }]
        }
    ],
    "canUpdateBadgeMetadata": [
        {
            "badgeIds": [{ "start": "1", "end": "10" }],
            "timelineTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Related Messages

* [MsgUniversalUpdateCollection](broken-reference) - Full collection update with all fields
* [MsgUpdateCollection](broken-reference) - Legacy update message


## File: ./x-badges/messages/msg-set-collection-approvals.md

# MsgSetCollectionApprovals

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetCollectionApprovals

Sets the collection approvals and update permissions for a collection. This is a convenience message that focuses specifically on collection approvals management.

### Overview

This message allows you to:

* Set collection approvals for the collection
* Configure permissions to update the collection approvals in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to update collection approvals according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetCollectionApprovals {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetCollectionApprovals";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New collection approvals to set.
  repeated CollectionApproval collectionApprovals = 3;

  // Permission to update collection approvals
  repeated CollectionApprovalPermission canUpdateCollectionApprovals = 4;
}

message MsgSetCollectionApprovalsResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-collection-approvals '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "collectionApprovals": [
        {
            "fromListId": "list1",
            "toListId": "list2",
            "initiatedByListId": "list3",
            "transferTimes": [{ "start": "1000", "end": "2000" }],
            "badgeIds": [{ "start": "1", "end": "10" }],
            "ownershipTimes": [{ "start": "1", "end": "100" }],
            "approvalId": "approval1",
            "approvalCriteria": {
                "mustOwnBadges": [],
                "merkleChallenges": [],
                "ethSignatureChallenges": [],
                "coinTransfers": [],
                "predeterminedBalances": null,
                "approvalAmounts": null,
                "autoDeletionOptions": null,
                "maxNumTransfers": null,
                "dynamicStoreChallenges": []
            }
        }
    ],
    "canUpdateCollectionApprovals": [
        {
            "fromListId": "list1",
            "toListId": "list2",
            "initiatedByListId": "list3",
            "transferTimes": [{ "start": "1000", "end": "2000" }],
            "badgeIds": [{ "start": "1", "end": "10" }],
            "ownershipTimes": [{ "start": "1", "end": "100" }],
            "approvalId": "approval1",
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Related Messages

* [MsgUniversalUpdateCollection](broken-reference) - Full collection update with all fields
* [MsgUpdateCollection](broken-reference) - Legacy update message


## File: ./x-badges/messages/msg-set-collection-metadata.md

# MsgSetCollectionMetadata

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetCollectionMetadata

Sets the collection metadata timeline and update permissions for a collection. This is a convenience message that focuses specifically on collection metadata management.

### Overview

This message allows you to:

* Set collection metadata timeline for the collection
* Configure permissions to update the collection metadata in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to update the collection metadata timeline according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetCollectionMetadata {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetCollectionMetadata";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New collection metadata timeline to set.
  repeated CollectionMetadataTimeline collectionMetadataTimeline = 3;

  // Permission to update collection metadata timeline
  repeated TimedUpdatePermission canUpdateCollectionMetadata = 4;
}

message MsgSetCollectionMetadataResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-collection-metadata '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "collectionMetadataTimeline": [
        {
            "collectionMetadata": {
                "uri": "https://example.com/collection.json",
                "customData": "{\"description\": \"My collection\"}"
            },
            "timelineTimes": [{ "start": "1000", "end": "2000" }]
        }
    ],
    "canUpdateCollectionMetadata": [
        {
            "timelineTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Related Messages

* [MsgUniversalUpdateCollection](broken-reference) - Full collection update with all fields
* [MsgUpdateCollection](broken-reference) - Legacy update message


## File: ./x-badges/messages/msg-set-custom-data.md

# MsgSetCustomData

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetCustomData

Sets the custom data timeline and update permissions for a collection. This is a convenience message that focuses specifically on custom data management.

### Overview

This message allows you to:

* Set custom data timeline for the collection
* Configure permissions to update the custom data in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to update the custom data timeline according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetCustomData {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetCustomData";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New custom data timeline to set.
  repeated CustomDataTimeline customDataTimeline = 3;

  // Permission to update custom data timeline
  repeated TimedUpdatePermission canUpdateCustomData = 4;
}

message MsgSetCustomDataResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-custom-data '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "customDataTimeline": [
        {
            "customData": "{\"description\": \"My custom data\", \"version\": \"1.0\"}",
            "timelineTimes": [{ "start": "1000", "end": "2000" }]
        }
    ],
    "canUpdateCustomData": [
        {
            "timelineTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Related Messages

* [MsgUniversalUpdateCollection](broken-reference) - Full collection update with all fields
* [MsgUpdateCollection](broken-reference) - Legacy update message


## File: ./x-badges/messages/msg-set-dynamic-store-value.md

# MsgSetDynamicStoreValue

Sets a numeric value for a specific address in a dynamic store.

## Proto Definition

```protobuf
message MsgSetDynamicStoreValue {
  string creator = 1; // Address setting the value (must be store creator)
  string storeId = 2; // ID of the dynamic store
  string address = 3; // Address to set the value for
  string value = 4; // Numeric value to set
}

message MsgSetDynamicStoreValueResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-dynamic-store-value [store-id] [address] [value] --from creator-key
```

### JSON Example
```json
{
  "creator": "bb1...",
  "storeId": "1",
  "address": "bb1...",
  "value": "100"
}
```

## File: ./x-badges/messages/msg-set-incoming-approval.md

# MsgSetIncomingApproval

A helper message to set a single incoming approval for token transfers. This is a developer-friendly wrapper around `MsgUpdateUserApprovals` that simplifies setting individual incoming approvals. For more information, we refer to the [MsgUpdateUserApprovals](./msg-update-user-approvals.md) documentation.

## Overview

This message allows you to set or update a single incoming approval without having to construct the full `MsgUpdateUserApprovals` message. It automatically handles version management and validation.

## Proto Definition

```protobuf
message MsgSetIncomingApproval {
  string creator = 1; // User setting the approval
  string collectionId = 2; // Target collection for approval
  UserIncomingApproval approval = 3; // The incoming approval to set
}

message MsgSetIncomingApprovalResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-incoming-approval [collection-id] '[approval-json]' --from user-key
```

## Behavior

-   **New Approval**: If the approval ID doesn't exist, a new approval is created with version 0
-   **Update Existing**: If the approval ID already exists, the approval is updated and the version is incremented
-   **No Change**: If the approval content hasn't changed, the version remains the same
-   **Validation**: The approval is validated according to the collection's permissions and user's approval update permissions

## Authorization & Permissions

Users can only set their own incoming approvals. The operation must be performed according to the permissions set (i.e. the `userPermissions` previously set for that user).

## Related Messages

-   [MsgUpdateUserApprovals](./msg-update-user-approvals.md) - Full approval management
-   [MsgDeleteIncomingApproval](./msg-delete-incoming-approval.md) - Delete an incoming approval
-   [MsgSetOutgoingApproval](./msg-set-outgoing-approval.md) - Set an outgoing approval


## File: ./x-badges/messages/msg-set-is-archived.md

# MsgSetIsArchived

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetIsArchived

Sets the isArchived timeline and update permissions for a collection. This is a convenience message that focuses specifically on archiving management.

### Overview

This message allows you to:

* Set isArchived timeline for the collection
* Configure permissions to archive the collection in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to archive the collection according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetIsArchived {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetIsArchived";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New isArchived timeline to set.
  repeated IsArchivedTimeline isArchivedTimeline = 3;

  // Permission to archive collection
  repeated TimedUpdatePermission canArchiveCollection = 4;
}

message MsgSetIsArchivedResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-is-archived '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "isArchivedTimeline": [
        {
            "isArchived": true,
            "timelineTimes": [{ "start": "1000", "end": "2000" }]
        }
    ],
    "canArchiveCollection": [
        {
            "timelineTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Related Messages

* [MsgUniversalUpdateCollection](broken-reference) - Full collection update with all fields
* [MsgUpdateCollection](broken-reference) - Legacy update message


## File: ./x-badges/messages/msg-set-manager.md

# MsgSetManager

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetManager

Sets the manager timeline and update permissions for a collection. This is a convenience message that focuses specifically on manager management.

### Overview

This message allows you to:

* Set who manages the collection at different times
* Configure permissions to update the manager in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to update the manager timeline according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetManager {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetManager";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New manager timeline to set.
  repeated ManagerTimeline managerTimeline = 3;

  // Permission to update manager timeline
  repeated TimedUpdatePermission canUpdateManager = 4;
}

message MsgSetManagerResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-manager '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "managerTimeline": [
        {
            "manager": "bb1def456...",
            "timelineTimes": [{ "start": "1000", "end": "2000" }]
        }
    ],
    "canUpdateManager": [
        {
            "timelineTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Related Messages

* [MsgUniversalUpdateCollection](broken-reference) - Full collection update with all fields
* [MsgUpdateCollection](broken-reference) - Legacy update message


## File: ./x-badges/messages/msg-set-outgoing-approval.md

# MsgSetOutgoingApproval

A helper message to set a single outgoing approval for token transfers. This is a developer-friendly wrapper around `MsgUpdateUserApprovals` that simplifies setting individual outgoing approvals. For more information, we refer to the [MsgUpdateUserApprovals](./msg-update-user-approvals.md) documentation.

## Overview

This message allows you to set or update a single outgoing approval without having to construct the full `MsgUpdateUserApprovals` message. It automatically handles version management and validation.

## Proto Definition

```protobuf
message MsgSetOutgoingApproval {
  string creator = 1; // User setting the approval
  string collectionId = 2; // Target collection for approval
  UserOutgoingApproval approval = 3; // The outgoing approval to set
}

message MsgSetOutgoingApprovalResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-outgoing-approval [collection-id] '[approval-json]' --from user-key
```

## Behavior

-   **New Approval**: If the approval ID doesn't exist, a new approval is created with version 0
-   **Update Existing**: If the approval ID already exists, the approval is updated and the version is incremented
-   **No Change**: If the approval content hasn't changed, the version remains the same
-   **Validation**: The approval is validated according to the collection's permissions and user's approval update permissions

## Authorization & Permissions

Users can only set their own outgoing approvals. The operation must be performed according to the permissions set (i.e. the `userPermissions` previously set for that user).

## Related Messages

-   [MsgUpdateUserApprovals](./msg-update-user-approvals.md) - Full approval management
-   [MsgDeleteOutgoingApproval](./msg-delete-outgoing-approval.md) - Delete an outgoing approval
-   [MsgSetIncomingApproval](./msg-set-incoming-approval.md) - Set an incoming approval


## File: ./x-badges/messages/msg-set-standards.md

# MsgSetStandards

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetStandards

Sets the standards timeline and update permissions for a collection. This is a convenience message that focuses specifically on standards management.

### Overview

This message allows you to:

* Set standards timeline for the collection
* Configure permissions to update the standards in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to update the standards timeline according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetStandards {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetStandards";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New standards timeline to set.
  repeated StandardsTimeline standardsTimeline = 3;

  // Permission to update standards timeline
  repeated TimedUpdatePermission canUpdateStandards = 4;
}

message MsgSetStandardsResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-standards '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "standardsTimeline": [
        {
            "standards": ["ERC1155", "ERC721"],
            "timelineTimes": [{ "start": "1000", "end": "2000" }]
        }
    ],
    "canUpdateStandards": [
        {
            "timelineTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Related Messages

* [MsgUniversalUpdateCollection](broken-reference) - Full collection update with all fields
* [MsgUpdateCollection](broken-reference) - Legacy update message


## File: ./x-badges/messages/msg-set-valid-badge-ids.md

# MsgSetValidBadgeIds

**Disclaimer:**\
This message is a streamlined alternative to [MsgUpdateCollection](broken-reference). If you need to update many fields at once, we recommend using MsgUpdateCollection instead.

## MsgSetValidBadgeIds

Sets the valid token IDs and update permissions for a collection. This is a convenience message that focuses specifically on token ID management.

### Overview

This message allows you to:

* Set which token IDs are valid for the collection
* Configure permissions to update the valid token IDs in the future

### Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. The manager must have permission to update valid token IDs according to the collection's current permission settings.

### Proto Definition

```protobuf
message MsgSetValidBadgeIds {
  option (cosmos.msg.v1.signer) = "creator";
  option (amino.name) = "badges/SetValidBadgeIds";

  // Address of the creator.
  string creator = 1;

  // ID of the collection.
  string collectionId = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // New token IDs to add to this collection
  repeated UintRange validBadgeIds = 3;

  // Permission to update valid token IDs
  repeated BadgeIdsActionPermission canUpdateValidBadgeIds = 4;
}

message MsgSetValidBadgeIdsResponse {
  // ID of the collection.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

### Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-valid-badge-ids '[tx-json]' --from manager-key
```

#### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "validBadgeIds": [
        { "start": "1", "end": "100" },
        { "start": "200", "end": "300" }
    ],
    "canUpdateValidBadgeIds": [
        {
            "badgeIds": [{ "start": "1", "end": "50" }],
            "permanentlyPermittedTimes": [{ "start": "1000", "end": "2000" }],
            "permanentlyForbiddenTimes": []
        }
    ]
}
```

### Related Messages

* [MsgUniversalUpdateCollection](broken-reference) - Full collection update with all fields
* [MsgUpdateCollection](broken-reference) - Legacy update message


## File: ./x-badges/messages/msg-transfer-badges.md

# MsgTransferBadges

Executes token transfers between addresses.

## Proto Definition

```protobuf
message MsgTransferBadges {
  string creator = 1; // Address initiating the transfer
  string collectionId = 2; // Collection containing tokens to transfer
  repeated Transfer transfers = 3; // Transfer operations (must pass approvals)
}

message MsgTransferBadgesResponse {}

message Transfer {
  // The address of the sender of the transfer.
  string from = 1;
  // The addresses of the recipients of the transfer.
  repeated string toAddresses = 2;
  // The balances to be transferred.
  repeated Balance balances = 3;
  // If defined, we will use the predeterminedBalances from the specified approval to calculate the balances at execution time.
  // We will override the balances field with the precalculated balances. Only applicable for approvals with predeterminedBalances set.
  ApprovalIdentifierDetails precalculateBalancesFromApproval = 4;
  // The Merkle proofs / solutions for all Merkle challenges required for the transfer.
  repeated MerkleProof merkleProofs = 5;
  // The ETH signature proofs / solutions for all ETH signature challenges required for the transfer.
  repeated ETHSignatureProof ethSignatureProofs = 6;
  // The memo for the transfer.
  string memo = 7;
  // The prioritized approvals for the transfer. By default, we scan linearly through the approvals and use the first match.
  // This field can be used to prioritize specific approvals and scan through them first.
  repeated ApprovalIdentifierDetails prioritizedApprovals = 8;
  // Whether to only check prioritized approvals for the transfer.
  // If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
  // If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
  bool onlyCheckPrioritizedCollectionApprovals = 9;
  // Whether to only check prioritized approvals for the transfer.
  // If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
  // If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
  bool onlyCheckPrioritizedIncomingApprovals = 10;
  // Whether to only check prioritized approvals for the transfer.
  // If true, we will only check the prioritized approvals and fail if none of them match (i.e. do not check any non-prioritized approvals).
  // If false, we will check the prioritized approvals first and then scan through the rest of the approvals.
  bool onlyCheckPrioritizedOutgoingApprovals = 11;
  // The options for precalculating the balances.
  PrecalculationOptions precalculationOptions = 12;
  // Affiliate address for the transfer.
  string affiliateAddress = 13;
  // The number of times to attempt approval validation. If 0 / not specified, we default to only one.
  string numAttempts = 14;
}

message PrecalculationOptions {
  // The timestamp to override with when calculating the balances.
  string overrideTimestamp = 1;
  // The IDs to override with when calculating the balances.
  repeated UintRange badgeIdsOverride = 2;
}
```

## Auto-Scan vs Prioritized Approvals

The transfer approval system operates in two modes to balance efficiency and precision:

### Auto-Scan Mode (Default)

By default, the system automatically scans through available approvals to find a match for the transfer. This mode:

* **Works with**: Approvals using [Empty Approval Criteria](../examples/empty-approval-criteria.md) (no side effects)
* **Behavior**: Automatically finds and uses the first matching approval
* **Use case**: Simple transfers without custom logic or side effects
* **No versioning required**: The system handles approval selection automatically

### Prioritized Approvals (Required for Side Effects)

**CRITICAL REQUIREMENT**: Any transfer with side effects or custom approval criteria MUST always be prioritized with proper versioning set. No exceptions.

#### Race Condition Protection

The versioning control ensures that before submitting, the user knows the exact approval they are using:

```typescript
"prioritizedApprovals": [
    {
        "approvalId": "abc123",
        "approvalLevel": "collection",
        "approverAddress": "",
        "version": "2" // Must specify exact version
    }
]
```

#### Example: Coin Transfer Approval

```typescript
// MUST be prioritized - has coin transfer side effects
"prioritizedApprovals": [
    {
        "approvalId": "reward-approval",
        "approvalLevel": "collection",
        "approverAddress": "",
        "version": "1"
    }
],
"onlyCheckPrioritizedCollectionApprovals": true
```

#### Example: Auto-Scan Safe Transfer

```typescript
// Can use auto-scan - no side effects
"prioritizedApprovals": [], // Empty - will auto-scan

// Only will succeed if it finds an approval has empty approval criteria with no custom logic
```

### Control Flags

* `onlyCheckPrioritizedCollectionApprovals`: If true, only check prioritized approvals
* `onlyCheckPrioritizedIncomingApprovals`: If true, only check prioritized incoming approvals
* `onlyCheckPrioritizedOutgoingApprovals`: If true, only check prioritized outgoing approvals

**Setting these to `true` is recommended when using prioritized approvals to ensure deterministic behavior.**

### Related Documentation

* [Empty Approval Criteria](../examples/empty-approval-criteria.md) - Template for auto-scan compatible approvals
* [Approval Criteria](broken-reference) - Understanding approval complexity
* [Coin Transfers](../concepts/approval-criteria/usdbadge-transfers.md) - Side effect examples

## Transfer Validation Process

Each transfer undergoes a systematic validation process to ensure security and proper authorization:

### Validation Steps

```
PRE. CALCULATE BALANCES (if needed)
  └── If precalculateBalancesFromApproval is specified, we will use the predeterminedBalances from the specified approval to pre-calculate the balances at execution time.

1. BALANCE CHECK
   └── Verify sender has sufficient balances for the transfer including ownership times
   └── FAIL if insufficient balances

2. COLLECTION APPROVAL CHECK
   └── Scan collection-level approvals (prioritized first, then auto-scan) to find a match for the entire transfer
   └── If match found:
       ├── Check approval criteria (merkle proofs, amounts, timing, etc.) and constraints
       ├── Check if it overrides sender approvals (overridesFromOutgoingApprovals)
       ├── Check if it overrides recipient approvals (overridesToIncomingApprovals)
       └── PROCEED with override flags set
   └── Else:
        └── Continue scanning
   └── If some attempted transfer balances have no valid collection approval: FAIL

3. SENDER APPROVAL CHECK (if not overridden)
   └── Check sender's outgoing approvals for this transfer
   └── Verify approval criteria and constraints
   └── FAIL if no valid outgoing approval found

4. RECIPIENT APPROVAL CHECK (if not overridden)
   └── Check each recipient's incoming approvals
   └── Verify approval criteria and constraints
   └── FAIL if any recipient lacks valid incoming approval

5. EXECUTE TRANSFER
   └── Update balances
   └── Execute any approved side effects
   └── Emit transfer events
   └── SUCCESS
```

### Override Behavior

Collection approvals can override user-level approvals:

* **`overridesFromOutgoingApprovals: true`** - Forcefully skips sender approval check
* **`overridesToIncomingApprovals: true`** - Forcefully skips recipient approval checks

This allows collection managers to enable transfers that would otherwise be blocked by user settings.

### Failure Points

Transfers fail at the first validation step that doesn't pass:

1. **Insufficient Balances** - Sender doesn't own the tokens
2. **No Collection Approval** - No valid collection-level approval found
3. **Blocked by Sender** - Sender's outgoing approvals reject the transfer
4. **Blocked by Recipient** - Recipient's incoming approvals reject the transfer

### ETH Signature Proofs

ETH Signature Proofs are required when transfers use [ETH Signature Challenges](../concepts/approval-criteria/eth-signature-challenges.md). Each proof contains:

* **`nonce`**: The unique identifier that was signed
* **`signature`**: The Ethereum signature of the message `nonce + "-" + creatorAddress`

**Important**: Each signature can only be used once per challenge tracker. The system tracks used signatures to prevent replay attacks.

### Related Documentation

* [Transferability / Approvals](../concepts/transferability-approvals.md) - Approval system overview
* [Collection Approvals](broken-reference) - Collection-level controls
* [User Approvals](../examples/building-user-approvals.md) - User-level settings
* [ETH Signature Challenges](../concepts/approval-criteria/eth-signature-challenges.md) - Ethereum signature requirements

## Collection ID Auto-Lookup

If you specify `collectionId` as `"0"`, it will automatically lookup the latest collection ID created. This can be used if you are creating a collection and do not know the official collection ID yet but want to perform a multi-message transaction.

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges transfer-badges '[tx-json]' --from sender-key
```

### JSON Example

```json
{
    "creator": "bb1initiator123...",
    "collectionId": "1",
    "transfers": [
        {
            "from": "bb1sender123...",
            "toAddresses": ["bb1recipient123..."],
            // Balances to transfer (can be left blank if you are using precalculateBalancesFromApproval)
            "balances": [
                {
                    "amount": "10",
                    "ownershipTimes": [
                        { "start": "1", "end": "18446744073709551615" }
                    ],
                    "badgeIds": [{ "start": "1", "end": "5" }]
                }
            ],
            // Specific approval to calculate balances dynamically for (from the approvalCriteria.predeterminedBalances)
            "precalculateBalancesFromApproval": {
                "approvalId": "",
                "approvalLevel": "",
                "approverAddress": "",
                "version": "0"
            },
            // Additional options dependent on what is allowed (e.g. allow timestamp override, token ID override, etc.)
            "precalculationOptions": {
                "overrideTimestamp": "0",
                "badgeIdsOverride": []
            },
            // Supply all merkle proofs for any merkle challenges that need to be satisfied
            "merkleProofs": [],
            // Supply all ETH signature proofs for any ETH signature challenges that need to be satisfied
            "ethSignatureProofs": [
                {
                    "nonce": "unique-nonce-001",
                    "signature": "0x..."
                }
            ],
            // Memo for the transfer (can be left blank)
            "memo": "",

            // Any approval IDs that you want to prioritize for this transfer
            // Note: All approvals with side effects must be prioritized with proper versioning
            "prioritizedApprovals": [
                {
                    "approvalId": "abc123",
                    "approvalLevel": "collection",
                    "approverAddress": "", // blank for collection, otherwise the address of the approver
                    "version": "0"
                }
            ],

            // If specified, we will stop checking after the prioritized approvals list.
            // If false, we will check prioritized first, but then continue to check the rest of the approvals in auto-scan mode
            "onlyCheckPrioritizedCollectionApprovals": false,
            "onlyCheckPrioritizedIncomingApprovals": false,
            "onlyCheckPrioritizedOutgoingApprovals": false,

            // Add your address if you want to claim part of the protocol fee
            "affiliateAddress": "",
            // Number of times to attempt this transfer (default is 1, 0 is empty and also defaults to 1)
            // Use this if you want to try this transfer multiple times
            "numAttempts": "1"
        }
    ]
}
```


## File: ./x-badges/messages/msg-universal-update-collection.md

# MsgUniversalUpdateCollection

A universal message that can be used to either create a new collection or update an existing one. This message combines the functionality of both `MsgCreateCollection` and `MsgUpdateCollection` into a single interface.

## Dual Purpose

-   **Collection Creation**: When `collectionId` is set to `"0"`, this message creates a new collection
-   **Collection Update**: When `collectionId` is set to an existing collection ID, this message updates that collection

## Update Flag Pattern

This message uses an update flag + value pattern for selective updates. Each updatable field has a corresponding boolean flag (e.g., `updateValidBadgeIds`, `updateCollectionPermissions`).

-   **If update flag is `true`**: The corresponding value field is processed and the collection is updated with the new value
-   **If update flag is `false`**: The corresponding value field is completely ignored, regardless of what data is provided

## Authorization & Permissions

-   **For Collection Creation**: Can be executed by any address
-   **For Collection Updates**: Can only be executed by the **current manager** of the collection. All updates must obey the previously set permissions.

## Proto Definition

```protobuf
message MsgUniversalUpdateCollection {
  string creator = 1; // Address creating/updating collection
  string collectionId = 2; // "0" for new collection, existing ID for updates

  // Creation-only fields (only used when collectionId = "0")
  UserBalanceStore defaultBalances = 3;

  // Updateable fields (used for both creation and updates)
  repeated UintRange validBadgeIds = 4;
  bool updateCollectionPermissions = 5;
  CollectionPermissions collectionPermissions = 6;
  bool updateManagerTimeline = 7;
  repeated ManagerTimeline managerTimeline = 8;
  bool updateCollectionMetadataTimeline = 9;
  repeated CollectionMetadataTimeline collectionMetadataTimeline = 10;
  bool updateBadgeMetadataTimeline = 11;
  repeated BadgeMetadataTimeline badgeMetadataTimeline = 12;
  bool updateCustomDataTimeline = 13;
  repeated CustomDataTimeline customDataTimeline = 14;
  bool updateCollectionApprovals = 15;
  repeated CollectionApproval collectionApprovals = 16;
  bool updateStandardsTimeline = 17;
  repeated StandardsTimeline standardsTimeline = 18;
  bool updateIsArchivedTimeline = 19;
  repeated IsArchivedTimeline isArchivedTimeline = 20;

  // Transfer fields
  repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 21;
  repeated CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 22;

  // Invariants (creation-only)
  CollectionInvariants invariants = 23;
}

message MsgUniversalUpdateCollectionResponse {
  string collectionId = 1; // ID of created/updated collection
}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges universal-update-collection '[tx-json]' --from creator-key
```

### JSON Example - Creating a New Collection

```json
{
    "creator": "bb1abc123...",
    "collectionId": "0",
    "defaultBalances": {
        "balances": [],
        "outgoingApprovals": [],
        "incomingApprovals": [],
        "autoApproveSelfInitiatedOutgoingTransfers": false,
        "autoApproveSelfInitiatedIncomingTransfers": true,
        "autoApproveAllIncomingTransfers": false,
        "userPermissions": {
            "canUpdateOutgoingApprovals": [],
            "canUpdateIncomingApprovals": [],
            "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [],
            "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [],
            "canUpdateAutoApproveAllIncomingTransfers": []
        }
    },
    "validBadgeIds": [{ "start": "1", "end": "100" }],
    "updateCollectionPermissions": true,
    "collectionPermissions": {
        "canDeleteCollection": [],
        "canArchiveCollection": [],
        "canUpdateStandards": [],
        "canUpdateCustomData": [],
        "canUpdateManager": [],
        "canUpdateCollectionMetadata": [],
        "canUpdateValidBadgeIds": [],
        "canUpdateBadgeMetadata": [],
        "canUpdateCollectionApprovals": []
    },
    "updateManagerTimeline": true,
    "managerTimeline": [],
    "updateCollectionMetadataTimeline": true,
    "collectionMetadataTimeline": [],
    "updateBadgeMetadataTimeline": true,
    "badgeMetadataTimeline": [],
    "updateCustomDataTimeline": true,
    "customDataTimeline": [],
    "updateCollectionApprovals": true,
    "collectionApprovals": [],
    "updateStandardsTimeline": true,
    "standardsTimeline": [],
    "updateIsArchivedTimeline": true,
    "isArchivedTimeline": [],
    "mintEscrowCoinsToTransfer": [],
    "cosmosCoinWrapperPathsToAdd": [],
    "invariants": {
        "noCustomOwnershipTimes": false,
        "maxSupplyPerId": "0"
    }
}
```

### JSON Example - Updating an Existing Collection

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "updateValidBadgeIds": true,
    "validBadgeIds": [{ "start": "1", "end": "200" }],
    "updateCollectionPermissions": false,
    "collectionPermissions": {},
    "updateManagerTimeline": false,
    "managerTimeline": [],
    "updateCollectionMetadataTimeline": false,
    "collectionMetadataTimeline": [],
    "updateBadgeMetadataTimeline": false,
    "badgeMetadataTimeline": [],
    "updateCustomDataTimeline": false,
    "customDataTimeline": [],
    "updateCollectionApprovals": false,
    "collectionApprovals": [],
    "updateStandardsTimeline": false,
    "standardsTimeline": [],
    "updateIsArchivedTimeline": false,
    "isArchivedTimeline": [],
    "mintEscrowCoinsToTransfer": [],
    "cosmosCoinWrapperPathsToAdd": [],
    "invariants": {}
}
```

## Key Differences from Other Messages

### vs MsgCreateCollection

-   More flexible update flag pattern
-   Can be used for both creation and updates
-   Includes invariants support

### vs MsgUpdateCollection

-   Can create new collections when collectionId = "0"
    -   Includes creation-only fields like `defaultBalances`
-   Includes invariants support

## Invariants Support

When creating a new collection (collectionId = "0"), you can set collection invariants using the `invariants` field. Invariants cannot be modified after collection creation.

```json
{
    "invariants": {
        "noCustomOwnershipTimes": true,
        "maxSupplyPerId": "0"
    }
}
```

## Related Messages

-   [MsgCreateCollection](./msg-create-collection.md)
-   [MsgUpdateCollection](./msg-update-collection.md)
-   [Collection Invariants](../concepts/collection-invariants.md)


## File: ./x-badges/messages/msg-update-collection.md

# MsgUpdateCollection

Updates an existing collection's properties.

## Update Flag Pattern

This message uses an update flag + value pattern for selective updates. Each updatable field has a corresponding boolean flag (e.g., `updateValidBadgeIds`, `updateCollectionPermissions`).

-   **If update flag is `true`**: The corresponding value field is processed and the collection is updated with the new value
-   **If update flag is `false`**: The corresponding value field is completely ignored, regardless of what data is provided

This allows you to update only specific fields without affecting others, and you can safely leave unused value fields empty or with placeholder data.

## Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. All updates must obey the previously set permissions - meaning the permission settings that were in effect _before_ this message was started.

**Important**: If you update the permissions in the current message, those new permissions are applied last and will not be applicable until the following transaction. This prevents circumventing permission restrictions within the same transaction.

## Proto Definition

```protobuf
message MsgUpdateCollection {
  string creator = 1; // Address updating collection (must be manager)
  string collectionId = 2; // ID of collection to update
  bool updateValidBadgeIds = 3;
  repeated UintRange validBadgeIds = 4;
  bool updateCollectionPermissions = 5;
  CollectionPermissions collectionPermissions = 6;
  bool updateManagerTimeline = 7;
  repeated ManagerTimeline managerTimeline = 8;
  bool updateCollectionMetadataTimeline = 9;
  repeated CollectionMetadataTimeline collectionMetadataTimeline = 10;
  bool updateBadgeMetadataTimeline = 11;
  repeated BadgeMetadataTimeline badgeMetadataTimeline = 12;
  bool updateCustomDataTimeline = 13;
  repeated CustomDataTimeline customDataTimeline = 14;
  bool updateCollectionApprovals = 15;
  repeated CollectionApproval collectionApprovals = 16;
  bool updateStandardsTimeline = 17;
  repeated StandardsTimeline standardsTimeline = 18;
  bool updateIsArchivedTimeline = 19;
  repeated IsArchivedTimeline isArchivedTimeline = 20;
  repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 21;
  repeated CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 22;
  CollectionInvariants invariants = 23;
}

message MsgUpdateCollectionResponse {
  string collectionId = 1; // ID of updated collection
}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges update-collection '[tx-json]' --from manager-key
```

### JSON Example

```json
{
    "creator": "bb1abc123...",
    "collectionId": "1",
    "updateValidBadgeIds": true,
    "validBadgeIds": [{ "start": "1", "end": "200" }],
    "updateCollectionPermissions": false,
    "collectionPermissions": {
        "canDeleteCollection": [],
        "canArchiveCollection": [],
        "canUpdateStandards": [],
        "canUpdateCustomData": [],
        "canUpdateManager": [],
        "canUpdateCollectionMetadata": [],
        "canUpdateValidBadgeIds": [],
        "canUpdateBadgeMetadata": [],
        "canUpdateCollectionApprovals": []
    },
    "updateManagerTimeline": false,
    "managerTimeline": [],
    "updateCollectionMetadataTimeline": false,
    "collectionMetadataTimeline": [],
    "updateBadgeMetadataTimeline": false,
    "badgeMetadataTimeline": [],
    "updateCustomDataTimeline": false,
    "customDataTimeline": [],
    "updateCollectionApprovals": false,
    "collectionApprovals": [],
    "updateStandardsTimeline": false,
    "standardsTimeline": [],
    "updateIsArchivedTimeline": false,
    "isArchivedTimeline": [],
    "mintEscrowCoinsToTransfer": [],
    "cosmosCoinWrapperPathsToAdd": [],
    "invariants": {
        "noCustomOwnershipTimes": false,
        "maxSupplyPerId": "0"
    }
}
```


## File: ./x-badges/messages/msg-update-dynamic-store.md

# MsgUpdateDynamicStore

Updates an existing dynamic store's default value.

## Proto Definition

```protobuf
message MsgUpdateDynamicStore {
  string creator = 1; // Address updating the store (must be creator)
  string storeId = 2; // ID of dynamic store to update
  bool defaultValue = 3; // New default value for uninitialized addresses
}

message MsgUpdateDynamicStoreResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges update-dynamic-store [store-id] [default-value] --from creator-key
```

### JSON Example

```json
{
    "creator": "bb1...",
    "storeId": "1",
    "defaultValue": true
}
```


## File: ./x-badges/messages/msg-update-user-approvals.md

# MsgUpdateUserApprovals

Updates a user's approval settings for token transfers.

## Collection ID Auto-Lookup

If you specify `collectionId` as `"0"`, it will automatically lookup the latest collection ID created. This can be used if you are creating a collection and do not know the official collection ID yet but want to perform a multi-message transaction.

## Update Flag Pattern

This message uses an update flag + value pattern for selective updates. Each updatable field has a corresponding boolean flag (e.g., `updateOutgoingApprovals`, `updateIncomingApprovals`, `updateAutoApproveSelfInitiatedOutgoingTransfers`).

-   **If update flag is `true`**: The corresponding value field is processed and the user's settings are updated with the new value
-   **If update flag is `false`**: The corresponding value field is completely ignored, regardless of what data is provided

This allows you to update only specific approval settings without affecting others, and you can safely leave unused value fields empty or with placeholder data.

## Authorization & Permissions

Users can only update their own approvals. Updates must be performed according to the permissions set (i.e. the `userPermissions` previously set for that user).

**Note**: Typically, user permissions are almost always permanently allowed/set to enabled. These permissions only need to be customized in advanced cases where fine-grained control over user approval updates is required.

## Proto Definition

```protobuf
message MsgUpdateUserApprovals {
  string creator = 1; // User updating their approval settings
  string collectionId = 2; // Target collection for approval updates
  bool updateOutgoingApprovals = 3;
  repeated UserOutgoingApproval outgoingApprovals = 4;
  bool updateIncomingApprovals = 5;
  repeated UserIncomingApproval incomingApprovals = 6;
  bool updateAutoApproveSelfInitiatedOutgoingTransfers = 7;
  bool autoApproveSelfInitiatedOutgoingTransfers = 8;
  bool updateAutoApproveSelfInitiatedIncomingTransfers = 9;
  bool autoApproveSelfInitiatedIncomingTransfers = 10;
  bool updateAutoApproveAllIncomingTransfers = 11;
  bool autoApproveAllIncomingTransfers = 12;
  bool updateUserPermissions = 13;
  UserPermissions userPermissions = 14;
}

message MsgUpdateUserApprovalsResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges update-user-approved-transfers '[tx-json]' --from user-key
```

### JSON Example

For complete transaction examples, see [MsgUpdateUserApprovals Examples](../examples/txs/msgupdate-user-approvals/).

```json
{
    "creator": "bb1user123...",
    "collectionId": "1",

    "updateOutgoingApprovals": false,
    "outgoingApprovals": [],

    "updateIncomingApprovals": false,
    "incomingApprovals": [],

    "updateAutoApproveSelfInitiatedOutgoingTransfers": true,
    "autoApproveSelfInitiatedOutgoingTransfers": true,

    "updateAutoApproveSelfInitiatedIncomingTransfers": false,
    "autoApproveSelfInitiatedIncomingTransfers": true,

    "updateAutoApproveAllIncomingTransfers": false,
    "autoApproveAllIncomingTransfers": false,

    "updateUserPermissions": false,
    "userPermissions": {
        "canUpdateOutgoingApprovals": [],
        "canUpdateIncomingApprovals": [],
        "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [],
        "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [],
        "canUpdateAutoApproveAllIncomingTransfers": []
    }
}
```


## File: ./x-badges/queries/README.md

# 🔍 Queries

This directory contains detailed documentation for all query types supported by the badges module.

## Query Categories

### Collection Queries

-   [GetCollection](./get-collection.md) - Retrieve collection data and properties

### Balance Queries

-   [GetBalance](./get-balance.md) - Get user balances for a collection
-   [GetWrappableBalances](./get-wrappable-balances.md) - Get maximum amount of badges that can be wrapped into cosmos coins

### Address List Queries

-   [GetAddressList](./get-address-list.md) - Retrieve address list information

### Approval Tracking Queries

-   [GetApprovalTracker](./get-approval-tracker.md) - Get approval usage tracking data and limits
-   [GetChallengeTracker](./get-challenge-tracker.md) - Get challenge completion tracking status
-   [GetETHSignatureTracker](./get-eth-signature-tracker.md) - Get ETH signature challenge usage tracking status

### Dynamic Store Queries

-   [GetDynamicStore](./get-dynamic-store.md) - Get dynamic store configuration and metadata
-   [GetDynamicStoreValue](./get-dynamic-store-value.md) - Get numeric value for specific address in store

### System Queries

-   [Params](./params.md) - Get current module parameters and configuration


## File: ./x-badges/queries/get-address-list.md

# GetAddressList

Retrieves information about a specific address list.

## Proto Definition

```protobuf
message QueryGetAddressListRequest {
  string listId = 1; // ID of address list to retrieve
}

message QueryGetAddressListResponse {
  AddressList list = 1;
}

message AddressList {
  string listId = 1; // Unique identifier for the address list
  repeated string addresses = 2; // List of addresses included in the list
  bool whitelist = 3; // Whether list includes (true) or excludes (false) specified addresses
  string uri = 4; // URI providing metadata, if applicable
  string customData = 5; // Custom arbitrary data or additional information
  string createdBy = 6; // The user or entity who created the address list
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-address-list [id]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_address_list/1"
```

### Response Example

```json
{
    "list": {
        "listId": "1",
        "addresses": ["bb1...", "bb1..."],
        "whitelist": true,
        "uri": "",
        "customData": "",
        "createdBy": "bb1..."
    }
}
```


## File: ./x-badges/queries/get-approval-tracker.md

# GetApprovalTracker

Retrieves tracking information for approval usage.

## Proto Definition

```protobuf
message QueryGetApprovalTrackerRequest {
  string amountTrackerId = 1; 
  string approvalLevel = 2; // "collection", "incoming", or "outgoing"
  string approverAddress = 3; // Leave blank if approvalLevel is "collection"
  string trackerType = 4; // "overall", "to", "from", "initiatedBy"
  string collectionId = 5;
  string approvedAddress = 6; // Leave blank if trackerType is "overall"
  string approvalId = 7;
}

message QueryGetApprovalTrackerResponse {
  ApprovalTracker tracker = 1;
}

message ApprovalTracker {
  string numTransfers = 1; // Number of transfers that have been processed
  repeated Balance amounts = 2; // Cumulative balances associated with processed transfers
  string lastUpdatedAt = 3; // Last updated at time (UNIX millisecond timestamp)
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-approval-tracker [collectionId] [approvalLevel] [approverAddress] [approvalId] [amountTrackerId] [trackerType] [approvedAddress]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_approvals_tracker/1/outgoing/bb1.../approval-1/tracker-1/overall/"
```

### Response Example
```json
{
  "tracker": {
    "numTransfers": "5",
    "amounts": [
      {
        "amount": "100",
        "badgeIds": [{"start": "1", "end": "10"}],
        "ownershipTimes": [{"start": "1672531200000", "end": "18446744073709551615"}]
      }
    ],
    "lastUpdatedAt": "1672531200000"
  }
}
```

## File: ./x-badges/queries/get-balance.md

# GetBalance

Retrieves balances for a specific address in a collection.

## Proto Definition

```protobuf
message QueryGetBalanceRequest {
  string collectionId = 1; // Collection ID to query
  string address = 2; // Address to get balances for
}

message QueryGetBalanceResponse {
  UserBalanceStore balance = 1;
}

message UserBalanceStore {
  repeated Balance balances = 1; // List of balances associated with this user
  repeated UserOutgoingApproval outgoingApprovals = 2; // Approved outgoing transfers
  repeated UserIncomingApproval incomingApprovals = 3; // Approved incoming transfers
  bool autoApproveSelfInitiatedOutgoingTransfers = 4; // Auto-approve self-initiated outgoing transfers
  bool autoApproveSelfInitiatedIncomingTransfers = 5; // Auto-approve self-initiated incoming transfers
  bool autoApproveAllIncomingTransfers = 6; // Auto-approve all incoming transfers
  UserPermissions userPermissions = 7; // Permissions for this user's actions
}

// See all the proto definitions [here](https://github.com/BitBadges/bitbadgeschain/tree/master/proto/badges)
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-balance [collection-id] [address]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_balance/1/bb1..."
```

### Response Example

```json
{
    "balance": {
        "balances": [
            {
                "amount": "1",
                "badgeIds": [{ "start": "1", "end": "1" }],
                "ownershipTimes": [
                    { "start": "1672531200000", "end": "18446744073709551615" }
                ]
            }
        ],
        "outgoingApprovals": [
            // ...
        ],
        "incomingApprovals": [
            // ...
        ],
        "autoApproveSelfInitiatedOutgoingTransfers": true,
        "autoApproveSelfInitiatedIncomingTransfers": true,
        "autoApproveAllIncomingTransfers": true,
        "userPermissions": {
            // ...
        }
    }
}
```


## File: ./x-badges/queries/get-challenge-tracker.md

# GetChallengeTracker

Retrieves the number of times a given leaf has been used for a specific challenge tracker.

## Proto Definition

```protobuf
message QueryGetChallengeTrackerRequest {
  string collectionId = 1;
  string approvalLevel = 2; // "collection", "incoming", or "outgoing"
  string approverAddress = 3; // Leave blank if approvalLevel is "collection"
  string challengeTrackerId = 4;
  string leafIndex = 5;
  string approvalId = 6;
}

message QueryGetChallengeTrackerResponse {
  string numUsed = 1; // Number of times this leaf has been used
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-challenge-tracker [collectionId] [approvalLevel] [approverAddress] [approvalId] [challengeTrackerId] [leafIndex]

# REST API
# Note for blank values, use "" so you may have // in the query
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_challenge_tracker/1/collection//approval-123/challenge-1/42"
```

### Response Example

```json
{
    "numUsed": "1"
}
```


## File: ./x-badges/queries/get-collection.md

# GetCollection

Retrieves complete information about a collection.

## Proto Definition

```protobuf
message QueryGetCollectionRequest {
  string collectionId = 1; // ID of collection to retrieve
}

message QueryGetCollectionResponse {
  BadgeCollection collection = 1;
}

message BadgeCollection {
  string collectionId = 1; // Unique identifier for this collection
  repeated CollectionMetadataTimeline collectionMetadataTimeline = 2; // Collection metadata over time
  repeated BadgeMetadataTimeline badgeMetadataTimeline = 3; // Token metadata over time
  repeated CustomDataTimeline customDataTimeline = 4; // Arbitrary custom data over time
  repeated ManagerTimeline managerTimeline = 5; // Manager address over time
  CollectionPermissions collectionPermissions = 6; // Collection permissions
  repeated CollectionApproval collectionApprovals = 7; // Collection-level approvals
  repeated StandardsTimeline standardsTimeline = 8; // Standards over time
  repeated IsArchivedTimeline isArchivedTimeline = 9; // Archive status over time
  UserBalanceStore defaultBalances = 10; // Default balance store for users
  string createdBy = 11; // Creator of the collection
  repeated UintRange validBadgeIds = 12; // Valid token ID ranges
  string mintEscrowAddress = 13; // Generated escrow address for the collection
}

// See all the proto definitions [here](https://github.com/bitbadges/bitbadgeschain/tree/master/proto/badges)
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-collection [id]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_collection/1"
```

### Response Example

```json
{
    "collection": {
        "collectionId": "1"
        // ...
    }
}
```


## File: ./x-badges/queries/get-dynamic-store-value.md

# GetDynamicStoreValue

Retrieves the numeric value for a specific address in a dynamic store. This is the number of uses an address has left for a dynamic store.

## Proto Definition

```protobuf
message QueryGetDynamicStoreValueRequest {
  string storeId = 1; // ID of dynamic store to query
  string address = 2; // Address to get value for
}

message QueryGetDynamicStoreValueResponse {
  DynamicStoreValue value = 1;
}

message DynamicStoreValue {
  string storeId = 1; // The dynamic store ID
  string address = 2; // The address this value applies to
  string value = 3; // The numeric value
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-dynamic-store-value [store-id] [address]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_dynamic_store_value/1/bb1..."
```

### Response Example

```json
{
    "value": {
        "storeId": "1",
        "address": "bb1...",
        "value": "100"
    }
}
```


## File: ./x-badges/queries/get-dynamic-store.md

# GetDynamicStore

Retrieves information about a dynamic store.

## Proto Definition

```protobuf
message QueryGetDynamicStoreRequest {
  string storeId = 1;
}

message QueryGetDynamicStoreResponse {
  DynamicStore store = 1;
}

message DynamicStore {
  // The unique identifier for this dynamic store. This is assigned by the blockchain.
  string storeId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  // The address of the creator of this dynamic store.
  string createdBy = 2;
  // The default value for uninitialized addresses.
  bool defaultValue = 3;
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-dynamic-store [store-id]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_dynamic_store/1"
```

### Response Example

```json
{
    "store": {
        "storeId": "1",
        "createdBy": "bb1...",
        "defaultValue": false
    }
}
```


## File: ./x-badges/queries/get-eth-signature-tracker.md

# GetETHSignatureTracker

Retrieves the number of times a given signature has been used for a specific ETH signature challenge tracker.

## Proto Definition

```protobuf
message QueryGetETHSignatureTrackerRequest {
  string collectionId = 1;
  string approvalLevel = 2; // "collection", "incoming", or "outgoing"
  string approverAddress = 3; // Leave blank if approvalLevel is "collection"
  string approvalId = 4;
  string challengeTrackerId = 5;
  string signature = 6;
}

message QueryGetETHSignatureTrackerResponse {
  string numUsed = 1; // Number of times this signature has been used
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-num-used-for-eth-signature-challenge [collectionId] [approvalLevel] [approverAddress] [approvalId] [challengeTrackerId] [signature]

# REST API
# Note for blank values, use "" so you may have // in the query
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_eth_signature_tracker/1/collection//approval-123/challenge-1/0x1234567890abcdef..."
```

### Response Example

```json
{
    "numUsed": "1"
}
```

## Notes

- Each signature can only be used once per challenge tracker
- If a signature has never been used, the response will be "0"
- The signature parameter should be the full Ethereum signature (0x-prefixed hex string) 

## File: ./x-badges/queries/get-wrappable-balances.md

# GetWrappableBalances

Retrieves the maximum amount of badges that can be wrapped into cosmos coins for a specific denom and user address.

## Proto Definition

```protobuf
message QueryGetWrappableBalancesRequest {
  string denom = 1; // The cosmos coin denom (e.g., "badges:1:mytoken")
  string address = 2; // Address to get wrappable balances for
}

message QueryGetWrappableBalancesResponse {
  Uint maxWrappableAmount = 1; // Maximum amount that can be wrapped
}
```

## Description

This query calculates the maximum amount of badges that a user can wrap into cosmos coins for a given denom. It:

1. **Parses the denom**: Extracts the collection ID from the denom format `badges:COLL_ID:*` or `badgeslp:COLL_ID:*`
2. **Finds the wrapper path**: Locates the corresponding cosmos coin wrapper path for the denom
3. **Calculates maximum wrappable amount**: Determines the largest amount the user can wrap based on their current badge balances

The query supports both static denoms and dynamic `{id}` placeholder denoms. For dynamic denoms, it extracts numeric characters from the base denom to replace the `{id}` placeholder.

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-wrappable-balances [denom] [address]

# Example with static denom
bitbadgeschaind query badges get-wrappable-balances "badges:1:mytoken" "bb1..."

# Example with dynamic denom (where 123 is the badge ID)
bitbadgeschaind query badges get-wrappable-balances "badgeslp:1:token123" "bb1..."
```

### REST API

```bash
# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_wrappable_balances?denom=badges:1:mytoken&address=bb1..."
```

### Response Example

```json
{
    "maxWrappableAmount": "1000"
}
```

## Error Cases

-   **Invalid denom format**: Denom must start with "badges:" or "badgeslp:" and follow the format `badges:COLL_ID:*` or `badgeslp:COLL_ID:*`
-   **Collection not found**: The specified collection ID doesn't exist
-   **Wrapper path not found**: No cosmos coin wrapper path matches the given denom
-   **No balances**: User has no balances for the required badge IDs and ownership times

## Use Cases

-   **Pre-wrapping validation**: Check how much a user can wrap before attempting the wrap operation
-   **UI display**: Show users their maximum wrappable amount for different tokens
-   **Batch operations**: Calculate optimal amounts for multiple wrapping operations
-   **Integration testing**: Verify wrapper path configurations work correctly

## Related Queries

-   [GetBalance](./get-balance.md) - Get user's current badge balances
-   [GetCollection](./get-collection.md) - Get collection details including wrapper paths


## File: ./x-badges/queries/params.md

# Params

Retrieves the current module parameters.

## Proto Definition

```protobuf
message QueryParamsRequest {}

message QueryParamsResponse {
  Params params = 1;
}

message Params {
  // Array of allowed denominations for fee payments and escrow operations
  repeated string allowed_denoms = 1;
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges params

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/params"
```

### Response Example
```json
{
  "params": {
    "allowedDenoms": ["ubadge", "ibc/1234567890"]
  }
}
```


## File: ./x-gamm/README.md

# 📚 Overview

This directory contains comprehensive developer documentation for the BitBadges blockchain's `x/gamm` module.

This module was forked from Osmosis's `x/gamm` module with several key modifications to support BitBadges tokens and enhance compatibility.

## Key Differences from Osmosis

### 1. Interface Revamps

-   Removed `smoothWeightChangeParams` and other unused parameters
-   Updated certain type definitions for better compatibility with our codebase
-   Streamlined interfaces for improved performance
-   Remove unneeded logic like stableswap pools and governance proposal handling
-   Removed future pool governor functionality
-   Removed pool creation fee requirements

### 2. Badge Token Integration

The main difference is in the badge token handling system. With every attempted transfer of BitBadges tokens, the system:

-   **Wrapping Conversion**: Uses `cosmosCoinWrapperPaths` defined by the collection to convert badge tokens to `x/bank` denominations (using the `path.balances` array) at a set conversion rate
-   **Mint/Burns**: Behind the scenes, mints/burns at the conversion rate into an `x/bank` denomination before / after each transfer to/from a pool
-   **Pool Compatibility**: Ensures seamless integration with existing pool infrastructure
-   **Automatic Conversion**: Handles badge token transfers to/from pools automatically

#### Conversion Example

Here's how the badge token conversion works:

**Badge Token**: `badgeslp:21:utoken`

-   Collection ID: `21`
-   Base Denom: `utoken`
-   Wrapper Path Balances Conversion Rate: `[{ amount: 1n, badgeIds: [{ start: 1n, end: 1n }], ownershipTimes: UintRangeArray.FullRanges() }]`

**Conversion Process**:

```
1 badgeslp:21:utoken = [{ amount: 1n, badgeIds: [{ start: 1n, end: 1n }], ownershipTimes: UintRangeArray.FullRanges() }]

2 badgeslp:21:utoken = [{ amount: 2n, badgeIds: [{ start: 1n, end: 1n }], ownershipTimes: UintRangeArray.FullRanges() }]
```

**Visual Flow**:

```
User wants to add 5 badgeslp:21:utoken to a pool in liquidity
    ↓
System reads cosmosCoinWrapperPaths for collection 21
    ↓
Finds path with denom "utoken" and balances array (using the wrapper path's balances array)
    ↓
Transfers the x/badges balances to the pool address with conversions applied
    ↓
Pool receives the x/badges balances and mints the corresponding badgeslp:21:utoken balances which are native x/bank denominations
    ↓
The user now has the equivalent of badgeslp:21:utoken balances in the pool (all else in x/gamm is kept the same as standard in Osmosis)
```

For the reverse, when a pool wants to send tokens to the user, it will burn the native x/bank denominations and transfer the x/badges balances back to the user address.

## Table of Contents

1. [Introduction](broken-reference) - Overview and key concepts
2. [Messages](messages/) - Transaction messages and handlers

## Message Reference

### Core Operations

-   [MsgCreateBalancerPool](messages/msg-create-balancer-pool.md) - Create new balancer pool
-   [MsgJoinPool](messages/msg-join-pool.md) - Join existing pool with liquidity
-   [MsgSwapExactAmountIn](messages/msg-swap-exact-amount-in.md) - Swap exact amount of tokens in
-   [MsgExitPool](messages/msg-exit-pool.md) - Exit pool and receive tokens

## Query Reference

For all GAMM queries, please refer to the [BitBadges LCD API](https://lcd.bitbadges.io/).

The LCD provides comprehensive query endpoints for:

-   Pool information and statistics
-   Trading data and spot prices
-   Module parameters
-   And more

All queries follow the standard Cosmos SDK query patterns and can be accessed via REST API or gRPC.

## Quick Links

-   [BitBadges Chain Repository](https://github.com/bitbadges/bitbadgeschain)
-   [BitBadges Documentation](https://docs.bitbadges.io)
-   [Proto Definitions](https://github.com/bitbadges/bitbadgeschain/tree/master/proto/gamm)

## Documentation Style

This documentation follows the [Cosmos SDK module documentation standards](https://docs.cosmos.network/main/building-modules/README) and is designed for developers building on or integrating with the BitBadges blockchain.


## File: ./x-gamm/introduction.md

# Introduction

The `x/gamm` module implements the Generalized Automated Market Maker (GAMM) functionality for the BitBadges blockchain. This module was forked from Osmosis's `x/gamm` module and provides the core infrastructure for decentralized exchange (DEX) operations, including liquidity pool creation, token swaps, and yield farming.

## Fork from Osmosis

This module maintains compatibility with Osmosis's GAMM functionality while adding specialized support for BitBadges tokens. The key modifications include:

-   **Interface Simplification**: Removed unused parameters and streamlined type definitions
-   **Badge Token Support**: Integrated native badge token handling with automatic conversion
-   **Enhanced Compatibility**: Ensures seamless operation with existing DeFi infrastructure

## Key Concepts

### Automated Market Maker (AMM)

An AMM is a decentralized exchange protocol that uses mathematical formulas to determine token prices and facilitate trades without the need for traditional orderbooks.

### Liquidity Pools

Liquidity pools are smart contracts that hold pairs of tokens and allow users to trade between them. Each pool has:

-   **Pool Assets**: The tokens held in the pool
-   **Pool Shares**: LP tokens representing ownership of the pool
-   **Swap Fee**: Fee charged on each trade
-   **Exit Fee**: Fee charged when exiting the pool

### Pool Types

The GAMM module currently supports:

-   **Balancer Pools**: Standard AMM pools with configurable weights


## File: ./x-gamm/messages/README.md

# 📨 Messages

This directory contains documentation for the core transaction messages supported by the `x/gamm` module.

## Core Operations

### Pool Management

* [MsgCreateBalancerPool](msg-create-balancer-pool.md) - Create new balancer pool with initial liquidity
* [MsgJoinPool](msg-join-pool.md) - Join existing pool with liquidity
* [MsgExitPool](msg-exit-pool.md) - Exit pool and receive underlying tokens

### Trading

* [MsgSwapExactAmountIn](msg-swap-exact-amount-in.md) - Swap exact amount of tokens in

## Core Message List

The GAMM module supports 4 core transaction messages:

1. **MsgCreateBalancerPool** - Create new balancer pool
2. **MsgJoinPool** - Join pool with proportional tokens
3. **MsgSwapExactAmountIn** - Swap exact input for minimum output
4. **MsgExitPool** - Exit pool and receive underlying tokens


## File: ./x-gamm/messages/msg-create-balancer-pool.md

# MsgCreateBalancerPool

Creates a new balancer pool.

The poolId will be assigned at execution time and is obtainable in the transaction response. The pool creator must provide initial liquidity and set pool parameters.

## Pool Creation Properties

The creation transaction for a balancer pool is unique in several ways:

-   Initial liquidity must be provided by the creator
-   Pool parameters like swap fee and exit fee are set
-   Token weights are configured for the pool assets
-   A dedicated module account is created for the pool

## Proto Definition

```protobuf
// ===================== MsgCreatePool
message MsgCreateBalancerPool {
  option (amino.name) = "gamm/create-balancer-pool";
  option (cosmos.msg.v1.signer) = "sender";

  string sender = 1 [ (gogoproto.moretags) = "yaml:\"sender\"" ];

  gamm.poolmodels.balancer.PoolParams pool_params = 2
      [ (gogoproto.moretags) = "yaml:\"pool_params\"" ];

  repeated gamm.poolmodels.balancer.PoolAsset pool_assets = 3
      [ (gogoproto.nullable) = false ];
}

// Returns the poolID
message MsgCreateBalancerPoolResponse {
  uint64 pool_id = 1 [ (gogoproto.customname) = "PoolID" ];
}
```

### JSON Example

```json
{
    "sender": "bb1abc123...",
    "pool_params": {
        "swap_fee": "0.003", // Note: Depending on serialization format this may be something like "300000000" for compatibility with sdk.Int format
        "exit_fee": "0.000"
    },
    "pool_assets": [
        {
            "token": {
                "denom": "ubadge",
                "amount": "1000000"
            },
            "weight": "50"
        },
        {
            "token": {
                "denom": "badgeslp:21:utoken",
                "amount": "5000000"
            },
            "weight": "50"
        }
    ]
}
```


## File: ./x-gamm/messages/msg-exit-pool.md

# MsgExitPool

Exits an existing pool by burning LP tokens and receiving underlying tokens.

Users can exit a pool by burning their LP tokens. In return, they receive the underlying pool tokens proportional to their share.

## Exit Pool Properties

When exiting a pool:

-   LP tokens are burned from the user
-   Underlying tokens are returned proportionally
-   Pool liquidity decreases
-   Exit fees may be applied

## Proto Definition

```protobuf
// ===================== MsgExitPool
message MsgExitPool {
  option (amino.name) = "gamm/exit-pool";
  option (cosmos.msg.v1.signer) = "sender";

  string sender = 1 [ (gogoproto.moretags) = "yaml:\"sender\"" ];
  uint64 pool_id = 2 [ (gogoproto.moretags) = "yaml:\"pool_id\"" ];
  string share_in_amount = 3 [

    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.moretags) = "yaml:\"share_in_amount\"",
    (gogoproto.nullable) = false
  ];

  repeated cosmos.base.v1beta1.Coin token_out_mins = 4 [
    (gogoproto.moretags) = "yaml:\"token_out_min_amounts\"",
    (gogoproto.nullable) = false
  ];
}

message MsgExitPoolResponse {
  repeated cosmos.base.v1beta1.Coin token_out = 1 [
    (gogoproto.moretags) = "yaml:\"token_out\"",
    (gogoproto.nullable) = false
  ];
}
```

### JSON Example

```json
{
    "sender": "bb1abc123...",
    "pool_id": "1",
    "share_in_amount": "100000",
    "token_out_mins": [
        {
            "denom": "uatom",
            "amount": "10000"
        },
        {
            "denom": "uosmo",
            "amount": "50000"
        }
    ]
}
```

## Token Proportions

The tokens received will be in the same proportion as the current pool composition. The user cannot specify which tokens to receive.

## Slippage Protection

The `token_out_mins` field provides slippage protection by setting minimum amounts for each token that must be received from the exit operation.

## Exit Fees

Some pools may charge exit fees, which are deducted from the tokens returned to the user.

## LP Token Burning

Upon successful exit, LP tokens are burned from the user's address, reducing their ownership stake in the pool.


## File: ./x-gamm/messages/msg-join-pool.md

# MsgJoinPool

Joins an existing pool by providing liquidity. Users can join a pool by providing tokens proportional to the current pool composition. In return, they receive LP tokens representing their share of the pool.

## Join Pool Properties

When joining a pool:

-   Tokens must be provided in the correct proportions
-   LP tokens are minted to the user
-   Pool liquidity increases
-   User becomes eligible for trading fees

## Proto Definition

```protobuf
// ===================== MsgJoinPool
// This is really MsgJoinPoolNoSwap
message MsgJoinPool {
  option (amino.name) = "gamm/join-pool";
  option (cosmos.msg.v1.signer) = "sender";

  string sender = 1 [ (gogoproto.moretags) = "yaml:\"sender\"" ];
  uint64 pool_id = 2 [ (gogoproto.moretags) = "yaml:\"pool_id\"" ];
  string share_out_amount = 3 [

    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.moretags) = "yaml:\"pool_amount_out\"",
    (gogoproto.nullable) = false
  ];
  repeated cosmos.base.v1beta1.Coin token_in_maxs = 4 [
    (gogoproto.moretags) = "yaml:\"token_in_max_amounts\"",
    (gogoproto.nullable) = false
  ];
}

message MsgJoinPoolResponse {
  string share_out_amount = 1 [

    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.moretags) = "yaml:\"share_out_amount\"",
    (gogoproto.nullable) = false
  ];
  repeated cosmos.base.v1beta1.Coin token_in = 2 [
    (gogoproto.moretags) = "yaml:\"token_out\"",
    (gogoproto.nullable) = false
  ];
}
```

### JSON Example

```json
{
    "sender": "bb1abc123...",
    "pool_id": "1",
    "share_out_amount": "1000000",
    "token_in_maxs": [
        {
            "denom": "uatom",
            "amount": "100000"
        },
        {
            "denom": "uosmo",
            "amount": "500000"
        }
    ]
}
```

## Token Proportions

The tokens provided must be in the same proportion as the current pool composition. If not, the transaction will fail or tokens will be returned.

## Slippage Protection

The `token_in_maxs` field provides slippage protection by setting maximum amounts for each token that can be used in the join operation.

## LP Token Minting

Upon successful join, LP tokens are minted to the user's address. These tokens represent ownership of the pool and can be used for:

-   Earning trading fees
-   Governance participation
-   Staking in yield farming programs


## File: ./x-gamm/messages/msg-swap-exact-amount-in.md

# MsgSwapExactAmountIn

Swaps an exact amount of tokens in for a minimum amount of tokens out.

This message allows users to swap a specific amount of input tokens for output tokens, with slippage protection through the minimum output amount.

## Swap Properties

When executing a swap:

-   Exact input amount is specified
-   Minimum output amount provides slippage protection
-   Swap fee is deducted from the input
-   Price impact is calculated based on pool liquidity

## Proto Definition

```protobuf
// ===================== MsgSwapExactAmountIn
message MsgSwapExactAmountIn {
  option (amino.name) = "gamm/swap-exact-amount-in";
  option (cosmos.msg.v1.signer) = "sender";

  string sender = 1 [ (gogoproto.moretags) = "yaml:\"sender\"" ];
  repeated poolmanager.v1beta1.SwapAmountInRoute routes = 2
      [ (gogoproto.nullable) = false ];
  cosmos.base.v1beta1.Coin token_in = 3 [
    (gogoproto.moretags) = "yaml:\"token_in\"",
    (gogoproto.nullable) = false
  ];
  string token_out_min_amount = 4 [

    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.moretags) = "yaml:\"token_out_min_amount\"",
    (gogoproto.nullable) = false
  ];
}

message MsgSwapExactAmountInResponse {
  string token_out_amount = 1 [

    (gogoproto.customtype) = "cosmossdk.io/math.Int",
    (gogoproto.moretags) = "yaml:\"token_out_amount\"",
    (gogoproto.nullable) = false
  ];
}
```

### JSON Example

```json
{
    "sender": "bb1abc123...",
    "routes": [
        {
            "pool_id": "1",
            "token_out_denom": "uosmo"
        }
    ],
    "token_in": {
        "denom": "uatom",
        "amount": "1000000"
    },
    "token_out_min_amount": "5000000"
}
```

## Multi-Hop Swaps

The `routes` field allows for multi-hop swaps through multiple pools. The swap will execute through each pool in sequence.

## Slippage Protection

The `token_out_min_amount` field ensures that the user receives at least the specified amount of output tokens, protecting against price slippage.

## Swap Fees

Each pool in the swap route charges a swap fee, which is deducted from the input amount before the swap is executed.


## File: ./.github/workflows/for--llms.yml

```
name: Generate LLM Training Text

on:
    push:
        branches: [main, master]
    workflow_dispatch: # Allows manual triggering

jobs:
    generate-llm-text:
        runs-on: ubuntu-latest
        permissions:
            contents: write
        steps:
            - name: Checkout repository
              uses: actions/checkout@v3

            - name: Set up Python
              uses: actions/setup-python@v4
              with:
                  python-version: '3.10'

            - name: Install dependencies
              run: |
                  python -m pip install --upgrade pip

            - name: Create for-llms.txt file
              run: |
                  echo "# Gitbook Documentation Compilation" > for-llms.txt
                  echo "Generated on $(date)" >> for-llms.txt
                  echo "" >> for-llms.txt

                  # Find all markdown files
                  find . -type f -name "*.md" | sort | while read -r file; do
                    # Skip hidden directories and node_modules
                    if [[ "$file" != *"/.git/"* && "$file" != */node_modules/* && "$file" != */build/* && "$file" != */dist/* ]]; then
                      echo "Processing $file"
                      
                      # Add file path as header
                      echo -e "\n\n## File: $file\n" >> for-llms.txt
                      
                      # Add file content
                      cat "$file" >> for-llms.txt
                    fi
                  done

                  # Also find and process any other text-based documentation files
                  find . -type f -name "*.txt" -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" | sort | while read -r file; do
                    if [[ "$file" != *"/.git/"* && "$file" != */node_modules/* && "$file" != */build/* && "$file" != */dist/* && "$file" != *"for-llms.txt"* ]]; then
                      echo "Processing $file"
                      
                      # Add file path as header
                      echo -e "\n\n## File: $file\n" >> for-llms.txt
                      echo '```' >> for-llms.txt
                      
                      # Add file content
                      cat "$file" >> for-llms.txt
                      
                      echo '```' >> for-llms.txt
                    fi
                  done

            - name: Upload for-llms.txt as artifact
              uses: actions/upload-artifact@v4
              with:
                  name: llm-training-data
                  path: for-llms.txt

            - name: Commit and push for-llms.txt
              run: |
                  git config --local user.email "action@github.com"
                  git config --local user.name "GitHub Action"
                  git add for-llms.txt
                  git commit -m "Update for-llms.txt via GitHub Action" || echo "No changes to commit"
                  git push
```


## File: ./.vscode/settings.json

```
{
  "workbench.colorCustomizations": {
    "activityBar.background": "#2E2461",
    "titleBar.activeBackground": "#403287",
    "titleBar.activeForeground": "#FBFBFE"
  }
}```

# Gitbook Documentation Compilation
Generated on Mon Jul 14 01:02:46 UTC 2025



## File: ./.gitbook/assets/README (1).md

BitBadges / [Exports](modules.md)


## File: ./.gitbook/assets/README.md

BitBadges / [Exports](modules.md)


## File: ./.gitbook/assets/modules (1).md

[BitBadges](README.md) / Exports

# BitBadges

## Table of contents

### Enumerations

- [DistributionMethod](enums/DistributionMethod.md)
- [MetadataAddMethod](enums/MetadataAddMethod.md)
- [SupportedChain](enums/SupportedChain.md)
- [TransactionStatus](enums/TransactionStatus.md)

### Interfaces

- [AccountDocs](interfaces/AccountDocs.md)
- [AccountDocument](interfaces/AccountDocument.md)
- [AccountMap](interfaces/AccountMap.md)
- [AccountResponse](interfaces/AccountResponse.md)
- [ActivityItem](interfaces/ActivityItem.md)
- [Addresses](interfaces/Addresses.md)
- [AnnouncementActivityItem](interfaces/AnnouncementActivityItem.md)
- [Approval](interfaces/Approval.md)
- [BadgeMetadata](interfaces/BadgeMetadata.md)
- [BadgeMetadataMap](interfaces/BadgeMetadataMap.md)
- [BadgeSupplyAndAmount](interfaces/BadgeSupplyAndAmount.md)
- [BadgeUri](interfaces/BadgeUri.md)
- [Balance](interfaces/Balance.md)
- [BalanceObject](interfaces/BalanceObject.md)
- [BalancesMap](interfaces/BalancesMap.md)
- [BitBadgeCollection](interfaces/BitBadgeCollection.md)
- [BitBadgeMintObject](interfaces/BitBadgeMintObject.md)
- [BitBadgesUserInfo](interfaces/BitBadgesUserInfo.md)
- [ClaimItem](interfaces/ClaimItem.md)
- [ClaimItemWithTrees](interfaces/ClaimItemWithTrees.md)
- [Claims](interfaces/Claims.md)
- [CollectionDocs](interfaces/CollectionDocs.md)
- [CollectionMap](interfaces/CollectionMap.md)
- [CosmosAccountInformation](interfaces/CosmosAccountInformation.md)
- [DbStatus](interfaces/DbStatus.md)
- [Docs](interfaces/Docs.md)
- [GetAccountResponse](interfaces/GetAccountResponse.md)
- [GetBadgeBalanceResponse](interfaces/GetBadgeBalanceResponse.md)
- [GetBalanceResponse](interfaces/GetBalanceResponse.md)
- [GetCollectionResponse](interfaces/GetCollectionResponse.md)
- [GetOwnersResponse](interfaces/GetOwnersResponse.md)
- [GetPortfolioResponse](interfaces/GetPortfolioResponse.md)
- [IdRange](interfaces/IdRange.md)
- [IndexerStatus](interfaces/IndexerStatus.md)
- [LatestBlockStatus](interfaces/LatestBlockStatus.md)
- [MetadataDocs](interfaces/MetadataDocs.md)
- [MetadataDocument](interfaces/MetadataDocument.md)
- [PaginationInfo](interfaces/PaginationInfo.md)
- [PasswordDocument](interfaces/PasswordDocument.md)
- [PendingTransfer](interfaces/PendingTransfer.md)
- [Proof](interfaces/Proof.md)
- [SearchResponse](interfaces/SearchResponse.md)
- [StoredBadgeCollection](interfaces/StoredBadgeCollection.md)
- [SubassetSupply](interfaces/SubassetSupply.md)
- [TransferActivityItem](interfaces/TransferActivityItem.md)
- [TransferList](interfaces/TransferList.md)
- [TransferListWithUnregisteredUsers](interfaces/TransferListWithUnregisteredUsers.md)
- [Transfers](interfaces/Transfers.md)
- [TransfersExtended](interfaces/TransfersExtended.md)
- [UserBalance](interfaces/UserBalance.md)

### Type Aliases

- [Permissions](modules.md#permissions)

### Variables

- [AllAddressesTransferList](modules.md#alladdressestransferlist)
- [CHAIN\_DETAILS](modules.md#chain_details)
- [CanCreateMoreBadgesDigit](modules.md#cancreatemorebadgesdigit)
- [CanDeleteDigit](modules.md#candeletedigit)
- [CanManagerBeTransferredDigit](modules.md#canmanagerbetransferreddigit)
- [CanUpdateBytesDigit](modules.md#canupdatebytesdigit)
- [CanUpdateDisallowedDigit](modules.md#canupdatedisalloweddigit)
- [CanUpdateUrisDigit](modules.md#canupdateurisdigit)
- [DefaultPlaceholderMetadata](modules.md#defaultplaceholdermetadata)
- [ErrorMetadata](modules.md#errormetadata)
- [GO\_MAX\_UINT\_64](modules.md#go_max_uint_64)
- [MAX\_DATE\_TIMESTAMP](modules.md#max_date_timestamp)
- [METADATA\_PAGE\_LIMIT](modules.md#metadata_page_limit)
- [MINT\_ACCOUNT](modules.md#mint_account)
- [NUM\_PERMISSIONS](modules.md#num_permissions)

### Functions

- [AddBalancesForIdRanges](modules.md#addbalancesforidranges)
- [DeleteBalanceForIdRanges](modules.md#deletebalanceforidranges)
- [GetAccountByNumberRoute](modules.md#getaccountbynumberroute)
- [GetAccountRoute](modules.md#getaccountroute)
- [GetAccountsRoute](modules.md#getaccountsroute)
- [GetBadgeBalanceRoute](modules.md#getbadgebalanceroute)
- [GetBalanceInfoToInsertToStorage](modules.md#getbalanceinfotoinserttostorage)
- [GetBalanceRoute](modules.md#getbalanceroute)
- [GetBalancesForIdRanges](modules.md#getbalancesforidranges)
- [GetCollectionRoute](modules.md#getcollectionroute)
- [GetCollectionsRoute](modules.md#getcollectionsroute)
- [GetIdRangeToInsert](modules.md#getidrangetoinsert)
- [GetIdRangesToInsertToStorage](modules.md#getidrangestoinserttostorage)
- [GetIdRangesWithOmitEmptyCaseHandled](modules.md#getidrangeswithomitemptycasehandled)
- [GetIdxSpanForRange](modules.md#getidxspanforrange)
- [GetIdxToInsertForNewId](modules.md#getidxtoinsertfornewid)
- [GetMetadataRoute](modules.md#getmetadataroute)
- [GetOwnersRoute](modules.md#getownersroute)
- [GetPermissionNumberValue](modules.md#getpermissionnumbervalue)
- [GetPermissions](modules.md#getpermissions)
- [GetPortfolioRoute](modules.md#getportfolioroute)
- [GetSearchRoute](modules.md#getsearchroute)
- [GetStatusRoute](modules.md#getstatusroute)
- [InsertRangeToIdRanges](modules.md#insertrangetoidranges)
- [MergePrevOrNextIfPossible](modules.md#mergeprevornextifpossible)
- [NormalizeIdRange](modules.md#normalizeidrange)
- [RemoveIdsFromIdRange](modules.md#removeidsfromidrange)
- [SafeAdd](modules.md#safeadd)
- [SafeSubtract](modules.md#safesubtract)
- [SearchBalances](modules.md#searchbalances)
- [SearchIdRangesForId](modules.md#searchidrangesforid)
- [SetBalanceForIdRanges](modules.md#setbalanceforidranges)
- [SortIdRangesAndMergeIfNecessary](modules.md#sortidrangesandmergeifnecessary)
- [SubtractBalancesForIdRanges](modules.md#subtractbalancesforidranges)
- [UpdateBalancesForIdRanges](modules.md#updatebalancesforidranges)
- [UpdatePermissions](modules.md#updatepermissions)
- [ValidatePermissions](modules.md#validatepermissions)
- [ValidatePermissionsUpdate](modules.md#validatepermissionsupdate)
- [checkIfApproved](modules.md#checkifapproved)
- [checkIfApprovedInTransferList](modules.md#checkifapprovedintransferlist)
- [checkIfIdRangesOverlap](modules.md#checkifidrangesoverlap)
- [convertToBitBadgesUserInfo](modules.md#converttobitbadgesuserinfo)
- [convertToBitBadgesAddress](modules.md#converttocosmosaddress)
- [createCollectionFromMsgNewCollection](modules.md#createcollectionfrommsgnewcollection)
- [doesChainMatchName](modules.md#doeschainmatchname)
- [filterBadgeActivityForBadgeId](modules.md#filterbadgeactivityforbadgeid)
- [getAbbreviatedAddress](modules.md#getabbreviatedaddress)
- [getBadgeIdsToDisplayForPageNumber](modules.md#getbadgeidstodisplayforpagenumber)
- [getBalanceAfterTransfer](modules.md#getbalanceaftertransfer)
- [getBalanceAfterTransfers](modules.md#getbalanceaftertransfers)
- [getBlankBalance](modules.md#getblankbalance)
- [getChainForAddress](modules.md#getchainforaddress)
- [getClaimsFromClaimItems](modules.md#getclaimsfromclaimitems)
- [getIdRangesForAllBadgeIdsInCollection](modules.md#getidrangesforallbadgeidsincollection)
- [getMatchingAddressesFromTransferList](modules.md#getmatchingaddressesfromtransferlist)
- [getMaxBatchId](modules.md#getmaxbatchid)
- [getMetadataForBadgeId](modules.md#getmetadataforbadgeid)
- [getMetadataMapObjForBadgeId](modules.md#getmetadatamapobjforbadgeid)
- [getNonTransferableDisallowedTransfers](modules.md#getnontransferabledisallowedtransfers)
- [getSupplyByBadgeId](modules.md#getsupplybybadgeid)
- [getTransferListForSelectOptions](modules.md#gettransferlistforselectoptions)
- [getTransfersFromClaimItems](modules.md#gettransfersfromclaimitems)
- [isAddressValid](modules.md#isaddressvalid)
- [isTransferListFull](modules.md#istransferlistfull)
- [populateFieldsOfOtherBadges](modules.md#populatefieldsofotherbadges)
- [updateMetadataForBadgeIdsFromIndexerIfAbsent](modules.md#updatemetadataforbadgeidsfromindexerifabsent)
- [updateMetadataMap](modules.md#updatemetadatamap)
- [updateTransferListAccountNums](modules.md#updatetransferlistaccountnums)

## Type Aliases

### Permissions

Ƭ **Permissions**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `CanCreateMoreBadges` | `boolean` |
| `CanDelete` | `boolean` |
| `CanManagerBeTransferred` | `boolean` |
| `CanUpdateBytes` | `boolean` |
| `CanUpdateDisallowed` | `boolean` |
| `CanUpdateUris` | `boolean` |

#### Defined in

[permissions.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L3)

## Variables

### AllAddressesTransferList

• `Const` **AllAddressesTransferList**: [`TransferList`](interfaces/TransferList.md)

#### Defined in

[badges.ts:109](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L109)

___

### CHAIN\_DETAILS

• `Const` **CHAIN\_DETAILS**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `chainId` | `number` |
| `cosmosChainId` | `string` |

#### Defined in

[constants.ts:9](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L9)

___

### CanCreateMoreBadgesDigit

• `Const` **CanCreateMoreBadgesDigit**: ``2``

#### Defined in

[permissions.ts:16](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L16)

___

### CanDeleteDigit

• `Const` **CanDeleteDigit**: ``6``

#### Defined in

[permissions.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L12)

___

### CanManagerBeTransferredDigit

• `Const` **CanManagerBeTransferredDigit**: ``4``

#### Defined in

[permissions.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L14)

___

### CanUpdateBytesDigit

• `Const` **CanUpdateBytesDigit**: ``5``

#### Defined in

[permissions.ts:13](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L13)

___

### CanUpdateDisallowedDigit

• `Const` **CanUpdateDisallowedDigit**: ``1``

#### Defined in

[permissions.ts:17](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L17)

___

### CanUpdateUrisDigit

• `Const` **CanUpdateUrisDigit**: ``3``

#### Defined in

[permissions.ts:15](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L15)

___

### DefaultPlaceholderMetadata

• `Const` **DefaultPlaceholderMetadata**: [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[constants.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L14)

___

### ErrorMetadata

• `Const` **ErrorMetadata**: [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[constants.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L20)

___

### GO\_MAX\_UINT\_64

• `Const` **GO\_MAX\_UINT\_64**: ``1000000000000000``

#### Defined in

[constants.ts:7](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L7)

___

### MAX\_DATE\_TIMESTAMP

• `Const` **MAX\_DATE\_TIMESTAMP**: `number`

#### Defined in

[constants.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L5)

___

### METADATA\_PAGE\_LIMIT

• `Const` **METADATA\_PAGE\_LIMIT**: ``100``

#### Defined in

[constants.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L3)

___

### MINT\_ACCOUNT

• `Const` **MINT\_ACCOUNT**: [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Defined in

[chains.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L5)

___

### NUM\_PERMISSIONS

• `Const` **NUM\_PERMISSIONS**: ``6``

#### Defined in

[permissions.ts:1](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L1)

## Functions

### AddBalancesForIdRanges

▸ **AddBalancesForIdRanges**(`userBalanceInfo`, `ranges`, `balanceToAdd`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `userBalanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `balanceToAdd` | `number` |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:116](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L116)

___

### DeleteBalanceForIdRanges

▸ **DeleteBalanceForIdRanges**(`ranges`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:142](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L142)

___

### GetAccountByNumberRoute

▸ **GetAccountByNumberRoute**(`id`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `id` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:8](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L8)

___

### GetAccountRoute

▸ **GetAccountRoute**(`bech32address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `bech32address` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:4](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L4)

___

### GetAccountsRoute

▸ **GetAccountsRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L12)

___

### GetBadgeBalanceRoute

▸ **GetBadgeBalanceRoute**(`collectionId`, `accountNumber`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |
| `accountNumber` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:28](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L28)

___

### GetBalanceInfoToInsertToStorage

▸ **GetBalanceInfoToInsertToStorage**(`balanceInfo`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `balanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:254](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L254)

___

### GetBalanceRoute

▸ **GetBalanceRoute**(`bech32address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `bech32address` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:16](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L16)

___

### GetBalancesForIdRanges

▸ **GetBalancesForIdRanges**(`badgeIds`, `currentUserBalances`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeIds` | [`IdRange`](interfaces/IdRange.md)[] |
| `currentUserBalances` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L36)

___

### GetCollectionRoute

▸ **GetCollectionRoute**(`collectionId`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L20)

___

### GetCollectionsRoute

▸ **GetCollectionsRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:24](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L24)

___

### GetIdRangeToInsert

▸ **GetIdRangeToInsert**(`start`, `end`): `Object`

#### Parameters

| Name | Type |
| :------ | :------ |
| `start` | `number` |
| `end` | `number` |

#### Returns

`Object`

| Name | Type |
| :------ | :------ |
| `end` | `number` |
| `start` | `number` |

#### Defined in

[idRanges.ts:152](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L152)

___

### GetIdRangesToInsertToStorage

▸ **GetIdRangesToInsertToStorage**(`idRanges`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:31](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L31)

___

### GetIdRangesWithOmitEmptyCaseHandled

▸ **GetIdRangesWithOmitEmptyCaseHandled**(`ids`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ids` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:144](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L144)

___

### GetIdxSpanForRange

▸ **GetIdxSpanForRange**(`targetRange`, `targetIdRanges`): [[`IdRange`](interfaces/IdRange.md), `boolean`]

#### Parameters

| Name | Type |
| :------ | :------ |
| `targetRange` | [`IdRange`](interfaces/IdRange.md) |
| `targetIdRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[[`IdRange`](interfaces/IdRange.md), `boolean`]

#### Defined in

[idRanges.ts:111](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L111)

___

### GetIdxToInsertForNewId

▸ **GetIdxToInsertForNewId**(`id`, `targetIds`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `id` | `number` |
| `targetIds` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

`number`

#### Defined in

[idRanges.ts:176](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L176)

___

### GetMetadataRoute

▸ **GetMetadataRoute**(`collectionId`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:40](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L40)

___

### GetOwnersRoute

▸ **GetOwnersRoute**(`collectionId`, `badgeId`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |
| `badgeId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:32](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L32)

___

### GetPermissionNumberValue

▸ **GetPermissionNumberValue**(`permissions`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `permissions` | [`Permissions`](modules.md#permissions) |

#### Returns

`number`

#### Defined in

[permissions.ts:19](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L19)

___

### GetPermissions

▸ **GetPermissions**(`permissions`): [`Permissions`](modules.md#permissions)

#### Parameters

| Name | Type |
| :------ | :------ |
| `permissions` | `number` |

#### Returns

[`Permissions`](modules.md#permissions)

#### Defined in

[permissions.ts:118](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L118)

___

### GetPortfolioRoute

▸ **GetPortfolioRoute**(`accountNumber`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `accountNumber` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L36)

___

### GetSearchRoute

▸ **GetSearchRoute**(`query`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `query` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:44](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L44)

___

### GetStatusRoute

▸ **GetStatusRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:48](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L48)

___

### InsertRangeToIdRanges

▸ **InsertRangeToIdRanges**(`rangeToAdd`, `targetIds`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `rangeToAdd` | [`IdRange`](interfaces/IdRange.md) |
| `targetIds` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:274](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L274)

___

### MergePrevOrNextIfPossible

▸ **MergePrevOrNextIfPossible**(`targetIds`, `insertedAtIdx`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `targetIds` | [`IdRange`](interfaces/IdRange.md)[] |
| `insertedAtIdx` | `number` |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:218](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L218)

___

### NormalizeIdRange

▸ **NormalizeIdRange**(`rangeToNormalize`): `Object`

#### Parameters

| Name | Type |
| :------ | :------ |
| `rangeToNormalize` | [`IdRange`](interfaces/IdRange.md) |

#### Returns

`Object`

| Name | Type |
| :------ | :------ |
| `end` | `number` |
| `start` | `number` |

#### Defined in

[idRanges.ts:164](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L164)

___

### RemoveIdsFromIdRange

▸ **RemoveIdsFromIdRange**(`rangeToRemove`, `rangeObject`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `rangeToRemove` | [`IdRange`](interfaces/IdRange.md) |
| `rangeObject` | [`IdRange`](interfaces/IdRange.md) |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:47](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L47)

___

### SafeAdd

▸ **SafeAdd**(`left`, `right`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `left` | `number` |
| `right` | `number` |

#### Returns

`number`

#### Defined in

[balances-gpt.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L5)

___

### SafeSubtract

▸ **SafeSubtract**(`left`, `right`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `left` | `number` |
| `right` | `number` |

#### Returns

`number`

#### Defined in

[balances-gpt.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L14)

___

### SearchBalances

▸ **SearchBalances**(`targetAmount`, `balanceObjects`): (`number` \| `boolean`)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `targetAmount` | `number` |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

(`number` \| `boolean`)[]

#### Defined in

[balances-gpt.ts:224](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L224)

___

### SearchIdRangesForId

▸ **SearchIdRangesForId**(`id`, `idRanges`): [`number`, `boolean`]

#### Parameters

| Name | Type |
| :------ | :------ |
| `id` | `number` |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`number`, `boolean`]

#### Defined in

[idRanges.ts:92](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L92)

___

### SetBalanceForIdRanges

▸ **SetBalanceForIdRanges**(`ranges`, `amount`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `amount` | `number` |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:183](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L183)

___

### SortIdRangesAndMergeIfNecessary

▸ **SortIdRangesAndMergeIfNecessary**(`idRanges`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L3)

___

### SubtractBalancesForIdRanges

▸ **SubtractBalancesForIdRanges**(`userBalanceInfo`, `ranges`, `balanceToRemove`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `userBalanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `balanceToRemove` | `number` |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:129](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L129)

___

### UpdateBalancesForIdRanges

▸ **UpdateBalancesForIdRanges**(`ranges`, `newAmount`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `newAmount` | `number` |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:22](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L22)

___

### UpdatePermissions

▸ **UpdatePermissions**(`currPermissions`, `permissionDigit`, `value`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `currPermissions` | `number` |
| `permissionDigit` | `number` |
| `value` | `boolean` |

#### Returns

`number`

#### Defined in

[permissions.ts:97](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L97)

___

### ValidatePermissions

▸ **ValidatePermissions**(`permissions`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `permissions` | `number` |

#### Returns

`void`

#### Defined in

[permissions.ts:53](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L53)

___

### ValidatePermissionsUpdate

▸ **ValidatePermissionsUpdate**(`oldPermissions`, `newPermissions`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `oldPermissions` | `number` |
| `newPermissions` | `number` |

#### Returns

`void`

#### Defined in

[permissions.ts:60](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L60)

___

### checkIfApproved

▸ **checkIfApproved**(`userBalance`, `accountNumber`, `balancesToCheck`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `userBalance` | [`UserBalance`](interfaces/UserBalance.md) |
| `accountNumber` | `number` |
| `balancesToCheck` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

`boolean`

#### Defined in

[badges.ts:311](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L311)

___

### checkIfApprovedInTransferList

▸ **checkIfApprovedInTransferList**(`addresses`, `connectedUser`, `managerAccountNumber`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `addresses` | [`Addresses`](interfaces/Addresses.md) |
| `connectedUser` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md) |
| `managerAccountNumber` | `number` |

#### Returns

`boolean`

#### Defined in

[badges.ts:130](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L130)

___

### checkIfIdRangesOverlap

▸ **checkIfIdRangesOverlap**(`idRanges`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

`boolean`

#### Defined in

[idRanges.ts:301](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L301)

___

### convertToBitBadgesUserInfo

▸ **convertToBitBadgesUserInfo**(`accountInfo`): [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `accountInfo` | [`AccountResponse`](interfaces/AccountResponse.md) |

#### Returns

[`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Defined in

[users.ts:4](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/users.ts#L4)

___

### convertToBitBadgesAddress

▸ **convertToBitBadgesAddress**(`address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |

#### Returns

`string`

#### Defined in

[chains.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L12)

___

### createCollectionFromMsgNewCollection

▸ **createCollectionFromMsgNewCollection**(`msgNewCollection`, `collectionMetadata`, `individualBadgeMetadata`, `connectedUser`, `claimItems`, `existingCollection?`): [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `msgNewCollection` | `MessageMsgNewCollection` |
| `collectionMetadata` | [`BadgeMetadata`](interfaces/BadgeMetadata.md) |
| `individualBadgeMetadata` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `connectedUser` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md) |
| `claimItems` | [`ClaimItemWithTrees`](interfaces/ClaimItemWithTrees.md)[] |
| `existingCollection?` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

[`BitBadgeCollection`](interfaces/BitBadgeCollection.md)

#### Defined in

[badges.ts:29](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L29)

___

### doesChainMatchName

▸ **doesChainMatchName**(`chain`, `name?`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `chain` | [`SupportedChain`](enums/SupportedChain.md) |
| `name?` | `string` |

#### Returns

`boolean`

#### Defined in

[chains.ts:87](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L87)

___

### filterBadgeActivityForBadgeId

▸ **filterBadgeActivityForBadgeId**(`badgeId`, `activity`): [`TransferActivityItem`](interfaces/TransferActivityItem.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `activity` | [`TransferActivityItem`](interfaces/TransferActivityItem.md)[] |

#### Returns

[`TransferActivityItem`](interfaces/TransferActivityItem.md)[]

#### Defined in

[badges.ts:10](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L10)

___

### getAbbreviatedAddress

▸ **getAbbreviatedAddress**(`address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |

#### Returns

`string`

#### Defined in

[chains.ts:46](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L46)

___

### getBadgeIdsToDisplayForPageNumber

▸ **getBadgeIdsToDisplayForPageNumber**(`collections?`, `startIdxNum`, `pageSize`): { `badgeIds`: `number`[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)  }[]

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `collections` | { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)  }[] | `[]` |
| `startIdxNum` | `number` | `undefined` |
| `pageSize` | `number` | `undefined` |

#### Returns

{ `badgeIds`: `number`[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)  }[]

#### Defined in

[badges.ts:197](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L197)

___

### getBalanceAfterTransfer

▸ **getBalanceAfterTransfer**(`balance`, `startSubbadgeId`, `endSubbadgeId`, `amountToTransfer`, `numRecipients`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `balance` | [`UserBalance`](interfaces/UserBalance.md) |
| `startSubbadgeId` | `number` |
| `endSubbadgeId` | `number` |
| `amountToTransfer` | `number` |
| `numRecipients` | `number` |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L14)

___

### getBalanceAfterTransfers

▸ **getBalanceAfterTransfers**(`balance`, `transfers`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `balance` | [`UserBalance`](interfaces/UserBalance.md) |
| `transfers` | [`TransfersExtended`](interfaces/TransfersExtended.md)[] |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:21](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L21)

___

### getBlankBalance

▸ **getBlankBalance**(): [`UserBalance`](interfaces/UserBalance.md)

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L5)

___

### getChainForAddress

▸ **getChainForAddress**(`address`): `SupportedChain`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |

#### Returns

`SupportedChain`

#### Defined in

[chains.ts:26](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L26)

___

### getClaimsFromClaimItems

▸ **getClaimsFromClaimItems**(`balance`, `claimItems`): `Object`

#### Parameters

| Name | Type |
| :------ | :------ |
| `balance` | [`UserBalance`](interfaces/UserBalance.md) |
| `claimItems` | [`ClaimItemWithTrees`](interfaces/ClaimItemWithTrees.md)[] |

#### Returns

`Object`

| Name | Type |
| :------ | :------ |
| `claims` | [`Claims`](interfaces/Claims.md)[] |
| `undistributedBalance` | `any` |

#### Defined in

[claims.ts:63](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/claims.ts#L63)

___

### getIdRangesForAllBadgeIdsInCollection

▸ **getIdRangesForAllBadgeIdsInCollection**(`collection`): `any`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`any`

#### Defined in

[badges.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L20)

___

### getMatchingAddressesFromTransferList

▸ **getMatchingAddressesFromTransferList**(`list`, `toAddresses`, `chain`, `managerAccountNumber`): `any`[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `list` | [`TransferList`](interfaces/TransferList.md)[] |
| `toAddresses` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)[] |
| `chain` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md) |
| `managerAccountNumber` | `number` |

#### Returns

`any`[]

#### Defined in

[badges.ts:153](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L153)

___

### getMaxBatchId

▸ **getMaxBatchId**(`collection`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`number`

#### Defined in

[badges.ts:245](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L245)

___

### getMetadataForBadgeId

▸ **getMetadataForBadgeId**(`badgeId`, `metadataMap`): `undefined` \| [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `metadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |

#### Returns

`undefined` \| [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[badges.ts:183](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L183)

___

### getMetadataMapObjForBadgeId

▸ **getMetadataMapObjForBadgeId**(`badgeId`, `metadataMap`): `undefined` \| { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `metadata`: [`BadgeMetadata`](interfaces/BadgeMetadata.md) ; `uri`: `string`  }

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `metadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |

#### Returns

`undefined` \| { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `metadata`: [`BadgeMetadata`](interfaces/BadgeMetadata.md) ; `uri`: `string`  }

#### Defined in

[badges.ts:170](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L170)

___

### getNonTransferableDisallowedTransfers

▸ **getNonTransferableDisallowedTransfers**(): `any`[]

#### Returns

`any`[]

#### Defined in

[badges.ts:105](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L105)

___

### getSupplyByBadgeId

▸ **getSupplyByBadgeId**(`badgeId`, `balances`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `balances` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

`number`

#### Defined in

[balances.ts:48](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L48)

___

### getTransferListForSelectOptions

▸ **getTransferListForSelectOptions**(`isFromList`, `unregistered`, `users`, `all`, `none`, `everyoneExcept`): `undefined` \| [`TransferListWithUnregisteredUsers`](interfaces/TransferListWithUnregisteredUsers.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `isFromList` | `boolean` |
| `unregistered` | `string`[] |
| `users` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)[] |
| `all` | `boolean` |
| `none` | `boolean` |
| `everyoneExcept` | `boolean` |

#### Returns

`undefined` \| [`TransferListWithUnregisteredUsers`](interfaces/TransferListWithUnregisteredUsers.md)

#### Defined in

[transferLists.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L36)

___

### getTransfersFromClaimItems

▸ **getTransfersFromClaimItems**(`claimItems`, `accounts`): [`TransfersExtended`](interfaces/TransfersExtended.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `claimItems` | [`ClaimItem`](interfaces/ClaimItem.md)[] |
| `accounts` | [`AccountMap`](interfaces/AccountMap.md) |

#### Returns

[`TransfersExtended`](interfaces/TransfersExtended.md)[]

#### Defined in

[claims.ts:6](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/claims.ts#L6)

___

### isAddressValid

▸ **isAddressValid**(`address`, `chain?`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |
| `chain?` | `string` |

#### Returns

`boolean`

#### Defined in

[chains.ts:55](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L55)

___

### isTransferListFull

▸ **isTransferListFull**(`transfersList`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `transfersList` | [`TransferList`](interfaces/TransferList.md)[] |

#### Returns

`boolean`

#### Defined in

[transferLists.ts:27](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L27)

___

### populateFieldsOfOtherBadges

▸ **populateFieldsOfOtherBadges**(`individualBadgeMetadata`, `badgeIds`, `key`, `value`, `metadataToSet?`): [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `individualBadgeMetadata` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `badgeIds` | [`IdRange`](interfaces/IdRange.md)[] |
| `key` | `string` |
| `value` | `any` |
| `metadataToSet?` | [`BadgeMetadata`](interfaces/BadgeMetadata.md) |

#### Returns

[`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Defined in

[metadata.ts:61](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/metadata.ts#L61)

___

### updateMetadataForBadgeIdsFromIndexerIfAbsent

▸ **updateMetadataForBadgeIdsFromIndexerIfAbsent**(`badgeIdsToDisplay`, `collection`): `number`[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeIdsToDisplay` | `number`[] |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`number`[]

#### Defined in

[badges.ts:264](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L264)

___

### updateMetadataMap

▸ **updateMetadataMap**(`currMetadataMap`, `metadata`, `badgeIds`, `uri`): [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `currMetadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `metadata` | [`BadgeMetadata`](interfaces/BadgeMetadata.md) |
| `badgeIds` | [`IdRange`](interfaces/IdRange.md) |
| `uri` | `string` |

#### Returns

[`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Defined in

[metadata.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/metadata.ts#L5)

___

### updateTransferListAccountNums

▸ **updateTransferListAccountNums**(`accountNumber`, `remove`, `transferListAddresses`): [`Addresses`](interfaces/Addresses.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `accountNumber` | `number` |
| `remove` | `boolean` |
| `transferListAddresses` | [`Addresses`](interfaces/Addresses.md) |

#### Returns

[`Addresses`](interfaces/Addresses.md)

#### Defined in

[transferLists.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L5)


## File: ./.gitbook/assets/modules.md

[BitBadges](README.md) / Exports

# BitBadges

## Table of contents

### Enumerations

- [DistributionMethod](enums/DistributionMethod.md)
- [MetadataAddMethod](enums/MetadataAddMethod.md)
- [SupportedChain](enums/SupportedChain.md)
- [TransactionStatus](enums/TransactionStatus.md)

### Interfaces

- [AccountDocs](interfaces/AccountDocs.md)
- [AccountDocument](interfaces/AccountDocument.md)
- [AccountMap](interfaces/AccountMap.md)
- [AccountResponse](interfaces/AccountResponse.md)
- [ActivityItem](interfaces/ActivityItem.md)
- [Addresses](interfaces/Addresses.md)
- [AnnouncementActivityItem](interfaces/AnnouncementActivityItem.md)
- [Approval](interfaces/Approval.md)
- [BadgeMetadata](interfaces/BadgeMetadata.md)
- [BadgeMetadataMap](interfaces/BadgeMetadataMap.md)
- [BadgeSupplyAndAmount](interfaces/BadgeSupplyAndAmount.md)
- [BadgeUri](interfaces/BadgeUri.md)
- [Balance](interfaces/Balance.md)
- [BalanceObject](interfaces/BalanceObject.md)
- [BalancesMap](interfaces/BalancesMap.md)
- [BitBadgeCollection](interfaces/BitBadgeCollection.md)
- [BitBadgeMintObject](interfaces/BitBadgeMintObject.md)
- [BitBadgesUserInfo](interfaces/BitBadgesUserInfo.md)
- [ClaimItem](interfaces/ClaimItem.md)
- [ClaimItemWithTrees](interfaces/ClaimItemWithTrees.md)
- [Claims](interfaces/Claims.md)
- [CollectionDocs](interfaces/CollectionDocs.md)
- [CollectionMap](interfaces/CollectionMap.md)
- [CosmosAccountInformation](interfaces/CosmosAccountInformation.md)
- [DbStatus](interfaces/DbStatus.md)
- [Docs](interfaces/Docs.md)
- [GetAccountResponse](interfaces/GetAccountResponse.md)
- [GetBadgeBalanceResponse](interfaces/GetBadgeBalanceResponse.md)
- [GetBalanceResponse](interfaces/GetBalanceResponse.md)
- [GetCollectionResponse](interfaces/GetCollectionResponse.md)
- [GetOwnersResponse](interfaces/GetOwnersResponse.md)
- [GetPortfolioResponse](interfaces/GetPortfolioResponse.md)
- [IdRange](interfaces/IdRange.md)
- [IndexerStatus](interfaces/IndexerStatus.md)
- [LatestBlockStatus](interfaces/LatestBlockStatus.md)
- [MetadataDocs](interfaces/MetadataDocs.md)
- [MetadataDocument](interfaces/MetadataDocument.md)
- [PaginationInfo](interfaces/PaginationInfo.md)
- [PasswordDocument](interfaces/PasswordDocument.md)
- [PendingTransfer](interfaces/PendingTransfer.md)
- [Proof](interfaces/Proof.md)
- [SearchResponse](interfaces/SearchResponse.md)
- [StoredBadgeCollection](interfaces/StoredBadgeCollection.md)
- [SubassetSupply](interfaces/SubassetSupply.md)
- [TransferActivityItem](interfaces/TransferActivityItem.md)
- [TransferList](interfaces/TransferList.md)
- [TransferListWithUnregisteredUsers](interfaces/TransferListWithUnregisteredUsers.md)
- [Transfers](interfaces/Transfers.md)
- [TransfersExtended](interfaces/TransfersExtended.md)
- [UserBalance](interfaces/UserBalance.md)

### Type Aliases

- [Permissions](modules.md#permissions)

### Variables

- [AllAddressesTransferList](modules.md#alladdressestransferlist)
- [CHAIN\_DETAILS](modules.md#chain_details)
- [CanCreateMoreBadgesDigit](modules.md#cancreatemorebadgesdigit)
- [CanDeleteDigit](modules.md#candeletedigit)
- [CanManagerBeTransferredDigit](modules.md#canmanagerbetransferreddigit)
- [CanUpdateBytesDigit](modules.md#canupdatebytesdigit)
- [CanUpdateDisallowedDigit](modules.md#canupdatedisalloweddigit)
- [CanUpdateUrisDigit](modules.md#canupdateurisdigit)
- [DefaultPlaceholderMetadata](modules.md#defaultplaceholdermetadata)
- [ErrorMetadata](modules.md#errormetadata)
- [GO\_MAX\_UINT\_64](modules.md#go_max_uint_64)
- [MAX\_DATE\_TIMESTAMP](modules.md#max_date_timestamp)
- [METADATA\_PAGE\_LIMIT](modules.md#metadata_page_limit)
- [MINT\_ACCOUNT](modules.md#mint_account)
- [NUM\_PERMISSIONS](modules.md#num_permissions)

### Functions

- [AddBalancesForIdRanges](modules.md#addbalancesforidranges)
- [DeleteBalanceForIdRanges](modules.md#deletebalanceforidranges)
- [GetAccountByNumberRoute](modules.md#getaccountbynumberroute)
- [GetAccountRoute](modules.md#getaccountroute)
- [GetAccountsRoute](modules.md#getaccountsroute)
- [GetBadgeBalanceRoute](modules.md#getbadgebalanceroute)
- [GetBalanceInfoToInsertToStorage](modules.md#getbalanceinfotoinserttostorage)
- [GetBalanceRoute](modules.md#getbalanceroute)
- [GetBalancesForIdRanges](modules.md#getbalancesforidranges)
- [GetCollectionRoute](modules.md#getcollectionroute)
- [GetCollectionsRoute](modules.md#getcollectionsroute)
- [GetIdRangeToInsert](modules.md#getidrangetoinsert)
- [GetIdRangesToInsertToStorage](modules.md#getidrangestoinserttostorage)
- [GetIdRangesWithOmitEmptyCaseHandled](modules.md#getidrangeswithomitemptycasehandled)
- [GetIdxSpanForRange](modules.md#getidxspanforrange)
- [GetIdxToInsertForNewId](modules.md#getidxtoinsertfornewid)
- [GetMetadataRoute](modules.md#getmetadataroute)
- [GetOwnersRoute](modules.md#getownersroute)
- [GetPermissionNumberValue](modules.md#getpermissionnumbervalue)
- [GetPermissions](modules.md#getpermissions)
- [GetPortfolioRoute](modules.md#getportfolioroute)
- [GetSearchRoute](modules.md#getsearchroute)
- [GetStatusRoute](modules.md#getstatusroute)
- [InsertRangeToIdRanges](modules.md#insertrangetoidranges)
- [MergePrevOrNextIfPossible](modules.md#mergeprevornextifpossible)
- [NormalizeIdRange](modules.md#normalizeidrange)
- [RemoveIdsFromIdRange](modules.md#removeidsfromidrange)
- [SafeAdd](modules.md#safeadd)
- [SafeSubtract](modules.md#safesubtract)
- [SearchBalances](modules.md#searchbalances)
- [SearchIdRangesForId](modules.md#searchidrangesforid)
- [SetBalanceForIdRanges](modules.md#setbalanceforidranges)
- [SortIdRangesAndMergeIfNecessary](modules.md#sortidrangesandmergeifnecessary)
- [SubtractBalancesForIdRanges](modules.md#subtractbalancesforidranges)
- [UpdateBalancesForIdRanges](modules.md#updatebalancesforidranges)
- [UpdatePermissions](modules.md#updatepermissions)
- [ValidatePermissions](modules.md#validatepermissions)
- [ValidatePermissionsUpdate](modules.md#validatepermissionsupdate)
- [checkIfApproved](modules.md#checkifapproved)
- [checkIfApprovedInTransferList](modules.md#checkifapprovedintransferlist)
- [checkIfIdRangesOverlap](modules.md#checkifidrangesoverlap)
- [convertToBitBadgesUserInfo](modules.md#converttobitbadgesuserinfo)
- [convertToBitBadgesAddress](modules.md#converttocosmosaddress)
- [createCollectionFromMsgNewCollection](modules.md#createcollectionfrommsgnewcollection)
- [doesChainMatchName](modules.md#doeschainmatchname)
- [filterBadgeActivityForBadgeId](modules.md#filterbadgeactivityforbadgeid)
- [getAbbreviatedAddress](modules.md#getabbreviatedaddress)
- [getBadgeIdsToDisplayForPageNumber](modules.md#getbadgeidstodisplayforpagenumber)
- [getBalanceAfterTransfer](modules.md#getbalanceaftertransfer)
- [getBalanceAfterTransfers](modules.md#getbalanceaftertransfers)
- [getBlankBalance](modules.md#getblankbalance)
- [getChainForAddress](modules.md#getchainforaddress)
- [getClaimsFromClaimItems](modules.md#getclaimsfromclaimitems)
- [getIdRangesForAllBadgeIdsInCollection](modules.md#getidrangesforallbadgeidsincollection)
- [getMatchingAddressesFromTransferList](modules.md#getmatchingaddressesfromtransferlist)
- [getMaxBatchId](modules.md#getmaxbatchid)
- [getMetadataForBadgeId](modules.md#getmetadataforbadgeid)
- [getMetadataMapObjForBadgeId](modules.md#getmetadatamapobjforbadgeid)
- [getNonTransferableDisallowedTransfers](modules.md#getnontransferabledisallowedtransfers)
- [getSupplyByBadgeId](modules.md#getsupplybybadgeid)
- [getTransferListForSelectOptions](modules.md#gettransferlistforselectoptions)
- [getTransfersFromClaimItems](modules.md#gettransfersfromclaimitems)
- [isAddressValid](modules.md#isaddressvalid)
- [isTransferListFull](modules.md#istransferlistfull)
- [populateFieldsOfOtherBadges](modules.md#populatefieldsofotherbadges)
- [updateMetadataForBadgeIdsFromIndexerIfAbsent](modules.md#updatemetadataforbadgeidsfromindexerifabsent)
- [updateMetadataMap](modules.md#updatemetadatamap)
- [updateTransferListAccountNums](modules.md#updatetransferlistaccountnums)

## Type Aliases

### Permissions

Ƭ **Permissions**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `CanCreateMoreBadges` | `boolean` |
| `CanDelete` | `boolean` |
| `CanManagerBeTransferred` | `boolean` |
| `CanUpdateBytes` | `boolean` |
| `CanUpdateDisallowed` | `boolean` |
| `CanUpdateUris` | `boolean` |

#### Defined in

[permissions.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L3)

## Variables

### AllAddressesTransferList

• `Const` **AllAddressesTransferList**: [`TransferList`](interfaces/TransferList.md)

#### Defined in

[badges.ts:109](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L109)

___

### CHAIN\_DETAILS

• `Const` **CHAIN\_DETAILS**: `Object`

#### Type declaration

| Name | Type |
| :------ | :------ |
| `chainId` | `number` |
| `cosmosChainId` | `string` |

#### Defined in

[constants.ts:9](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L9)

___

### CanCreateMoreBadgesDigit

• `Const` **CanCreateMoreBadgesDigit**: ``2``

#### Defined in

[permissions.ts:16](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L16)

___

### CanDeleteDigit

• `Const` **CanDeleteDigit**: ``6``

#### Defined in

[permissions.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L12)

___

### CanManagerBeTransferredDigit

• `Const` **CanManagerBeTransferredDigit**: ``4``

#### Defined in

[permissions.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L14)

___

### CanUpdateBytesDigit

• `Const` **CanUpdateBytesDigit**: ``5``

#### Defined in

[permissions.ts:13](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L13)

___

### CanUpdateDisallowedDigit

• `Const` **CanUpdateDisallowedDigit**: ``1``

#### Defined in

[permissions.ts:17](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L17)

___

### CanUpdateUrisDigit

• `Const` **CanUpdateUrisDigit**: ``3``

#### Defined in

[permissions.ts:15](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L15)

___

### DefaultPlaceholderMetadata

• `Const` **DefaultPlaceholderMetadata**: [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[constants.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L14)

___

### ErrorMetadata

• `Const` **ErrorMetadata**: [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[constants.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L20)

___

### GO\_MAX\_UINT\_64

• `Const` **GO\_MAX\_UINT\_64**: ``1000000000000000``

#### Defined in

[constants.ts:7](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L7)

___

### MAX\_DATE\_TIMESTAMP

• `Const` **MAX\_DATE\_TIMESTAMP**: `number`

#### Defined in

[constants.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L5)

___

### METADATA\_PAGE\_LIMIT

• `Const` **METADATA\_PAGE\_LIMIT**: ``100``

#### Defined in

[constants.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/constants.ts#L3)

___

### MINT\_ACCOUNT

• `Const` **MINT\_ACCOUNT**: [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Defined in

[chains.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L5)

___

### NUM\_PERMISSIONS

• `Const` **NUM\_PERMISSIONS**: ``6``

#### Defined in

[permissions.ts:1](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L1)

## Functions

### AddBalancesForIdRanges

▸ **AddBalancesForIdRanges**(`userBalanceInfo`, `ranges`, `balanceToAdd`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `userBalanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `balanceToAdd` | `number` |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:116](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L116)

___

### DeleteBalanceForIdRanges

▸ **DeleteBalanceForIdRanges**(`ranges`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:142](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L142)

___

### GetAccountByNumberRoute

▸ **GetAccountByNumberRoute**(`id`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `id` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:8](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L8)

___

### GetAccountRoute

▸ **GetAccountRoute**(`bech32address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `bech32address` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:4](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L4)

___

### GetAccountsRoute

▸ **GetAccountsRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L12)

___

### GetBadgeBalanceRoute

▸ **GetBadgeBalanceRoute**(`collectionId`, `accountNumber`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |
| `accountNumber` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:28](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L28)

___

### GetBalanceInfoToInsertToStorage

▸ **GetBalanceInfoToInsertToStorage**(`balanceInfo`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `balanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:254](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L254)

___

### GetBalanceRoute

▸ **GetBalanceRoute**(`bech32address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `bech32address` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:16](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L16)

___

### GetBalancesForIdRanges

▸ **GetBalancesForIdRanges**(`badgeIds`, `currentUserBalances`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeIds` | [`IdRange`](interfaces/IdRange.md)[] |
| `currentUserBalances` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L36)

___

### GetCollectionRoute

▸ **GetCollectionRoute**(`collectionId`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L20)

___

### GetCollectionsRoute

▸ **GetCollectionsRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:24](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L24)

___

### GetIdRangeToInsert

▸ **GetIdRangeToInsert**(`start`, `end`): `Object`

#### Parameters

| Name | Type |
| :------ | :------ |
| `start` | `number` |
| `end` | `number` |

#### Returns

`Object`

| Name | Type |
| :------ | :------ |
| `end` | `number` |
| `start` | `number` |

#### Defined in

[idRanges.ts:152](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L152)

___

### GetIdRangesToInsertToStorage

▸ **GetIdRangesToInsertToStorage**(`idRanges`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:31](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L31)

___

### GetIdRangesWithOmitEmptyCaseHandled

▸ **GetIdRangesWithOmitEmptyCaseHandled**(`ids`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ids` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:144](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L144)

___

### GetIdxSpanForRange

▸ **GetIdxSpanForRange**(`targetRange`, `targetIdRanges`): [[`IdRange`](interfaces/IdRange.md), `boolean`]

#### Parameters

| Name | Type |
| :------ | :------ |
| `targetRange` | [`IdRange`](interfaces/IdRange.md) |
| `targetIdRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[[`IdRange`](interfaces/IdRange.md), `boolean`]

#### Defined in

[idRanges.ts:111](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L111)

___

### GetIdxToInsertForNewId

▸ **GetIdxToInsertForNewId**(`id`, `targetIds`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `id` | `number` |
| `targetIds` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

`number`

#### Defined in

[idRanges.ts:176](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L176)

___

### GetMetadataRoute

▸ **GetMetadataRoute**(`collectionId`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:40](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L40)

___

### GetOwnersRoute

▸ **GetOwnersRoute**(`collectionId`, `badgeId`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collectionId` | `number` |
| `badgeId` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:32](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L32)

___

### GetPermissionNumberValue

▸ **GetPermissionNumberValue**(`permissions`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `permissions` | [`Permissions`](modules.md#permissions) |

#### Returns

`number`

#### Defined in

[permissions.ts:19](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L19)

___

### GetPermissions

▸ **GetPermissions**(`permissions`): [`Permissions`](modules.md#permissions)

#### Parameters

| Name | Type |
| :------ | :------ |
| `permissions` | `number` |

#### Returns

[`Permissions`](modules.md#permissions)

#### Defined in

[permissions.ts:118](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L118)

___

### GetPortfolioRoute

▸ **GetPortfolioRoute**(`accountNumber`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `accountNumber` | `number` |

#### Returns

`string`

#### Defined in

[routes.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L36)

___

### GetSearchRoute

▸ **GetSearchRoute**(`query`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `query` | `string` |

#### Returns

`string`

#### Defined in

[routes.ts:44](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L44)

___

### GetStatusRoute

▸ **GetStatusRoute**(): `string`

#### Returns

`string`

#### Defined in

[routes.ts:48](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/routes.ts#L48)

___

### InsertRangeToIdRanges

▸ **InsertRangeToIdRanges**(`rangeToAdd`, `targetIds`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `rangeToAdd` | [`IdRange`](interfaces/IdRange.md) |
| `targetIds` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:274](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L274)

___

### MergePrevOrNextIfPossible

▸ **MergePrevOrNextIfPossible**(`targetIds`, `insertedAtIdx`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `targetIds` | [`IdRange`](interfaces/IdRange.md)[] |
| `insertedAtIdx` | `number` |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:218](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L218)

___

### NormalizeIdRange

▸ **NormalizeIdRange**(`rangeToNormalize`): `Object`

#### Parameters

| Name | Type |
| :------ | :------ |
| `rangeToNormalize` | [`IdRange`](interfaces/IdRange.md) |

#### Returns

`Object`

| Name | Type |
| :------ | :------ |
| `end` | `number` |
| `start` | `number` |

#### Defined in

[idRanges.ts:164](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L164)

___

### RemoveIdsFromIdRange

▸ **RemoveIdsFromIdRange**(`rangeToRemove`, `rangeObject`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `rangeToRemove` | [`IdRange`](interfaces/IdRange.md) |
| `rangeObject` | [`IdRange`](interfaces/IdRange.md) |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:47](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L47)

___

### SafeAdd

▸ **SafeAdd**(`left`, `right`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `left` | `number` |
| `right` | `number` |

#### Returns

`number`

#### Defined in

[balances-gpt.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L5)

___

### SafeSubtract

▸ **SafeSubtract**(`left`, `right`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `left` | `number` |
| `right` | `number` |

#### Returns

`number`

#### Defined in

[balances-gpt.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L14)

___

### SearchBalances

▸ **SearchBalances**(`targetAmount`, `balanceObjects`): (`number` \| `boolean`)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `targetAmount` | `number` |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

(`number` \| `boolean`)[]

#### Defined in

[balances-gpt.ts:224](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L224)

___

### SearchIdRangesForId

▸ **SearchIdRangesForId**(`id`, `idRanges`): [`number`, `boolean`]

#### Parameters

| Name | Type |
| :------ | :------ |
| `id` | `number` |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`number`, `boolean`]

#### Defined in

[idRanges.ts:92](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L92)

___

### SetBalanceForIdRanges

▸ **SetBalanceForIdRanges**(`ranges`, `amount`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `amount` | `number` |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:183](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L183)

___

### SortIdRangesAndMergeIfNecessary

▸ **SortIdRangesAndMergeIfNecessary**(`idRanges`): [`IdRange`](interfaces/IdRange.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

[`IdRange`](interfaces/IdRange.md)[]

#### Defined in

[idRanges.ts:3](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L3)

___

### SubtractBalancesForIdRanges

▸ **SubtractBalancesForIdRanges**(`userBalanceInfo`, `ranges`, `balanceToRemove`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `userBalanceInfo` | [`UserBalance`](interfaces/UserBalance.md) |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `balanceToRemove` | `number` |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances-gpt.ts:129](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L129)

___

### UpdateBalancesForIdRanges

▸ **UpdateBalancesForIdRanges**(`ranges`, `newAmount`, `balanceObjects`): [`Balance`](interfaces/Balance.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `ranges` | [`IdRange`](interfaces/IdRange.md)[] |
| `newAmount` | `number` |
| `balanceObjects` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

[`Balance`](interfaces/Balance.md)[]

#### Defined in

[balances-gpt.ts:22](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances-gpt.ts#L22)

___

### UpdatePermissions

▸ **UpdatePermissions**(`currPermissions`, `permissionDigit`, `value`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `currPermissions` | `number` |
| `permissionDigit` | `number` |
| `value` | `boolean` |

#### Returns

`number`

#### Defined in

[permissions.ts:97](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L97)

___

### ValidatePermissions

▸ **ValidatePermissions**(`permissions`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `permissions` | `number` |

#### Returns

`void`

#### Defined in

[permissions.ts:53](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L53)

___

### ValidatePermissionsUpdate

▸ **ValidatePermissionsUpdate**(`oldPermissions`, `newPermissions`): `void`

#### Parameters

| Name | Type |
| :------ | :------ |
| `oldPermissions` | `number` |
| `newPermissions` | `number` |

#### Returns

`void`

#### Defined in

[permissions.ts:60](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/permissions.ts#L60)

___

### checkIfApproved

▸ **checkIfApproved**(`userBalance`, `accountNumber`, `balancesToCheck`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `userBalance` | [`UserBalance`](interfaces/UserBalance.md) |
| `accountNumber` | `number` |
| `balancesToCheck` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

`boolean`

#### Defined in

[badges.ts:311](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L311)

___

### checkIfApprovedInTransferList

▸ **checkIfApprovedInTransferList**(`addresses`, `connectedUser`, `managerAccountNumber`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `addresses` | [`Addresses`](interfaces/Addresses.md) |
| `connectedUser` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md) |
| `managerAccountNumber` | `number` |

#### Returns

`boolean`

#### Defined in

[badges.ts:130](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L130)

___

### checkIfIdRangesOverlap

▸ **checkIfIdRangesOverlap**(`idRanges`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `idRanges` | [`IdRange`](interfaces/IdRange.md)[] |

#### Returns

`boolean`

#### Defined in

[idRanges.ts:301](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/idRanges.ts#L301)

___

### convertToBitBadgesUserInfo

▸ **convertToBitBadgesUserInfo**(`accountInfo`): [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `accountInfo` | [`AccountResponse`](interfaces/AccountResponse.md) |

#### Returns

[`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)

#### Defined in

[users.ts:4](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/users.ts#L4)

___

### convertToBitBadgesAddress

▸ **convertToBitBadgesAddress**(`address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |

#### Returns

`string`

#### Defined in

[chains.ts:12](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L12)

___

### createCollectionFromMsgNewCollection

▸ **createCollectionFromMsgNewCollection**(`msgNewCollection`, `collectionMetadata`, `individualBadgeMetadata`, `connectedUser`, `claimItems`, `existingCollection?`): [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `msgNewCollection` | `MessageMsgNewCollection` |
| `collectionMetadata` | [`BadgeMetadata`](interfaces/BadgeMetadata.md) |
| `individualBadgeMetadata` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `connectedUser` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md) |
| `claimItems` | [`ClaimItemWithTrees`](interfaces/ClaimItemWithTrees.md)[] |
| `existingCollection?` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

[`BitBadgeCollection`](interfaces/BitBadgeCollection.md)

#### Defined in

[badges.ts:29](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L29)

___

### doesChainMatchName

▸ **doesChainMatchName**(`chain`, `name?`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `chain` | [`SupportedChain`](enums/SupportedChain.md) |
| `name?` | `string` |

#### Returns

`boolean`

#### Defined in

[chains.ts:87](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L87)

___

### filterBadgeActivityForBadgeId

▸ **filterBadgeActivityForBadgeId**(`badgeId`, `activity`): [`TransferActivityItem`](interfaces/TransferActivityItem.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `activity` | [`TransferActivityItem`](interfaces/TransferActivityItem.md)[] |

#### Returns

[`TransferActivityItem`](interfaces/TransferActivityItem.md)[]

#### Defined in

[badges.ts:10](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L10)

___

### getAbbreviatedAddress

▸ **getAbbreviatedAddress**(`address`): `string`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |

#### Returns

`string`

#### Defined in

[chains.ts:46](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L46)

___

### getBadgeIdsToDisplayForPageNumber

▸ **getBadgeIdsToDisplayForPageNumber**(`collections?`, `startIdxNum`, `pageSize`): { `badgeIds`: `number`[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)  }[]

#### Parameters

| Name | Type | Default value |
| :------ | :------ | :------ |
| `collections` | { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)  }[] | `[]` |
| `startIdxNum` | `number` | `undefined` |
| `pageSize` | `number` | `undefined` |

#### Returns

{ `badgeIds`: `number`[] ; `collection`: [`BitBadgeCollection`](interfaces/BitBadgeCollection.md)  }[]

#### Defined in

[badges.ts:197](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L197)

___

### getBalanceAfterTransfer

▸ **getBalanceAfterTransfer**(`balance`, `startSubbadgeId`, `endSubbadgeId`, `amountToTransfer`, `numRecipients`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `balance` | [`UserBalance`](interfaces/UserBalance.md) |
| `startSubbadgeId` | `number` |
| `endSubbadgeId` | `number` |
| `amountToTransfer` | `number` |
| `numRecipients` | `number` |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:14](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L14)

___

### getBalanceAfterTransfers

▸ **getBalanceAfterTransfers**(`balance`, `transfers`): [`UserBalance`](interfaces/UserBalance.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `balance` | [`UserBalance`](interfaces/UserBalance.md) |
| `transfers` | [`TransfersExtended`](interfaces/TransfersExtended.md)[] |

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:21](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L21)

___

### getBlankBalance

▸ **getBlankBalance**(): [`UserBalance`](interfaces/UserBalance.md)

#### Returns

[`UserBalance`](interfaces/UserBalance.md)

#### Defined in

[balances.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L5)

___

### getChainForAddress

▸ **getChainForAddress**(`address`): `SupportedChain`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |

#### Returns

`SupportedChain`

#### Defined in

[chains.ts:26](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L26)

___

### getClaimsFromClaimItems

▸ **getClaimsFromClaimItems**(`balance`, `claimItems`): `Object`

#### Parameters

| Name | Type |
| :------ | :------ |
| `balance` | [`UserBalance`](interfaces/UserBalance.md) |
| `claimItems` | [`ClaimItemWithTrees`](interfaces/ClaimItemWithTrees.md)[] |

#### Returns

`Object`

| Name | Type |
| :------ | :------ |
| `claims` | [`Claims`](interfaces/Claims.md)[] |
| `undistributedBalance` | `any` |

#### Defined in

[claims.ts:63](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/claims.ts#L63)

___

### getIdRangesForAllBadgeIdsInCollection

▸ **getIdRangesForAllBadgeIdsInCollection**(`collection`): `any`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`any`

#### Defined in

[badges.ts:20](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L20)

___

### getMatchingAddressesFromTransferList

▸ **getMatchingAddressesFromTransferList**(`list`, `toAddresses`, `chain`, `managerAccountNumber`): `any`[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `list` | [`TransferList`](interfaces/TransferList.md)[] |
| `toAddresses` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)[] |
| `chain` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md) |
| `managerAccountNumber` | `number` |

#### Returns

`any`[]

#### Defined in

[badges.ts:153](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L153)

___

### getMaxBatchId

▸ **getMaxBatchId**(`collection`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`number`

#### Defined in

[badges.ts:245](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L245)

___

### getMetadataForBadgeId

▸ **getMetadataForBadgeId**(`badgeId`, `metadataMap`): `undefined` \| [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `metadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |

#### Returns

`undefined` \| [`BadgeMetadata`](interfaces/BadgeMetadata.md)

#### Defined in

[badges.ts:183](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L183)

___

### getMetadataMapObjForBadgeId

▸ **getMetadataMapObjForBadgeId**(`badgeId`, `metadataMap`): `undefined` \| { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `metadata`: [`BadgeMetadata`](interfaces/BadgeMetadata.md) ; `uri`: `string`  }

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `metadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |

#### Returns

`undefined` \| { `badgeIds`: [`IdRange`](interfaces/IdRange.md)[] ; `metadata`: [`BadgeMetadata`](interfaces/BadgeMetadata.md) ; `uri`: `string`  }

#### Defined in

[badges.ts:170](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L170)

___

### getNonTransferableDisallowedTransfers

▸ **getNonTransferableDisallowedTransfers**(): `any`[]

#### Returns

`any`[]

#### Defined in

[badges.ts:105](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L105)

___

### getSupplyByBadgeId

▸ **getSupplyByBadgeId**(`badgeId`, `balances`): `number`

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeId` | `number` |
| `balances` | [`Balance`](interfaces/Balance.md)[] |

#### Returns

`number`

#### Defined in

[balances.ts:48](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/balances.ts#L48)

___

### getTransferListForSelectOptions

▸ **getTransferListForSelectOptions**(`isFromList`, `unregistered`, `users`, `all`, `none`, `everyoneExcept`): `undefined` \| [`TransferListWithUnregisteredUsers`](interfaces/TransferListWithUnregisteredUsers.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `isFromList` | `boolean` |
| `unregistered` | `string`[] |
| `users` | [`BitBadgesUserInfo`](interfaces/BitBadgesUserInfo.md)[] |
| `all` | `boolean` |
| `none` | `boolean` |
| `everyoneExcept` | `boolean` |

#### Returns

`undefined` \| [`TransferListWithUnregisteredUsers`](interfaces/TransferListWithUnregisteredUsers.md)

#### Defined in

[transferLists.ts:36](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L36)

___

### getTransfersFromClaimItems

▸ **getTransfersFromClaimItems**(`claimItems`, `accounts`): [`TransfersExtended`](interfaces/TransfersExtended.md)[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `claimItems` | [`ClaimItem`](interfaces/ClaimItem.md)[] |
| `accounts` | [`AccountMap`](interfaces/AccountMap.md) |

#### Returns

[`TransfersExtended`](interfaces/TransfersExtended.md)[]

#### Defined in

[claims.ts:6](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/claims.ts#L6)

___

### isAddressValid

▸ **isAddressValid**(`address`, `chain?`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `address` | `string` |
| `chain?` | `string` |

#### Returns

`boolean`

#### Defined in

[chains.ts:55](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/chains.ts#L55)

___

### isTransferListFull

▸ **isTransferListFull**(`transfersList`): `boolean`

#### Parameters

| Name | Type |
| :------ | :------ |
| `transfersList` | [`TransferList`](interfaces/TransferList.md)[] |

#### Returns

`boolean`

#### Defined in

[transferLists.ts:27](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L27)

___

### populateFieldsOfOtherBadges

▸ **populateFieldsOfOtherBadges**(`individualBadgeMetadata`, `badgeIds`, `key`, `value`, `metadataToSet?`): [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `individualBadgeMetadata` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `badgeIds` | [`IdRange`](interfaces/IdRange.md)[] |
| `key` | `string` |
| `value` | `any` |
| `metadataToSet?` | [`BadgeMetadata`](interfaces/BadgeMetadata.md) |

#### Returns

[`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Defined in

[metadata.ts:61](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/metadata.ts#L61)

___

### updateMetadataForBadgeIdsFromIndexerIfAbsent

▸ **updateMetadataForBadgeIdsFromIndexerIfAbsent**(`badgeIdsToDisplay`, `collection`): `number`[]

#### Parameters

| Name | Type |
| :------ | :------ |
| `badgeIdsToDisplay` | `number`[] |
| `collection` | [`BitBadgeCollection`](interfaces/BitBadgeCollection.md) |

#### Returns

`number`[]

#### Defined in

[badges.ts:264](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/badges.ts#L264)

___

### updateMetadataMap

▸ **updateMetadataMap**(`currMetadataMap`, `metadata`, `badgeIds`, `uri`): [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `currMetadataMap` | [`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md) |
| `metadata` | [`BadgeMetadata`](interfaces/BadgeMetadata.md) |
| `badgeIds` | [`IdRange`](interfaces/IdRange.md) |
| `uri` | `string` |

#### Returns

[`BadgeMetadataMap`](interfaces/BadgeMetadataMap.md)

#### Defined in

[metadata.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/metadata.ts#L5)

___

### updateTransferListAccountNums

▸ **updateTransferListAccountNums**(`accountNumber`, `remove`, `transferListAddresses`): [`Addresses`](interfaces/Addresses.md)

#### Parameters

| Name | Type |
| :------ | :------ |
| `accountNumber` | `number` |
| `remove` | `boolean` |
| `transferListAddresses` | [`Addresses`](interfaces/Addresses.md) |

#### Returns

[`Addresses`](interfaces/Addresses.md)

#### Defined in

[transferLists.ts:5](https://github.com/trevormil/bitbadges-sdk/blob/80ff4be/src/transferLists.ts#L5)


## File: ./README.md

---
description: >-
    Here, you will find documentation about BitBadges, how it works, how to
    interact, and how to contribute!
---

# 👋 BitBadges Overview

<figure><img src=".gitbook/assets/bitbadgeslogo.png" alt="" width="188"><figcaption></figcaption></figure>

## 🚀 The Next-Generation Token Standard

BitBadges offers tokenization-as-a-service and gating-as-a-service. We are building the best tokenization standard out there because current standards are simply not good enough. Our revolutionary token standard goes far beyond ERC-20, ERC-721, and other existing standards with features like time-dependent ownership, fine-grained transferability controls, multi-chain compatibility, connecting to 7000+ apps, connecting to EVM, IBC, CosmWASM, and more.

<div data-full-width="false"><figure><img src=".gitbook/assets/image (8) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure></div>

### ❓ Why BitBadges?

Traditional token standards are limited, inflexible, and locked to single blockchain ecosystems. BitBadges fixes this with a 100x improvement that supports:

-   **Multi-Chain Compatibility** - Users from ANY blockchain can own and transfer the SAME tokens. One interface, one token experience for all blockchain ecosystems.
-   **Time-Dependent Ownership** - Create subscriptions, time-locked tokens, and expiring credentials
-   **Advanced Transferability** - Fine-grained controls over who can transfer what, when, and how on any level
-   **No Code by Default, No Smart Contracts Required** - Everything works out-of-the-box with no code
-   **Connect to 7000+ Apps** - Connect to 7000+ apps and integrations with seamless on/off-chain criteria checks
-   **Connect to Cosmos via IBC** - Connect to Cosmos and beyond via IBC and use the BitBadges token standard on any Cosmos chain
-   **Extend with CosmWASM or EVM Contracts** - Extend the BitBadges token standard with CosmWASM or EVM contracts
-   **Customizable Permissions** - Flexible manager controls for collections

## 🛠️ Supporting Services

We also offer complementary services:

-   **Sign In with BitBadges** - Universal, outsource multi-chain authentication
-   **Claims System** - Check criteria and deliver rewards in no-code from 7000+ apps and integrations
-   **Address Lists** - Manage users across multiple blockchains
-   **Attestations** - Zero-knowledge credential verification

## 🔍 How BitBadges Works

BitBadges can be simply thought of in two parts.

**Criteria Checking:** Let us do the heavy lifting of checking the criteria through multi-chain authentication, criteria checks from 7000+ apps, multi-chain badges / NFTs, points, address lists, and much more!

**Utility:** Seamlessly offer gated services like websites, URLs, tiered perks, subscriptions, anything to users who meet the criteria!

## 💡 Use Cases

Create anything from subscriptions and memberships to tradable NFTs, credentials, and access tokens - all with the most advanced token standard ever built.

Tokens (badges) are simply something that you can own digitally and prove ownership of it. You probably already use and own many digital tokens: verification checkmarks, a movie streaming subscription, concert tickets, etc. These tokens can be used for many use cases, each potentially offering you different utility and value. Some may have real-world use cases (e.g. entry to a concert), while some may be purely digital (e.g. verification checkmark). Some may signify something about your reputation (certifications), while some may just be collected for fun.

When combined with blockchain technology, badges become even more secure and more powerful, due to the unique properties of the blockchain (verifiable, decentralized, tamper-proof, and so on). However, the existing infrastructure and technology is not nearly good enough to realize the vast potential of digital blockchain tokens (not scalable, lacks consistency, and is limited to a single blockchain ecosystem at a time).

## 🤔 Motive for building BitBadges?

The answer is simple. We believe in the potential of blockchains and a multi-chain world, but this potential cannot be realized with the current infrastructure and technology in place today.


## File: ./SUMMARY.md

# Table of contents
## Overview

* [👋 BitBadges Overview](README.md)
* [👨‍💻 Learn the Basics](overview/learn/README.md)
  * [BitBadges Claims](overview/learn/distribution.md)
  * [Multi-Chain Accounts](overview/learn/accounts.md)
  * [Sign In with BitBadges](overview/learn/verification-tools.md)
  * [Badges](overview/learn/badges.md)
  * [Address Lists](overview/learn/address-lists.md)
  * [Attestations](overview/learn/attestations.md)
  * [Applications (Points)](overview/learn/applications-points.md)
  * [Subscriptions](overview/learn/subscriptions.md)
  * [Additional Badge Concepts](overview/learn/badge-concepts/README.md)
    * [Manager](overview/learn/badge-concepts/manager.md)
    * [Total Supplys](overview/learn/badge-concepts/total-supplys.md)
    * [Time-Dependent Ownership](overview/learn/badge-concepts/time-dependent-ownership.md)
    * [Transferability](overview/learn/badge-concepts/transferability.md)
    * [Balances Types](overview/learn/badge-concepts/balances-types.md)
    * [Protocol Fee](overview/learn/badge-concepts/protocol-fee.md)
  * [Wallets and Sign Ins](overview/learn/wallets-and-sign-ins/README.md)
    * [Supported Wallets](overview/learn/wallets-and-sign-ins/supported-wallets.md)
    * [Alternate Sign Ins / Mobile](overview/learn/wallets-and-sign-ins/mobile-support.md)
    * [Approved Transactors](overview/learn/wallets-and-sign-ins/approved-transactors.md)
* [🎨 Use Cases](overview/use-cases.md)
* [🔗 Official Links and Resources](overview/official-links.md)
* [🌴 Ecosystem](overview/ecosystem/README.md)
  * [WordPress Plugin](overview/ecosystem/wordpress-plugin.md)
  * [MetaMask Snap](overview/ecosystem/metamask-snap.md)
  * [Browser Extensions](overview/ecosystem/chrome-extension.md)
  * [LinkedIn Certifications](overview/ecosystem/linkedin-certifications.md)
  * [Blockin](overview/ecosystem/blockin.md)
* [🤝 Brand Guidelines](overview/link-sharing.md)
* [❓ FAQ](overview/faq.md)

## ⌨️ For Developers
-   [🔨 Getting Started](for-developers/getting-started.md)
-   [👤 Handling Addresses](for-developers/accounts.md)
-   [🪄 BitBadges x AI](for-developers/bitbadges-x-ai/README.md)
    -   [Overview](for-developers/bitbadges-x-ai/overview.md)
    -   [Prompts](for-developers/bitbadges-x-ai/prompts/README.md)
        -   [Signing a Transaction](for-developers/bitbadges-x-ai/prompts/signing-a-transaction.md)
-   [📚 BitBadges API](for-developers/bitbadges-api/README.md)
    -   [Getting Started](for-developers/bitbadges-api/api.md)
    -   [Full Reference](https://bitbadges.stoplight.io/docs/bitbadges)
    -   [Typed SDK Types](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html)
    -   [Upgrading an API Key Tier](for-developers/bitbadges-api/upgrading-an-api-key-tier.md)
    -   [Concepts](for-developers/bitbadges-api/concepts/README.md)
        -   [Native Chain Algorithm](for-developers/bitbadges-api/concepts/native-chain-algorithm.md)
        -   [Refresh / Claim Completion Queue](for-developers/bitbadges-api/concepts/refresh-queue.md)
        -   [Limits / Restrictions](for-developers/bitbadges-api/concepts/limits-restrictions.md)
        -   [Managing Views](for-developers/bitbadges-api/concepts/managing-views.md)
        -   [Use via Pipedream](for-developers/bitbadges-api/concepts/use-via-pipedream.md)
-   [🖱️ Sign In with BitBadges](for-developers/sign-in-with-bitbadges/README.md)
    -   [Overview](for-developers/sign-in-with-bitbadges/overview.md)
    -   [Already Have Web3 Auth?](for-developers/sign-in-with-bitbadges/already-have-web3-auth.md)
    -   [Alternative - P2P Verification](for-developers/sign-in-with-bitbadges/alternative-p2p-verification.md)
    -   [Templates and Frameworks](for-developers/sign-in-with-bitbadges/templates-and-frameworks/README.md)
        -   [WordPress](for-developers/sign-in-with-bitbadges/templates-and-frameworks/wordpress.md)
        -   [Auth0](for-developers/sign-in-with-bitbadges/templates-and-frameworks/auth0.md)
        -   [ExpressJS](for-developers/sign-in-with-bitbadges/templates-and-frameworks/expressjs.md)
        -   [Discourse](for-developers/sign-in-with-bitbadges/templates-and-frameworks/discourse.md)
        -   [Supabase](for-developers/sign-in-with-bitbadges/templates-and-frameworks/supabase.md)
        -   [Others](for-developers/sign-in-with-bitbadges/templates-and-frameworks/others.md)
    -   [Setting Up an App](for-developers/sign-in-with-bitbadges/setting-up-an-app.md)
    -   [Connecting a Claim](for-developers/sign-in-with-bitbadges/connecting-a-claim.md)
    -   [Authorization URL](for-developers/sign-in-with-bitbadges/authorization-url/README.md)
        -   [Configuration](for-developers/sign-in-with-bitbadges/authorization-url/configuration.md)
        -   [Generating the URL](for-developers/sign-in-with-bitbadges/authorization-url/generating-the-url.md)
    -   [Approaches](for-developers/sign-in-with-bitbadges/approaches/README.md)
        -   [QR Codes](for-developers/sign-in-with-bitbadges/approaches/qr-codes.md)
        -   [Redirect Callback](for-developers/sign-in-with-bitbadges/approaches/redirected-callback.md)
    -   [Verification](for-developers/sign-in-with-bitbadges/verification/README.md)
        -   [Verification Flow](for-developers/sign-in-with-bitbadges/verification/verification-flow.md)
        -   [Access Tokens](for-developers/sign-in-with-bitbadges/verification/access-tokens.md)
        -   [Offline Verification](for-developers/sign-in-with-bitbadges/verification/offline-verification.md)
        -   [Security Considerations](for-developers/sign-in-with-bitbadges/verification/security-considerations.md)
    -   [Blockin Docs](https://blockin.gitbook.io/blockin)
-   [🎁 BitBadges Claims](overview/claim-builder/README.md)
    -   [Overview](for-developers/claim-builder/overview.md)
    -   [Concepts](for-developers/claim-builder/concepts/README.md)
        -   [Standard vs On-Demand](for-developers/claim-builder/concepts/standard-vs-on-demand.md)
        -   [Completion Methods](for-developers/claim-builder/completion-methods.md)
        -   [Gating Badge Distribution](for-developers/claim-builder/concepts/gating-badge-distribution.md)
        -   [Claim Numbers](for-developers/claim-builder/concepts/claim-numbers.md)
        -   [Success Logic](for-developers/claim-builder/success-logic.md)
        -   [Claim Links (URLs)](for-developers/claim-builder/claim-links.md)
        -   [Signed In vs Select Address](for-developers/claim-builder/concepts/signed-in-vs-select-address.md)
        -   [Universal Approach - Claim Codes](for-developers/claim-builder/concepts/universal-approach-claim-codes.md)
        -   [Identify By Socials / Emails?](for-developers/claim-builder/concepts/identify-by-socials-emails.md)
        -   [Payment Checking](for-developers/claim-builder/concepts/monetizing-apps-badges.md)
        -   [Receiving Attestations](for-developers/claim-builder/concepts/receiving-attestations.md)
    -   [Checking Custom Criteria](for-developers/claim-builder/checking-custom-criteria.md)
    -   [Implementing Custom Utility](for-developers/claim-builder/implementing-custom-utility.md)
    -   [Leveraging AI](for-developers/claim-builder/leveraging-ai.md)
    -   [BitBadges API & Claims](for-developers/claim-builder/bitbadges-api-claims/README.md)
        -   [Verifying Claim Attempts w/ the API](for-developers/claim-builder/bitbadges-api-claims/verifying-claim-attempts-w-the-api.md)
        -   [Fetching Claims](for-developers/claim-builder/bitbadges-api-claims/fetching-claims.md)
        -   [Auto-Complete Claims w/ BitBadges API](for-developers/claim-builder/bitbadges-api-claims/auto-complete-claims-w-bitbadges-api.md)
    -   [Dynamic Stores](for-developers/claim-builder/dynamic-stores/README.md)
        -   [Overview](for-developers/claim-builder/dynamic-stores/overview.md)
        -   [Adding Data](for-developers/claim-builder/dynamic-stores/adding-data.md)
    -   [Custom Plugins / Webhooks](for-developers/claim-builder/plugins/README.md)
        -   [Overview](for-developers/claim-builder/plugins/overview.md)
        -   [Pre-Built Webhook Plugins](for-developers/claim-builder/plugins/creating-a-custom-plugin/alternatives.md)
        -   [Creating a Custom Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/README.md)
            -   [Implement Your Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/README.md)
                -   [Getting Started](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/getting-started.md)
                -   [Hook Types and Simulations](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/hook-types-and-simulations.md)
                -   [Design Considerations](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/design-considerations.md)
                -   [Parameters](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/parameters.md)
                -   [Custom Inputs](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/user-inputs.md)
                -   [API Handler](for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/api-handler.md)
            -   [Managing Your Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/managing-your-plugin.md)
            -   [Testing Your Plugin](for-developers/claim-builder/plugins/creating-a-custom-plugin/testing-your-plugin.md)
        -   [Configuration Tools](for-developers/claim-builder/plugins/configuration-tools.md)
    -   [Integrate with Zapier](for-developers/claim-builder/auto-completing-claims/automate-w-zapier/README.md)
        -   [Overview](for-developers/claim-builder/auto-completing-claims/automate-w-zapier/overview.md)
        -   [Dynamic Store Zaps](for-developers/claim-builder/automate-w-zapier/dynamic-store-zaps.md)
        -   [Automatic Claim Tutorial](for-developers/claim-builder/auto-completing-claims/automate-w-zapier/automatic-claim-tutorial.md)
        -   [Post-Success Zaps](for-developers/claim-builder/automate-w-zapier/post-success-zaps.md)
        -   [Leveraging Zapier AI Actions / MCP](for-developers/claim-builder/automate-w-zapier/leveraging-zapier-ai-actions-mcp.md)
        -   [Automate Any Part of the Process](for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/README.md)
            -   [Google Forms](for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/google-forms.md)
    -   [Integrate with Pipedream](for-developers/claim-builder/integrate-with-pipedream/README.md)
        -   [Overview](for-developers/claim-builder/integrate-with-pipedream/overview.md)
        -   [Leveraging Pipedream MCP](for-developers/claim-builder/integrate-with-pipedream/leveraging-pipedream-mcp.md)
        -   [Build Custom Plugins](for-developers/claim-builder/integrate-with-pipedream/build-custom-plugins.md)
        -   [Workflow Actions](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/README.md)
            -   [Complete Claim](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/complete-claim.md)
            -   [Get Claim Attempt Status](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-attempt-status.md)
            -   [Get Claim Code by Idx](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-code-by-idx.md)
            -   [Add User to Dynamic Store](for-developers/claim-builder/integrate-with-pipedream/workflow-actions/add-user-to-dynamic-store.md)
        -   [Workflow Triggers](for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/README.md)
            -   [Poll Claim Attempts](for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/poll-claim-attempts.md)
        -   [End to End Example](for-developers/claim-builder/integrate-with-pipedream/end-to-end-example.md)
    -   [In-Site Plugins](for-developers/claim-builder/bitbadges-created-plugins/README.md)
        -   [Plugins Directory](https://bitbadges.io/plugin-directory)
        -   [Plugin Documentation](for-developers/claim-builder/bitbadges-created-plugins/plugin-documentation.md)
        -   [Ownership Requirements](for-developers/claim-builder/bitbadges-created-plugins/ownership-requirements.md)
    -   [Tutorials](for-developers/claim-builder/other-tutorials/README.md)
        -   [In-Site Guides](for-developers/claim-builder/other-tutorials/in-site-guides.md)
        -   [Get Integration User IDs](for-developers/claim-builder/other-tutorials/get-integration-user-ids/README.md)
            -   [Get Discord User ID](for-developers/claim-builder/other-tutorials/get-integration-user-ids/get-discord-user-id.md)
            -   [Get Discord Server ID](for-developers/claim-builder/other-tutorials/get-integration-user-ids/discord.md)
            -   [X / Twitch / GitHub IDs](for-developers/claim-builder/other-tutorials/get-integration-user-ids/x-twitch-github-ids.md)
        -   [Add Telegram Bot to Channel](for-developers/claim-builder/other-tutorials/add-telegram-bot-to-channel.md)
-   [⚒️ BitBadges JS / SDK](for-developers/bitbadges-sdk/README.md)
    -   [Overview](for-developers/bitbadges-sdk/overview.md)
    -   [SDK Types](for-developers/bitbadges-sdk/sdk-types.md)
    -   [Common Snippets](for-developers/bitbadges-sdk/common-snippets/README.md)
        -   [Address Conversions](for-developers/bitbadges-sdk/common-snippets/address-conversions.md)
        -   [NumberType Conversions](for-developers/bitbadges-sdk/common-snippets/numbertype-conversions.md)
        -   [Uint Ranges](for-developers/bitbadges-sdk/common-snippets/uint-ranges.md)
        -   [Balances](for-developers/bitbadges-sdk/common-snippets/balances.md)
        -   [Transfers](for-developers/bitbadges-sdk/common-snippets/transfers-w-increments.md)
        -   [Address Lists](for-developers/bitbadges-sdk/common-snippets/address-lists.md)
        -   [Badge Metadata](for-developers/bitbadges-sdk/common-snippets/badge-metadata.md)
        -   [Approvals / Transferability](for-developers/bitbadges-sdk/common-snippets/get-unhandled-approvals.md)
        -   [Timelines](for-developers/bitbadges-sdk/common-snippets/timelines.md)
-   [⛓️ BitBadges Blockchain](for-developers/bitbadges-blockchain/README.md)
    -   [Overview](for-developers/bitbadges-blockchain/overview.md)
    -   [Accounts (Technical)](for-developers/concepts/accounts-technical.md)
    -   [Chain Details](for-developers/bitbadges-blockchain/chain-details.md)
    -   [Staking / Validators](overview/staking-usdbadge.md)
    -   [Create a WASM Contract](for-developers/bitbadges-blockchain/create-a-wasm-contract.md)
    -   [Run a Node](for-developers/bitbadges-blockchain/run-a-node/README.md)
        -   [Overview](for-developers/bitbadges-blockchain/run-a-node/overview.md)
        -   [Run a Mainnet Node](for-developers/bitbadges-blockchain/run-a-node/run-a-mainnet-node.md)
        -   [Run a Local Dev Node](for-developers/bitbadges-blockchain/run-a-node/run-a-local-dev-node.md)
        -   [Cosmovisor](for-developers/bitbadges-blockchain/run-a-node/cosmovisor.md)
    -   [Create, Generate, and Sign Txs](for-developers/bitbadges-blockchain/create-and-broadcast-txs/README.md)
        -   [Ex: Run an AI Agent](for-developers/bitbadges-blockchain/create-and-broadcast-txs/ex-run-an-ai-agent.md)
        -   [Transaction Context](for-developers/bitbadges-blockchain/create-and-broadcast-txs/transaction-context.md)
        -   [Generate Msg Contents](for-developers/bitbadges-blockchain/create-and-broadcast-txs/generate-msg-contents.md)
        -   [Signing - Cosmos](for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-cosmos.md)
        -   [Signing - Ethereum](for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-ethereum.md)
        -   [Signing - Solana](for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-solana.md)
        -   [Signing - Bitcoin](for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-bitcoin.md)
        -   [Broadcast to a Node](for-developers/bitbadges-blockchain/create-and-broadcast-txs/broadcast-to-a-node.md)
        -   [Sign + Broadcast - bitbadges.io](for-developers/bitbadges-blockchain/create-and-broadcast-txs/sign-+-broadcast-bitbadges.io.md)
    -   [Cosmos SDK Msgs](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/README.md)
        -   [x/anchor](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-anchor/README.md)
            -   [MsgAddCustomData](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-anchor/msgaddcustomdata.md)
        -   [x/badges](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/README.md)
        -   [x/wasmx](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/README.md)
            -   [MsgStoreCodeCompat](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msgstorecodecompat.md)
            -   [MsgInstantiateContractCompat](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msginstantiatecontractcompat.md)
            -   [MsgExecuteContractCompat](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msgexecutecontractcompat.md)
        -   [x/maps](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/README.md)
            -   [MsgCreateMap](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgcreateprotocol.md)
            -   [MsgUpdateMap](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgupdateprotocol.md)
            -   [MsgDeleteMap](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgdeleteprotocol.md)
            -   [MsgSetValue](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgsetcollectionforprotocol.md)
        -   [MsgSend](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/msgsend.md)
        -   [Cosmos Native Msgs](for-developers/bitbadges-blockchain/cosmos-sdk-msgs/cosmos-native-msgs.md)
-   [🧪 Testnet Mode](overview/testnet-mode.md)
-   [🧠 Other Concepts](for-developers/core-concepts/README.md)
    -   [Maps / Protocols](for-developers/core-concepts/maps.md)
    -   [Attestations - Advanced](for-developers/core-concepts/verifiable-attestations/README.md)
        -   [Overview](for-developers/core-concepts/verifiable-attestations/overview.md)
        -   [Creating an Attestation](for-developers/core-concepts/verifiable-attestations/creating-a-attestation.md)
        -   [Custom Creation Links](for-developers/core-concepts/verifiable-attestations/custom-creation-links.md)
        -   [Proofs vs Attestations](for-developers/core-concepts/verifiable-attestations/proofs-vs-attestations.md)
        -   [Deriving a Proof](for-developers/core-concepts/verifiable-attestations/deriving-a-proof.md)
        -   [Design Considerations](for-developers/core-concepts/verifiable-attestations/design-considerations.md)
        -   [Verification / Presentations](for-developers/core-concepts/verifiable-attestations/creating-and-verifying-a-proof.md)
        -   [Custom Schemes](for-developers/core-concepts/verifiable-attestations/custom-schemes/README.md)
            -   [WITNESS Proofs](for-developers/core-concepts/verifiable-attestations/custom-schemes/witness-proofs.md)

## 🏗️ Badge Standard

* [Overview](x-badges/README.md)

* [Concepts](x-badges/concepts/README.md)
  * [Address Lists](x-badges/concepts/address-lists.md)
  * [Archived Collections](x-badges/concepts/archived-collections.md)
  * [Badge Collections](x-badges/concepts/badge-collections.md)
  * [Balances Type](x-badges/concepts/balances-type.md)
  * [Balance System](x-badges/concepts/balance-system.md)
  * [Cosmos Wrapper Paths](x-badges/concepts/cosmos-wrapper-paths.md)
  * [Custom Data](x-badges/concepts/custom-data.md)
  * [Default Balances](x-badges/concepts/default-balances.md)
  * [Manager](x-badges/concepts/manager.md)
  * [Metadata](x-badges/concepts/metadata.md)
  * [Mint Escrow Address](x-badges/concepts/mint-escrow-address.md)
  * [Standards](x-badges/concepts/standards.md)
  * [Different Time Fields](x-badges/concepts/time-fields.md)
  * [Timeline System](x-badges/concepts/timeline-system.md)
  * [Total Supply](x-badges/concepts/total-supply.md)
  * [Transferability / Approvals](x-badges/concepts/transferability-approvals.md)
  * [UintRanges](x-badges/concepts/uintrange.md)
  * [Valid Badge IDs](x-badges/concepts/valid-badge-ids.md)
  * [Approval Criteria](x-badges/concepts/approval-criteria/README.md)
    * [Overview](x-badges/concepts/approval-criteria/approval-system.md)
    * [Approval Trackers](x-badges/concepts/approval-criteria/approval-trackers.md)
    * [Badge Ownership](x-badges/concepts/approval-criteria/badge-ownership.md)
    * [Dynamic Store Challenges](x-badges/concepts/approval-criteria/dynamic-store-challenges.md)
    * [Extending the Approval (Advanced)](x-badges/concepts/approval-criteria/linking-trackers-advanced.md)
    * [Max Number of Transfers](x-badges/concepts/approval-criteria/max-number-of-transfers.md)
    * [Merkle Challenges](x-badges/concepts/approval-criteria/merkle-challenges.md)
    * [Override User Level Approvals](x-badges/concepts/approval-criteria/overrides.md)
    * [Predetermined Balances](x-badges/concepts/approval-criteria/predetermined-balances.md)
    * [Requires](x-badges/concepts/approval-criteria/requires.md)
    * [Tallied Approval Amounts](x-badges/concepts/approval-criteria/tallied-approval-amounts.md)
    * [$BADGE Transfers](x-badges/concepts/approval-criteria/usdbadge-transfers.md)
  * [Permissions](x-badges/concepts/permissions/README.md)
    * [Overview](x-badges/concepts/permissions/permission-system.md)
    * [Action Permission](x-badges/concepts/permissions/action-permission.md)
    * [Badge IDs Action Permission](x-badges/concepts/permissions/balances-action-permission.md)
    * [Timed Update Permission](x-badges/concepts/permissions/timed-update-permission.md)
    * [Timed Update With Badge Ids Permission](x-badges/concepts/permissions/timed-update-with-badge-ids-permission.md)
    * [Update Approval Permission](x-badges/concepts/permissions/update-approval-permission.md)
  * [Protocols](x-badges/concepts/protocols/README.md)
    * [Subscriptions Protocol](x-badges/concepts/protocols/subscriptions-protocol.md)
* [Messages](x-badges/messages/README.md)
  * [MsgCreateAddressLists](x-badges/messages/msg-create-address-lists.md)
  * [MsgCreateCollection](x-badges/messages/msg-create-collection.md)
  * [MsgCreateDynamicStore](x-badges/messages/msg-create-dynamic-store.md)
  * [MsgDeleteCollection](x-badges/messages/msg-delete-collection.md)
  * [MsgDeleteDynamicStore](x-badges/messages/msg-delete-dynamic-store.md)
  * [MsgSetDynamicStoreValue](x-badges/messages/msg-set-dynamic-store-value.md)
  * [MsgTransferBadges](x-badges/messages/msg-transfer-badges.md)
  * [MsgUpdateCollection](x-badges/messages/msg-update-collection.md)
  * [MsgUpdateDynamicStore](x-badges/messages/msg-update-dynamic-store.md)
  * [MsgUpdateUserApprovals](x-badges/messages/msg-update-user-approvals.md)
* [Queries](x-badges/queries/README.md)
  * [GetAddressList](x-badges/queries/get-address-list.md)
  * [GetApprovalTracker](x-badges/queries/get-approval-tracker.md)
  * [GetBalance](x-badges/queries/get-balance.md)
  * [GetChallengeTracker](x-badges/queries/get-challenge-tracker.md)
  * [GetCollection](x-badges/queries/get-collection.md)
  * [GetDynamicStore](x-badges/queries/get-dynamic-store.md)
  * [GetDynamicStoreValue](x-badges/queries/get-dynamic-store-value.md)
  * [Params](x-badges/queries/params.md)
* [Badge Standard Examples](x-badges/examples/README.md)
  * [Base Collection Details](x-badges/examples/base-collection-details.md)
  * [Building Your Collection Approvals](x-badges/examples/building-collection-approvals.md)
  * [Building Your Collection Permissions](x-badges/examples/building-collection-permissions.md)
  * [Cosmos Coin Wrapper Tutorial](x-badges/examples/cosmos-coin-wrapper-example.md)
  * [Mint All Badges to Self - Tutorial](x-badges/examples/mint-all-to-self-tutorial.md)
  * [Approvals](x-badges/examples/approvals/README.md)
    * [Admin Override Approval](x-badges/examples/approvals/admin-override-approval.md)
    * [Burnable Approval](x-badges/examples/approvals/burnable-approval.md)
    * [Cosmos Unwrapper Approval](x-badges/examples/approvals/cosmos-unwrapper-approval.md)
    * [Cosmos Wrapper Approval](x-badges/examples/approvals/cosmos-wrapper-approval.md)
    * [Transferable Approval](x-badges/examples/approvals/transferable-approval.md)
  * [Permission Examples](x-badges/examples/permissions/README.md)
* [Events](x-badges/events.md)
* [State](x-badges/state.md)




## File: ./for-developers/accounts.md

# 👤 Handling Addresses

This page will give you an overview of BitBadges accounts. It should be enough information for most, but for more low-level interaction, [this page](broken-reference) will give you more in-depth explanations.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Mapping to a Common Address (bitbadgesAddress)**

To enable interoperability between different blockchains, each individual L1 blockchain will have its native addresses mapped to an equivalent Cosmos (aka BitBadges) bech32 address. We use the mapped **bitbadgesAddress** as the universal base address whenever needed.

We try to be as accommodating of native addresses as possible, but there are many places where universal standardization is needed. You will often come across places in development where you need to specify a **bitbadgesAddress.** This is expected to be the mapped address and not the native address (thus, you will need to map first). The typical naming convention we use is **bitbadgesAddress** vs **address.**&#x20;

The mappings should ONLY happen behind the scenes. On the user facing side, you should always display the user's native address.

Ethereum Example:

* Mapped BitBadges Address (Bech32): bb14au322k9munkmx5wrchz9q30juf5wjgz2cfqku
* Address (Native - [EIP55](https://eips.ethereum.org/EIPS/eip-55) Ethereum Hex): 0xAF79152AC5dF276D9A8e1E2E22822f9713474902

Solana Example:

* Address (Native - Base58): 6H2af68Yyg6j7N4XeQKmkZFocYQgv6yYoU3Xk491efa5
* Mapped BitBadges Address (Bech32): bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl

Bitcoin Example

* Address (Native - P2WPKH): bc1q9s7rynm5pwhluhecsmlku8rn5yej5wdgj0gv3e
* Mapped BitBadges Address (Bech32): bb19s7rynm5pwhluhecsmlku8rn5yej5wdg8g75f9

#### Why can I convert Solana address to a BitBadges / ETH / BTC address but not the other way around?

You may notice that you cannot go from a BitBadges / ETH / BTC address directly to a Solana address but you can the other way around. This is because conversion from a Solana address requires a hash, so if you just have the postimage of the hash (an ETH / BitBadges address), you cannot deduce the preimage without prior knowledge of it.

#### **How to convert?**

The mapped addresses can be converted behind the scenes using the converter functions from [BitBadges SDK](bitbadges-sdk/) (address-converter). This can be done with any validly formatted address.

<pre class="language-typescript"><code class="lang-typescript"><strong>import { convertToEthAddress, convertToBitBadgesAddress, mustConvertToBtcAddress } from 'bitbadgesjs-sdk';
</strong>
<strong>const bitbadgesAddress = convertToBitBadgesAddress(btcAddress);
</strong>const ethAddress = convertToEthAddress(bitbadgesAddress);
const bitbadgesAddressFromSolana = convertToBitBadgesAddress(solAddress);
const btcAddress = mustConvertToBtcAddress(address);

// Note there is no convertToSolanaAddress due to how the addresses work. See above
</code></pre>

**What is signature compatibility?**

To enable interoperability between different blockchains, BitBadges is signature compatible with all of the supported chains (Bitcoin, Ethereum, Solana, and Cosmos).

Signature compatibility means that we can verify transaction signatures from any wallet of any supported ecosystem. BitBadges is its own blockchain and does not pull any data from any other blockchain. Everything is confined to the BitBadges blockchain.

#### **How do I query details for an address?**

1. You can use the [BitBadges API](bitbadges-api/api.md) to get information about an address (recommended option). This is the recommended options because we have indexed all the data already for you.
2. You an also query a BitBadges blockchain node directly, either through the CLI or [REST API](https://docs.cosmos.network/v0.46/run-node/interact-node.html)


## File: ./for-developers/bitbadges-api/README.md

# 📚 Indexer / API



## File: ./for-developers/bitbadges-api/api.md

# Getting Started

## Getting Started - API Keys

By default, certain routes are available publicly in a rate limited manner with no API key. However, API keys allow you access to all routes with higher limits.

1. Sign in on and create an API key by going to [https://bitbadges.io/developer](https://bitbadges.io/developer) -> API Keys tab.
2. Start sending requests to the base URL of [https://api.bitbadges.io/](https://api.bitbadges.io/) with the HTTP header x-api-key. All routes require an API key.
3. For higher tiers / paid plans, visit [https://bitbadges.io/pricing](https://bitbadges.io/pricing). To actually upgrade, see the Upgrading an API Key Tier demo on the next page.

<figure><img src="../../.gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

## Quickstarter

See the [quickstart repo](https://github.com/BitBadges/bitbadges-quickstart) for a fully configured example repository with fetching collections, accounts, and more with the API!

## Number Types

Note: Numbers are stringified in responses to avoid precision loss. You will have to convert them. The SDK does this for you if you use it.

## References

* [Main](https://bitbadges.stoplight.io/docs/bitbadges)
* [Postman](https://www.postman.com/bitbadges/workspace/bitbadges-api/collection/11647629-5bc57e3c-1818-4446-988e-23a9442cc0df?action=share\&creator=11647629)
* [OpenAPI](https://github.com/BitBadges/bitbadgesjs/blob/main/packages/bitbadgesjs-sdk/openapitypes/combined.yaml)

In this documentation, we often use the SDK format for explanation purposes. Please convert the corresponding function name to vanilla HTTP if you are not using the SDK from the documentation above.

```typescript
await BitBadgesApi.routeFn(...)
```

```
POST https://api.bitbadges.io/api/v0/routeFn
```

## Testnet Mode

A testnet version of the API is available with the base URL [https://api.bitbadges.io/testnet](https://api.bitbadges.io/testnet). Everything else is the same, just add the /testnet before all paths.

Note that this testnet API is an entirely separate service from normal API. Nothing carries over. It commmunicates with the frontend with testnet mode turned on and uses the testnet BitBadges blockchain.

## Using the API SDK (Recommended)

If you are using JavaScript / TypeScript, consider using the typed API SDK for convenience. This will give you typed routes, provide quality checks, and also auto-convert all responses to your desired number type (bigint, Number, etc).

```typescript
import { BigIntify, BitBadgesAPI } from 'bitbadgesjs-sdk';

export type DesiredNumberType = bigint;
export const ConvertFunction = BigIntify;

//BACKEND_URL for main API is https://api.bitbadges.io
//Make sure process.env.BITBADGES_API_KEY is set with a valid API key.

const BitBadgesApi = new BitBadgesAPI({
    apiKey: '...',
    //converts responses to your desired number type (bigint, Number, etc)
    convertFunction: ConvertFunction //Can also do Numberify, Stringify, etc
    apiUrl: '...' //defaults to official one if empty
});

//See https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html for documentation
//Some might require authentication. Some might be CORS only from the official site.
await BitBadgesApi.getAccounts(...);
await BitBadgesApi.getAddressLists(...);
await BitBadgesApi.getCollections(...);
await BitBadgesApi.simulateTx(...);
```

Note we also have a python auto-generated SDK wrapper for the API without any of the helper functions like the JS SDK has at [https://pypi.org/project/bitbadgespy-sdk/](https://pypi.org/project/bitbadgespy-sdk/)

## Using BitBadges JS/SDK

Check out the BitBadges JS/SDK for implementing further functionality beyond just API requests / responses, such as manipulating balances, handling approvals, checking permissions, etc.

{% content-ref url="../bitbadges-sdk/" %}
[bitbadges-sdk](../bitbadges-sdk/)
{% endcontent-ref %}

## API Authorization

For most applications, you should be fine without needing to access private user authenticated information. However if you do, check out Sign In with BitBadges. This follows a standard OAuth 2.0 flow. Use the scopes to gain access to authenticated routes. Refer to the API reference to see what scopes are needed where.

{% content-ref url="broken-reference" %}
[Broken link](broken-reference)
{% endcontent-ref %}

## Bookmarking

Throughout the API, we use a bookmark technique. For the first request, you will not need to specify a bookmark (e.g. ""), and it will fetch the first page. Within the response, it will return a **bookmark** and **hasMore**. **hasMore** defines whether there are more pages to be fetched. To fetch the next page, you will specify the returned bookmark from the previous request to the next request. This process can be repeated until all are loaded.


## File: ./for-developers/bitbadges-api/concepts/README.md

# Concepts



## File: ./for-developers/bitbadges-api/concepts/limits-restrictions.md

# API Limits & Restrictions

The following limits are in place to ensure API stability and performance. If these limits are too restrictive for your use case, please contact us.

## Request Limits

-   **Rate Limit**: 10,000 requests per day per API key
-   **Global Rate Limit**: Enforced to prevent infinite loops
-   **Refresh Rate**: Operations can only be refreshed once per hour

## Data Limits

-   **Batch Size**: Maximum 250 items per request for:
    -   Metadata URIs
    -   Account lookups
    -   Collection fetches
-   **IPFS Storage**: Maximum 100MB total uploads per address
-   **Collection Size**: Limited functionality for collections exceeding JavaScript's `Number.MAX_SAFE_INTEGER`

## Timeouts & Retries

This applies to any external fetches, including metadata URIs and other external sources like custom success hooks.

-   **URI Fetch Timeout**: 10 seconds maximum for direct source URI fetches
-   **Retry Policy**: For failed fetches, exponential backoff:
    ```
    Delay = 1 hour × 2^(number of attempts)
    ```

Note: These limits may change over time. Please refer to our latest documentation for current values.


## File: ./for-developers/bitbadges-api/concepts/managing-views.md

# Managing Views

Throughout the BitBadges API, we use a bookmark-based pagination system for efficient data retrieval. This system is particularly useful when dealing with large datasets that need to be fetched in smaller chunks.

Some endpoints like the get accounts or get collections will use a generic viewsToFetch and views object which can maintain multiple paginated views. Some endpoints will request the bookmark directly. Refer to the documentation for each endpoint to see how it handles pagination.

### How Bookmark Pagination Works

1. **First Request**: For your initial request, use an empty bookmark string (`""`).

```typescript
const firstRequest = {
    viewType: 'owners',
    viewId: 'owners',
    bookmark: '', // Empty for first page
};
```

2. **Response Structure**: Each paginated response includes:
   * The requested data
   * A `bookmark` string for the next page
   * A `hasMore` boolean indicating if more data exists

```typescript
{
    data: [...],
    views: {
        'owners': {
            ids: [...],
            pagination: {
                bookmark: 'abc123...', // Use this for next request
                hasMore: true
            }
        }
    }
}
```

3. **Subsequent Requests**: To fetch the next page, use the bookmark from the previous response:

```typescript
const nextRequest = {
    viewType: 'owners',
    viewId: 'owners',
    bookmark: 'abc123...', // Bookmark from previous response
};
```

4. **Completion**: Continue this process until `hasMore` is `false`.

## Understanding the Views Object

```
Note: This is planning to be deprecated in favor of more confined view routes. 
Please use those instead. They are much less confusing.
```

The views object is a central concept in the BitBadges API, used to manage paginated data across different interfaces (BitBadgesCollection, BitBadgesAddressList, BitBadgesUserInfo, etc). It follows this structure:

```typescript
views: {
    [viewId: string]: {
        ids: string[];          // Array of document IDs
        pagination: {
            bookmark: string;    // Bookmark for next page
            hasMore: boolean;    // Whether more data exists
        };
        type: string;           // The view type
    } | undefined;
}
```

### Key Components

1. **viewId**: A unique identifier for the view
2. **ids**: Array of document IDs that correspond to full documents in the response
3. **pagination**: Contains the bookmark and hasMore flag
4. **type**: Indicates the type of view (e.g., 'owners', 'activity', etc.)

### Document ID Mapping

Documents in the response are referenced by their `_docId` field. To access the full document, you map the IDs from the view to the corresponding array in the response. For example, the activity view documents are stored in the `activity` array, and the view IDs are stored in the `views.activity.ids` array.

```typescript
// Example of accessing activity documents from a view
getActivityView(viewId: string) {
    return (this.views[viewId]?.ids.map((x) => {
        return this.activity.find((y) => y._docId === x);
    }) ?? []);
}
```

### Common View Types

Different interfaces support different view types. See the corresponding documentation for each interface to see what views are supported.

#### Collections Interface

* `owners`: List of badge owners
* `activity`: Transfer activity
* `approvalTrackers`: Approval tracking documents

See all at [CollectionViewKey](https://bitbadges.github.io/bitbadgesjs/types/CollectionViewKey.html)

#### Account Interface

* `transferActivity`: User's transfer history
* `badgesCollected`: Badges owned by the user
* `createdBadges`: Collections created by the user
* `managingBadges`: Collections being managed
* `allLists`: Address lists the user is on

See all at [AccountViewKey](https://bitbadges.github.io/bitbadgesjs/types/AccountViewKey.html)

## Helper Functions

The BitBadges SDK provides several helper functions for managing views:

```typescript
// Check if more pages exist
const hasMore = collection.viewHasMore('owners');

// Get bookmark for next page
const nextBookmark = collection.getViewBookmark('owners');

// Fetch next page of data
await collection.fetchNextForView(BitBadgesApi, 'owners', 'owners');

// Get all documents for a view
const ownersView = collection.getOwnersView('owners');
```

## Best Practices

1. **Consistent ViewIds**: Use consistent viewIds when paginating through the same dataset
2. **Error Handling**: Always check for undefined views before accessing
3. **Document Mapping**: Use helper functions when available for mapping IDs to documents
4. **Pagination State**: Track both bookmark and hasMore status for proper pagination
5. **Response Merging**: Remember that each response is confined to its request - use helper functions or manually merge data as needed


## File: ./for-developers/bitbadges-api/concepts/native-chain-algorithm.md

# Native Chain Algorithm

### How is a user's "native" chain determined?

You may have noticed that on the BitBadges site and other places, a user's "preferred" or "main" blockchain is remembered and auto-populated. This is how we populate the **chain** and **address** field in account route responses. We determine the main chain in the following order.

1. Chain of last signed BitBadges transaction
2. Chain of last sign in on BitBadges app
3. Try to check any transaction history (e.g. submitted any transactions on Ethereum mainnet chain?)
4. Requested address format
5. Guess / default to Ethereum since it is the most popular


## File: ./for-developers/bitbadges-api/concepts/refresh-queue.md

# Refresh / Claim Completion Queue

The API / indexer makes use of a load-balanced refresh queue system whenever we need to fetch anything from a source URI (metadata, off-chain balances, etc). Because this is a queue-based system, certain metadata may take awhile to fully load and populate. Once we fetch the metadata, we cache it and return the fetched values until it is refreshed again.

**When do we trigger refreshes?**

Refreshes are triggered automatically when certain things occur on-chain, such as a collection is created / URI is changed. You can also manually trigger refreshes (note there are cooldown limits in place to prevent spam) to refresh the cached values via the refresh endpoints.

**What happens if the fetch fails?**

See [Restrictions / Limits](limits-restrictions.md). We implement an exponential retry system.

**Off-Chain Balances**

Note that for off-chain balances, we also throw an error if the fetched balances exceed the total supply of badges defined on-chain (i.e. you are trying to allocate more badges than you should).

**Checking Status**

If you are having issues, you can check the BitBadges collection page on site -> Actions -> Refresh for statuses. Or, if you need a programmatic solution, you can use following route to see its status and see if it has any error docs.

```typescript
await BitBadgesApi.getRefreshStatus()
```



## File: ./for-developers/bitbadges-api/concepts/use-via-pipedream.md

# Use via Pipedream

[Pipedream BitBadges Integration](https://pipedream.com/apps/bitbadges) allows you to interact with the BitBadges API via Pipedream. Connect your Pipedream account to the BitBadges API and start building!

This opens up a lot of possibilities for automating your workflows with BitBadges. For claim-speciifc automation, see the Pipedream section in the claims documentation.

{% content-ref url="../../claim-builder/integrate-with-pipedream/" %}
[integrate-with-pipedream](../../claim-builder/integrate-with-pipedream/)
{% endcontent-ref %}


## File: ./for-developers/bitbadges-api/indexer.md

# Indexer

If you want to run your own indexer and API, check out the source code at [https://github.com/bitbadges/bitbadges-indexer](https://github.com/bitbadges/bitbadges-indexer).

The indexer is split into two main parts: the poller and the API. The poller fetches the latest block from a connected node every second and updates the MongoDB database accordingly. The API is an Express.js API that makes the indexed data queryable to users.

Although you can query other blockchain nodes, it is strongly recommended that you run your own node and query that. HTTP requests can reach >100 per second.

### Running from Scratch

1. Install and setup CouchDB
2. Setup a valid .env file. See environment.d.ts below for the expected format of the .env file.&#x20;
3. Use **npm run setup** to setup the CouchDB databases. Note that you can run **npm run setup with-delete** to restart all indexer databases from scratch.
4. Use **npm run indexer-dev** to start in development mode.
5. Use **npm run build** and **npm run indexer** to start in production mode.

### Running with Docker

See [https://github.com/bitbadges/bitbadges-docker](https://github.com/bitbadges/bitbadges-docker).

### Customization Options (.env file)

Below are the supported customization options. Some may be applicable. Some may not.

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadges-indexer/blob/master/environment.d.ts" %}



## File: ./for-developers/bitbadges-api/upgrading-an-api-key-tier.md

# Upgrading an API Key Tier

1. Sign in and create your API key in the [developer portal -> API Keys tab](https://bitbadges.io/developer).

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

2. Once you've created it and copied it somewhere safe, select "Update Tier".

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

3. This will take you to the billing page. Select your desired tier. Note that if you have a coupon code, it will typically only apply to a specific tier.

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

4. Lastly, complete the form, selecting your newly created API key. Enter your email, enter promo code (if applicable), and complete the rest of the form.

<figure><img src="../../.gitbook/assets/image (5) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

5. Once that form is submitted, you're ready to start building! See the [BitBadges API documentation](https://docs.bitbadges.io) for more information on how to use the BitBadges API. The new tier may take 5-10 minutes to register, so please allow some time for the changes to take effect.


## File: ./for-developers/bitbadges-blockchain/README.md

# ⛓ BitBadges Blockchain



## File: ./for-developers/bitbadges-blockchain/accounts-technical.md

# Accounts (Low-Level)

## Pre-Readings

* [Cosmos SDK Accounts](https://docs.cosmos.network/main/basics/accounts)
* [Ethereum Accounts](https://ethereum.org/en/whitepaper/#ethereum-accounts)

### Accounts[​](https://docs.injective.network/learn/basic-concepts/accounts#injective-accounts) <a href="#injective-accounts" id="injective-accounts"></a>

For accounts (standard senders of transactions) , we support users from four L1 blockchain ecosystems currently (Ethereum, Bitcoin, Solana, and Cosmos). These are mapped behind the scenes through mapping addresses to an equivalent BitBadges address and being signature compatible (able to verify signatures of the native signature schemes).

### Signing Transactions <a href="#injective-accounts" id="injective-accounts"></a>

For non-Cosmos signatures, we map everything to a SHA256 content hash to get a string such as:

```
This is a BitBadges transaction with the content hash: b0d2944e1e367cc394d0e305f94eccf543983265a32b5cb71800da7d6df57679
```

We then verify the signatures of the transaction string as a personal message signature via the respective signature algorithm (e.g. ECDSA for Ethereum).

### **Cosmos**

Normal Cosmos accounts are also supported with all the Cosmos SDK's native functionality. We refer you to their documentation for further information.

### **Ethereum**

BitBadges allows Ethereum addresses to use Ethereum's ECDSA secp256k1 curve for keys.

### **Solana**

BitBadges also extends the SDK's functionality to support Solana signatures signing with a ed25519 key. Addresses are expected to be in the native Base58 format.

### Bitcoin

BitBadges supports Bitcoin P2WPKH addresses and BIP322 signature verification.

### **Public Key Types**

For standard Cosmos accounts and Bitcoin accounts, the public key will have the `"@type": "/cosmos.crypto.secp256k1.PubKey"`.

For Solana accounts, the public key will have the `"@type": "/cosmos.crypto.ed25519.PubKey"`.

For standard Ethereum accounts, the public key will have the `"@type": "/ethereum.PubKey"`.

`{"@type":"/ethereum.PubKey","key":"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2"}`

### Deriving BitBadges Ethereum Account from a private key/mnemonic[​](https://docs.injective.network/learn/basic-concepts/accounts#deriving-injective-account-from-a-private-keymnemonic) <a href="#deriving-injective-account-from-a-private-keymnemonic" id="deriving-injective-account-from-a-private-keymnemonic"></a>

Below you will see an example code snippet on how to derive a BitBadges Account from a private key and/or a mnemonic phase:

```typescript
import { Wallet } from 'ethers'
import { Address as EthereumUtilsAddress } from 'ethereumjs-util'

const mnemonic = "indoor dish desk flag debris potato excuse depart ticket judge file exit"
const privateKey = "afdfd9c3d2095ef696594f6cedcae59e72dcd697e2a7521b1578140422a4f890"
const defaultDerivationPath = "m/44'/60'/0'/0/0"
const defaultBech32Prefix = 'bb'
const isPrivateKey: boolean = true /* just for the example */

const wallet = isPrivateKey ? Wallet.fromMnemonic(mnemonic, defaultDerivationPath) : new Wallet(privateKey)
const ethereumAddress = wallet.address
const addressBuffer = EthereumUtilsAddress.fromString(ethereumAddress.toString()).toBuffer()
const bitbadgesAddress = bech32.encode(defaultBech32Prefix, bech32.toWords(addressBuffer))
```

Let's see an example code snipped on how to derive a public key from a private key:

```typescript
import secp256k1 from 'secp256k1'

const privateKey = "afdfd9c3d2095ef696594f6cedcae59e72dcd697e2a7521b1578140422a4f890"
const privateKeyHex = Buffer.from(privateKey.toString(), 'hex')
const publicKeyByte = secp256k1.publicKeyCreate(privateKeyHex)

const buf1 = Buffer.from([10])
const buf2 = Buffer.from([publicKeyByte.length])
const buf3 = Buffer.from(publicKeyByte)

const publicKey = Buffer.concat([buf1, buf2, buf3]).toString('base64')
const type = '/ethereum.PubKey'
```

#### Acknowledgements

Credit to [https://docs.injective.network/learn/basic-concepts/accounts](https://docs.injective.network/learn/basic-concepts/accounts) and [https://docs.evmos.org/protocol/concepts/accounts](https://docs.evmos.org/protocol/concepts/accounts).


## File: ./for-developers/bitbadges-blockchain/chain-details.md

# Chain Details

Cosmos Chain ID (Mainnet) - bitbadges-1

Cosmos Chain ID (Testnet) - bitbadges-2

[Cosmos SDK Coin Denom](https://docs.cosmos.network/main/modules/bank) - "ubadge" (1 $BADGE = 1 \* 10^9 ubadge)

### Official Links

**RPCs**

[https://rpc.bitbadges.io](https://rpc.bitbadges.io)

Tendermint Node ID: 2703c1304a70186372aa726a762d60da94c29ffe

See genesis.json in source code repository for genesis file. See [here](htttps://github.com/bitbadges/bitbadgeschain) for source code repository.

**Blockchain Node REST APIs**

[https://lcd.bitbadges.io](https://lcd.bitbadges.io)

**State Snapshots (Unofficial)**

[https://snapshots.whenmoonwhenlambo.money/](https://snapshots.whenmoonwhenlambo.money/)

**BitBadges API / Indexer**

[https://api.bitbadges.io](https://api.bitbadges.io)

**Explorer**

[https://explorer.bitbadges.io](https://explorer.bitbadges.io)

**Web App**

{% embed url="https://bitbadges.io" %}

**Testnet**

Node ID: 745b694aeef8c2e831ed6ec65060230a91f17914

Hosted At: http://138.197.10.8:(1317 | 26657)


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/README.md

# 📩 Cosmos SDK Msgs

**What are Cosmos SDK Msgs? Msgs vs Transactions?**

In Cosmos SDK, Msgs are messages that represent actions to be executed on the blockchain, such as sending tokens.

Each transaction must consist of one or Msgs to be executed. Transactions also consist of other accompanying details such as the signature info.

**What Msgs does the BitBadges blockchain implement?**

The BitBadges blockchain utilizes various pre-written modules from the Cosmos SDK (auth, authz, genutil, bank, capability, staking, distr, gov, params, crisis, slashing, feegrant, group, wasm, ibc, upgrade, evidence, transfer, ica, vesting). The documentation for the pre-written modules can be found [here](https://docs.cosmos.network/main/modules).

The x/badges module is the core functionality of BitBadges written by us, and within this module, all the Msg types that correspond to badges are defined. We also use an x/wasmx module which helps to create compatible smart contracts (forked from Injective). The x/maps allows storing data in a structured format with many customization options for the map. The x/anchor alllows for storing unstructured data.

**How to broadcast transactions with Msgs?**

You can generate and submit your transactions (Msgs) via:

* [BitBadges SDK](../create-and-broadcast-txs/): Generate and broadcast transactions to a running node with TypeScript. See [tutorials](../create-and-broadcast-txs/). This is the recommended option.
* CLI: Run your own node and interact with the command line
* Other: [https://docs.cosmos.network/main/user/run-node/txs#using-rest](https://docs.cosmos.network/main/user/run-node/txs#using-rest)

**What is the creator field?**

The **creator** field for each message should be the transaction signer's BitBadges address.

## Msg Definitions

Below, we link the documentation for the Msgs from our x/badges and x/wasmx module.

**x/badges**

* [MsgCreateCollection](https://bitbadges.github.io/bitbadgesjs/classes/MsgCreateCollection.html) - Creates a new collection. For creation transactions, everything is considered "free" (no permission restrictions). For following update transactions, everything must follow the permissions set.
* [MsgUpdateCollection](https://bitbadges.github.io/bitbadgesjs/classes/MsgUpdateCollection.html) - Updates the details of a collection. Must be manager of the corresponding collection to execute and all updates must follow the permissions set.
* [MsgUniversalUpdateCollection](https://bitbadges.github.io/bitbadgesjs/classes/MsgUniversalUpdateCollection.html) - This is a universal all-in-one message that supports everything from both MsgCreateCollection and MsgUpdateCollection. If collectionId == 0, we treat it as a create transaction. If collectionId > 0, we update the corresponding collection.
  * Mainly used for legacy purposes. To avoid confusion, we recommend using MsgCreate or MsgUpdate because those will be typed correctly for your use case.
* [MsgTransferBadges](https://bitbadges.github.io/bitbadgesjs/classes/MsgTransferBadges.html) - Transfer badges between users, if approvals allow.
* [MsgUpdateUserApprov](https://bitbadges.github.io/bitbadgesjs/classes/MsgUpdateUserApprovals.html)[als](https://bitbadges.github.io/bitbadgesjs/classes/MsgUpdateUserApprovals.html) - Set incoming / outgoing approvals for a collection, in addition to permissions which define the updatability of the approvals.
* [MsgDeleteCollection](https://bitbadges.github.io/bitbadgesjs/classes/MsgDeleteCollection.html) - Deletes the collection, if permissions allow. Must be manager.
* [MsgCreateAddressLists](https://bitbadges.github.io/bitbadgesjs/classes/MsgCreateAddressLists.html) - Creates address list(s).

**x/wasmx**

* [MsgExecuteContractCompat](https://bitbadges.github.io/bitbadgesjs/classes/MsgExecuteContractCompat.html) - Helper Msg to support executing contracts from Ethereum wallets for EIP712. See [here](broken-reference) for tutorial.

**x/maps**

* MsgCreateMap - Creates a map, uniquely identifed by an ID
* MsgUpdateMap - Updates an existing map.
* MsgDeleteMap - Deletes a map
* MsgSetValue - Allows a user to specify a (key, value) pair if permissions allow.

**x/anchor**

* MsgAddCustomData - Add custom data to the blockchain. No structure to the data at all (just a string). Will return a location for where to find your data.

**Other Cosmos SDK Modules**

For other standard Cosmos SDK messages, you can check out the bitbadges SDK documentation (such as [MsgSend](https://bitbadges.github.io/bitbadgesjs/classes/MsgSend.html) here). Or, check the official Cosmos documentation as these were written by them!


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/cosmos-native-msgs.md

# Cosmos Native Msgs

We refer you to Cosmos SDK documentation for other Cosmos native Msgs.


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/msgsend.md

# MsgSend

MsgSend is the Msg to send $BADGE. It is a core Cosmos SDK msg (i.e. not written by BitBadges), o we refer you to their documentation for more information.

```typescript
/**
 * MsgSend represents a message to send coins from one account to another.
 *
 * @typedef {Object} MsgSend
 * @property {string} fromAddress - The sender of the transaction.
 * @property {string} toAddress - The recipient of the transaction.
 * @property {CosmosCoin[]} amount - The amount of coins to send.
 */
export interface MsgSend<T extends NumberType> {
  fromAddress: string
  toAddress: string
  amount: CosmosCoin<T>[]
}


/**
 * Type for Cosmos SDK Coin information with support for bigint amounts (e.g. { amount: 1000000, denom: 'ubadge' }).
 *
 * @typedef {Object} CosmosCoin
 * @property {NumberType} amount - The amount of the coin.
 * @property {string} denom - The denomination of the coin.
 */
export interface CosmosCoin<T extends NumberType> {
  amount: T,
  denom: string,
}

```

```json
{
  "fromAddress": "bb1pa6p7nsqg57yqv23khnu5dumfhycr459jjnzsg",
  "toAddress": "bb1uy4my3dwzwv9drgq06pt433z742l9vrlsm053p",
  "amount": [
    {
      "denom": "ubadge",
      "amount": "1"
    }
  ]
}
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-anchor/README.md

# x/anchor



## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-anchor/msgaddcustomdata.md

# MsgAddCustomData

MsgAddCustomData is a part of the x/anchor module which allows you to anchor any custom data to the blockchain. The blcokchain will store with an incrementing location ID along with the timestamp. This can be used to prove knowledge of something at a specific time by anchoring it to the chain.

```protobuf
message MsgAddCustomData {
  string creator = 1;
  string data    = 2;
}
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-badges/README.md

# x/badges

See the x/badges documentation below the For Developers section.

{% content-ref url="broken-reference" %}
[Broken link](broken-reference)
{% endcontent-ref %}


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/README.md

# x/maps



## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgcreateprotocol.md

# MsgCreateMap

MsgCreateMap creates a map on-chain. We refer you to here for more information on each individual field.

{% content-ref url="../../../core-concepts/maps.md" %}
[maps.md](../../../core-concepts/maps.md)
{% endcontent-ref %}

```typescript
export interface iMsgCreateMap<T extends NumberType> {
  creator: string;
  mapId: string;

  inheritManagerTimelineFrom: T;
  managerTimeline: iManagerTimeline<T>[];

  updateCriteria: iMapUpdateCriteria<T>;
  valueOptions: iValueOptions;
  defaultValue: string;

  metadataTimeline: iMapMetadataTimeline<T>[];

  permissions: iMapPermissions<T>;
}
```

```typescript
export interface iValueOptions {
  noDuplicates: boolean;
  permanentOnceSet: boolean;
  expectUint: boolean;
  expectBoolean: boolean;
  expectAddress: boolean;
  expectUri: boolean;
}
```

```typescript
export interface iMapPermissions<T extends NumberType> {
  canUpdateMetadata: iTimedUpdatePermission<T>[];
  canUpdateManager: iTimedUpdatePermission<T>[];
  canDeleteMap: iActionPermission<T>[];
}
```

```typescript
export interface iMapMetadataTimeline<T extends NumberType> {
  timelineTimes: iUintRange<T>[];
  metadata: iCollectionMetadata;
}
```

```typescript
export interface iMapUpdateCriteria<T extends NumberType> {
  managerOnly: boolean;
  collectionId: T;
  creatorOnly: boolean;
  firstComeFirstServe: boolean;
}
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgdeleteprotocol.md

# MsgDeleteMap

MsgDeleteProtocol deletes the map with the given name.

<pre class="language-typescript"><code class="lang-typescript"><a data-footnote-ref href="#user-content-fn-1">export</a> interface MsgDeleteMap {
  creator: string,
  mapId: string,
}
</code></pre>

[^1]: 


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgsetcollectionforprotocol.md

# MsgSetValue

MsgSetValue sets the specific key-value pair for the mapId. For example, set my BitBadges Follow Protocol collection to collection ID 12.&#x20;

All values are stringified for comaptibility, but it will check they are in proper format within the Msg logic. You can set **options.useMostRecentCollectionId** to auto-fetch the latest collection ID. This can be leveraged in multi-msg transactions where you want to create a collection and set the ID to the just created collection. Typically, you do not know the collection ID until after the collection is created which is why this feature is useful. See below

```typescript
export interface iMsgSetValue {
  creator: string;
  mapId: string;
  key: string;
  value: string;
  options: iSetOptions;
}

export interface iSetOptions {
  useMostRecentCollectionId: boolean;
}
```

**Combining with MsgCreateCollection or MsgUpdateCollection**

The two Msgs can be easily combined in the same transaction (as Cosmos transactions support multiple Msgs). See [here](broken-reference) for an example of how to do it with the SDK. Just make sure MsgCreateCollection is executed first and precedes when it is actually used.

```typescript
const msgs: MessageGenerated[] = [];
msgs.push(...bootstrapCollections().map(x => createProtoMsg(x))) //MsgCreateCollections
msgs.push(...bootstrapSetProtocols().map(x => createProtoMsg(x))); //MsgSetCollectionForProtocol

//Note how MsgCreateAddressLists is first in the array
const txn = createTransactionPayload(txContext, msgs);
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-maps/msgupdateprotocol.md

# MsgUpdateMap

MsgUpdateMap updates the map with the matching ID. Similar to the x/badges Msgs, we use an update flag + value interface. If update flag = true, we update with the corresponding value. Else, we ignore it.

```typescript
export interface iMsgUpdateMap<T extends NumberType> {
  creator: string;
  mapId: string;

  updateManagerTimeline: boolean;
  managerTimeline: iManagerTimeline<T>[];

  updateMetadataTimeline: boolean;
  metadataTimeline: iMapMetadataTimeline<T>[];

  updatePermissions: boolean;
  permissions: iMapPermissions<T>;
}
```


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/README.md

# x/wasmx



## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msgexecutecontractcompat.md

# MsgExecuteContractCompat



```typescript
/**
 * MsgExecuteContractCompat defines a ExecuteContractCompat message.
 *
 * @typedef {Object} MsgExecuteContractCompat
 * @property {string} sender - The sender of the transaction.
 * @property {string} contract - The contract address to execute.
 * @property {string} msg - The message to pass to the contract. Must be a valid JSON string.
 * @property {string} funds - The funds to send to the contract. Must be a valid JSON string.
 */
export interface MsgExecuteContractCompat {
  sender: string
  contract: string
  msg: string
  funds: string
}
```

MsgExecuteContractCompat is a wrapper for CosmWASM's MsgExecuteContract that is compatible with all signing methods for BitBadges users. See [Create a Smart Contract](broken-reference) tutorial for more information.


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msginstantiatecontractcompat.md

# MsgInstantiateContractCompat

```typescript
export interface MsgInstantiateContractCompat {
  sender: string
  codeId: string
  label: string
  funds: string
}
```

MsgInstantiateContractCompat is a wrapper for CosmWASM's MsgInstantiateContract that is compatible with all signing methods for BitBadges users. See [Create a Smart Contract](broken-reference) tutorial for more information.


## File: ./for-developers/bitbadges-blockchain/cosmos-sdk-msgs/x-wasmx/msgstorecodecompat.md

# MsgStoreCodeCompat

```typescript
export interface MsgStoreCodeCompat {
  sender: string
  hexWasmByteCode: string
}
```

MsgStoreCompat is a wrapper for CosmWASM's MsgStoreCode that is compatible with all signing methods for BitBadges users. See [Create a Smart Contract](broken-reference) tutorial for more information.


## File: ./for-developers/bitbadges-blockchain/create-a-wasm-contract.md

# Create a WASM Contract

BitBadges support CosmWASM smart contracts to allow you to extend the token interface for custom functionality as desired. If you do need to extend the interface with unsupported functionality but you think it would be a good fit to be added natively, please let us know. Our end goal is that no smart contracts are ever needed, and everything is supported natively!

We refer you to official CosmWASM and Rust documentation for more information. This tutorial will only focus on BItBadges specific information.

{% embed url="https://cosmwasm.cosmos.network/" %}

```go.mod
github.com/CosmWasm/wasmd v0.52.0
```

**Permissioned Uploads**

```
BitBadges implements CosmWASM in a permissioned manner. 
```

Instantiating and officially deploying a contract does require a review process and governance approval. Reach out for more information.

Requirements:

* No avoidance of the protocol fee. Any badge transfers that take place must use MsgTransferBadges, or if you need to implement transfer functionality directly in the contract, the protocol fee must be obeyed.
* We encourage audits and a peer review process before officailly deploying.
* You must also showcase a working testnet implementation as well (testnet is permissionless)

Generally speaking, even though this is a permissioned implementation, we want the contract layer to be as permissionless as possible. We just have to enforce that our business model (protocol fee) is obeyed.

**High-Level Development Overview**

```rust
const msgExecuteContract: MsgExecuteContractCompat = {
    sender: 'bb1uqxan5ch2ulhkjrgmre90rr923932w38gwez5d', 
    contract:
        'bb14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sc8kg9e', 
    msg: '{"myCustomMsg1": {"collectionId": "1"}}',
    funds: '1ubadge',
};
```

* Each contract has a Cosmos bech32 contract address (e.g. bb14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sc8kg9e).
* 3-Step Process: Upload / Store Code, Instantiate, Execute
  * Instantiating requires governance proposal (see below)
* Contracts can call into the core x/badges module as submessages (delayed until directly after the contract)
  * When calling into x/badges, msg.Creator will ALWAYS be the contract address. You may need to come up with creative workarounds or creative solutions in certain situations.
* The main execution part of every contract is ExecuteMsg. Think of this like the API definition for your contract. You can have multiple message types with different logic.

```rust
//contract.rs
use bitbadges_cosmwasm::{
  transfer_badges_msg
};

#[entry_point]
pub fn execute(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response<BitBadgesMsg>, StdError> {
    match msg {
        ExecuteMsg::CustomMsg1 { collection_id, transfers } => {
          let msg = transfer_badges_msg(collection_id, transfers);
          Ok(Response::new().add_submessage(SubMsg::reply_always(msg, BADGES_REPLY_ID)))
        }
        ExecuteMsg::CustomMsg2 { collection_id, transfers } => {
          let msg = transfer_badges_msg(collection_id, transfers);
          Ok(Response::new().add_submessage(SubMsg::reply_always(msg, BADGES_REPLY_ID)))
        }
        // Add other messages here as needed
    }
}
```

### **Create a Contract Tutorial**

1. Clone the BitBadges Cosmwasm repository

```
git clone https://github.com/BitBadges/bitbadges-cosmwasm-bindings.git
cd bitbadges-cosmwasm-bindings
```

This repository exports all the custom bindings via `packages/bitbadges-cosmwasm`. You should typically NOT edit the exported types. These are already pregenerated exactly as defined on-chain for you to use.

2. Create your contract

You will be dealing with the `contracts` folder.  This is where you implement your contract logic. The `contracts` folder is automatically configured to import from the local `packages/bitbadges-cosmwasm.` We have provided an example and boilerplate for you.

Tools at your disposal:

```rust
// All BitBadges type bindings
use bitbadges_cosmwasm::{
  Transfer, Balance, ....
};
```

<pre class="language-rust"><code class="lang-rust">// BitBadges *_msg() functions
// This is how you call into x/badges by adding Ok(Response::new().add_message(msg))
use bitbadges_cosmwasm::{
  transfer_badges_msg, delete_collection_msg, BitBadgesMsg
}
<strong>
</strong><strong>pub fn execute_my_msg(
</strong>    collection_id: String,
    transfers: Vec&#x3C;Transfer>,
) -> StdResult&#x3C;Response&#x3C;BitBadgesMsg>> {
    let msg = transfer_badges_msg(
        collection_id,
        transfers,
    );

    Ok(Response::new().add_message(msg))
}

#[entry_point]
pub fn execute(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: ExecuteMsg,
) -> Result&#x3C;Response&#x3C;BitBadgesMsg>, StdError> {
    match msg {
        ExecuteMsg::MyCustomMsg { collection_id, transfers } => {
          execute_my_msg(collection_id, transfers)
        }
        // Add other messages here as needed
    }
}
</code></pre>

3. Build and Optimize

You may have to edit the script for you file names and paths. Consider also using an optimizer like   [https://github.com/CosmWasm/rust-optimizer](https://github.com/CosmWasm/rust-optimizer).

```bash
cargo build
source ./build.sh # outputs a .wasm
gzip youcontractname.wasm # outputs a .wasm.gz
```

```bash
# build.sh
RUSTFLAGS='-C link-arg=-s' cargo wasm
cp ../../target/wasm32-unknown-unknown/release/YOUR_CONTRACT_NAME.wasm .
```

4. Uploading Your Contract

Go to [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast) and select MsgStoreCode. Upload your .wasm.gz file. Submit the transaction. &#x20;

For testnet uploads, use testnet.bitbadges.io

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

5. Instantiate your Contract

A notification from Step 4 should pop up with your code ID, assuming the transaction was successful.

Refresh the page or clear all Msgs and start a new transaction. Now, select MsgInstantiateContractCompat. Set a label (name for your contract) and enter the code ID from step 3. Submit the transaction.

If you want to instantiate it with funds. the **funds** property will be in the format "1badge".

A notification should pop up with your contract's address. Store this somewhere.

```
Note: This is only applicable to testnet. 

For mainnet, instantiation requires a governance proposal. Reach out to us to start this process.
```

6. Interact with the Contract

Once deployed, you need to to let your users interact with it. Use our custom x/wasmx MsgExecuteContractCompat to do so. This is a wrapper around the core x/wasm MsgExecuteContract with support for BitBadges signing. This is the same as broadcasting any other transaction, so we refer you to Creating, Signing, and Broadcasting Txs for a tutorial.

Couple common misunderstandings:

* Note msg is an encoded stringified JSON. Be mindful of single vs double quotes and escaped characters.
*   Note camelCase vs snake\_case. Contracts typically auto-format with camelCase via&#x20;

    ```rust
    #[serde(rename_all = "camelCase")]
    ```
* Parsing may not be smart enough to identify empty values like empty arrays. You may have to manually specify empty strings, arrays for compatibility.

**Examples**

```typescript
const msgExecuteContract: MsgExecuteContractCompat = {
    sender: 'bb1uqxan5ch2ulhkjrgmre90rr923932w38gwez5d', //enter sender adress here
    contract:
        'bb14hj2tavq8fpesdwxxcu44rty3hh90vhujrvcmstl4zr3txmfvw9sc8kg9e', //
    msg: '{"deleteCollectionMsg": {"collectionId": "1"}}',
    funds: '1badge',
};
```


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/README.md

# 🔃 Create, Generate, and Sign Txs

To learn more about broadcasting transactions with Cosmos SDK, you can visit [https://docs.cosmos.network/v0.46/run-node/txs.html](https://docs.cosmos.network/v0.46/run-node/txs.html).

We recommend generating, signing, and broadcasting your transactions with the [BitBadges SDK](../../bitbadges-sdk/). The SDK provides easy-to-use TypeScript functions to construct transactions of all types and broadcast them to a blockchain node.&#x20;

You can also run the BitBadges blockchain software and interact with its CLI, but this is more complicated and only supports Cosmos signatures.


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/broadcast-to-a-node.md

# Broadcast to a Node

**Pre-Req:** You have the body variable with a valid signature (see prior pages).

### **Simulating**

A good practice to have is to simulate the transaction before you actually broadcast and update the **fee** from the transaction context with up to date values.&#x20;

To do this, you can use&#x20;

```
https://api.bitbadges.io/api/v0/simulate
```

**or**

```typescript
http://URL:1317/cosmos/tx/v1beta1/simulate
```

This will return the gas used on a dry run of the transaction and any errors if it finds any. You can leave all signature fields empty because simulations do not check any signatures.

Note this tutorial is slightly out of order for clarity, the simulation step should typically be done before the user signs, so they only have to sign the final Msg with the up to date gas.

Once simulated, replace the expected gas you want in the transaction context.

```typescript
export interface SimulateTxRouteSuccessResponse<T extends NumberType> {
    gas_info: {
        gas_used: string;
        gas_wanted: string;
    };
    result: {
        data: string;
        log: string;
        events: {
            type: string;
            attributes: {
                key: string;
                value: string;
                index: boolean;
            }[];
        }[];
        msg_responses: any[];
    };
}
```

### **Broadcasting**

You can replace the URL below with any valid BitBadges blockchain node.

```typescript
`http://URL:1317${generateEndpointBroadcast()}`;
```

Or, you can use the BitBadges API to broadcast.

```typescript
https://api.bitbadges.io/api/v0/broadcast
```

<pre class="language-typescript"><code class="lang-typescript"><strong>await BitBadgesApi.broadcastTx(body);
</strong></code></pre>

This will give you a response immediately. You should then use the tx_response.txhash to view it on an explorer, query the blockchain directly, see if it had errors, and so on. The response code should be 0 for a successful transaction. We refer you to Cosmos docs for more information about each indivdual item.

```typescript
export interface BroadcastTxRouteSuccessResponse<T extends NumberType> {
    tx_response: {
        code: number;
        codespace: string;
        data: string;
        events: {
            type: string;
            attributes: {
                key: string;
                value: string;
                index: boolean;
            }[];
        }[];
        gas_wanted: string;
        gas_used: string;
        height: string;
        info: string;
        logs: {
            events: {
                type: string;
                attributes: {
                    key: string;
                    value: string;
                    index: boolean;
                }[];
            }[];
        }[];
        raw_log: string;
        timestamp: string;
        tx: object | null;
        txhash: string;
    };
}
```

### Polling

Once you have the tx hash, you can poll a node until the transaction is confirmed like below. Note this is a blockchain REST API_URL, not the BitBadges API. You can also view it on explorers.

Use [https://lcd.bitbadges.io](https://lcd.bitbadges.io) for the BitBadges maintained node.

```typescript
const txHash = res.data.tx_response.txhash;
const code = res.data.tx_response.code;
if (code !== undefined && code !== 0) {
    throw new Error(
        `Error broadcasting transaction: Code ${code}: ${JSON.stringify(
            res.data.tx_response,
            null,
            2
        )}`
    );
}

let fetched = false;
while (!fetched) {
    try {
        const res = await axios.get(
            `${process.env.API_URL}/cosmos/tx/v1beta1/txs/${txHash}`
        );
        fetched = true;

        return res;
    } catch (e) {
        // wait 1 sec
        console.log('Waiting 1 sec to fetch tx');
        await new Promise((resolve) => setTimeout(resolve, 1000));
    }
}

return res;
```


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/ex-run-an-ai-agent.md

# Run an AI Agent

{% @github-files/github-code-block url="https://github.com/BitBadges/bitbadges-ai" %}

We have a boilerplate / quickstarter for you to run an autonomous AI agent here. Please read the README for all details.

This implements all of the signing functionality for a managed Ethereum address (the agent's address). You can interact with it through a chatbot interface, or you can extend / customize for more functionality. This is a recommended place to start if you are just experimenting.


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/generate-msg-contents.md

# Generate Msg Contents

The first step is to know what Msg type you are trying to submit and build out the contents of the Msgs in the transaction.&#x20;

If you plan to use [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast), the transaction building is already handled for you behind the scenes. The only applicable section below is Building the Msgs. This site is also a good reference if you want to explore the different types of messages.

### **Building the Msgs**

You can build out the transaction from the exported Proto type definitions. This allows you to create transactions with multiple Msg types in one tx. It also supports all Msgs for the BitBadges blockchain (even standard Cosmos SDK ones). Note that certain NumberTypes may need to be stringified before creating a proto object.

See [https://github.com/BitBadges/bitbadgesjs/tree/main/packages/bitbadgesjs-sdk/src/proto](https://github.com/BitBadges/bitbadgesjs/tree/main/packages/bitbadgesjs-sdk/src/proto) for all proto Msg definitions.

```typescript
import { proto } from 'bitbadgesjs-sdk';

//proto.cosmos.module for standard Cosmos
//proto.badges for BitBadges x/badges
//proto.wasmx for BitBadges x/wasmx
//proto.protocols for BitBadges x/protocols
const ProtoMsgDeleteCollection = proto.badges.MsgDeleteCollection;

const protoMsgs = [
    new ProtoMsgDeleteCollection({ collectionId: '1', creator: 'bb...' }),
    //Add more here (executed in order)
];
```

### Building the Transaction

```typescript
const txContext = { ... } //See prior page

const txnPayload = createTransactionPayload(txContext, protoMsgs);
```

The outputted payload will be in the following format.

For Cosmos, you will use signDIrect.

For Ethereum/Solana/Bitcoin, you will use txnString.

If you stringify txnJSON and SHA256 it, you will get the content hash from the txnString.

```typescript
export interface TransactionPayload {
    legacyAmino: {
        body: TxBody;
        authInfo: AuthInfo;
        signBytes: string;
    };
    signDirect: {
        body: TxBody;
        authInfo: AuthInfo;
        signBytes: string;
    };
    txnString: string;
    txnJson: Record<string, any>;
}
```

### Next Steps

Once you have the generated transaction, you now need to determine how you want to sign and broadcast your transaction. You have two options:

1. Use [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast) - This is a visual UI that you can simply copy and paste your Msgs into. You can get the JSON string for each message with protoMsg.toJsonString(). Generating all additional transaction details, gas, fees, and signing is all outsourced to the user interface. This is the recommended option if you do not require programmatically submitting TXs. Navigate to [Sign + Broadcast - bitbadges.io](sign-+-broadcast-bitbadges.io.md) if this is your desired option.
2. Generate, sign, and broadcast directly to a running blockchain node. This is more technical and has more steps but can be done programmatically. Navigate to the corresponding Signing page if this is your desired option ([Signing - Cosmos](signing-cosmos.md), [Signing - Ethereum](signing-ethereum.md), [Signing - Solana](signing-solana.md), [Signing - Bitcoin](signing-bitcoin.md)).


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/sign-+-broadcast-bitbadges.io.md

# Sign + Broadcast - bitbadges.io

**Option 1: Copy / Paste**

To broadcast a Msg using this [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast) user interface, all you have to do is to copy and paste the Msg contents into the text box. You should have the **txn** object from prior pages in this tutorial. Or, you can start with the samples provided and customize from there.

**Option 2: Redirect**

Or, if you are wanting to redirect to this page, you can pass in the stringified URL **txsInfo** query param, which will be auto-populated. It is expected to be a JSON stringified TxInfo\[].

```typescript
export interface TxInfo {
  type: string, //'MsgCreateCollection'
  msg: object, //JSON stringified message
}
```

This transaction builder ONLY deals with the Msg contents and not anything about the transaction context (handled by the site behind the scenes). The interface will provide you with default examples. Make sure all properties align and no extra properties like account\_number, sequence, etc are pasted. These are handled behind the scenes.

If you open via a popup, such as below, it will pass back the txHash via a window callback and auto-close upon success.

```typescript
import { proto } from 'bitbadgesjs-sdk';

const MsgCreateProtocol = proto.protocols.MsgCreateProtocol;
const msgCreateProtocol = new MsgCreateProtocol({
  "name": "Test",
  "uri": "https://www.youtube.com/watch?v=5qap5aO4i9A",
  "customData": "Test",
  "isFrozen": false,
  "creator": chain.bitbadgesAddress
})
const url = 'https://bitbadges.io/dev/broadcast?txsInfo=[{ "type": "MsgCreateProtocol", "msg": ' + msgCreateProtocol.toJsonString() + ' }]';
const openedWindow = window.open(url, '_blank', 'location=yes,height=570,width=520,scrollbars=yes,status=yes');

setLoading(true);
// You can further customize the child window as needed
openedWindow?.focus();

//set listener for when the child window closes
const timer = setInterval(() => {
  if (openedWindow?.closed) {
    clearInterval(timer);
    setLoading(false);
  }
}, 1000);
```

<pre class="language-typescript"><code class="lang-typescript"><strong>// bitbadges.io code
</strong><strong>if (window.opener) {
</strong>    window.opener.postMessage({ type: 'txSuccess', txHash: txHash }, '*');
    window.close();
}
</code></pre>

```typescript
//https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage
const FRONTEND_URL = 'https://bitbadges.io';
const handleChildWindowMessage = async (event: MessageEvent) => {

  if (event.origin === FRONTEND_URL) {

    if (!event.source) {
      throw new Error('Event source is null');
    }

    const txHash = event.data.txHash;
    if (!txHash) {
      //To avoid the listening to self events if we are actually on bitbadges.io and just an overall quality check
      return
    }


    setLoading(false);
  }
};

// Add a listener to handle messages from the child window
useEffect(() => {
  window.addEventListener('message', handleChildWindowMessage);

  // Cleanup the listener when the component unmounts
  return () => {
    window.removeEventListener('message', handleChildWindowMessage);
  };
}, []);
```

<figure><img src="../../../.gitbook/assets/image (7) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-bitcoin.md

# Signing - Bitcoin

**Signing with Bitcoin - Phantom Wallet**

Using the payload / context obtained from previous steps. We use the **jsonToSign** field and sign it as a personal signMessage using phantom wallet.

```typescript
const getProvider = () => {
  if ('phantom' in window) {
    const phantomWindow = window as any;
    const provider = phantomWindow.phantom?.bitcoin;
    if (provider?.isPhantom) {
      return provider;
    }

    window.open('https://phantom.app/', '_blank');
  }
};

function bytesToBase64(bytes: Uint8Array) {
  const binString = String.fromCodePoint(...bytes);
  return btoa(binString);
}

const signTxn = async (context: ExternalTxContext, payload: TransactionPayload, messages: any[], simulate: boolean) => {
    const bitcoinProvider = getProvider();

    let sig = '';
    if (!simulate) {
      const message = payload.txnString;
      const encodedMessage = new TextEncoder().encode(message);
      const signedMessage = await bitcoinProvider.signMessage(address, encodedMessage);

      const base64Sig = bytesToBase64(signedMessage.signature);
      sig = Buffer.from(base64Sig, 'base64').toString('hex');
    }

    const txBody = createTxBroadcastBody(context, messages, sig);
    return txBody;
};
```

## Output

This will leave you with a variable which is to be submitted to a running blockchain node. See [Broadcast to a Node.](broadcast-to-a-node.md)


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-cosmos.md

# Signing - Cosmos

Pre-Requisite: You have generated the transaction context, payload, and Msgs (see prior pages).

#### Signing with Keplr

```ts
const signTxn = async (
    context: TxContext,
    payload: TransactionPayload,
    protoMsgs: any[],
    simulate: boolean
) => {
    if (!account) {
        throw new Error('Account does not exist');
    }
    const { sender } = context;
    await window.keplr?.enable(chainId);

    let signatures = [new Uint8Array(Buffer.from('0x', 'hex'))];
    if (!simulate) {
        const signResponse = await window?.keplr?.signDirect(
            chainId,
            sender.address,
            {
                bodyBytes: payload.signDirect.body.toBinary(),
                authInfoBytes: payload.signDirect.authInfo.toBinary(),
                chainId: chainId,
                accountNumber: new Long(sender.accountNumber),
            },
            {
                preferNoSetFee: true,
            }
        );

        if (!signResponse) {
            throw new Error('No signature returned from Keplr');
        }

        signatures = [
            new Uint8Array(
                Buffer.from(signResponse.signature.signature, 'base64')
            ),
        ];
    }

    const hexSig = Buffer.from(signatures[0]).toString('hex');

    const txBody = createTxBroadcastBody(context, protoMsgs, hexSig);
    return txBody;
};
```

### Output

This will leave you with a variable which is to be submitted to a running blockchain node. See [Broadcast to a Node.](broadcast-to-a-node.md)


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-ethereum.md

# Signing - Ethereum

Pre-Requisite: You have generated the transaction context, payload, and Msgs (see prior pages).

You can simply sign the **payload.txnString** with a personal\_sign. below, we use wasgmi's signMessageAsync but you can replace this with any wallet's implementation of personal\_sign.

```typescript
const signTxn = async (context: ExternalTxContext, payload: TransactionPayload, messages: any[], simulate: boolean) => {
  const sig = simulate
    ? ''
    : await signMessageAsync({
        message: payload.txnString
      });
 
  const txBody = createTxBroadcastBody(context, messages, sig);
  return txBody;
};
```

## Output

This will leave you with a variable which is to be submitted to a running blockchain node. See [Broadcast to a Node.](broadcast-to-a-node.md)


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/signing-solana.md

# Signing - Solana

Pre-Requisite: You have generated the transaction context, payload, and Msgs (see prior pages).

**Signing with Solana - Phantom Wallet**



Phantom / Solana do not allow message signatures > \~1000 bytes. To workaround this, we allow signing the SHA256 hash of the JSON in cases where payload.jsonToSign.length > 1000.

```typescript
const getProvider = () => {
    if ('phantom' in window) {
        const phantomWindow = window as any;
        const provider = phantomWindow.phantom?.solana;
        if (provider?.isPhantom) {
            return provider;
        }

        window.open('https://phantom.app/', '_blank');
    }
};

const signTxn = async (context: ExternalTxContext, payload: TransactionPayload, messages: any[], simulate: boolean) => {
  if (!account) throw new Error('Account not found.');

  let sig = '';
  if (!simulate) {
    //Phantom has a weird error where messages must be < ~1000 bytes
    //If we are within limit, we can have user sign the JSON
    //Else, we hash the JSON and have user sign the hash
    const encodedMessage = new TextEncoder().encode(payload.txnString);

    const signedMessage = await getProvider().request({
      method: 'signMessage',
      params: {
        message: encodedMessage,
        display: 'utf8'
      }
    });
    sig = signedMessage.signature.toString('hex');
  }

  //We need to pass in solAddress manually here
  const txBody = createTxBroadcastBody(context, messages, sig, address);
  return txBody;
};
```

## Output

This will leave you with a variable which is to be submitted to a running blockchain node. See [Broadcast to a Node.](broadcast-to-a-node.md)


## File: ./for-developers/bitbadges-blockchain/create-and-broadcast-txs/transaction-context.md

# Transaction Context

You have two options for generating, signing, and brodcasting messages.

1. Use [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast) - This is a visual UI that you can simply copy and paste your transaction Msg contents into or provide them in the URL parameters. Generating all additional transaction details, gas, fees, and signing is all outsourced to the user interface. This is the recommended option if you do not require programmatically submitting TXs.
2. Generate, sign, and broadcast directly to a running blockchain node. This is more technical and has more steps but can be done programmatically.

If you plan to use Option 1, you may proceed to the next page because generating the transaction context is already handled via the user interface.

If you plan to use option 2, see below.

### Generating Transaction Context

The first step is to fetch and identify the transaction context and the account details for who is going to sign. You will need the following information below.

Pre-Reqs: For a user who has not yet interacted with the blockchain, the fetched public key will be null and accountNumber will be -1. To get an account number, they need to receive $BADGE somehow (this is also a pre-requisite to pay for any fees).

```typescript
import { createTxMsgSend, SupportedChain } from 'bitbadgesjs-sdk'

//TODO: Fetch the account details (see below)

//Pre-Reqs: Ensure users are registered (i.e. have a valid account number) or else this will fail
const txContext = {
  testnet: false,
  sender: {
    //Must be in native format ('0xabc..' vs 'bc1...' etc)
    address: account.address,
    sequence: account.sequence,
    accountNumber: account.accountNumber,
    //Public key is only needed for Cosmos native signatures (see below). '' if non-Cosmos
    publicKey: account.publicKey
  }, 
  //TODO: adjust accordingly
  fee: {
    amount: `0`,
    denom: 'ubadge',
    gas: `400000`
  },
  memo: ''
};
```

**Get Public Key - Cosmos**

For Keplr / Cosmos, you will need to specify the public key in the txContext. You can simply use getKey() then convert to base64.

Note: It will also be returned with the account details from the BitBadges API (if the user has interacted with the chain before via a signature).

```typescript
const getPublicKey = async () => {
    const account = await window?.keplr?.getKey('bitbadges-1')
    if (!account) return '';
    return Buffer.from(account.pubKey).toString('base64')
}
```

**Fee**

Generating the fee can be tricky. It should be reasonable for the current gas prices but also not too expensive. To get the **gas**, we recommend simulating the transaction right before broadcasting to see how much gas it uses on a dry run. We will walk you through how to do this in the broadcast tutorial. You can also fetch the estimated gas prices via the BitBadgesApi.getStatus() route.

**Sender Details**

To fetch a user's account details, the easiest way is to use the routes from the BitBadges API in [Users](../../create-and-broadcast-txs/broken-reference/). You can also query a node directly.

This will return the user's BitBadges address, account ID, sequence (nonce), and public key. If the user has previously interacted with the blockchain, all this information will already be populated.

<figure><img src="../../../.gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/bitbadges-blockchain/overview.md

# Overview

BitBadges offers an L1 delegated proof-of-stake blockchain built with [Cosmos SDK](https://docs.cosmos.network/main). The blockchain is able to attain instant transaction finality using Tendermint and natively supports users from multiple Layer 1 blockchains (Ethereum, Bitcoin, Cosmos, Solana) via IBC and account lists.

The source code can be found at [https://github.com/bitbadges/bitbadgeschain](https://github.com/bitbadges/bitbadgeschain). The blockchain supports the Inter-Blockchain Communication Protocol (IBC) and CosmWASM.


## File: ./for-developers/bitbadges-blockchain/run-a-node/README.md

# Run a Node

In this guide, we will provide detailed instructions for setting up and running a BitBadges blockchain node. This should not be used as a universal guide, as there are many methods and best practices that you can use. However, we will cover each step thoroughly and include examples to ensure a smooth setup.&#x20;

The BitBadges blockchain is built using the Cosmos SDK, so if you have prior experience running a Cosmos SDK blockchain node, you will find this process quite familiar. If you encounter any issues during the setup process, you can also refer to other Cosmos SDK node documentation, such as "[Cosmos SDK - Running a Node](https://docs.cosmos.network/main/user/run-node/run-node)" or "[Cosmos Tutorials - Run in Production documentation](https://tutorials.cosmos.network/tutorials/9-path-to-prod/1-overview.html)." These resources provide additional in-depth information and examples. Make sure that you replace everything with the corresponding BitBadges details where necessary.

**Becoming a Betanet Validator:** If you aspire to become a betanet validator, reach out to us to receive a tokens for staking.

**Chain IDs:** When a chain ID is required, use the following:

-   "bitbadges-1" for the mainnet chain ID
-   "bitbadges-2" for the testnet chain ID

**Genesis JSON:** See [https://github.com/bitbadges/bitbadgeschain](https://github.com/bitbadges/bitbadgeschain). Note different versions (testnets vs mainnet) will have different genesis JSONs.

**BitBadges Public RPCs:** https://node.bitbadges.io/rpc (alias of http://node.bitbadges.io:26657)&#x20;

Node ID (mainnet): 2703c1304a70186372aa726a762d60da94c29ffe

**Handling Upgrades:** BitBadges uses the x/upgrade module from Cosmos SDK for upgrades and expects upgrades to be handled with zero-dwontime using Cosmovisor.

**Discord:** Communications and announcements for node operators is facilitated via our Discord.


## File: ./for-developers/bitbadges-blockchain/run-a-node/cosmovisor.md

# Cosmovisor

**Installing Cosmovisor**

The first step is to download Cosmovisor as an executable using [their documentation](https://docs.cosmos.network/v0.50/build/tooling/cosmovisor). Below is the Dockerized way we do it.

```dockerfile
FROM --platform=linux golang:1.21 AS builder

ENV COSMOS_VERSION=v0.47.5
RUN apt-get update && apt-get install -y git curl
RUN apt-get install -y make wget

WORKDIR /root
RUN git clone --depth 1 --branch ${COSMOS_VERSION} https://github.com/cosmos/cosmos-sdk.git

WORKDIR /root/cosmos-sdk/tools/cosmovisor

RUN make cosmovisor
```

**Environment Variables**

You will then need to set the following environment variables. The DAEMON\_HOME will be the home of your config files.&#x20;

<pre class="language-docker"><code class="lang-docker"><strong>DAEMON_HOME=/root/.bitbadgeschain
</strong>DAEMON_NAME=bitbadgeschaind
</code></pre>

**Initializing Executables**

Then, run the following to setup your Cosmovisor directory. The executable should be named bitbadgeschaind (if not, please rename).

```bash
cosmosvisor init ./bitbadgeschaind
```

This will create the necessary folders and copy the executable into the DAEMON\_HOME/cosmovisor/genesis/bin.

IMPORTANT: Depending on your sync method (explained later), you will need to download all relevant executables. If you are syncing from genesis, you will need all executables to be able to sync to the current state. If you are syncing from a later time, you will only need the binaries used after that time. See Adding Upgrades below. You must repeat this process for all such executables.

**Adding Upgrades**

For a given upgrade, it will have a new binary and a \<upgrade-name>. \<upgrade-name> is the name used in the x/upgrade module when proposing a new software upgrade.

Depending on your version of cosmovisor, you may be able to run the following. Again, make sure the binary name is bitbadgeschaind.

```
cosmovisor add-upgrade ...
```

Or, to manually upgrade, do the following.

1. Download the new binary and name it bitbadgeschaind. Do this in a separate folder to not interfere with anything currently running.
2. Create the DAEMON\_HOME/cosmovisor/upgrades/\<upgrade-name> and DAEMON\_HOME/cosmovisor/upgrades/\<upgrade-name>/bin directory.
3. Copy the new upgrade executable to the folder (keeping its name as bitbadgeschaind).

```dockerfile
# upgrade name = abc123
RUN mkdir ${DAEMON_HOME}/cosmovisor/upgrades/abc123/
RUN mkdir ${DAEMON_HOME}/cosmovisor/upgrades/abc123/bin
RUN cp /path_to_executable ${DAEMON_HOME}/cosmovisor/upgrades/abc123/bin/bitbadgeschaind
```


## File: ./for-developers/bitbadges-blockchain/run-a-node/overview.md

# Overview

In this guide, we will provide detailed instructions for setting up and running a BitBadges blockchain node. This should not be used as a universal guide, as there are many methods and best practices that you can use. However, we will cover each step and include examples to ensure a smooth setup.

The BitBadges blockchain is built using the Cosmos SDK, so if you have prior experience running a Cosmos SDK blockchain node, you will find this process quite familiar. If you encounter any issues during the setup process, you can also refer to other Cosmos SDK node documentation, such as "[Cosmos SDK - Running a Node](https://docs.cosmos.network/main/user/run-node/run-node)" or "[Cosmos Tutorials - Run in Production documentation](https://tutorials.cosmos.network/tutorials/9-path-to-prod/1-overview.html)." These resources provide additional in-depth information and examples. Make sure that you replace everything with the corresponding BitBadges details where necessary.

**Becoming a Validator:** If you aspire to become a validator, reach out to us to receive a tokens for staking.

**Chain IDs:** When a chain ID is required, use the following:

-   "bitbadges-1" for the mainnet / betanet chain ID
-   "bitbadges-2" for the testnet chain ID

**Genesis JSON:** See [https://github.com/bitbadges/bitbadgeschain](https://github.com/bitbadges/bitbadgeschain). Note different versions (testnets vs betanet vs mainnet) will have different genesis JSONs.

**BitBadges Public RPCs:** https://rpc.bitbadges.io

Node ID (betanet): 3958a0e660599d8146e7f2a6da8d4df83561b0fc

**State Snapshots:** See [Chain Details](../chain-details.md)

**Handling Upgrades:** BitBadges uses the x/upgrade module from Cosmos SDK for upgrades and expects upgrades to be handled with zero-downtime using Cosmovisor.

**Discord:** Communications and announcements for node operators is facilitated via our Discord.


## File: ./for-developers/bitbadges-blockchain/run-a-node/run-a-local-dev-node.md

# Run a Local Dev Node

Running a local development node follows pretty much the same instructions as the mainnet ones except the following.

* Chain ID should be something non-conflicting (i.e. not bitbadges-1 or -2)
* No need for seed nodes or peers (since you are running a single node local chain)
* Assuming you want to start a new chain with the latest binary, you will not have any upgrades to handle. Genesis -> Current Block will always be the current, latest binary.
  * If you are using Docker, you should be using the latest binary image instead of the mainnet node one. The mainnet node one has all binaries built.
* You can also start with an existing genesis / snapshot if you would like.
* You may have to setup a validator to be able to start producing blocks

Please reach out in the dev Discord if you are stuck or need help!

**Ignite CLI**

Throughout BitBadges' development phase, we used Ignite CLI to help scaffold, build,  and serve our chain. This is also a great option for bootstrapping a local development node. Visit their documentation for more information. You will need to download the bitbadgeschain  source code to use Ignite CLI and use Ignite on the source folder.

**Setting Up a Validator**

See [**https://docs.cosmos.network/v0.45/run-node/run-node.html**](https://docs.cosmos.network/v0.45/run-node/run-node.html) for more information if you need to setup a local validator to start your chain. Replace simd with your run command.

**Funding Your Address**

With a local development chain started from scratch, you probably want to have an address that is seeded with some starting balances. You can fund your address by editing the DAEMON\_HOME/config/genesis.json -> app\_state.bank.balances path as seen below.

You can use any converted BitBadges address (e.g. an Ethereum address converted), but we recommend using an address you can sign with via the CLI.  To get one or view your existing ones, run&#x20;

```
cosmovisor run keys ...
```

```json
...
  "bank": {
      ...
      "balances": [
        {
          "address": "bb1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs7gvmv",
          "coins": [
            {
              "denom": "ubadge",
              "amount": "1"
            }
          ]
        },
...
```

**Interacting with the Chain**

Cosmos SDK has an in-depth CLI for interacting with the chain and getting details about it. To see all commands or get help, simply run any command with --help (or an invalid command will auto print the help messages). &#x20;

The main ones you will be using are **tx** and **query** to sign transactions and query state, respectively**.**&#x20;

For example,

```bash
# --from keystorename is to sign the tx
cosmovisor run tx badges transfer-badges ... --from keystorename
```

```
cosmovisor run query badges get-balance ...
```

We refer you to the CLI docs or other Cosmos SDK documentation for more information. The best way to get started is to simply just try stuff in the CLI, in our opinion.

**Ports**

http://localhost:1317 will be the node's REST API port for queries. Navigate to it in a browser to see.

http://localhost:26657 will be the Tendermint RPC. You can also navigate here in the browser.

<!-- **Running the Full-Stack**

To run the indexer and frontend along with a local development chain, we refer you to the documentation for those. Make sure that the URLs are configured properly (i.e. pointing to localhost and not the main deployed one).&#x20;

Please reach out if you have problems. -->


## File: ./for-developers/bitbadges-blockchain/run-a-node/run-a-mainnet-node.md

# Run a Mainnet Node

## DAEMON\_HOME

Your DAEMON\_HOME is the folder that will contain everything about the blockchain state, configuration, genesis, etc. Ensure that this folder persists across upgrades and changes. This is especially important if you plan to run the node using a container approach (Docker, Kubernetes, etc).

## Fetch / Build Binaries

### Download

Download the executable directly from GitHub. For the latest releases, check the [releases page](https://github.com/BitBadges/bitbadgeschain/releases). Choose the correct executable for your machine and operating system.

```
wget https://github.com/BitBadges/bitbadgeschain/releases/download/v1.0-betanet/bitbadgeschain-linux-amd64
```

Example: [https://github.com/BitBadges/bitbadgeschain/releases/tag/v1.0-betanet](https://github.com/BitBadges/bitbadgeschain/releases/tag/v1.0-betanet)

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1)  (14).png" alt=""><figcaption></figcaption></figure>

If this is your first time downloading, you will need to also download the Wasm VM runtime library as well. This is the libwasmvm.x86\_64.so file and should be placed into /usr/lib. If not, you will get "error while loading shared libraries: libwasmvm.x86\_64.so: cannot open shared object file: No such file or directory".

Example

<pre><code>wget https://github.com/BitBadges/bitbadgeschain/releases/download/v1.0-betanet/bitbadgeschain-linux-amd64
<strong>wget https://github.com/BitBadges/bitbadgeschain/releases/download/v1.0-betanet/libwasmvm.x86_64.so
</strong><strong>mv libwasmvm.x86_64.so /usr/lib/
</strong></code></pre>

### **Build from Source**

We refer you to the README of the blockchain code repository.

### **Docker**

Running with Docker may be the easiest option, but it also is not compatible with automatic upgrades through Cosmovisor (see section below). This means you will sacrifice availability (which is especially important for validators who are slashed when down).

```bash
docker pull bitbadges/bitbadgeschain:latest
```

## Handling Upgrades - Cosmovisor

BitBadges handles binary upgrades using Cosmovisor, a tool for automating upgrades with zero downtime. You can find detailed information in the [Cosmos documentation](https://tutorials.cosmos.network/tutorials/9-path-to-prod/7-migration.html) and the [Cosmovisor documentation](https://docs.cosmos.network/main/tooling/cosmovisor.html). It is expected all validators are using Cosmovisor.

Upgrades will be announced in the Discord and are facilitated with the x/upgrades module behind the scenes. You, as the node operator, will have until the upgrade time to successfully handle the upgrade. If not completed by upgrade time, your node will halt at the upgrade height. If your node is a validator, it will be slashed.

### **Installation / Setup**

{% content-ref url="cosmovisor.md" %}
[cosmovisor.md](cosmovisor.md)
{% endcontent-ref %}

## RUN\_COMMAND

Depending on your setup method, you may have different commands to run the binary. Throughout the rest of this documentation, we use RUN\_COMMAND to avoid repeating ourselves. Please replace your command wherever you see RUN\_COMMAND

**Cosmovisor**

```bash
# The "run" is important. Ex:
# cosmovisor run init -> Blockchain initialixation
# cosmosvisor init -> Cosmosvisor folder initialization
cosmovisor run ....
```

**Plain Executable**

```
./bitbadgeschaind ....
```

**Docker**

<pre class="language-bash"><code class="lang-bash"><strong># Replace DAEMON_HOME
</strong><strong>docker run -it \
</strong>    -p 26656:26656 \
    -p 26657:26657 \
    -p 26660:26660 \
    -p 6060:6060 \
    -p 9090:9090 \
    -p 1317:1317 \
<strong>    --mount type=bind,source="$DAEMON_HOME",target=/root/.bitbadgeschain \
</strong>    bitbadges/bitbadgeschain:latest ... 
</code></pre>

## Initialization / Syncing

In order to catch up to the current consensus, you will need to get your node synced. This can be done from genesis (time consuming but no trust needed) or from a recent snapshot of the state (much faster but requires slight trust assumptions).

### **From Snapshosts (Recommended)**

If you do not want to reconstruct the entire history of the chain from genesis, you can start from a checkpoint. This can potentially save you days of syncing but requires you to trust an existing node.

{% embed url="https://explorer.bitbadges.io/BitBadges%20Mainnet/statesync" %}

**State Sync**

You can configure your config.toml to use the Cosmos SDK state sync feature to quickly sync from a trusted node. Feel free to use the official RPC node to do this. We refer you to here [https://docs.tendermint.com/v0.34/tendermint-core/state-sync.html](https://docs.tendermint.com/v0.34/tendermint-core/state-sync.html) or you can reference other Cosmos SDK state sync documentation.

**From Snapshots**

You can get the necessary files from an existing snapshot, add them to your DAEMON\_HOME, and start the chain. See [Chain Details](../chain-details.md) for providers.

For [https://snapshots.whenmoonwhenlambo.money/bitbadges-1](https://snapshots.whenmoonwhenlambo.money/bitbadges-1), use this command. Replace /cosmos/.bitbadgeschain with your home directoyry.

```
lz4 -c -d bitbadges-1-snapshot-latest.tar.lz4 | tar -x -C /cosmos/.bitbadgeschain
```

### **From Block Sync**

Syncing from genesis or via block sync means that you start with the blank genesis state and verify all transactions from the start block to the current block (time consuming). This is not recommended unless you need to run a full archive node.

**Chain Binaries**

The chain binary may be upgraded over time. To continue syncing, you will always need the relevant binary for the current block. This means you must handle ALL chain upgrades (since you are syncing from genesis). See Cosmovisor section.

**Chain Forks**

```
NOTE: We had a hard fork after block 711315
```

Normal Comet BFT block sync will not work from block 711315 -> 711316 due to this fork. You will need to manually handle this.

For handling this, you can either:

1. Start with block 711316 genesis or later (recommended). Everything will work as intended.

<pre><code>cd DAEMON_HOME/config
<strong>rm genesis.json
</strong>curl -o genesis.json https://raw.githubusercontent.com/BitBadges/bitbadgeschain/master/genesis-711316.json
RUN_COMMAND comet unsafe-reset-all
RUN_COMMAND start
</code></pre>

2. Or if you really need blocks 1-711315 for a full archive node (maybe like an explorer). Please reach out if you are planning to use this approach as we can help you through this process.

See ./scripts/handle-fork-711315.sh in the btibadgeschain GitHub repository for a full script. Or, do the following below:

You can get blocks 1-711315 via running it below or via a snapshot (recommended).

```
cd DAEMON_HOME/config
rm genesis.json
curl -o genesis.json https://raw.githubusercontent.com/BitBadges/bitbadgeschain/master/genesis.json
RUN_COMMAND start 
```

If you want to migrate and join together the blockstores / transaction indexes so they are all in one place:

<pre class="language-bash"><code class="lang-bash"># Backup the /data folder for blocks 1-711315 somewhere for later use
# Get the chain up and running for 711316+ (see above). Sync a few blocks. Stop the chain. 

<strong>git clone https://github.com/bitbadges/bitbadgeschain
</strong><strong># Edit migrate.go to use your intended source / target DB paths
</strong><strong># Run migrate.go which copies all blockstores / transaction data and sets base height back to 1
</strong><strong># Note: If you need more than just block data (cs.wal, state.db, or evidence.dd), this is left  up to you. 
</strong>go run scripts/migrate.go -source /path/to/snapshot/data -target /path/to/target/data
</code></pre>

**Testnet Genesis**

Note: Replace the genesis files with the corresponding testnet ones if you are planning to run a testnet node

## Configuration

To initialize a new chain, run the following (depending on your build method). CHAIN\_ID will be "bitbadges-1" for mainnet. Initialization should only be performed once.

```
RUN_COMMAND init <moniker> --chain-id CHAIN_ID
```

You'll need to replace `<moniker>` with a custom username for your node and the CHAIN\_ID for the chain you want (bitbadges-1 for mainnet).

Take note of where your configuration files live. We expect it to be in /root/.bitbadgeschain but if it isn't, you will need to make sure it is correct with --home flags. We call this DAEMON\_HOME.

If you are getting directories do not exist error, you may have to do the following first. These will be overwritten when the init command is executed, but it is just to get the errors out of there.

<pre><code><strong>cd DAEMON_HOME
</strong>mkdir config
mkdir data
mkdir wasm
</code></pre>

Inside the DAEMON\_HOME/config folder, you'll find two files: `config.toml` and `app.toml`. Both files contain extensive comments to help you customize your node settings. You can also run `RUN_COMMAND start --help` for explanations.

Tweak these as desired. Some important ones are highlighted below.

**Setting Seed Nodes**

In order to pull data from other nodes, you need to have seed nodes or peers to pull from. You may use 2703c1304a70186372aa726a762d60da94c29ffe@node.bitbadges.io:26656 for our official node ID. To establish connections with trusted nodes, edit `config.toml`. For instance:

```toml
seeds = "2703c1304a70186372aa726a762d60da94c29ffe@node.bitbadges.io:26656"
```

These entries follow the format `nodeId@listenaddress:port`. Additionally, you can set up seed nodes by specifying them in the `seeds` field. Or, private peers at `private_peer_ids.`

**Listen Addresses / Firewalls**

Ensure that the listen address settings are correct, using your IP address or domain name if configured. Also, make sure that your firewall exposes the necessary ports (22, 1317, 9090, 26656, 26657, 26660). See here for more information and other best practices running a node in production: [https://docs.cosmos.network/main/user/run-node/run-production#go](https://docs.cosmos.network/main/user/run-node/run-production#go).

## Running the Node

Once you have the node all configured, run the following to start the chain. You should see blocks being synced if configured correctly.

```
RUN_COMMAND start
```

**Other Considerations**

Setting up your node infrastructure correctly and with best practices is crucial to ensure security. There are many options for this, so below we just give some general guidelines.

* DDoS Mitigation: Being part of a network with a known IP address can expose you to DDoS attacks. Learn how to mitigate these risks [here](https://tutorials.cosmos.network/tutorials/9-path-to-prod/5-network.html#ddos). Consider using sentry nodes and proxies.
* Key Management: Implement best practices for key management, including key management systems such as [TMKMS](https://hub.cosmos.network/main/validators/kms/kms.html). This is especially important for validators.
* Redundancy: Plan for infrastructure failures such as power outages to ensure the continuous operation of your validator. Consider setting up your software as a service to avoid relaunching it manually every time. Refer to the [Cosmos documentation](https://tutorials.cosmos.network/tutorials/9-path-to-prod/6-run.html#as-a-service) for guidance on configuring your node as a service.
* Consider also running your node + Cosmovisor as a service, so it relaunches automatically. See [https://tutorials.cosmos.network/tutorials/9-path-to-prod/6-run.html](https://tutorials.cosmos.network/tutorials/9-path-to-prod/6-run.html) and [https://tutorials.cosmos.network/tutorials/9-path-to-prod/7-migration.html](https://tutorials.cosmos.network/tutorials/9-path-to-prod/7-migration.html)

## Running a Validator

As explained in the [Launch Phases](broken-reference) docs, reach out to us in Discord if you plan to run a validating node and need $STAKE. This is free and only requires a quick application process.

**Setup - Validator Keys**

Follow the instructions in the [Cosmos documentation](https://docs.cosmos.network/main/run-node/keyring) and/or the [Cosmos Tutorials](https://tutorials.cosmos.network/tutorials/9-path-to-prod/3-keys.html) to set up your validator keys. Replace `simd` with `bitbadgeschaind` or `myproject` with `bitbadgeschain`.

A validator handles [two](https://hub.cosmos.network/main/validators/validator-faq.html#what-are-the-different-types-of-keys) perhaps three, different keys. Most likely keys 2 and 3 [are the same](https://github.com/cosmos/cosmos-sdk/blob/v0.46.1/proto/cosmos/staking/v1beta1/tx.proto#L45-L47). Each has a different purpose:

1. The **Tendermint consensus key** is used to sign blocks on an ongoing basis. It is of the key type `ed25519`, which the KMS can keep. When Bech-encoded, the address is prefixed with `bbvalcons` and the public key is prefixed with `bbvalconspub`.
2. The **validator operator application key** is used to create transactions that create or modify validator parameters. It is of type `secp256k1`, or whichever type the application supports. When Bech-encoded, the address is prefixed with `bbvaloper`.
3. The [**delegator application key** ](https://hub.cosmos.network/main/validators/validator-faq.html#are-validators-required-to-self-delegate-atom)is used to handle the stake that gives the validator more weight. When Bech-encoded, the address is prefixed with `bb` and the public key is prefixed with `bbpub`.

**Consensus Key**

The consensus key is HOT, meaning it is needed on the validator node to sign blocks. It is strongly recommended that this is set up with a signing service and key management system.

By default, when you ran the **init** command, it creates a key for you in `..../config/priv_validator_key.json.`

This is convenient if you are starting a testnet, for which the security requirements are low. However, for a more valuable network, you should not store it directly in the node's filesystem. It should be stored in a more secure manner, such as with a signing service or key management system.

**Operator / Delegator Key**

The application / operator key should be COLD and NOT be stored on the validator node. This is just your standard public/private key pair used to sign transactions.

This can be generated (if you don't already have one) by running the following command.

```
bitbadgeschaind keys --keyring-backend file --keyring-dir /root/.bitbadgeschain/keys
add <name>
```

Adjust the command accordingly. **Note you should run this and store it on your local desktop, not the validating node.**

### Joining the Validator Set

If you intend to run a validator node, execute the following command adjusted accordingly to join the set of validators (assuming you're not part of the initial genesis set). Run with --help for more details. Replace bitbadgeschaind tx with your run command (dependent on your build method). This is the same command as how you started the node (but replace start with tx).

```shell
RUN_COMMAND tx staking create-validator /path/to/validator.json \
  --chain-id="name_of_chain_id" \
  --gas="auto" \
  --gas-adjustment="1.2" \
  --gas-prices="0.025ubadge" \
  --from=mykey
```

This should be signed with your normal key pair for signing transactions. Ensure you have enough $BADGE credits to cover gas and your stake. The `validator.json` file should contain relevant information about your validator, including the consensus public key, moniker, website, security contact, details, commission rates, and min-self-delegation.

You can obtain the public validator consensus public key using the`bitbadgeschaind tendermint show-validator` command.


## File: ./for-developers/bitbadges-sdk/README.md

# ⚒ BitBadges SDK



## File: ./for-developers/bitbadges-sdk/common-snippets/README.md

# Common Snippets

In this section, we provide common snippets and examples for the SDK. Some of these were auto-generated with AI, so please let us know if there are issues.


## File: ./for-developers/bitbadges-sdk/common-snippets/address-conversions.md

# Address Conversions

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> Address Utils

```ts
import { convertToBitBadgesAddress, convertToBtcAddress, convertToEthAddress } from "bitbadgesjs-sdk"

let address = convertToBitBadgesAddress("0x14574a6DFF2Ddf9e07828b4345d3040919AF5652")
// "bb1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw"

let address = convertToEthAddress("bb1z3t55m0l9h0eupuz3dp5t5cypyv674jj7mz2jw")
// "0x14574a6DFF2Ddf9e07828b4345d3040919AF5652"
```


## File: ./for-developers/bitbadges-sdk/common-snippets/address-lists.md

# Address Lists

AddressLists are the base type for lists. The BitBadgesAddressList class you see returned from the API extends this. Learn more about lists in the core concepts.

```typescript
const list = new AddressList({
  addresses: ['bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh'],
  whitelist: true,
  customData: '',
  uri: '',
  createdBy: 'bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh',
  listId: 'abc123',
})

const isInList = list.checkAddress('bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh') // true
const invertedList = list.toInverted()
const isInListNow = invertedList.checkAddress('bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh') // false

list.remove('bb1hsk6jryyqjfhp5g4g7j0qldj9nqdj0qc02fgmh')
const isEmpty = list.isEmpty()


const MintList = AddressList.Reserved('Mint')
const All = AddressList.AllAddresses();
```


## File: ./for-developers/bitbadges-sdk/common-snippets/badge-metadata.md

# Badge Metadata

#### Tutorial: Managing Badge Metadata in TypeScript

**1. Introduction to `BadgeMetadataDetails`**

The `BadgeMetadataDetails` type captures comprehensive details about the metadata of a badge. It contains fields such as badge IDs (ranges), associated metadata, a URI, and custom data. This is what is used via the **cachedBadgeMetadata** field from collection responses.

**2. Removing Metadata for Specific Badge IDs**

To delete metadata associated with specific badge IDs:

```typescript
const currentMetadata: BadgeMetadataDetails<bigint>[] = [...]; // your current metadata array

const badgeIdsToRemove = UintRangeArray.From([
  { start: 5n, end: 10n }
];

const updatedMetadata = removeBadgeMetadata(currentMetadata, badgeIdsToRemove);
console.log(updatedMetadata); // This will show metadata without the removed badge IDs.
```

**3. Updating Metadata for Badges**

If you wish to update specific badge metadata in the badge metadata details:

```typescript
const currentMetadata: BadgeMetadataDetails<bigint>[] = [...]; // your current metadata array

const metadataToUpdate: BadgeMetadataDetails<bigint> = new BadgeMetadataDetails<bigint>({
  badgeIds: [{ start: 7n, end: 7n }],
  metadata: { /* your metadata details here */ },
  uri: "http://new-metadata-url.com", //Or 'Placeholder' or something else
  customData: "Some custom information",
});

const newMetadataArray = updateBadgeMetadata(currentMetadata, metadataToUpdate);
console.log(newMetadataArray); // This will show the array with the updated metadata.
```

**4. Fetch Metadata Details for a Specific Badge ID**

To retrieve metadata details for a particular badge ID:

```typescript
const badgeIdToFetch = 12n;

const badgeMetadataDetails = getMetadataDetailsForBadgeId(badgeIdToFetch, currentMetadata);
console.log(badgeMetadataDetails); // This will display the metadata details for the specified badge ID.
```

**5. Fetch Only the Metadata for a Specific Badge ID**

To only retrieve the metadata (without the surrounding details) for a particular badge ID:

```typescript
const badgeIdToFetch = 15n;

const badgeMetadata = getMetadataForBadgeId(badgeIdToFetch, currentMetadata);
console.log(badgeMetadata); // This will show only the metadata for the given badge ID.
```

**Conclusion**

These functions provide a robust toolkit for managing badge metadata. Whether you're updating, fetching, or deleting metadata associated with badges, you have a systematic and structured approach available.


## File: ./for-developers/bitbadges-sdk/common-snippets/balances.md

# Balances

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> Balances



### Tutorial: Using the TypeScript SDK for Balance Operations

**1. Define the Balance**

Here's how you create a balance using the provided `Balance` interface:

<pre class="language-typescript"><code class="lang-typescript"><strong>const userBalance = BalanceArray.From([{
</strong>  "amount": 5n, // example badge amount using the BigInt type
  "badgeIds": [{ start: 1n, end: 5n }],
  "ownershipTimes": [{ start: 1628770800000n, end: 1628857200000n }] // example timestamps using BigInt
}])
</code></pre>

Note: The `UintRange` type is assumed to be an object with `start` and `end` properties of type `bigint`. Adjust as necessary based on the actual definition.

**2. Add Balance**

To add a balance to an array of existing balances:

```typescript
const balanceToAdd = {
  amount: 3n,
  badgeIds: [{ start: 6n, end: 8n }],
  ownershipTimes: [{ start: 1628860800000n, end: 1628947200000n }]
};
userBalance.addBalances([balanceToAdd]);
```

This will add `balanceToAdd` to the list of existing balances.

**3. Subtract Balance**

To subtract a balance from an array of existing balances:

```typescript
const balanceToRemove = {
  amount: 2n,
  badgeIds: [{ start: 2n, end: 3n }],
  ownershipTimes: [{ start: 1628784400000n, end: 1628870800000n }]
};
userBalance.subtractBalances([balanceToRemove], false) //second param is to allow underflow (negatives)
```

**Conclusion**

This SDK provides a clear and structured way to manage and operate on badge balances. With the `addBalance` and `subtractBalance` functions, you can effortlessly update and maintain badge balances in your application.\
\
Given the new functions you've shared, I'll provide a tutorial snippet for each of them.

### Tutorial: Retrieving Balances Based on Badge ID and Time

**1. Get Balance for a Specific ID and Time**

If you need to retrieve the balance for a specific badge ID and a specific ownership time, you can use the `getBalanceForIdAndTime` function:

```typescript
const badgeIdToLookup = 3n;
const timeToLookup = 1628784400000n;  // example timestamp using BigInt
const specificBalance = balances.getBalanceForIdAndTime(badgeIdToLookup, timeToLookup);

console.log(specificBalance); // This will show the balance for the specified badge ID and time, if found.
```

**2. Get Balances for a Specific Badge ID**

To get all balances associated with a specific badge ID:

```typescript
const badgeIdToLookup = 4n;
const badgeBalances = balances.getBalancesForId(badgeIdToLookup);

console.log(badgeBalances); // This will display all the balances for the given badge ID.
```

**3. Get Balances for a Specific Time**

If you need to retrieve all badge balances for a specific ownership time:

```typescript
const timeToLookup = 1628784400000n;
const timeSpecificBalances = balances.getBalancesForTime(timeToLookup);

console.log(timeSpecificBalances); // This will show all the balances that have the specified ownership time.
```

Alright, given the new function `getBalancesForIds` which retrieves balances for a range of badge IDs and a range of times, let's create a tutorial snippet for it:

4. **Get Balances for Specific Ranges of Badge IDs and Times**

If you need to retrieve balances for a range of badge IDs and a range of ownership times, you can utilize the `getBalancesForIds` function:

```typescript
// Define the range of badge IDs and times you want to look up
const idRangesToLookup = [
    { start: 1n, end: 3n },
    { start: 5n, end: 7n }
];

const timeRangesToLookup = [
    { start: 1628770800000n, end: 1628857200000n },  // example timestamp range using BigInt
    { start: 1628943600000n, end: 1629030000000n }   // another timestamp range
];

// Retrieve the balances
const specificBalances = balances.getBalancesForIds(idRangesToLookup, timeRangesToLookup);
console.log(specificBalances); // This will show the balances that fall within the specified badge ID ranges and time ranges.
```

**Conclusion**

The provided functions in this SDK make it easy to retrieve specific badge balances based on different criteria, such as badge ID and ownership time. Utilize these functions to access and display relevant data as per your application's requirements.


## File: ./for-developers/bitbadges-sdk/common-snippets/get-unhandled-approvals.md

# Approvals / Transferability

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> Approvals / Transferability

You can use the following functions to get the approval combinations that have unhandled. If unhandled, they are disapproved.

```typescript
export function getUnhandledCollectionApprovals(
  collectionApprovals: CollectionApprovalWithDetails<bigint>[],
  ignoreTrackerIds?: boolean
  doNotMerge?: boolean
)
```

```typescript
export function getUnhandledUserOutgoingApprovals(
  approvals: UserOutgoingApprovalWithDetails<bigint>[],
  userAddress: string,
  doNotMerge?: boolean
)
```

```typescript
export function getUnhandledUserIncomingApprovals(
  approvals: UserIncomingApprovalWithDetails<bigint>[],
  userAddress: string,
  doNotMerge?: boolean
)
```

Use the following functions to add the default user approvals to an existing set of approvals. For incoming, this will be: if unhandled, approve only if to == initiatedBy. For outgoing, vice versa.

```typescript
export function appendSelfInitiatedOutgoingApproval(currApprovals: UserOutgoingApprovalWithDetails<bigint>[], userAddress: string): UserOutgoingApprovalWithDetails<bigint>[]
```

```typescript
export function appendSelfInitiatedIncomingApproval(currApprovals: UserIncomingApprovalWithDetails<bigint>[], userAddress: string): UserIncomingApprovalWithDetails<bigint>[] 
```


## File: ./for-developers/bitbadges-sdk/common-snippets/numbertype-conversions.md

# NumberType Conversions

A problem with creating a JavaScript SDK for a Cosmos SDK based blockchain is that JavaScript's number primitive cannot natively handle numbers > Number.MAX\_SAFE\_INTEGER, but the blockchain allows amounts greater than that.

To combat this, we have made all TypeScript types in the SDK generic via a NumberType interface.

```typescript
export type NumberType = bigint | number | string | boolean;
```

Types that you will find in the SDK that are number-based will all be generically typed, so that you can use any of the above NumberTypes, according to your preferences.

It is recommended that you use bigint and/or stringified because these can represent all possible numbers and do not lose precision. Also, note that for almost all SDK functions, we only take bigints.

For example, the following will represent a BadgeMetadata type where all numbers are stringified (i.e. "100" or "123").

```typescript
const stringifiedMetadata: BadgeMetadata<string> = new BadgeMetadata({ uri: ... });
```

**Converting Between NumberTypes**

To convert between different number types, all types come with a converter function (**.convert()**). This allows you to convert all the stringified numbers to another format (such as JS number or JS bigint). To convert, you can simply do the following:

```typescript
import { BigIntify, BadgeMetadata, JSPrimitiveNumberType, NumberType, convertBadgeMetadata } from "bitbadgesjs-sdk";

const stringifiedMetadata: BadgeMetadata<string> = new BadgeMetadata({ uri: ... });
const bigIntifiedMetadata = stringifiedBadgeMetadata.convert(BigIntify);
```

We export the following types and converter functions for your convenience.

```typescript
export type NumberType = bigint | number | string | boolean;
export type JSPrimitiveNumberType = string | number | boolean;

export const BigIntify = (item: NumberType) => numberify(item, StringNumberStorageOptions.BigInt) as bigint;
export const Stringify = (item: NumberType) => numberify(item, StringNumberStorageOptions.String) as string;
export const Numberify = (item: NumberType) => numberify(item, StringNumberStorageOptions.Number) as number;
export const NumberifyIfPossible = (item: NumberType) => numberify(item, StringNumberStorageOptions.NumberIfPossible) as number | string;
```

**Example Application**

In our API, JS bigints cannot be natively sent over HTTP. So, we use the following execution flow:

1. Before sending to the client, stringify everything before sending over HTTP
2. The client can use the converter functions to coonvert all types to their preferred method


## File: ./for-developers/bitbadges-sdk/common-snippets/timelines.md

# Timelines

As you may have noticed, many of the collection fields are timeline-based, meaning they can be scheduled to have different values at different times. Check out the [Timeline helpers](https://bitbadges.github.io/bitbadgesjs/functions/getCurrentValuesForCollection.html) from bitbadgesjs-sdk in the SDK.

**Examples:**

If you are using the BitBadgesCollection interface, this is achievable simply with the helper functions. There is one for every timeline.

```typescript
const manager = collection.getManager(); //Can pass in a time too (defaults to now)
```

Or, you can do it manually

<pre class="language-typescript"><code class="lang-typescript"><strong>const manager = getCurrentValuesForCollection(collection).manager;
</strong></code></pre>

<pre class="language-typescript"><code class="lang-typescript"><strong>const manager = getValuesAtTimeForCollection(collection, Date.now() + 1000 * 60).manager;
</strong></code></pre>

You can also get all possible values for timelines as such. This will set all missing times with empty or default values.

```typescript
function getFullManagerTimeline(
    timeline: ManagerTimeline<bigint>[]
): ManagerTimeline<bigint>[];
```

```typescript
function getFullCollectionMetadataTimeline(
    timeline: CollectionMetadataTimeline<bigint>[]
): CollectionMetadataTimeline<bigint>[];
```

And so on for all other timelines.


## File: ./for-developers/bitbadges-sdk/common-snippets/transfers-w-increments.md

# Transfers

The `TransferWithIncrements` type provides a convenient method for handling batch transfers, especially when you need to distribute badges sequentially or when badges have varying ownership times. By combining this with the `getBalancesAfterTransfers` function, you can effortlessly manage and update badge balances in your application.

```typescript
import { BalanceArray, TransferWithIncrements, getAllBadgeIdsToBeTransferred, getAllBalancesToBeTransferred } from '../packages/bitbadgesjs-sdk'

const startingBalances = BalanceArray.From([
  {
    amount: 100n,
    badgeIds: [{ start: 1n, end: 100n }],
    ownershipTimes: [{ start: 1628770800000n, end: 1628857200000n }],
  },
])

const batchTransfer = new TransferWithIncrements<bigint>({
  from: 'Mint', // replace with your address

  balances: startingBalances,

  toAddresses: [], // this will be empty because we're using `toAddressesLength`
  toAddressesLength: 100n,

  incrementBadgeIdsBy: 1n,
  incrementOwnershipTimesBy: 86400000n, // assuming this is 1 day in milliseconds in BigInt form
})


const allBadgeIds = getAllBadgeIdsToBeTransferred([batchTransfer]) // returns [{ start: 1n, end: 100n }]
const allBalancesToBeTransferred = getAllBalancesToBeTransferred([batchTransfer]) // returns [{ amount: 100n, badgeIds: [{ start: 1n, end: 100n }], ownershipTimes: [{ start: 1628770800000n, end: 1628857200000n }] }
```


## File: ./for-developers/bitbadges-sdk/common-snippets/uint-ranges.md

# Uint Ranges

Documentation Link: [Here](https://bitbadges.github.io/bitbadgesjs/packages/bitbadgesjs-sdk/docs) -> UintRanges



#### Tutorial: Managing and Querying Unsigned Integer Ranges

**1. Introduction to `UintRange`**

The `UintRange` interface captures a range of unsigned integers using a start and end property. This is handy when representing intervals or spans of values.

**2. Sorting and Merging Ranges**

To sort a list of ranges and merge adjacent or overlapping ones:

```typescript
const ranges = UintRangeArray.From([
  { start: 10n, end: 20n },
  { start: 5n, end: 12n },
  { start: 21n, end: 25n }
]);
ranges.sortAndMerge();

console.log(ranges); // Expected: [{ start: 5n, end: 25n }]
```

**3. Searching Within Ranges**

To search for a specific ID within a list of ranges and return its index and a boolean indicating if it was found:

```typescript
const idToSearch = 15n;
const [index, isFound] = ragnes.search(idToSearch)
console.log(`Index: ${index}, Found: ${isFound}`);
```

**4. Inverting Ranges**

To invert a list of ranges between a minimum and maximum ID:

<pre class="language-typescript"><code class="lang-typescript"><strong>ranges.invert(1n, 30n);
</strong>console.log(invertedRanges); // This would show the gaps between the given ranges within the specified bounds.
</code></pre>

**5. Removing One Range From Another**

To remove one range from another and also get the removed part:

```typescript
const rangesToRemove = [{ start: 10n, end: 20n }];

ranges.remove(rangesToRemove);
console.log("Remaining:", ranges);

const [inCurrButNotOther, overlaps, inOtherButNotCurr] = ranges.getOverlapDetails(rangesToRemove)
```

**6. Checking for Overlaps**

To determine if there are overlaps within a list of ranges:

```typescript
const overlaps = ranges.overlaps([{ ...}]);
console.log(`Ranges Overlap: ${overlappingCheck}`);
```

**Conclusion**

The functions provided offer a comprehensive toolkit for managing and querying unsigned integer ranges. Whether you're checking for overlaps, inverting ranges, or removing specific integers from a range, you now have the tools to do it efficiently and systematically.



```typescript
import { GO_MAX_UINT_64, UintRange, UintRangeArray } from 'bitbadgesjs-sdk'

//Singular range functions
const range = new UintRange<bigint>({ start: 1n, end: 10n })
const size = range.size() //10n
const fullRange = UintRange.FullRange() // 1n - GO_MAX_UINT_64
const isFull = fullRange.isFull()
const inverted = range.invert() // 11n - GO_MAX_UINT_64
const overlaps = range.overlaps(inverted) // false
const doesFiveExist = range.search(5n) // true
const overlapDetails = range.getOverlapDetails(fullRange) // [[], [{ start: 1n, end: 10n }], [{ start: 11n, end: GO_MAX_UINT_64 }]]
const overlappingRanges = range.getOverlaps(fullRange) // [{ start: 1n, end: 10n }]

const rangeArr = UintRangeArray.From<bigint>([{ start: 1n, end: 10n }, { start: 11n, end: 20n }])
const rangeArrSize = rangeArr.size() // 20n
const rangeArrFull = UintRangeArray.FullRanges() // 1n - GO_MAX_UINT_64
const rangeArrIsFull = rangeArrFull.isFull()
const rangeArrInverted = rangeArr.toInverted({ start: 1n, end: GO_MAX_UINT_64 }) // 21n - GO_MAX_UINT_64

const unsortedArr = UintRangeArray.From<bigint>([{ start: 11n, end: 20n }, { start: 1n, end: 15n }])
const hasOverlaps = unsortedArr.hasOverlaps() // true
unsortedArr.sortAndMerge() // [{ start: 1n, end: 20n }]

const sortedArr = unsortedArr.clone()
const [inCurrButNotOther, overlaps, inOtherButNotCurr] = sortedArr.getOverlapDetails(unsortedArr) // [[], [{ start: 1n, end: 20n }], []]

sortedArr.remove({ start: 1n, end: 10n }) // [{ start: 11n, end: 20n }]

const [idx, found] = sortedArr.search(11n) // [0n, true]
const exists = sortedArr.searchIfExists(11n) // true
const index = sortedArr.searchIndex(11n) // 0n
```


## File: ./for-developers/bitbadges-sdk/overview.md

# Overview

The BitBadges SDK is a bundle of TypeScript libraries that provide all the tools and functions needed for you to build your own frontend or interact with the BitBadges API, blockchain, and indexer.

GitHub: [https://github.com/bitbadges/bitbadgesjs](https://github.com/bitbadges/bitbadgesjs)

Full Documentation: [https://bitbadges.github.io/bitbadgesjs/](https://bitbadges.github.io/bitbadgesjs/)

```
npm install bitbadgesjs-sdk
```

Note: We also have a python API SDK wrapper. This only includes the API routes auto-generated and no helper functions like the SDK route.

```
pip install bitbadgespy-sdk
```

This library provides miscellaneous functionality to help you interact with BitBadges, such as types, API routes, managing metadata requests, logic with ID ranges and balances, etc.

```typescript
const bitbadgesAddress = convertToBitBadgesAddress(address);
const ethAddress = bitbadgesToEth(bitbadgesAddress);
```

It also exports functions for broadcasting transactions and interacting with the blockchain. See [Broadcasting Txs](../bitbadges-blockchain/create-and-broadcast-txs/) for how to use.

```typescript
const nodeUrl = ...

const postOptions = {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: generatePostBodyBroadcast(signedTx),
}

const broadcastEndpoint = `${nodeUrl}${generateEndpointBroadcast()}`
const broadcastPost = await fetch(
  broadcastEndpoint,
  postOptions,
)

const response = await broadcastPost.json()
```

For most use cases, you will not need to broadcast transactions. If you do, consider first exploring the helper broadcast tool at [https://bitbadges.io/dev/broadcast](https://bitbadges.io/dev/broadcast).


## File: ./for-developers/bitbadges-sdk/sdk-types.md

# SDK Types

### Custom Types

All types used in the SDK are exported via two ways.&#x20;

**Classes**

The first is via a JavaScript class. These will always begin with a capital letter. This class will always have the core functions below. Other specific functions may also be implemented.

```typescript
export declare class CustomTypeClass<T extends CustomType<T>> implements CustomType<T> {
    toJson(): JsonObject;
    toJsonString(): string;
    equals<U extends CustomType<U>>(other: CustomType<U> | null | undefined, normalizeNumberTypes?: boolean | undefined): boolean;
    clone(): T;
    getNumberFieldNames(): string[]; //Used behind the scenes
    convert<U extends NumberType>(_convertFunction?: (val: NumberType) => U): CustomType<any>;
}
```

The .convert() function is especially useful when dealing with different NumberTypes (bigint -> string).

```typescript
import { Balance, Numberify } 

const balance = new Balance<bigint>({
    amount: 1n,
    badgeIds: [{ start: 1n, end: 100n }],
    ownershipTimes: [{ start: 1n, end: 100n }]
})
const convertedBalance = balance.convert(Numberify); //1, 100 instead of 1n, 100n
```

**Interfaces**

The second is a JavaScript interface. This is the same as the class version minus all functions (just the core JSON object).

```typescript
export interface iBalance<T extends NumberType> {
    amount: T;
    badgeIds: iUintRange<T>[];
    ownershipTimes: iUintRange<T>[];
}
```

**Which one to use?**

Many functions support both; however, you may have to convert between them occasionally for compatibility. We recommend using the classes, but we recognize that many developers prefer the interfaces.&#x20;

### Typed Arrays

Some types also have a typed array exported as well. Similar to a Uint8Array in Javascript, these have all the features of traditional arrays. Thus, you can use .find, .map, .filter(), etc. Plus, additional functions will be available on them (e.g. array.addBalances for the BalanceArray type).&#x20;

```typescript
//Option 1
const balances = new BalanceArray()
balances.push(...)

//Option 2
const balances = BalanceArray.From([{ ... })

balances.addBalances([{ ... }]); //adds balances in-place
```

### **Proto Types**

The blockchain behind the scenes uses the Protocol Buffer type language. Within the SDK, we auto-generate all these proto types for you, but these are typically not the ones you should use in development (only when broadcasting transactions (see [here](../bitbadges-blockchain/create-and-broadcast-txs/))).&#x20;

Some might have duplicates between the two types.

```typescript
import { Balance } from "bitbadgesjs-sdk/dist/proto/balances";
import { Balance } from "bitbadgesjs-sdk";
```

The Proto types are exported via the following

```typescript
import { proto } from "bitbadgesjs-sdk";
const MsgCreateProtocol = proto.protocols.MsgCreateProtocol;
```

If you ever end up with something like the following, this is also the proto definition. We recommend using the proto.abc.xyz method to avoid confusion.

```typescript
import { MsgUpdateCollection } from "bitbadgesjs-sdk/dist/proto/badges";
```


## File: ./for-developers/bitbadges-x-ai/README.md

# 🪄 BitBadges x AI



## File: ./for-developers/bitbadges-x-ai/overview.md

# Overview

Below, we provide some resources that may be helpful for developing with AI. If there is anything else we can do to make development easier, let us know!

[Cosmos Msg Proto Definitions](https://github.com/BitBadges/bitbadgeschain/tree/master/proto)

[BitBadges API OpenApi Spec](https://github.com/BitBadges/bitbadgesjs/blob/main/packages/bitbadgesjs-sdk/openapi/combined_processed.yaml) - [Stoplight Reference](https://bitbadges.stoplight.io/docs/bitbadges)

[Full Documentation .txt](../../for-llms.txt)

[BitBadges AI Chatbot Starter](https://github.com/BitBadges/bitbadges-ai)

[Full SDK Reference](https://bitbadges.github.io/bitbadgesjs/classes/BitBadgesAPI.html) - [Full Types Reference](https://github.com/BitBadges/bitbadgesjs/blob/main/packages/bitbadgesjs-sdk/type-map/typedoc-output.json)





AI is already incredibly powerful for interacting with BitBadges:

* Distribute claim codes or add users to a dynamic user store to gate claims
* Use MCP to check any criteria on your own
* Offer any custom-built utility with AI and checking the BitBadges API
* And much more!


## File: ./for-developers/bitbadges-x-ai/prompts/README.md

# Prompts



## File: ./for-developers/bitbadges-x-ai/prompts/signing-a-transaction.md

# Signing a Transaction

## BitBadges Transaction Signing and Generation Guide

This guide explains how to create, fund, and sign transactions for the BitBadges blockchain using Ethereum-compatible wallets and the BitBadges SDK.

### Prerequisites

```bash
npm install @cosmjs/crypto @cosmjs/proto-signing @cosmjs/stargate
npm install bitbadgesjs-sdk ethers
```

### Step 1: Create ETH Wallet

There are several ways to create an Ethereum wallet for BitBadges transactions:

#### Option A: Create Random Wallet

```javascript
import { ethers } from 'ethers';

// Create a random wallet
const ethWallet = ethers.Wallet.createRandom();
console.log('Address:', ethWallet.address);
console.log('Private Key:', ethWallet.privateKey);
console.log('Mnemonic:', ethWallet.mnemonic.phrase);
```

#### Option B: From Existing Mnemonic

```javascript
import { ethers } from 'ethers';

const mnemonic = "your twelve word mnemonic phrase here";
const ethWallet = ethers.Wallet.fromMnemonic(mnemonic);
```

#### Option C: From Private Key

```javascript
import { ethers } from 'ethers';

const privateKey = "0x..."; // Your private key
const ethWallet = new ethers.Wallet(privateKey);
```

### Step 2: Fund the Wallet

#### Option A: Using Cosmos SDK Direct Transfer (Requires Funded Account)

The easiest way to do this is through the BitBadges website. If you want to do it programmatically, you can do so via the snippet below.

```javascript
import { DirectSecp256k1HdWallet } from '@cosmjs/proto-signing';
import { SigningStargateClient } from '@cosmjs/stargate';
import { convertToBitBadgesAddress } from 'bitbadgesjs-sdk';

// If you have a funded mnemonic account
const fromMnemonic = "your funded account mnemonic";
const wallet = await DirectSecp256k1HdWallet.fromMnemonic(fromMnemonic);
const [firstAccount] = await wallet.getAccounts();

// Connect to BitBadges RPC
const rpcUrl = "https://rpc.bitbadges.io"; // or your preferred RPC
const signingClient = await SigningStargateClient.connectWithSigner(rpcUrl, wallet);

// Transfer tokens to your new wallet
const amount = {
  denom: 'ubadge', // BitBadges native token
  amount: '1000000' // Amount in micro-units
};

const fee = {
  amount: [{ denom: 'ubadge', amount: '5000' }],
  gas: '200000'
};

const result = await signingClient.sendTokens(
  firstAccount.address,
  convertToBitBadgesAddress(ethWallet.address),
  [amount],
  fee
);
```

### Step 3: Get Current Account Number and Sequence

#### Option A: Using Cosmos RPC Query

```javascript
import { SigningStargateClient } from '@cosmjs/stargate';
import { convertToBitBadgesAddress } from 'bitbadgesjs-sdk';

const rpcUrl = "https://rpc.bitbadges.io";
const client = await SigningStargateClient.connect(rpcUrl);

const bitbadgesAddress = convertToBitBadgesAddress(ethWallet.address);
const account = await client.getAccount(bitbadgesAddress);

if (!account) {
  throw new Error('Account not found - ensure it has been funded');
}

console.log('Account Number:', account.accountNumber);
console.log('Sequence:', account.sequence);
```

#### Option B: Direct REST API Query

```javascript
const bitbadgesAddress = convertToBitBadgesAddress(ethWallet.address);
const restUrl = `https://lcd.bitbadges.io/cosmos/auth/v1beta1/accounts/${bitbadgesAddress}`;

const response = await fetch(restUrl);
const data = await response.json();

const accountNumber = data.account.account_number;
const sequence = data.account.sequence;
```

### Step 4: Generate Transaction Payload

#### Get Public Key First

For Ethereum signatures, this is automatically detected via the SDK, so you do not need to pre-generate.

```javascript
const base64PubKey = '';
```

#### Create Transaction Context

```javascript
import { createTransactionPayload, convertToBitBadgesAddress, Numberify } from 'bitbadgesjs-sdk';

const sender = {
  address: ethWallet.address, // Ethereum address - not BitBadges address
  sequence: sequence,
  accountNumber: Numberify(accountNumber),
  pubkey: base64PubKey,
  publicKey: base64PubKey
};

const txContext = {
  testnet: false,
  sender,
  memo: 'My BitBadges transaction',
  fee: {
    denom: 'ubadge',
    amount: '5000',
    gas: '200000'
  }
};
```

#### Create Transaction Messages

Refer to the proto definitions for all transaction types available. Standard Cosmos messages are also supported.

[https://github.com/BitBadges/bitbadgeschain/tree/master/proto](https://github.com/BitBadges/bitbadgeschain/tree/master/proto)

[https://bitbadges.github.io/bitbadgesjs/modules/proto.html](https://bitbadges.github.io/bitbadgesjs/modules/proto.html)

```javascript
import { badges } from 'bitbadgesjs-sdk';

// Example: Create a badge collection
const createCollectionMsg = new badges.MsgUniversalUpdateCollection({
  creator: convertToBitBadgesAddress(ethWallet.address),
  collectionId: '0', // 0 for new collection
  badgesToCreate: [
    {
      amount: '100',
      badgeIds: [{ start: '1', end: '100' }]
    }
  ],
  managerTimeline: [
    {
      manager: convertToBitBadgesAddress(ethWallet.address),
      timelineTimes: [{ start: '1', end: Number.MAX_SAFE_INTEGER.toString() }]
    }
  ],
  updateManagerTimeline: true,
  updateBadgeMetadataTimeline: true,
  updateCollectionMetadataTimeline: true
});

// Example: Transfer badges
const transferMsg = new badges.MsgTransferBadges({
  creator: convertToBitBadgesAddress(ethWallet.address),
  collectionId: '1',
  transfers: [
    {
      from: convertToBitBadgesAddress(ethWallet.address),
      toAddresses: ['bb1recipient...'],
      balances: [
        {
          amount: '1',
          badgeIds: [{ start: '1', end: '1' }],
          ownershipTimes: [{ start: '1', end: '18446744073709551615' }]
        }
      ]
    }
  ]
});

const messages = [createCollectionMsg]; // Add your messages here
```

#### Generate Transaction Payload

```javascript
const txPayload = createTransactionPayload(txContext, messages);

if (!txPayload.txnString) {
  throw new Error('Failed to generate transaction payload');
}

console.log('Transaction to sign:', txPayload.txnString);
```

### Step 5: Simulate Transaction

```typescript
import { createTxBroadcastBody } from 'bitbadgesjs-sdk';

const simulationBroadcastBody = createTxBroadcastBody(txContext, messages, '');
```

#### Option A: Using BitBadges API Simulation Endpoint

```javascript
const simulateUrl = "https://api.bitbadges.io/api/v0/simulate";

const simulationResponse = await fetch(simulateUrl, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    tx_bytes: simulationBroadcastBody.tx_bytes,
    // Some APIs accept the full broadcast body for simulation
    ...simulationBroadcastBody
  })
});

const simulationResult = await simulationResponse.json();

if (simulationResult.error) {
  throw new Error(`Simulation failed: ${simulationResult.error}`);
}

// Extract gas used from simulation
const gasUsed = simulationResult.gas_info?.gas_used || simulationResult.gasUsed;
const gasWanted = simulationResult.gas_info?.gas_wanted || simulationResult.gasWanted;

console.log('Simulation successful!');
console.log('Gas used:', gasUsed);
console.log('Gas wanted:', gasWanted);
```

#### Option B: Using Cosmos REST API Simulation

```javascript
const restSimulateUrl = "https://rest.bitbadges.io/cosmos/tx/v1beta1/simulate";

const restSimulationResponse = await fetch(restSimulateUrl, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    tx_bytes: simulationBroadcastBody.tx_bytes
  })
});

const restSimulationResult = await restSimulationResponse.json();

if (restSimulationResult.code && restSimulationResult.code !== 0) {
  throw new Error(`Simulation failed: ${restSimulationResult.raw_log}`);
}

const gasInfo = restSimulationResult.gas_info;
console.log('Gas used:', gasInfo.gas_used);
console.log('Gas wanted:', gasInfo.gas_wanted);
```

### Step 6: Sign and Broadcast Transaction

Note: Before signing and broadcasting, you will want to fix errors from the simulation and most likely adjust gas usage dynamically.

#### Sign the Transaction

```javascript
import { createTxBroadcastBody } from 'bitbadgesjs-sdk';

// Sign the transaction string with your Ethereum wallet
const signature = await ethWallet.signMessage(txPayload.txnString);

// Create the broadcast body
const broadcastBody = createTxBroadcastBody(txContext, messages, signature);
```

#### Broadcast the Transaction

```javascript
// Option A: Using BitBadges API
const broadcastUrl = "https://api.bitbadges.io/api/v0/broadcast";
const response = await fetch(broadcastUrl, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(broadcastBody)
});

const result = await response.json();
console.log('Transaction hash:', result.txhash);

// Option B: Using Cosmos RPC directly
const rpcBroadcastUrl = "https://rpc.bitbadges.io/broadcast_tx_sync";
const rpcResponse = await fetch(rpcBroadcastUrl, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    jsonrpc: '2.0',
    id: 1,
    method: 'broadcast_tx_sync',
    params: {
      tx: broadcastBody.tx_bytes
    }
  })
});
```

### Important Notes

1. **Testnet vs Mainnet**: Ensure you're using the correct RPC URLs and chain IDs
2. **Gas Estimation**: Always estimate gas properly for complex transactions
3. **Sequence Management**: Increment sequence for each transaction from the same account
4. **Error Handling**: Always implement proper error handling for network calls
5. **Security**: Never expose private keys or mnemonics in production code

### Common Issues

* **Account not found**: Ensure the account has been funded at least once
* **Sequence mismatch**: Query the latest sequence before each transaction
* **Insufficient gas**: Increase gas limit for complex transactions
* **Invalid signature**: Ensure the public key extraction and signing process is correct


## File: ./for-developers/claim-builder/auto-completing-claims/automate-w-zapier/README.md

# Integrate with Zapier



## File: ./for-developers/claim-builder/auto-completing-claims/automate-w-zapier/automatic-claim-tutorial.md

# Automatic Claim Tutorial

### Overview

The other option is to trigger claims automatically with Zapier. You will configure the Zap to automatically complete the claim for the user upon a custom trigger. For example, upon purchasing an item, auto-send them a purchased item badge.

To do this, you **MUST** get the users' crypto addresses somehow before the action is executed. This can be beforehand or somehow obtained during the duration of the Zap. We leave this up to you. If you cannot obtain users' addresses, this approach will not work.

We want to note that functionality is slightly different for badges with on-chain balances as opposed to off-chain badges or address lists.

* On-Chain: The check and complete claim action will **RESERVE** the right for the user to complete the claim. However, it does not actually automatically trigger anything on the blockchain. This is because such a transaction requires a signature from the recipient. Thus, the user still has to go to the BitBadges site and complete the claim process, although the reservation process is automatic.
* Off-Chain and Other Claims: For badges with off-chain balances or other claim types, there is no reservation process. The claims are automatically completed. For off-chain badge claims, this means the badges will be auto-distributed. For address lists, this means the address will be automatically appended to the list.

You will use the BitBadges API Zapier plugin with the Complete Claim action to perform the final claim completion. This approach takes special configuration explained in the tutorial below to ensure the claim process is correct and only executable by the Zap. See the tutorial for more information.

<figure><img src="../../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Create the Claim

The first step is to create the claim via the Bitbadges site; however, note that the configuration of the claim must be correct to ensure correct behavior of the claim process and allow Zapier to communicate. Select the Zapier approach when creating, and it should guide you through the process.

Note: Many in-site plugins may become incompatible due to the user not completing in-site. However, you gain access to any custom trigger from 7000+ apps on Zapier.

<figure><img src="../../../../.gitbook/assets/image (195).png" alt=""><figcaption></figcaption></figure>

## Tutorial

Example walkthrough of a custom Zap. Customize to your use case.

Step 1: Create and setup your Zap on [https://zapier.com/](https://zapier.com/). The site will walk you through it all.

Step 2: Select and configure your trigger. Triggers are the action that initiate the automation flow. In this cases, this is a new Udemy course being completed. We leave the selection of the trigger up to you. This will depend on your intended use case.

<figure><img src="../../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Step 3: Configure the Complete Claim by BitBadges integration. The password and other config parameters will be constant and obtained when creating the claim. However, the address may be fetched from prior integrations or manually provided. This is up to you.

<figure><img src="../../../../.gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure>

You can get the claim information from the form when you are creating the claim.

Step 4: Simulate / Test

You may use the simulation feature to test that your claim communicates and will pass without actually executing the action.

Note that behind the scenes, this is just a simulation (does not actually complete the claim) if sent manually from the test step. The claim will actually be completed for successful Zaps once live.

Step 5: Track Progress

For most use cases, just submitting the claim is typically adequate. However, you can also track it with the other BitBadges action in Zapier (Get Claim Attempt Status). You will pass the ID received from the submission to this. Note that we use a queue system so it may take some time to officially process.

And, it is as easy as that!


## File: ./for-developers/claim-builder/auto-completing-claims/automate-w-zapier/overview.md

# Overview

Zapier BitBadges Integration: [https://zapier.com/apps/bitbadges/integrations](https://zapier.com/apps/bitbadges/integrations)

**What is Zapier?**

Zapier is an online automation tool that connects your favorite apps, such as Gmail, Slack, Mailchimp, and more than 2,000 others. You can automate repetitive tasks with workflows known as Zaps. A Zap connects two or more apps to automate part of your business or personal tasks. A Zap is created using a trigger and one or more actions. A trigger is an event in an app that starts the Zap. After a trigger occurs, Zapier automatically completes an action—or series of actions—in another app. This seamless connection between apps enables complex tasks to be completed automatically, saving time and improving productivity.

See all supported apps here: [https://zapier.com/apps](https://zapier.com/apps).

<figure><img src="../../../../.gitbook/assets/image (72).png" alt=""><figcaption></figcaption></figure>

**How does Zapier x BitBadges work?**

Couple ways:

* Claims can be auto-completed from Zapier
* Post-success Zaps can implement utility or rewards
* Dynamic stores can be implemented with automatic updates of the list
* Claim infomration like codes can be automatically distributed to users

<figure><img src="../../../../.gitbook/assets/image (197).png" alt=""><figcaption></figcaption></figure>

When automating claims with Zapier, you will follow the approach of upon doing something (custom trigger), perform an action  (claim a badge, distribute a code, add to dynamic store).

<figure><img src="../../../../.gitbook/assets/image (89).png" alt=""><figcaption></figcaption></figure>

## **Error Handling**

You should also account for the fact that Zaps can partially execute. For example, if you have a Zap with 10 plugins and it fails on the 8th plugin, the Zap will not be considered a success but 8/10 plugins would be executed already. There is no rollback feature.

Similarly, if you are triggering a Zap during a claim's execution, there is no guarantee that the overall claim is successful because other plugins might fail.

## Triggers

The custom trigger step is left up to you to implement from any of the 7000+ app integrations.&#x20;

## **Actions**

With the claim or action step of the automated flow, you have a couple options depending on your use case.

{% content-ref url="../../automate-w-zapier/distribute-claim-information-tutorial/" %}
[distribute-claim-information-tutorial](../../automate-w-zapier/distribute-claim-information-tutorial/)
{% endcontent-ref %}

{% content-ref url="automatic-claim-tutorial.md" %}
[automatic-claim-tutorial.md](automatic-claim-tutorial.md)
{% endcontent-ref %}


## File: ./for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/README.md

# Automate Any Part of the Process

You can also get creative and customize other parts of the claim too, like the distribution of secret information like codes.&#x20;

<figure><img src="../../../../.gitbook/assets/image (196).png" alt=""><figcaption></figcaption></figure>

You can send the claim code, for example, via the Email by Zapier Plugin or Gmail plugin, and once the user receives the email, they can log on to the BitBadges site and select their address to receive the badges for when claiming.

<figure><img src="../../../../.gitbook/assets/image (142).png" alt=""><figcaption></figcaption></figure>



## File: ./for-developers/claim-builder/automate-w-zapier/distribute-claim-information-tutorial/google-forms.md

# Google Forms

## Setting Up a Claim with Google Forms Zapier

The easiest way is to simply create a Zap using the Google Forms and BitBadges integrations. See the link below for a full tutorial.

<figure><img src="../../../../.gitbook/assets/image (145).png" alt=""><figcaption></figcaption></figure>

{% content-ref url="./" %}
[.](./)
{% endcontent-ref %}

## Setting Up a Claim with Google Forms Script Editor

This guide will walk you through setting up a Google Form to generate unique claim codes using a seed code from the BitBadges Codes plugin.

### Prerequisites

* A Google account
* Access to Google Forms
* A claim with the BitBadges Codes plugin

### Steps

#### 1. Create a Google Form

* Go to Google Forms.
* Create a new form or open an existing one. Customize as needed.

#### 2. Open the Script Editor

* In your Google Form, click on the three dots in the upper right corner.
* Select Script editor.

<figure><img src="../../../../.gitbook/assets/image (138).png" alt=""><figcaption></figcaption></figure>

#### 3. Add the Script

1\. Delete any existing code in the script editor.

2\. Copy and paste the following code into the script editor.\


```javascript
var SEED_CODE = 'ENTER_SEED_CODE_HERE';

function onFormSubmit(e) {
  var form = FormApp.getActiveForm();
  var submissionNumber = getSubmissionNumber();
  var code = generateCodeFromSeed(SEED_CODE, submissionNumber);
  setCustomConfirmation(form, code);
}

function generateCodeFromSeed(seedCode, submissionNumber) {
  var data = seedCode + '-' + submissionNumber;
  var hash = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, data);
  var hexHash = hash.map(function(byte) {
    var hex = (byte & 0xFF).toString(16);
    return (hex.length === 1 ? '0' : '') + hex;
  }).join('');
  return hexHash + '-' + submissionNumber;
}

function getSubmissionNumber() {
  var form = FormApp.getActiveForm();
  return form.getResponses().length;
}

function setCustomConfirmation(form, code) {
  var confirmationMessage = "Thank you for completing the survey. Your unique code is: " + code + '. Provide this in the form on BitBadges when claiming.'
  form.setConfirmationMessage(confirmationMessage);
}
```

3\. Replace 'ENTER\_SEED\_CODE\_HERE' with your actual seed code. To get your seed code, use the Codes plugin on BitBadges:

* Click on the Distribute button which opens up the modal.
* Select Batch.
* Copy the seed code.

<figure><img src="../../../../.gitbook/assets/image (139).png" alt=""><figcaption></figcaption></figure>

#### 4. Set Up the Trigger

* In the script editor, click on the clock icon to open the Triggers page.
* Click on + Add Trigger.
* Set the following options:
  * Choose which function to run: onFormSubmit
  * Choose which deployment should run: Head
  * Select event source: From form
  * Select event type: On form submit

<figure><img src="../../../../.gitbook/assets/image (140).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/image (137).png" alt="" width="554"><figcaption></figcaption></figure>

#### 5. Save and Close

Save your script by clicking on the disk icon or pressing Ctrl + S. Close the script editor.

#### 6. Test Your Form

Submit a response to your form.

* Check the confirmation message to see your unique code.
* Note that the forms are assigned based on number of responses (including any test submissions). If you want to reset from scratch, you can delete all saved responses in your form.



**Add-Ons**

Consider adding functionality to the script like sending the code via emails, protecting against multiple submissions, etc. We leave thi sup to you and your needs.



## File: ./for-developers/claim-builder/automate-w-zapier/dynamic-store-zaps.md

# Dynamic Store Zaps

We refer you [here](../dynamic-stores/adding-data.md) for more information.&#x20;

Zaps to add users to a dynamic store may be the most common use case for the BitBadges Zapier integration, notably because they can operate without crypto addresses in favor of emails. You can simply just use the Zap to parse email or user ID or username -> add to the store and let BitBadges handle the rest of the crypto-native stuff.

<figure><img src="../../../.gitbook/assets/image (175).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/automate-w-zapier/leveraging-zapier-ai-actions-mcp.md

# Leveraging Zapier AI Actions / MCP

Leverage Zapier AI actions to build cool use cases with BitBadges x AI. This is applciable ot both the criteria and rewards side.

{% content-ref url="../leveraging-ai.md" %}
[leveraging-ai.md](../leveraging-ai.md)
{% endcontent-ref %}

<figure><img src="../../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/automate-w-zapier/post-success-zaps.md

# Post-Success Zaps

Post-success Zaps are a great way to implement custom utility from over 7000+ apps upon claim successes.

There are two options:

1. Use Webhooks by Zapier plugin and catch a POST request + Post-Success Zap plugin in your claim. This is recommended as it is much more feature complete and allows you to get social identifiers like emails, apps, etc.
2. Use the Claim Success trigger provided by BitBadges x Zapier Integration



For this tutorial, we will showcase Option 1 (recommended):

1. Setup your Zap (in the Zapier interface) with Webhooks by Zapier and catch a POST request

<figure><img src="../../../.gitbook/assets/image (204).png" alt=""><figcaption></figcaption></figure>

2. Configure your Post-Success Zapier Webhook plugin in the BitBadges site. Add the webhook URL it gives you from Step 1. For Zapier, the validation secret is not as important, but you can additionally add a step to check it within the Zap. The JSON preview it shows you will give you all the available fields you can use.

<figure><img src="../../../.gitbook/assets/image (207).png" alt=""><figcaption></figcaption></figure>

3. Use the Send Test Request in the BitBadges site to complete the test / simulation step in your Zap.

<figure><img src="../../../.gitbook/assets/image (205).png" alt=""><figcaption></figcaption></figure>

4. Configure your action with any app and dynamically replace values where needed. For example, if your action is an outbound send email, you will need to parse the email from the webhook and automatically populate the recipient address for the email.

<figure><img src="../../../.gitbook/assets/image (206).png" alt=""><figcaption></figcaption></figure>

5. Setup the rest of your Zap, create the claim, and you are good to go!


## File: ./for-developers/claim-builder/bitbadges-api-claims/README.md

# BitBadges API & Claims



## File: ./for-developers/claim-builder/bitbadges-api-claims/auto-complete-claims-w-bitbadges-api.md

# Auto-Complete Claims w/ BitBadges API

Note: This is a more advanced option that is incompatible with in-site plugins. Before going through the entire process, consider whether you can implement your use case with a plugin-only approach.&#x20;

Typically, we recommend making a custom webhook / plugin over this. Get creative! Use existing plugins, Zapier, create custom plugins, etc as an alternative to needing a complete auto-complete implementation.

<figure><img src="../../../.gitbook/assets/image (4) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Auto-Completion

You can use the BitBadges SDK to auto-complete claims for users.

```typescript
const res = await BitBadgesApi.completeClaim(claimId, address, { ... });
console.log(res.claimAttemptId);

//Sleep 2 seconds to wait for it to be processed in the queue

const res = await BitBadgesApi.getClaimAttemptStatus(res.claimAttemptId);
console.log(res); // { success: true }
```

When creating on the BitBadges site, go to the API Code tab, and you should see code snippets customized to your claim.

<figure><img src="../../../.gitbook/assets/image (119).png" alt=""><figcaption></figcaption></figure>

Couple notes with auto-completing claims:

* If your claim is setup to require proof of sign in, proof of other socials sign ins (Sign In with Discord, etc), you must have the proper session authentication handled.
* Otherwise, you can setup your claim to be open to anyone but restricted by non-session criteria. For example, do not require proof of address but all claimees must present a valid password (potentially only known by you or the code which is expected to claim).

**Simulating**

You can also simulate the claim (which is instant and not put into the queue). There are also options within this request to simulate specific plugins only for further fine-grained testing (\_specificInstanceIds). The complete claim route automatically simulates and returns instantly if simulation fails. If simulation passes, it is put into the queue.

The body is the same as the completeClaim route. See below.

```typescript
const res = await BitBadgesApi.simulateClaim(claimId, address, { ...body });
```

**Custom Body**

Custom plugins may also require custom body inputs from the user. If you are using a custom plugin not created by you, refer to that plugin's documentation or contact the creator for more input on the custom body schema.

You will need to pass \_expectedVersion. This is the version number of the claim that you expect to complete. If there is a version mismatch at claim time, the claim will fail. This is to avoid instances where the claim creator maliciously changes criteria / actions without you knowing. You can specify -1 for don't check, but this is not recommended.

The custom body (if needed) should be in the following format

```typescript
{
    _expectedVersion: '0', //version of the claim (obtained from fetching the claim)
    [instanceId: string]: { ...pluginBody }
}
```

For example,

```typescript
{
    _expectedVersion: '0', //version of the claim 
    [`abc123`]: { //password plugin w/ instance ID = "abc123"
        password: "abc123"
    },
    [`codes1234`]: { //codes plugin w/ instance ID = "codes1234"
        code: "supersecretcode"
    },
}
```

**Customization**

The rest is left up to you. You decide when to trigger this code. It could be when a user signs in, you can auto-trigger based on certain criteria, or anything else you want.


## File: ./for-developers/claim-builder/bitbadges-api-claims/fetching-claims.md

# Fetching Claims

More documentation is available via the API routes for fetching claims.

Go to the JSON tab of the claim details in-site to see an example one. Note that fetchPrivateParams: true is necessary to get certain private information. You must have permissions to view private parameters.

```typescript
// GET https://api.bitbadges.io/api/v0/claim/claimId?...
const claimsRes = await BitBadgesApi.getClaim({ 
    claimId, 
    fetchPrivateParams: false, 
    fetchAllClaimedUsers: true, 
    privateStatesToFetch: [instanceId],
});
```

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/bitbadges-api-claims/verifying-claim-attempts-w-the-api.md

# Verifying Claim Attempts w/ the API

IMPORTANT: Verifying claim attempts are two-fold:

* Authentication: Authenticate the user (can be done with Sign In with BitBadges or however)
* Verifying Claim Attempt: Lookup the claim attempt via the BitBadges API and cross-check the user has satisfied the criteria

Note: You may opt to simply receive a post-success webhook which would take the API verification step out of it.

```typescript
// Pre-Req: Set up your claim at https://bitbadges.io/create
// Pre-Req: User is authenticated

// 1. By address (if you already have it)
// GET https://api.bitbadges.io/api/v0/claims/success/{claimId}/{address}
// successCount will be 1 for on-demand claims and the number of completions for standard
const res = await BitBadgesApi.checkClaimSuccess(claimId, address);
if (res.successCount >= 1) { doSomething(); }

// 2. By attempt ID 
// GET https://api.bitbadges.io/api/v0/claims/status/{claimAttemptId}
const res = await BitBadgesApi.getClaimAttemptStatus(claimAttemptId);
if (res.success) { doSomething() }

// You may also browse all claim-based API routes in the reference like a fetch all claim
// attempts for a user, but the above two are typically what you are looking for.
```

**Claim Attempt IDs vs By Address**

If you already have the user address, you can simply use option 1.

If you want to verify by claim attempt ID, you can use option 2. Claim attempt IDs can be obtained if you are completing the claim on behalf of the user (e.g. via Zapier or the API), or you can set up a custom webhook to receive it.

Note: If you are receiving a post-success webhook, you already know the claim has gone through by the nature of it, so you do not need to verify it.

This will also allow you to map a user address / claim attempt to another social that you may identify your users by. For example, if you authenticate with email, you can request us to verify the user email, receive the email, and use the (ID, email) pair instead of an address.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Use one of the plugins pictured below or a custom plugin to do so when setting up your claim.

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**More Advanced Ways**

Note: You may also implement other ways of verifying claim attempts such as parsing state directly, storing data yourself from webhooks, etc. You can also trust the post-success webook to only be fired upon success. For these, we refer you to the corresponding documentation such as the API. The process is flexible, but the above should be all you need.


## File: ./for-developers/claim-builder/bitbadges-created-plugins/README.md

# BitBadges Created Plugins

##


## File: ./for-developers/claim-builder/bitbadges-created-plugins/ownership-requirements.md

# Ownership Requirements

Below we explain more about the ownership requirements field and schema. This is used in certain plugins for checking badge / list ownership.

```typescript
const ownershipRequirements = {
    $and: [
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 1n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 0n, end: 0n },
                },
            ],
        },
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 2n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 0n, end: 0n },
                },
            ],
        },
    ],
};

const popupParams = {
    ...ownershipRequirements,
};
```

#### **Asset Ownership Requirements**

The **assetOwnershipRequirements** uses an $and, $or, and base case schema to allow you to implement custom logical requirements. For $and requirements, all criteria in the array must be satisfied. For $or, one of the criteria in the array needs tobe satisfied. You can implement the "not" case by saying owns x0 of a badge.

```typescript
assetOwnershipRequirements: {
    $or: [
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 1n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 0n, end: 0n },
                },
            ],
        },
        {
            assets: [
                {
                    chain: 'BitBadges',
                    collectionId: 2n,
                    assetIds: [{ start: 1n, end: 1n }],
                    ownershipTimes: UintRangeArray.FullRanges(),
                    mustOwnAmounts: { start: 1n, end: 1n },
                },
            ],
        },
    ];
}
```

**Options**

As an alternative to $or, we also support specifying **options.numMatchesForVerification** which sets a threshold for how many assets in the current group the criteria needs to pass for. For example, below requires 1 / 1000 badges to be owned out of the IDs 1-1000.

```typescript
assetOwnershipRequirements: {
  assets: [
    {
      chain: 'BitBadges',
      collectionId: 1n,
      assetIds: [{ start: 1n, end: 1000n }],
      ownershipTimes: UintRangeArray.FullRanges(),
      mustOwnAmounts: { start: 1n, end: 1n }
    }
  ],
  options: { numMatchesForVerification: 1n }
}
```

**BitBadges Badge Collections**

For BitBadges assets, we expect the chain = ' BitBadges', all collection IDs to be numeric, and all assetIds to be UintRanges. Querying a user owns a badge at a specific time is also supported via ownership times.

```typescript
{
  chain: 'BitBadges',
  collectionId: 1n,
  assetIds: [{ start: 1n, end: 1000n }],
  ownershipTimes: UintRangeArray.FullRanges(),
  mustOwnAmounts: { start: 0n, end: 0n }
}
```

**BitBadges Address Lists**

For BitBadges address lists, they are supported with the collection ID = 'BitBadges Lists'. The assetIds will be the string list ID. A user will be considered to own x1 if they are on the list and x0 if they are not on the list. Note that with blacklists, they are flipped. Not being on a blacklist equals x1 owned.

```typescript
{
    chain: 'BitBadges',
    collectionId: 'BitBadges Lists',
    assetIds: ["listId"],
    ownershipTimes: UintRangeArray.FullRanges(),
    mustOwnAmounts: { start: 1n, end: 1n }
}
```

**Ethereum / Polygon / Solana NFTs (Beta)**

We also support verifying Ethereum Polygon NFTs through this interface. However, note that we use external APIs to check this, so is not reliant on our infrastructure. Use at your own risk.

```typescript
{
    $and: [
        {
            assets: [
                {
                    chain: 'Polygon', //Or 'Ethereum'
                    collectionId: '0x9a7f0b7d4b6c1c3f3b6d4e6d5b6e6d5b6e6d5b6e',
                    assetIds: ['1'],
                    ownershipTimes: [],
                    mustOwnAmounts: { start: 0n, end: 0n },
                },
            ],
        },
    ];
}
```

#### **Ownership Times** <a href="#ownership-times" id="ownership-times"></a>

```
ownershipTimes: []
```

The default when ownership times is empty or missing is to verify at the current time. If this is the case, we dynamically add the current time as \[{ start: currTime, end: currTime }].

```typescript
ownershipTimes: UintRangeArray.FullRanges();
```

For assets that support ownership times like BitBadges badges, you can specify custom times to check.


## File: ./for-developers/claim-builder/bitbadges-created-plugins/plugin-documentation.md

# Plugin Documentation

Head over to the the BitBadges site link below with the plugin ID you are interested in.

```
https://bitbadges.io/plugins/{pluginId} (e.g. "password")
```

This will give you documentation on the configuration of each plugin, including state management, parameter schemas, user input schemas and more.

<figure><img src="../../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>



## File: ./for-developers/claim-builder/checking-custom-criteria.md

# Checking Custom Criteria

If the in-site plugins are not enough on the criteria side, consider one of the following:

## Dynamic Stores

Dynamic stores can be created in the developer portal. They are simply a list of users stored by BitBadges, managed by you. You attach it to a claim and gate the claim to users in the list.

Stores are nice because they are not tied to a specific claim, and you do not have to deal with addresses if not needed. They are serverless.

You can:

1. Update users manually in-site
2. Update programmatically via the API
3. Update via Zapier - Triggers from 7000+ apps -> add to dynamic store

{% content-ref url="dynamic-stores/" %}
[dynamic-stores](dynamic-stores/)
{% endcontent-ref %}

<figure><img src="../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Custom Webhooks / Plugins

Configure your claim with custom webhooks. Use the "Check Your Own Criteria" plugin. Alternatively, you can use the Forms / Collect Inputs plugin to instead let us store the requests for you, and you can fetch the details in-site / export to CSV format.

Note: The in-site webhook plugins are streamlined alternatives to building your own custom plugins which are a little more feature-rich and reusable.

Be mindful though that if you are checking criteria, you should have verification BEFORE the claim is completed. Post-success hooks cannot affect the outcome.

{% content-ref url="plugins/" %}
[plugins](plugins/)
{% endcontent-ref %}

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Auto-Completion

You could also initiate the completion of claims on behalf of users with the API or via Zapier. This is advanced and a custom plugin / webhook is oftnetimes a better alternative.


## File: ./for-developers/claim-builder/claim-links.md

# Claim Links (URLs)

If users claim in-site, simply direct them to the claim page, such as the following:

[https://bitbadges.io/claims/ad831a95b20ab0aeaa1695ae8ada7bb6](https://bitbadges.io/claims/ad831a95b20ab0aeaa1695ae8ada7bb6)

Or if it is tied with an application, address list, or badge, direct them to the corresponding page there.

#### Auto-filled Details (Advanced / Experimental)

The following details can be auto-filled for the user if specified in the query parameters.

* `code`: The unique code for the Codes plugin (assumes only one code plugin)
* `password`: A password for the Passwords plugin (assumes only one password plugin)
* `claimId`: The unique identifier for the claim. This lets us know which one to highlight.
* `customBody`: The preconfigured JSON encoded claim body for the user. See the API for more information. Note that you will have to URL encode it.
* `approvalLevel`: "collection" | "incoming" | "outgoing". We scan for the claimId (collection level first) but for on-chain collections, you may have claims for user level approvals as well. This is used in the case of duplicate claimIds on different levels.

https://bitbadges.io/collections/1?code=ABC123\&password=securepass\&claimId=98765\&customBody={"exampleInstanceId":%20"abc123"}


## File: ./for-developers/claim-builder/completion-methods.md

# Completion Methods

With BitBadges claims, you will have a couple ways of completing claims. Note on-demand do not have a completion "action", so this is only applicable to standard claims.

**Option 1: Directly In-Site (Recommended)**

Users can claim directly on the corresponding page directly in the BitBadges site. We envision this is to be used for almost all cases. Custom logic can be implemented through custom plugins or webhooks or other means.

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Option 2: Auto-Claim by Zapier**

You can can extend BitBadges Claims with our custom Zapier integration that allows you to connect claims with over 7000+ apps. See all supported apps here: [https://zapier.com/apps](https://zapier.com/apps).

For example, make a purchase on Shopify -> get allocated a badge or complete a course on Udemy -> get a completion badge. The "airdrop" is a claim completion.

<figure><img src="../../.gitbook/assets/image (87).png" alt=""><figcaption></figcaption></figure>

Note: Zapier can also be used to automate other parts of the claim, like specific plugins or implementing post-claim rewards.

**Option 3: Auto-Claim by API**

You can implement a hybrid approach on your own using the BitBadges API and connect it behind the scenes. This allows you full flexibility over the claiming process.

```typescript
const res = await BitBadgesApi.completeClaim(claimId, address, { ... });
```

**Get Creative!**

A common theme you may see when implementing claims is to get creative and think outside the box. There are a ton of integrations and features already implemented. Even if your use case doesn't exactly match the implementation, you can get creative and implement workarounds.

For example,

* Give out claim codes / passwords to those who meet the criteria on your end rather than needing a direct integration.
* Many apps and services are email based rather than username based. Consider using the Email plugin universally.

## Claiming on Behalf of Others

With each claim, there is only one address (the claiming address). There is no initiator and recipient like with standard approvals. If you want to initiate a claim on behalf of others, you have to get a little creative.

**Password (Secrets) Approach**

The typical approach (used for Zapier and other examples) is to disable all user authentication (Signed In to BitBadges) but gate the claim with a password or other secret information. This allows you (who has knowledge of the password) to complete claims.

Because the authentication check is disabled, you can specify any claiming address. However, note that this disables the authentication check for everyone. You must gate the claim in other ways (like the password).

<figure><img src="../../.gitbook/assets/image (187).png" alt=""><figcaption></figcaption></figure>

**OAuth - Complete Claim Scope**

Or, you could also be authorized to complete claims on behalf of the user via the BitBadges API, but this is only used in some cases. You will need separate authorizations from every claiming user. See Sign In with BitBadges for how to implement.


## File: ./for-developers/claim-builder/concepts/README.md

# Concepts



## File: ./for-developers/claim-builder/concepts/claim-numbers.md

# Claim Numbers

By default, we use an incrementing claim number system for standard claims. For example, claim #1, then claim #2, etc.&#x20;

However, certain implementations may custom assign claim numbers, which can be used to implement custom logic, such as distributing specific badges.

Only one plugin is allowed to assign claim numbers which is determined by the **assignMethod** of the claim. If the assignMethod === a plugin's unique instance ID, we allow it to assign claim numbers.

<figure><img src="../../../.gitbook/assets/image (186).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/gating-badge-distribution.md

# Gating Badge Distribution

One utility offered with claims is to gate badge distribution as the reward via the Create -> Badges flow. This uses a special clai type.

For off-chain balances, we can just allocate the balances directly after claiming.

For on-chain badge balances, a successful claim will result in reserving the right to claim, not actually completing the claim. This is because the claim criteria is checked off-chain, and we need an on-chain transfer transaction. It is a two-step process.

Behind the scenes, we reserve the unique claim code for the user. The on-chain transaction will eventually specify that claim code in the eventual transfer transaction. On-chain, these are the leaves of [Merkle challenge](broken-reference) in the approval criteria and are one-time use only to prevent replay attacks. These are not the same codes as the Codes plugin, if enabled.

**When to use claims vs self-hosted balances?**

For claims that gate badge distribution, you may want to evaluate the tradeoff of claims vs self-hosted balances. Claims are handled on a trigger basis. When something occurs or the user attempts to claim, a claim can be completed and transfer badges or perform another claim action.

However, note claims may not be the right choice for you, especially if you already have all the data you need already. If you already have the data, you may consider self-hosting the balances / airdropping badges to your users. This removes the middle action step required to complete the process.

<figure><img src="../../../.gitbook/assets/image (5) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/identify-by-socials-emails.md

# Identify By Socials / Emails?

Do you identify your users by emails or a supported social username?

Select one of the webhook plugins (or forms for serverless) when setting up your claim. This will set you up to be able to track and maintain a map of (attempt ID / address) -> user socials or emails, enabling you to continue identifying your users how you already do!

Note: Verifying claim attempts are two-fold: 1) authenticate the user and 2) verify the claim. In this instance, step 1 would be authenticating the user email / social on your end if needed.&#x20;

{% content-ref url="../plugins/creating-a-custom-plugin/alternatives.md" %}
[alternatives.md](../plugins/creating-a-custom-plugin/alternatives.md)
{% endcontent-ref %}

<figure><img src="../../../.gitbook/assets/image (225).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/monetizing-apps-badges.md

# Payment Checking

If your use case requires monetization (such as memberships or recurring payments), we host an in-site Stripe plugin for you to use. While $BADGE is the native credits of the blockchain and we do offer accepting $BADGE fees per on-chain approval use, we do not recommend using it for payment purposes. We recommend to accept payments using existing processors like Stripe.&#x20;

Note: This is provided for convenience and is not the only solution. You can choose to self-implement payments however you want. Ex: Self-host and gate by emails who have paid.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Setting Up Your Account

To setup a Stripe Connect account, go to the connected accounts section of the Developer Portal ([https://bitbadges.io/developer](https://bitbadges.io/developer)).&#x20;

### Creating a Claim

Once setup, you can then get started creating claims with the Stripe Payment plugin. Users will be prompted to complete the checkout process before claiming.

Note: Refunds are possible (learn more below). In the event of an auto-refund, the Stripe fees are not returned, and you make up the difference.

To mitigate refunds, the golden rule for designing payment-gated claims that avoids any refund logic is that a a specific claim attempt from a user will either always succeed or always fail. It should never be able to succeed at time A but not at time B. In other words, assume that if the queue is backed up for 100 days, that should not alter whether a claim succeeds or fails.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Payment Capture

Since claims and Stripe are two separate services, we can either capture payments immediately before or after the claim has been completed. For our design, we capture claims before to guarantee payment before the claim.

#### How Claims Work Behind the Scenes (The Basic Process)

1. The claim is fully completed / simulated to see if it will succeed (both external and internal logic). This also includes a ready to capture payment check to ensure the user has completed checkout and we are ready.&#x20;
2. If all claim checks pass, the claim is queued. We cache any external logic.
3. We capture the payment here.
4. The claim is added to a queue
5. At the queue's final processing time, we rerun the claim's internal logic (state handling) to ensure it still passes and there are no race conditions. We reuse any external logic from Step 1.
   1. If the sanity check fails, we have to issue a refund to the customer at this point. This is rare but can happen with poor claim design.

This process is often immediate (<1 second), but the time ultimately goes at the speed of the queue.

#### Capture Before Claim

* **What happens**: The payment is captured immediately before the final processing of the claim but after confirming a full simulation.
* **Advantage**: Guarantees payment for successful claims. 100% of users who complete the claim have guaranteed payment went through.
* **Risk**: In the rare case of the sanity check of failing after Step 1) full simulation succeeded, we automatically issue refunds to the customer. Stripe fees are NOT returned, you make up the difference in the refund to each customer (poor user experience as well - 2 charges on statements plus additional processing).
* **Proper Design:** This can always be mitigated with proper claim design. **T**he golden rule is design your claims such that a specific claim attempt from a user will either always succeed or always fail. It should never be able to succeed at time A but not at time B.
  * When might the refund case occur?
    * **Max Uses Exceeded:** 1000 users submit at exact same time with only 1 claim use left. All 1000 get added to the queue. We have to refund 999 of them.
    * **Claim Codes:** If you give out a one-time use code to two users and they both submit at the same time and both make it into the queue, we will have to refund one.
  * Note though, these cases are rare but need to be accounted for
    * It only applies to internal state race conditions, not external fetches
    * Even just a second or two between claim submissions typically would invalidate the initial simulation (Step 1) leading to it never being placed in the queue and payment never being captured.
    * We do our best on our end to mitigate and prevent such cases before they happen


## File: ./for-developers/claim-builder/concepts/receiving-attestations.md

# Receiving Attestations

Within the user inputs for both pre-built and custom plugins, we support accepting the "Attestation" type. This allows you to securely receive user selected attestations they have saved or uploaded which may be private via webhooks or plugins. This is only possible with standard in-site claims because the user has to be signed in and select it manually.

You will receive the attestation in the payload of your request via the **key** you configure. The builder should give you a preview.

{% content-ref url="../plugins/creating-a-custom-plugin/alternatives.md" %}
[alternatives.md](../plugins/creating-a-custom-plugin/alternatives.md)
{% endcontent-ref %}

IMPORTANT: Don't trust, verify! You should also note that we simply provide you with the attestation. Treat BitBadges as the middleman. All custom checks like the content of the messages, issuer is correct, etc.

You need to verify the attestations on your side. Verification is done according to the expected format. If you need to check BitBadges core ones (scheme == 'bbs' || scheme == 'standard'), you can use the SDK's **verifyAttestation** function or API **verifyAttestation** route. If it is a third-party upload, see the corresponding documentation.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/signed-in-vs-select-address.md

# Signed In vs Select Address

To require the user to be signed in, select the Signed In to BitBadges plugin. If not selected, we allow any address to be manually entered without address verification or sign in requirements. However, disabling "Signed In with BitBadges" allows any user to claim on another's behalf. Make sure this is intended and all other criteria properly gates the claim.

By not including a sign-in requirement, this makes the user experience better (no signatures). This is also helpful on mobile or other places where users may not have access to their wallets. However, this can be mitigated with approved sign-ins or other approaches like embedded wallets, but those require prior setup. 

**Auto-Completing Claims**

If you are planning to auto complete claims behind the scenes via the API or via Zapier, note that you have two approaches.

1. OAuth Sign In with BitBadges - The Signed In requirement will pass if you have the Complete Claims ("completeClaims") scope.
2. Disable + Gate In Another Way - For example, our Zapier flow does not check user sign in but gates with a password that only Zapier knows.

<figure><img src="../../../.gitbook/assets/image (198).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/standard-vs-on-demand.md

# Standard vs On-Demand

Claims, at their core, are just criteria checks, but there are two ways we can check this criteria. The first is standard claims which require a "complete claim" process or action:

* Criteria is checked at completion time
* Claim numbers are assigned
* Can maintain statefulness
* Ledger of users who have claimed

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

The second is on-demand (sometimes described as non-indexed). These are a special type of claim that has unique properties. Notably, they are autonomous, self-contained, can be fetched on-demand, stateless, does not require any user inputs, sessions, and can function with just a user address / creator parameters.

The critieria is not indexed anywhere but rather calculated on-demand.

* No indexing
* No claim numbers
* No verifiable list of users who have claimed
* Limited in feature set because you need to be able to check criteria at any time, so you cannot use authenticated sessions or other apporaches
* Calculated in real-time
* No success webhooks

For example, checking a minimum balance of $BADGE is safe to use on-demand because we always know a user's balance at any given time wihtout user interaction and just their address. Another common on-demand check is badge ownership as shown below.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/concepts/universal-approach-claim-codes.md

# Universal Approach - Claim Codes

We want to highlight that claim codes are a universal approach that can be used with any application / criteria. For example,

-   Give codes to finishers of a race
-   Give codes to attendees of an event
-   Give codes to those who sign in to your website
-   Distribute codes via email, SMS, etc
-   And so on. You distribute according to your needs!

No need for a custom integration or to identify the user by an identifier. Simply identify them with a code.

Use the Codes plugin to set the codes for your claim. We recommend auto-generating them for sufficient randomness, but you may also custom create them.

**Generate Codes from Seed Snippet**

Auto-generated codes are calculated from a seed code, rather than needing to store all N codes. Note indexes are zero-based (code #1 = idx 0).

```typescript
import CryptoJS from 'crypto-js';
const { SHA256 } = CryptoJS;
export const generateCodesFromSeed = (
    seedCode: string,
    numCodes: number
): string[] => {
    let currCode = seedCode;
    const codes = [];
    for (let i = 0; i < numCodes; i++) {
        currCode = SHA256(`${seedCode}-${i}`).toString();
        codes.push(`${currCode}-${i}`);
    }
    return codes;
};
```

**Generate Codes from Seed API Endpoint**

Or, outsource the generation to our [API Route](https://bitbadges.stoplight.io/docs/bitbadges/abee9e7fa5f8d-get-code-codes-plugin)

## **Save for Later Links**

You may also consider using a save for later link. See example below.

[https://bitbadges.io/saveforlater?value=38d3fe58dffea3f7a675b587bc9239e0360047b7482d245f6770deb589aef869](https://bitbadges.io/saveforlater?value=38d3fe58dffea3f7a675b587bc9239e0360047b7482d245f6770deb589aef869)

## **Zapier**

The get code via idx from seedCode route is also available in Zapier opening up some cool possibilities like auto-distribution.

{% content-ref url="../automate-w-zapier/distribute-claim-information-tutorial/" %}
[distribute-claim-information-tutorial](../automate-w-zapier/distribute-claim-information-tutorial/)
{% endcontent-ref %}


## File: ./for-developers/claim-builder/dynamic-stores/README.md

# Dynamic Stores



## File: ./for-developers/claim-builder/dynamic-stores/adding-data.md

# Adding Data

**Method 1: UI**

You can directly manage your store in the interface.

**Method 2: API**

```typescript
await BitBadgesApi.performStoreAction(...)
await BitBadgesApi.performBatchStoreAction(...)
```

If you want to use the BitBadges API to send hooks / POST requests to, you can do so manually. We refer you to the interface in the developer portal for getting the exact route / body you might need.

<figure><img src="../../../.gitbook/assets/image (173).png" alt=""><figcaption></figcaption></figure>

**Method 3: Zapier**

Use the BitBadges Zapier integration to automate workflows for you. Zapier connects to over 7000+ integrations. In this case, your trigger will be the app you want to integrate nad the action will be BitBadges Add User to Dynamic Store.

Typically, you will want to field map data from your trigger (e.g. Eventbrite attendee email) into the BitBadges Store Action step. For documentation on how to do this, see Zapiers documentation.

* [Field Mapping](https://help.zapier.com/hc/en-us/articles/31709122224653-Enter-data-in-Zap-fields#01JC4MFMXXJXSS7GBAYZP32XKZ)
* [Send Data Between Steps By Mapping Fields](https://help.zapier.com/hc/en-us/articles/8496343026701-Send-data-between-steps-by-mapping-fields)

You may notice that we have a few different identifier fields (email, address, id, username). Leave the ones you don't need blank. Which field you populate should correspond to the store type you have created.

<figure><img src="../../../.gitbook/assets/image (176).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (174).png" alt=""><figcaption></figcaption></figure>

You can also use the Zapier approach to check criteria as well. For example,

1. Setup a Google Form that users can enter their email (or parse the Gmail from the metadata).
2. Setup a Zap to trigger upon Google Forms responses.
3. Check if existing Mailchimp subscriber using email provided via the Mailchimp integration plugin.
4. Add email to dynamic store if subscribed (note: we only allow claims for verified emails)

If setting up an in-site claim, you can redirect the users to the form via the URL Click plugin, Custom Instructions Plugin, or just in the description as well.


## File: ./for-developers/claim-builder/dynamic-stores/overview.md

# Overview

#### What are Dynamic Stores?

A flexible storage system on BitBadges' side for maintaining lists of:

* Email addresses
* User Crypto addresses
* User IDs / usernames names from platforms like Discord, etc

These can be thought of as a separate store for maintaining a list of users. You then "attach" stores to a claim and gate the claim by checking if a user is in the store. You control it. We store it. Update it:

* Manually in-site in the developer portal
* Automatically w/ API calls

```typescript
await BitBadgesApi.performStoreAction(...)
await BitBadgesApi.performBatchStoreAction(...)
```

* Automatically w/ Zapier - Listen to 7000+ apps and add users to store in no-code

To get started, go to the Developer Portal. This will walk you through the process of creating, attaching, and adding data to the store.

Once your store is created, you can add users / data to it. Note that we add via a queue-based approach, so the data may take a couple moments to populate.

**Attach to a Claim**

The interface should walk you through the process of attaching it to a claim:
1. Directly in claim builder, you should see your stores in the templates section
2. In the stores tab, click Create Claim for a one-click create a claim which is auto-configured
3. Add the corresponding plugin (email for email stores) and add the store in the parameters select

**Store ID and Store Secret**

When creating your store, you will get a store ID and secret. These are to be provided by the API / Zapier when managing data. You can also manage the store without the secret if you are signed in with the owner address.

#### Core Advantages

**1. Reusability**

* Not tied to specific plugins or claims
* Can be shared across multiple verification processes

**2. Dynamic Management**

* Real-time updates on the go (dynamic instead of static)
* For example, as users check in to an event, you can dynamically add them to the store which would then make the plugin pass for those users dynamically

**3. Outsourced Storage**

* As opposed to a traditional plugin where you maintain a validation endpoint and potentially store data, this is outsourced to us.
* The roles are flipped. We handle the storage and validation, and you just send update hooks as they come in.

**4. Not Address Dependent**

* All accounting for claims and other BitBadges services is done primarily with crypto addresses. For example, to complete a claim, you need to specify a claiming address. However, many apps and services do not have such a link from user ID on the app -> crypto address.&#x20;
  * This approach allows you to not need to worry about addresses and only the app identifiers / emails. BitBadges handles the rest.&#x20;

<figure><img src="../../../.gitbook/assets/image (222).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (168).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (223).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/implementing-custom-utility.md

# Implementing Custom Utility

Need to perform some additional action upon the user claiming successfully?

## **Preconfigured Plugins**

The easiest and most typical approach is to just do this with preconfigured plugins. No code required. Many use cases are already implemented for you and will auto execute for you if configured. For example, the Send BitBadges Notification plugin or Assign Discord Role.

<figure><img src="../../.gitbook/assets/image (189).png" alt=""><figcaption></figcaption></figure>

## **Integrations**

Some integrations may check claims automatically for you. For example, create a WordPress gated site by just entering the claim ID to check in the settings.

{% content-ref url="broken-reference" %}
[Broken link](broken-reference)
{% endcontent-ref %}

## **In-Site Rewards - URLs / Content**

When creating rewards on the claim builder page, you can also link gated content / URLs to only be visible to users upon successfully claiming.

You may want additional authentication depending on your tolerance level. You can even consider this in-site URL to initially be a Sign In with BitBadges URL here with eventual redirect support to your destination URL. Authentication becomes streamlined this way.

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Use the BitBadges API

To lookup claim state or recent claim attempts by address or other claim information, use the BitBadges API to query this data. Then, implement your logic as you see fit.

{% content-ref url="bitbadges-api-claims/verifying-claim-attempts-w-the-api.md" %}
[verifying-claim-attempts-w-the-api.md](bitbadges-api-claims/verifying-claim-attempts-w-the-api.md)
{% endcontent-ref %}

## Use Post-Success Zaps

If you want to automate this process, consider using Zapier to auto-execute logic upon claim successes per user.

For example, new claim -> add to Mailchimp list or add to Google Sheets.

<figure><img src="../../.gitbook/assets/image (219).png" alt=""><figcaption></figcaption></figure>

{% content-ref url="automate-w-zapier/post-success-zaps.md" %}
[post-success-zaps.md](automate-w-zapier/post-success-zaps.md)
{% endcontent-ref %}

## **Use Post-Success Webhooks / Plugins / Serverless Request Bin**

<figure><img src="../../.gitbook/assets/image (217).png" alt=""><figcaption></figcaption></figure>

Set up a custom success webhook or plugin (post-success) and receive the configured information (plus any custom user inputs or configured user socials you want to receive) via the payload. By the nature of it being a post-success webhook, you do not even need to verify the claim attempt was successful.

Or, the Collect User Inputs (request bin) plugin is a serverless alternative! Instead of needing your own handler, we store the requests for you. You access them in-site or via the API.

<figure><img src="../../.gitbook/assets/image (218).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/integrate-with-pipedream/README.md

# Integrate with Pipedream



## File: ./for-developers/claim-builder/integrate-with-pipedream/build-custom-plugins.md

# Build Custom Plugins

Building custom plugins with Pipedream could streamline a lot of the development process for you. This is a unique feature that Zapier doesn't offer because you can execute custom code from their SDK rather than just automated workflows that are setup.

Below, we provide an overview in how to do so. For further implementation guides, see the official Pipedream docs and the Custom Plugins docs. All principles of creating and setting up your custom BitBadges plugin apply. This will just streamline the authentication and logic handling on your end.&#x20;

{% content-ref url="../plugins/" %}
[plugins](../plugins/)
{% endcontent-ref %}

Note when building custom plugins, it is typically not recommended to trust full on automation workflows since these are asynchronous and may not handle the claim plugin logic quick enough. Please use direct API calls or code executed directly, or if you do trigger a full automation workflow, return a quick 200 OK and expect logic to be processed asynchronously (e.g. post-claim rewards).

[https://pipedream.com/docs](https://pipedream.com/docs)

**Pipedream SDK**

If you only need your own authentication and not end users, you can simply set this up with the standard SDK code.&#x20;

```javascript
import { axios } from "@pipedream/platform"
export default defineComponent({
  props: {
    slack: {
      type: "app",
      app: "slack",
    }
  },
  async run({steps, $}) {
    return await axios($, {
      url: `https://slack.com/api/users.profile.get`,
      headers: {
        Authorization: `Bearer ${this.slack.$auth.oauth_access_token}`,
      },
    })
  },
})
```

**Pipedream Connect**

Pipedream Connect allows you to actually obtain the access tokens for your users and directly execute API requests on their behalf all programmatically. This takes all of the authentication setup out for you. This is great for seamlessly building third-party custom plugins. Simply setup Pipedream Connect in your app, and then, you have SDK access to 1000s of API integrations at your fingertips. We refer you to their docs for setting this up.

Note that there are two flows for authenticating users:

* Manually triggered by your frontend - If you already have a frontend, you may consider just handling it all there.
* [Connect links](https://pipedream.com/docs/connect/connect-link) - You redirect the user to a Pipedream connect URL and Pipedream handles it for you. This could be useful if you want to make a headless plugin without a custom frontend.

Your frontend URL or connect URL can be configured in the tutorial / user input redirect URI when building your custom plugin. Then, once you have the authentication, you can handle your logic in the plugin handler as you see fit.&#x20;

Or, alternatives including adding custom instructions or developing a configuration tool.

<figure><img src="../../../.gitbook/assets/image (211).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/integrate-with-pipedream/end-to-end-example.md

# End to End Example

This will walk you through an entire end-to-end auto-completion flow for Pipedream. This will assume you need the whole stack of per-user authorizatioon and auto-completing claims. If you do not, you can remove some of these steps and adapt for your use case.

Note: This is not the only way to implement. It is just a guided tutorial.

With user authentication, you will need your users to go through the Pipedream Connect authorize flow somehow. Each user will be identified by an `external_user_id` that you set, and once they authorize, you can specify to use that user's authorization details in the automation workflow. Their authorization details are stored under that user ID within your Connect app.

See docs here: [https://pipedream.com/docs/connect](https://pipedream.com/docs/connect). When creating a project, you can also get a step by step tutorial through the Connect tab.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

We leave this step open ended up to you. For the sake of the tutorial, we are going to assume that the claim is to be auto-completed upon user authorization. We will also use the Pipedream SDK Connect Link feature to outsource the frontend code, but Pipedream also is flexible for more custom flows.

You will need to create a **token** (short-lived) which can be used to create a Connect Link (see [https://pipedream.com/docs/connect/connect-link](https://pipedream.com/docs/connect/connect-link)). Note the `external_user_id`you use for this user. This is done server-side.

This is also open-ended. For this tutorial, we are going to use a proxy handler endpoint to generate the Connect Link to not need frontend code at all.

If you want to have a headless no frontend plugin, you can consider adding the Custom Instructions plugin in a claim with a link to a proxy handler endpoint. Because tokens are short-lived and generated dynamically, this should be a proxy one that generates the Connect URL and redirects users there (User -> Proxy Handler -> Generate Connect Link -> Redirect to Connect Link).

Let's say our proxy handler endpoint is hosted on `https://my-proxy-handler.com/generate-connect-link`. You will redirect your users to this endpoint to initiate the Connect Link flow. Consider adding this in the claim description or custom instructions plugin or however you want to expose it to your users.

The proxy handler endpoint is as follows:

```typescript
import express from 'express';
import { serverConnectTokenCreate } from '@pipedream/sdk/server';

const app = express();
const PORT = process.env.PORT || 3000;

// Configuration for Pipedream
const PIPEDREAM_CONFIG = {
    clientId: process.env.PIPEDREAM_CLIENT_ID,
    clientSecret: process.env.PIPEDREAM_CLIENT_SECRET,
    appSlug: process.env.PIPEDREAM_APP_SLUG, // Your app's slug from Pipedream
};

// Proxy handler endpoint
app.get('/generate-connect-link', async (req, res) => {
    try {
        //TODO: Get the user ID from query params or however you want to identify the user
        const externalUserId = req.query.userId;

        if (!externalUserId) {
            return res.status(400).json({ error: 'Missing userId parameter' });
        }

        // Generate the short-lived token
        const { token, expires_at } = await serverConnectTokenCreate({
            external_user_id: externalUserId,
            credentials: {
                clientId: PIPEDREAM_CONFIG.clientId,
                clientSecret: PIPEDREAM_CONFIG.clientSecret,
            },
        });

        // Success / error handler URIs
        const successRedirectUrl =
            'https://my-success-redirect-url.com/auth-callback';
        const errorRedirectUrl =
            'https://my-error-redirect-url.com/error-callback';

        // Construct the Connect Link URL
        const connectUrl = `https://pipedream.com/_static/connect.html?token=${token}&connectLink=true&app=${PIPEDREAM_CONFIG.appSlug}&success_redirect_url=${successRedirectUrl}&error_redirect_url=${errorRedirectUrl}`;

        // Redirect the user to the Pipedream Connect flow
        res.redirect(connectUrl);
    } catch (error) {
        console.error('Error generating Connect link:', error);
        res.status(500).json({
            error: 'Failed to generate Connect link',
            details: error.message,
        });
    }
});

// Optional: Callback endpoint for after authorization
app.get('/auth-callback', (req, res) => {
    res.send('Authorization successful! You can close this window.');

    //TODO: Trigger the workflow here if you want to auto-complete the claim automatically (see below)
});

app.get('/error-callback', (req, res) => {
    res.send('Authorization failed!');
});

// Start the server
app.listen(PORT, () => {
    console.log(`Proxy handler running on port ${PORT}`);
});
```

The final Pipedream Connect URL the user will be redirected to is:

```
https://pipedream.com/_static/connect.html?token={token}&connectLink=true&app={appSlug}&success_redirect_url={successRedirectUrl}&error_redirect_url={errorRedirectUrl}
```

Once the user has completed the authorization, you can now use that `external_user_id`to perform authenticated requests. If you want to do this in a headless way, you can use the success callback URL to automatically do it upon completion.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

For this tutorial, we will auto-complete a claim with their no-code workflow interface ([https://pipedream.com/docs/connect/workflows](https://pipedream.com/docs/connect/workflows)). Follow along here for implementation details. Alternatively, you can directly execute code too without a workflow using their SDK or also fetch the user's authorization credentials and use them in your own code. We recommend the interface for ease of use and testing.

Below, we will explain at a high level and will skip over some lower level details.

1. Create a workflow in the Pipedream site with a HTTP POST webhook trigger.
2. Configure authorization for the webhook. This can be done in a couple ways.
   1. Use Pipedream OAuth
   2. Check for a secret hardcoded value (add a step after) to make sure you are the origin of the request
   3. No authentication - if you do not add authentication, the only thing saving the endpoint from unwanted requests is the knowledge of the endpoint itself. It is important to not leak it if this is your approach
3. When adding your custom actions, select to use the end user's authentication. See the Pipedream docs for testing this. You will probably need to generate a test account and specify the external user ID in the headers.
   1. Ex: For adding a Slack action with the user's authentication, add another step with Slack and select the little switch icon to use user authentication.
4. We recommend using the API request w/ code (NodeJS) feature. You customize your criteria checks here. You may setup custom parameters parsed from the trigger per claim or static hardcoded props. We leave this open-ended up to you. The only requirement is that if a user that does not meet the criteria, this step should throw an error / fail.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

5. Lastly, set up the BitBadges action step as the final action in the workflow. We refer you to the workflow actions for the options here. Typically, you will auto-complete claims if you have the user's crypto address. If not, it may involve setting up and adding a dynamic store. Make sure to test or simulate before actually claiming for real. Also, ensure you are dynamically adding the user info from prior steps and not hardcoding it.

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

6. The workflow setup is now complete. The workflow will be triggered upon the HTTP request. It will then use the provided `external_user_id`and execute the claim criteria checks from your configured apps and finally, it will complete a BitBadges claim or add to a dynamic store as the final action properly gating the claim.

You can then invoke the workflow per unique `external_user_id`as shown here with the SDK. Or, you can also trigger via HTTP.

```typescript
import { createBackendClient, HTTPAuthType } from "@pipedream/sdk/server";

// These secrets should be saved securely and passed to your environment
const pd = createBackendClient({
  environment: "development", // change to production if running for a test production account, or in production
  credentials: {
    clientId: "{oauth_client_id}",
    clientSecret: "{oauth_client_secret}",
  },
  projectId: "{your_project_id}"
});

await pd.invokeWorkflowForExternalUser(
  "{your_endpoint_url}", // pass the endpoint ID or full URL here
  "{your_external_user_id}" // The end user's ID in your system
  {
    method: "POST",
    body: {
      message: "Hello World"
    }
  },
  HTTPAuthType.OAuth // Will automatically send the Authorization header with a fresh token
)
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/leveraging-pipedream-mcp.md

# Leveraging Pipedream MCP

Pipedream Connect / MCP is super powerful as you can connect BitBadges to 3000+ integrations on the criteria and the rewards side.  We refer youy here for more information!

{% content-ref url="../leveraging-ai.md" %}
[leveraging-ai.md](../leveraging-ai.md)
{% endcontent-ref %}



## File: ./for-developers/claim-builder/integrate-with-pipedream/overview.md

# Overview

Similar to Zapier, Pipedream allows you to build automation workflows. We recommend checking out what is possible via Zapier first. Everything there can be done with Pipedream as well. Pipedream may have less connected apps, but it is more extendible and developer friendly.

**Custom Plugins**

Because Pipedream allows more customization on your level (in addition to just automation workflows), you can use their SDK to implement custom plugins seamlessly. This streamlines the development process and helps you connect to 1000s of applications seamlessly!

{% content-ref url="build-custom-plugins.md" %}
[build-custom-plugins.md](build-custom-plugins.md)
{% endcontent-ref %}

**Automation Workflows**

Automation workflows with Pipedream and BitBadges allow you to auto-complete claims, auto-add users to dynamic stores, implement post-claim logic, and more

Get started by creating a workflow with the BitBadges configuration. Then, you can copy/paste the code provided from the actions / triggers in the subpages of this section to programmatically interact with the BitBadges API. We refer you to the Zapier flows documentation for the high-level concepts and designs.

{% embed url="https://pipedream.com/apps/bitbadges" %}

{% content-ref url="../auto-completing-claims/automate-w-zapier/" %}
[automate-w-zapier](../auto-completing-claims/automate-w-zapier/)
{% endcontent-ref %}

{% content-ref url="workflow-actions/" %}
[workflow-actions](workflow-actions/)
{% endcontent-ref %}

{% content-ref url="workflow-triggers/" %}
[workflow-triggers](workflow-triggers/)
{% endcontent-ref %}

For the inputs, there are two ways of configuring. You may nee dto slightly adapt the templates to fit your desired flow.

Props - You set it manually via the props

```typescript
export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    },
    claimInfo: {
      type: "string",
      "label":  "Claim Information",
      optional: false, // Use optional: false instead of required: true
    },
...
```

Dynamic - Parse from the trigger / another step (steps.trigger.event)

```typescript
export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      const response = await axios($, {
        method: 'POST',
        url: `https://api.bitbadges.io/api/v0/claims/status/${steps.trigger.event.claimAttemptId}`,
 ...
```

<figure><img src="../../../.gitbook/assets/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>



## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/README.md

# Workflow Actions



## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/add-user-to-dynamic-store.md

# Add User to Dynamic Store

```typescript
import { axios } from "@pipedream/platform"

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      await axios($, {
        method: 'POST',
        url: `https://api.bitbadges.io/api/v0/storeActions/add/${steps.trigger.event.dynamicDataId}/${steps.trigger.event.dataSecret}`,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'x-api-key': this.bitbadges.$auth.api_key
        },
        data: {
          "address": steps.trigger.event.address,
          "id": steps.trigger.event.id,
          "email": steps.trigger.event.email,
          "username": steps.trigger.event.username
        }
      })

      return { success: true }
    } catch (error) {
      $.export('error', error)
      throw error
    }
  },
})
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/complete-claim.md

# Complete Claim

To complete a claim, enter this code in your workflow with [the BitBadges integration](https://pipedream.com/apps/bitbadges) and adapt as needed. &#x20;

The **claimInfo** is in the format: ${claimId}-${passwordPluginInstanceId}-${password}. You can setup the password plugin manually or select the Automation Workflow completion method -> Copy.

This is the approach we use for automation workflows. We remove any sign in requirements, but anyone claim must specify the secret password (only known to Pipedream / Zapier).

```
62f59244fc1003e331f183c4b3907f87-ecdb0ed0513716af3124899f6e7b5da70eb85c4399dafe2bf970236b34940da9-30892aa1bb0f84b19ecf244958c9cd4676400e13a24791e7512bc88efa217c89
```

<figure><img src="../../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

```typescript
import { axios } from "@pipedream/platform";

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    },
    claimInfo: {
      type: "string", // Claim details passed as a string in the format "claimId-passwordPluginId-password"
    },
    address: {
      type: "string", // Address of the user
    },
    isSimulation: {
      type: "boolean", // Boolean to determine if this is a simulated run
      default: false,
    },
  },
  async run({ steps, $ }) {
    const details = this.claimInfo.split("-");
    if (details.length !== 3) {
      throw new Error("Invalid claim details parsed");
    }

    const claimId = details[0];
    const passwordPluginId = details[1];
    const password = details[2];

    const endpoint = `https://api.bitbadges.io/api/v0/claims/${
      this.isSimulation ? "simulate" : "complete"
    }/${claimId}/${this.address}`;

    const data = {
      _expectedVersion: -1, 
      [`${passwordPluginId}`]: {
        password: password,
      },
    };

    try {
      const response = await axios($, {
        method: "post",
        url: endpoint,
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
          "x-api-key": `${this.bitbadges.$auth.api_key}`,
        },
        data,
      });

      const result = response;

      // Note: This means a successful trigger (add to queue), not a claim completion
      // You can use the claimAttemptId to poll
      return {
        success: true,
        claimAttemptId: result.claimAttemptId || "",
        currentTimestamp: Date.now()
      };
    } catch (error) {
      throw new Error(`Failed to complete claim: ${error.message}`);
    }
  },
});
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-attempt-status.md

# Get Claim Attempt Status

```typescript
import { axios } from "@pipedream/platform"

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      const response = await axios($, {
        method: 'POST',
        url: `https://api.bitbadges.io/api/v0/claims/status/${steps.trigger.event.claimAttemptId}`,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'x-api-key': this.bitbadges.$auth.api_key
        },
        data: {}
      })

      return {
        success: response.success,
        error: response.error
      }
    } catch (error) {
      $.export('error', error)
      throw error
    }
  },
})
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-actions/get-claim-code-by-idx.md

# Get Claim Code by Idx

```typescript
import { axios } from "@pipedream/platform"

//TODO: Edit where you get the props from. Static manually entered props are in via
//      the props field. Or you can configure to use steps.trigger.event.propName
//      for dynamic props from the trigger or other steps

export default defineComponent({
  props: {
    bitbadges: {
      type: "app",
      app: "bitbadges",
    }
  },
  async run({steps, $}) {
    try {
      const codeIdx = this.sub_by_one 
        ? steps.trigger.event.code_idx - 1 
        : steps.trigger.event.code_idx;

      const response = await axios($, {
        method: 'POST',
        url: 'https://api.bitbadges.io/api/v0/codes',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'x-api-key': this.bitbadges.$auth.api_key
        },
        data: {
          'seedCode': steps.trigger.event.seed_code,
          'idx': codeIdx
        }
      })

      return response;
    } catch (error) {
      $.export('error', error)
      throw error
    }
  },
})
```


## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/README.md

# Workflow Triggers



## File: ./for-developers/claim-builder/integrate-with-pipedream/workflow-triggers/poll-claim-attempts.md

# Poll Claim Attempts

For polling claim attempts, we recommend that you jsut set up a custom success webhook with the HTTP trigger on Pipedream. This can be directly configured into your workflow by just adding the POST endpoint URL it gives you.

<figure><img src="../../../../.gitbook/assets/image (212).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/image (213).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/leveraging-ai.md

# Leveraging AI

A great way to implement both criteria and utility is through AI models and agents. This will follow along with the plugins / webhooks that we already have in place!

**Reward Side**

On the reward side, simply set up a post-success claim, receive any user identifiers or inputs needed, and trigger your actions. This can be custom webhooks to any model or service of your choice (Pipedream Connect / MCP, Zapier MCP, anything!), and we also have an in-site plugin for you to use the Zapier AI Actions / MCP service!

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

**Criteria Side**

On the criteria side, this is recommended to follow the dynamic stores approach. While you can check and trigger AI models during execution time, we typically recommend against this due to long wait times and poor UX. If you pre-add a user to a dynamic store, the claim process is good UX for the user.

{% content-ref url="dynamic-stores/" %}
[dynamic-stores](dynamic-stores/)
{% endcontent-ref %}

This is left open-ended. You could leverage Zapier AI Actions / MCP and the BitBadges integration to do this automatically.

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

```typescript
import fetch from 'node-fetch';

const ZAPIER_API_KEY = 'ADD_YOURS';

const options = { method: 'GET', headers: { 'x-api-key': ZAPIER_API_KEY } };

const fetchActions = async () => {
  const response = await fetch('https://actions.zapier.com/api/v2/ai-actions/', options);
  const data = await response.json();
  return data;
};

const executeAction = async (actionId: string, email: string) => {
  const options = {
    method: 'POST',
    headers: { 'x-api-key': ZAPIER_API_KEY, 'Content-Type': 'application/json' },
    body: `{"instructions":"Add ${email} to the store" ,"params":{}}`
  };

  await fetch(`https://actions.zapier.com/api/v2/ai-actions/${actionId}/execute/`, options)
    .then((response) => response.json())
    .then((response) => console.log(response));
};
```


## File: ./for-developers/claim-builder/other-tutorials/README.md

# Other



## File: ./for-developers/claim-builder/other-tutorials/add-telegram-bot-to-channel.md

# Add Telegram Bot to Channel

This guide will walk you through the process of adding the BitBadges bot (@bitbadges\_bot) to your Telegram channel. By integrating this bot, you can enhance your channel with BitBadges functionality.

### Prerequisites

* You must be an admin of the Telegram channel where you want to add the bot.
* You need to have the Telegram app installed on your device.

### Steps to Add the BitBadges Bot

#### 1. Find the BitBadges Bot

1. Open your Telegram app.
2. In the search bar at the top, type "@bitbadges\_bot".
3. Tap on the BitBadges bot in the search results.

#### 2. Start a Chat with the Bot

1. Tap on the "Start" button to initiate a conversation with the bot.
2. The bot may send you a welcome message with instructions.

#### 3. Add the Bot to Your Channel

1. Go to your Telegram channel.
2. Tap on the channel name at the top to open the channel info.
3. Scroll down and tap on "Administrators".
4. Tap on "Add Administrator".
5. Search for "@bitbadges\_bot" and select it from the results.
6. Review the bot's permissions. Ensure it has the necessary permissions to function properly in your channel.
7. Tap "Done" to add the bot as an administrator.

####


## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/README.md

# Get Integration User IDs



## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/discord.md

# Get Discord Server ID

To get your discord server ID, this can be done by right clicking on the  server -> Copy Server ID,

<figure><img src="../../../../.gitbook/assets/image (60).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/get-discord-user-id.md

# Get Discord User ID

<figure><img src="../../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/other-tutorials/get-integration-user-ids/x-twitch-github-ids.md

# X / Twitch / GitHub IDs

X / Twitter - [https://www.wikihow.com/Find-Your-User-ID-on-Twitter#:\~:text=Visit%20a%20site%20like%20What's,as%20you%20know%20their%20username.](https://www.wikihow.com/Find-Your-User-ID-on-Twitter)

GitHub  - [https://caius.github.io/github\_id/](https://caius.github.io/github\_id/)

Twitch - [https://www.streamweasels.com/tools/convert-twitch-username-to-user-id/](https://www.wikihow.com/Find-Your-User-ID-on-Twitter)


## File: ./for-developers/claim-builder/other-tutorials/in-site-guides.md

# In-Site Guides

The best way to get started with a tutorial is to use the Claim Tester in-site, and simply browse the guides section or experiment by adding plugins. The guides section will have a ton of common patterns and show you how to implement ideas that may or may not be supported natively. Find a similar use case to yours and apply the same steps. Even if there is nothing similar, most of the same principes to apply to almost all integrations.

If you need to see the resulting claim JSON (for advanced implementations), you can also see this in-site under the JSON tab of the claim details.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>



## File: ./for-developers/claim-builder/overview.md

# Overview

```
Note: This documentation is not meant to explain everything in the claim builder interface. It is to provide developer documentation for more advanced use cases.
```

**What are claims?**

BitBadges claims are designed to be a comprehensive tool directly within the site or via the API for you to custom gate your utility. Claims can be simply thought of as: **Meet criteria? -> Offer utility / rewards.** The implementation process aims to be super flexible, allowing you maximum customization.

<figure><img src="../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

**How do claims work? What are plugins?**

Claims are made up of one or more plugins executed in order. By default, all must pass, but this can be customized. Out of the box, we offer plenty of built-in plugins and features with no code required and directly claimable by users in the site. Or, you can extend its functionality with helper tools, custom plugins, Zapier, our API, and more!

Note: Certain plugins may become unavailable due to design decisions. For example, claim codes make no sense for on-demand claims since there is no "complete claim" action.

**Get Creative**

While we do offer a ton of functionality directly in-site, your desired functionality may not be directly supported. Before considering custom implementations, get creative!

* Use claim codes or a password which can be used as a universal approach (no need for a specific app integration)
* Can your users be identified by email? Addresses? Use those plugins or dynamic stores
* Does Zapier support your approach? They have 7000+ apps and integrations natively. Pipedream?

There may also be plenty of ways for you to implement the same thing with varying tradeoffs. Select the best for your use case.

**How to create / manage claims?**

Claims are created and managed in the developer portal.

**What is possible in-site?**

Most of the time, you can directly do everything without a line of code. Get creative and experiment!

* Gate URLs / Content to those who claim with the Rewards tab
* Use the Discord Role Assigner plugin to create gated channels
* Use Stripe Payments to create payment-gated claims
* And much more

**Can claims connect to other BitBadges services?**

Claims are the universal connector. You can not only check criteria from any BitBadges service (badge ownership, >100 points) but also use claims on the reward side (gate mints, award points).

<figure><img src="../../.gitbook/assets/image (221).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/README.md

# Plugins



## File: ./for-developers/claim-builder/plugins/configuration-tools.md

# Configuration Tools

Configuration tools are a helper layer abstracted over the core plugin implementations. Instead of creating new, individual plugins for each use case, you can often reuse existing ones. Configuration tools help the user configure the parameters of existing plugins.

For example,&#x20;

* Google Calendar can be implemented by configuring the Email plugin with the attendee emails
* Auto-configure approved user addresses with the Address Restrictions plugin
* Or any application can be implemented by issuing claim codes with the Codes plugin.

```
Note: This is a more advanced option and is not a great user experience. 
This should only be used in select cases.

Please create custom plugins for better UX.
```

Prompt the user to add the copy / paste the stringified JSON to the Configuration Tools tab on the claim builder.

<figure><img src="../../../.gitbook/assets/image (214).png" alt=""><figcaption></figcaption></figure>

```json
{"pluginId":"codes","version": "0", "publicParams":{"numCodes":1},"privateParams":{"codes":["code123"]}}
```


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/README.md

# Creating a Custom Plugin



## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/alternatives.md

# Pre-Built Webhook Plugins

Configure prebuilt webhook plugins in the claim builder without needing to create an entirely new custom plugin. Just enter the endpoint and configure what you want to receive.If you do not want to actually set up a full handler, you can also use the Forms plugin which allows you to store and view the requests in-site (serverless).

<figure><img src="../../../../.gitbook/assets/image (6) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Note**: These plugins only support a simple POST request and expect a 200 OK response. If you require more custom logic or reusability, a custom plugin is necessary.

### Configuration

* **POST Routes**: Customizable routes for your needs.
* **User Details**: Optionally select to receive user details, like their address, custom inputs, or connected socials (only identifying information and no authentication tokens or details)
* **Validation Secret**: Customize a validation secret to confirm requests are from BitBadges. This is what is entered in the form.
* **Expected Response:** 200 OK within 10 seconds
  * For non-critical logic, consider returning 200 early and asynchronously process.
  * Stateless

### Forms Plugin  - Serverless

The forms plugin is a serverless alternative. This is titled "Collect User Inputs" in the site.

Think of this like a request storage bin. We store the requests that would've been sent to the webhooks for you. You can then view them in-site or fetch them from the API when needed.

```typescript
// Pre: Get the attempt ID. If you do not have it already, see the API reference endpoints

// GET /api/v0/requestBin/attemptData/{claimId}/{claimAttemptId}
const res = await BitBadgesApi.getAttemptDataFromRequestBin("claim123", "attempt123", { ... });
console.log(res);
// { bitbadgesAddress, email, claimAttemptId } 
```

<figure><img src="../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Implementation - Handlers

The request/response flow mirrors that of custom plugins, with the `pluginSecret` replaced by the inputted validation secret. For detailed implementation guidance, refer to the respective documentation. The configuration is done in-site via the claim builder.

1. Setup your plugin handler (see plugin documentation for more information)
2. Create your claim and configure the webhook as one of the plugins, specifying your endpoint
3. Test it out to make sure it is working


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/README.md

# Implement Your Plugin

###


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/api-handler.md

# API Handler

The outgoing request (from BitBadges to your plugin) will be made up of the custom body inputs (passed from your frontend), the claim parameters, plus some contextual information about the claim and the claiming user.

* **Plugin Secret:** A plugin secret value that you can use to verify BitBadges as the origin of the call. This is secret only to you and can be obtained via the developer portal when creating your plugin.
* **Claiming Address:** The **bitbadgesAddress** of the user who is attempting to claim. We also provide the mapped equivalents (**ethAddress**, etc).
  * Note the claiming address may not be verified (signed in) dependeing on the configuration (the user must have the Signed In to BitBadges plugin). If you need to make sure that the user is signed in, use the **isAddressSignedIn** field. This will be true if the claiming user is signed in as the claiming address. All other socials you can assume have been verified / signed in.
* **Claim Information**: Lastly, we also pass the **claimId,** as well as the claim's **createdAt** and **lastUpdated** timestamps. These can be used, for example, to implement version control systems on your end.
* **Claim Attempt ID:** The claim attempt ID is the ID of the attempt, and you can use it to track the status of the claim (whether it eventually fails or succeeds).
* **Attempt Status:** The attempt status (attemptStatus) will be 'executing' during the execution of the claim. If you subscribe to success status webhooks (in the configuration), we will also send a second request (with same body and headers) and \_attemptStatus='success'. This can be used to trigger post-claim logic that needs to wait until completion.
* **Simulation (Dry Run) Flag:** The **\_isSimulation** flag tells you whether this is a known dry run.

For POST, PUT, and DELETE requests, we pass the values over the body. For GET, we pass them over the GET params. You are responsible for making sure the endpoint is accessible (e.g. no CORS errors, etc.). Make sure it is the desired type as well (i.e. GET vs POST vs DELETE vs PUT).

```typescript
const payload = {
    ...customBody, //if applicable
    ...allConfiguredParams, //if applicable

    // Context info

    email: 'bob@abc.com', //If pass email is configured
    discord: { id: '...', username: '...', discriminator: '...' }, //If configured
    twitch: { id: '...', username: '...' }, //If configured
    twitter: { id: '...', username: '...' }, //If configured
    github: { id: '...', username: '...' }, //If configured
    google: { id: '...', username: '...' }, //If configured
    pluginSecret: pluginDoc.pluginSecret,
    claimId: context.claimId,
    claimAttemptId: context.claimAttemptId,
    bitbadgesAddress: context.bitbadgesAddress, //If pass address is configured
    ethAddress: context.ethAddress, //If pass address is configured
    solAddress: context.solAddress, //If pass address is configured
    btcAddress: context.btcAddress, //If pass address is configured
    _attemptStatus: context._attemptStatus,
    lastUpdated: context.lastUpdated,
    createdAt: context.createdAt,
    version: context.version,
};
```

### **Identifying the Claiming User**

If you need to identify the claiming user, we pass their address + other requested socials to your endpoint. The socials will all be verified and signed in on our side. The address will be authorized if your plugin specifies the require sign in? option or the claim creator requires sign in.

Although that may not be enough if you identify your users in another way, or you may just not want to fully trust BitBadges. You can also simply check via a secret authorization code. Give them the authorization code on your end while authenticated. Have them enter it as a custom user input in-site. Then, verify it on your end.

### **Responses**

All responses expect a 200 success OK status code within 10 seconds for a successful attempt. For any of the below, do not assume that a 200 OK response means a successful claim and a successful set of the new state. Think of this as a hypothetical state transition IF the claim is eventually successful.

Note: Ensure the returned JSON object keys do not contain any "." characters because that may mess up the state handler. For example, emails should be bob@abc\[dot]com rather than bob@abc.com.

**Stateless Preset**

The stateless preset is simple. If we receive the 200, the plugin is successful. Nothing else is checked via the response. Everything is handled on your end (if you have state).

<figure><img src="../../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) ( (7).png" alt=""><figcaption></figcaption></figure>

**Claim Token Preset**

This preset expects a { claimToken} in the response. The claim token is a one-time use only claim code. Issuing claim tokens is left up to you.

<figure><img src="../../../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Claim Numbers Preset**

This preset expects a { claimNumber } in the response. The claim number is the claim number that will be assigned if the claim number is successful. Claim numbers are 0-based, so claimNumber === 0 is the first claim, and so on.

IMPORTANT: Only one plugin can control claim number assignment. If you select this approach, claims that use this plugin will not be compatible with any other plugin that uses the claim number preset.

Another important decision you will have to consider is whether to reuse your plugin for address lists because claim numbers do not matter for address list plugins. So basically, your plugin will function like the stateless preset for address list claims, if selected.

### **Success Hook Responses**

For success hooks (\_attemptStatus=success), we also expect a 200 OK within 10 seconds. If you need to do asynchronous processing, return 200 OK early and process as you desire.

Otherwise, for failed attempts, we will retry later with an exponential backoff policy.

### **Error Responses**

If your plugin fails, we will save the error for debugging / monitor purposes. It may be displayed to the claiming user and / or claim cretor, so make errors informative but do not reveal sensitive information.

Please follow the { message } interface for returned JSON error responses.

### Example Plugin Handler

<pre class="language-typescript"><code class="lang-typescript"><strong>//TODO: Fill in missing information
</strong>const handlePlugin = async (req: NextApiRequest, res: NextApiResponse) => {
  try {
    //Step 1: Handle the request payload from the plugin
    const body = req.body; //We assume the plugin sends the payload in the body of the request (change this for GET)
    const { claimId, pluginSecret, bitbadgesAddress, ethAddress, solAddress, btcAddress, lastUpdated, createdAt } = body;
    const { ...otherCustomProvidedInputs } = body;
    
    //Handle anything specific to dry runs _isSimulation

    //Step 2: Verify BitBadges as origin by checking plugin secret is correct
    const YOUR_PLUGIN_SECRET = '';
    if (pluginSecret !== YOUR_PLUGIN_SECRET) {
      return res.status(401).json({ message: 'Invalid plugin secret' });
    }

    //Step 3: Implement your custom logic here. Consider checking the plugin's creation / last updated time to implement version control.
    //TODO: 

    //Step 4: Return the response to the plugin based on your configured state function preset
    // const claimTokenRes = { claimToken: '...'  }
    // const statelessRes = {};
    return res.status(200).json({});
  } catch (err) {
    console.log(err);
    return res.status(401).json({ message: `${err}` });
  }
};

export default handlePlugin;
</code></pre>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/design-considerations.md

# Design Considerations

### Your Plugin Status !== Claim Success Status

For processing hooks, note that your plugin may succeed, but this does not mean the overall claim will succeed. Other plugins may fail, or other stuff may go wrong.

If you receive a post-success hook, you can be sure the claim has succeeded. Or, you can use the attempt ID to verify it on your end as well,

### Asynchronous Processing

Claims are processed in an asynchronous manner. For processing hooks, your plugin may succeed, but the claim may not complete until a later time.

Best practices:

* If using state management on BitBadges end for custom plugins, design your plugin to avoid race conditions. For example, do not return the same one-time use claim token to multiple attempts. Most plugins are stateless (on BitBadges end) though and do not have to worry about this. It should always be eventually oconsistent.
* Do not depend on the BitBadges claim state like number of claims completed. It may not be up to date or real-tie at the time of your plugin's execution. Your custom parameters are okay to depend on.

This is not really applicable to post-success hooks.

### State Management

An important aspect to consider is how you will handle state (if applicable). The golden rule here is that a successful response from your plugin DOES NOT mean the overall claim attempt was successful. Other plugins might fail. Or vice versa, your plugin may fail, but the claim succeeds. We only update state on our end if your plugin passed and was in the success path (we short-circuit OR requirements).

You have a couple options:

* Use the preset response patterns to customize how BitBadges controls state for your plugin on our end. This is eventually consistent meaning that you return an intent from your handler, and we update only upon successful claim (and in the success path).
  * A typical flow is to associate certain state with unique claim tokens and let BitBadges handle the claim tokens being marked as USED vs UNUSED.
* Manage state on your end, but be mindful of the way BitBadges processes claims.

### Reusing for On-Demand Claims

To be used with on-demand claims, the plugin must meet specific requirements and have specific properties:

* Stateless - No per-attempt state
* No User Inputs - The plugin should be able to function at any time without any custom user inputs. Note this also includes socials or connected sessions.
* Only Needs Context - The plugin should be able to function with just the contextual information passed. The context mainly includes the plugin information, claim information, and the claimee's address.

Typically, these are only possible with crypto-native plugins. For example,

* Check >1 ETH in account from address
* Check POAP ownership
* Check badge ownership

Parameters are okay because they are hardcoded and not changed (e.g. set min ETH to 1).

### **Authentication / Sensitive Values**

As a design decision, we do NOT want to handle your authentication or sensitive values. Treat BitBadges as a middleman. Authentication should either be fully managed by BitBadges (identifers passed to you like email, usernames) or fully managed by you from start to finish. This applies to both the creator and the end claiming user.

If you need to make authenticated requests on behalf of the user (beyond just receving identification information), you will need to implement authentication on your end. You may let the claim creator store sensitive information in the private parameters of the plugin.

Consider a workaround such as storing any information yourself, mapping it to a token or code, giving that code to the user / creator, and having them enter it in the flow. You then use the token / code to lookup the information in your handler.

This approach follows the same flow as OAuth authorization codes, except with a custom claim code. You should follow all the same best practices (expiring tokens, PKCE for preventing authorization code interception attacks, and more).

<figure><img src="../../../../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/getting-started.md

# Getting Started

To create, publish, and maintain your plugin, go to [https://bitbadges.io/developer](https://bitbadges.io/developer) and use the Plugins tab. This should walk you through the whole process of configuration and submitting it to be used on the BitBadges site. If you are confused at any point, refer back to this documentation.

For testing purposes, you can setup using Pipedream's request bin ([https://pipedream.com/requestbin](https://pipedream.com/requestbin)) and just monitor incoming requests that way.

<figure><img src="../../../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/hook-types-and-simulations.md

# Hook Types and Simulations

### Timing of Hooks

BitBadges can send the request at two different times (during processing hooks and success hooks after successful claim). Certain settings in the creation form can be set to customize how or if we send these. You may choose to receive or ignore them.

* Processing hooks (\_attemptStatus = "executing") are checked during the execution of the claim, and the results could influence whether the claim succeeds or not.
* Post-Success hooks (\_attemptStatus = "success") are only sent after the claim is successful and cannot affect the outcome of the claim. Typically used for post-claim actions or success logic. If a 200 OK is not received, we will use exponential backoff to retry until successful.

<figure><img src="../../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Simulations

```
NOTE: Catching simulations is important. 

You do not want to execute success logic on a dry run.
```

We allow users to simulate claims as a dry run before they actually submit for real. The BitBadges site will always simulate once before submitting, but you should not depend on every claim attempt having a prior simulation.

The scope of the dry run is left up to you, but we recommend as a rule of thumb is that if the user successfully simulates, they are expected to always pass at execution time.

To determine whether you are receiving a simulation hook or a "for real" hook, you can use the \_isSimulation flag that is passed. The claimAttemptId will also be empty / blank, but the rest of the payload should remain the same.

You can select to not receive simulation hooks at all in the usage settings when creating your plugin in the developer portal.


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/parameters.md

# Parameters

Each plugin can configure the expected schema of parameters inputted by the claim creator and the end user. These will all be available in the payload of your handler in addition to contextual information like address, attempt ID, etc.

```json
{
    ...context,
    ...publicParams, // Public to the end users
    ...privateParams, // Private to BitBadges and the claim creator
    ...userInputs
}
```

Parameters will be passed to your backend handler in the payload.

<figure><img src="../../../../../.gitbook/assets/image (163).png" alt=""><figcaption></figcaption></figure>

## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/implementing-your-plugin/user-inputs.md

# Custom Inputs

### Handling User / Creator Inputs

If your plugin requires inputs from the claiming user or claim creator, you can do this in the BitBadges site (recommended) or via a window.postMessage from a custom frontend / tool. All inputs will be passed along to your handler via the payload. If none are provided, we assume there is nothing needed to be passed.

<figure><img src="../../../../../.gitbook/assets/image (165).png" alt=""><figcaption></figcaption></figure>

Note to be compatible with Zapier (and possibly API auto-claiming) or on-demand claims, user inputs are typically not allowed (because the user is not manually initiating anything).&#x20;

**Option 1: Completely In-Site**

When creating the plugin, configure the expected schemas. We will prompt the users / creators to enter such information in-site via a form. All outsourced to BitBadges.

<figure><img src="../../../../../.gitbook/assets/image (121).png" alt=""><figcaption></figcaption></figure>

**Option 2: Custom Frontend**

Consider creating your own frontend that the user will be redirected to via the redirect URL.You will need to combine approaches. This typically follows a code approach. For example, handle secure stuff on your end -> grant an authorization / claim code -> have user add it directly in the site -> use the code for whatever.

**Supported Schema Types**

Primitives: String, Number, Boolean

Date: UNIX millisecond timestamp

URL: Stringified URL

Attestations (for user inputs): [User inputted attestation proofs](../../../../core-concepts/verifiable-attestations/) array.

### Identifying the Claiming User

You can also select to automatically pass supported identifying details about the user (e.g. crypto addresses, Discord, X, GitHub, etc).  Note no access tokens or auth details are passed along so private, authorized requests are not possible with this information.

We will authenticate the user on our end where needed, and you can use their identifying information to execute queries (e.g. public GitHub contributions). The only one that may not be verified in some cases is the claiming address. This depends on the configuration (the user must have the Signed In to BitBadges plugin). If you need to make sure that the user is signed in, check the **isAddressSignedIn** field. This will be true if the claiming user is signed in as the claiming address.

<figure><img src="../../../../../.gitbook/assets/image (215).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../../.gitbook/assets/image (216).png" alt=""><figcaption></figcaption></figure>


## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/managing-your-plugin.md

# Managing Your Plugin

### Updating Your Plugin / Version Control

Management of your plugin is done through the developer portal. You may configure different versions of your plugin. New claims will always use the latest **finalized** version. Existing claims will remain on the version they were created with. Unfinalized versions can ONLY be used by you in the claim tester.

We leave updates and version control management up to you. It is your responsibility to keep claims compatible and functioning. If you need to implement a breaking change, you can also consider using the createdAt, lastUpdated, or version fields passed via the context to implement version control and handle it on your end. Or, you can also create a new plugin.

## File: ./for-developers/claim-builder/plugins/creating-a-custom-plugin/testing-your-plugin.md

# Testing Your Plugin

There are two approaches to testing your plugin.

**Local Development**

Use your favorite tool to simulate requests to your handler such as the one below. Replace with your corresponding details.

```bash
curl -X POST https://yourhandler.com  -H 'Content-Type: application/json' -d '{
  "pluginSecret": "068145b0058668ac5b880e23ca2556e4207efe8066227f4eb3466a6b0d16daa4",
  "claimId": "abcxyz123",
  "claimAttemptId": "...",
  "lastUpdated": 1800000000000,
  "createdAt": 1800000000000,
  "version": "0",
  "_attemptStatus": "executing",
  ...USER_ID_DETAILS, //whatever is configured
  ...YOUR_INPUTS
}'
```

**Test Requests**

In the creation / update interface, there will be a Send Test Request button which will send a formatted request from your browser. This uses mocked data, and should only be used for testing purposes.

<figure><img src="../../../../.gitbook/assets/image (147).png" alt=""><figcaption></figcaption></figure>

**Claim Tester**

The easiest way to test your plugin integration with BitBadges is with the Claim Tester tab in the developer portal. This is the only place you will be able to test unfinalized versions of your plugin.

<figure><img src="../../../../.gitbook/assets/image (8) (1) (1).png" alt=""><figcaption></figcaption></figure>

## File: ./for-developers/claim-builder/plugins/overview.md

# Overview

Plugins / webhooks are simply HTTP requests.

1. Configure your plugin / webhook in the BitBadges site
2. Set up your handler at the specified URL / method. Use the payload to implement your logic. The payload includes context about the attempt plus can include the user address, email, social usernames, custom inputs, and more.
   1. Check the pluginSecret to verify BitBadges as the origin of the request if this is important
3. Return the expected response that was configured (e.g. 200 OK)

<figure><img src="../../../.gitbook/assets/image (5) (1) (1).png" alt=""><figcaption></figcaption></figure>

```typescript
const handlePlugin = async (req: NextApiRequest, res: NextApiResponse) => {
  //Step 1: Handle the request payload from the plugin
  const body = req.body; //For POST
  const { _isSimulation, claimId, pluginSecret, bitbadgesAddress, ethAddress, solAddress, btcAddress, lastUpdated, createdAt } = body;
  const { ...otherCustomProvidedInputs } = body;
  
  //Step 1.5: Catch simulations if applicable. Don't run success logic on a dry run
  // if (_isSimulation) return doDryRunStuffOnly();
  
  //Step 2: Verify BitBadges as origin by checking plugin secret is correct
  const YOUR_PLUGIN_SECRET = '';
  if (pluginSecret !== YOUR_PLUGIN_SECRET) {
    return res.status(401).json({ message: 'Invalid plugin secret' });
  }
  
  //Step 3: Implement your custom logic here. Consider checking the plugin's creation / last updated time to implement version control.
  
  //Step 4: Return expected responses
  return res.status(200).json({});
};

export default handlePlugin;
```

We have designed plugins in a way to allow you maximum customization by letting you handle as much of the plugin logic as possible. This is a design decision as we believe the core logic of the distribution process should be decentralized and community-driven (not centralized on BitBadges servers).

**Potential Parties**

* Claim Creator - Entity creating the claim that uses the plugin
* Claiming User - End user attempting to claim
* Plugin Creator - Entity creating the plugin

**Timing of Requests**

Plugins can either be:

* Success hooks: Only sent after the claim succeeds. Typically for post-claim logic or rewards
* Processing hooks: Sent during execution and can affect the overall outcome of the claim depending on the response.

We also allow users to simulate (dry run) their claim attempts. Plugins are expected to handle these as necessary. These are all configurable in the creation process in-site.

**Parts of the Plugin**

* Backend Handler (Your API) - All plugins have a backend handler that we expect a 200 OK response from, along with other details depending on the configuration, at claim time.
* Claim Creator Input Handlers (Public / Private Parameters) - The creator will need to configure public and private parameter, if applicable. This can be done in-site or outsourced to a configuration tool.
* User Input Handlers (Custom Input Body) - The user may also need to enter inputs for the claim attempt. This can also be done in-site or outsourced to your own custom frontend.

<figure><img src="../../../.gitbook/assets/image (5) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**State Management**

If there is any core state required to be used, this must be managed on BitBadges side to avoid race conditions. To workaround this, the plugin will pass along expected updates IF the claim is passed (e.g. mark this one time use claim token as USED IF the claim is successful).

The golden rule here is that a successful response from your plugin DOES NOT mean the overall claim attempt was successful. Other plugins might fail. The other way around is also true. If your plugin fails, the overall claim may still be successful (e.g. 1 out of 10 plugins must pass but yours fails).

**Published Plugins**

Plugins are private and only usable by the creator and approved users by default, but you can publish them as well. Published plugins will be displayable in the directory (after a review process) and selectable by anyone creating a claim.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Plugin IDs vs Instance IDs**

Plugin IDs are constant and specific to a specific plugin type. For example, the password pluginId is "password".

Instance IDs are a unique identifier for a specific plugin in your claim. This is to handle duplicates. For example, you may have two password plugins, one with instance Id "abc" and one with "def". This is just used as a unique identifier and can really be anything. If you only have one instance of a specific type, you can name it the same as the pluginId as well.


## File: ./for-developers/claim-builder/success-logic.md

# Success Logic

Certain claims may make use of the **satsifyMethod** property to implement dynamic logic. This option is currently only available behind the scenes. Frontend defaults to all are required (satisfyMethod = undefined). By default, all plugins must pass without any custom success logic specified.

<figure><img src="../../.gitbook/assets/image (188).png" alt=""><figcaption></figcaption></figure>

This works in the following ways:

* By default, if  **satisfyMethod** is falsy (undefined), ALL plugins are required in order for the overall claim to succeed.
* The "numUses" plugin or those critical to assigning claim numbers are required and cannot be optional
* Claimees are allowed to select which plugins they want to execute / be applied. Behind the scene this uses the **\_specificInstanceIds** property on the simulate / complete API claim request.
* For stateful plugins, we ONLY update the state for the plugins in the success path (we will short circuit where necessary).
  * For example, if there is a requirement group with 2 out of 8 plugins needing success and the first two pass, we will not even check or apply state for the other six.

```typescript
export interface iSatisfyMethod {
  type: 'AND' | 'OR' | 'NOT';
  /** Conditions can either be the instance ID of the plugin to check success for or another satisfyMethod object. */
  conditions: Array<string | iSatisfyMethod>;
  options?: {
    /** Only applicable to OR logic. Implements M of N logic. */
    minNumSatisfied?: number;
  };
}
```



## File: ./for-developers/concepts/README.md

# 👥 Concepts

This section covers core BitBadges concepts that developers need to understand when building with the platform.

## Account System

BitBadges supports multi-chain accounts, allowing users from Ethereum, Bitcoin, Solana, and Cosmos to interact with the same tokens and services using their native wallets and signing methods.


## File: ./for-developers/concepts/accounts-technical.md

# 👥 Accounts (Technical)

## Pre-Readings

* [Cosmos SDK Accounts](https://docs.cosmos.network/main/basics/accounts)
* [Ethereum Accounts](https://ethereum.org/en/whitepaper/#ethereum-accounts)

### Accounts and Validator Operators

For accounts (standard senders of transactions) and validator operators, we support users from four L1 blockchain ecosystems currently (Ethereum, Bitcoin, Solana, and Cosmos).

### **Ethereum**

BitBadges allows Ethereum addresses to use Ethereum's ECDSA secp256k1 curve for keys. The public key for these accounts will be a custom type (forked from [Ethermint](https://github.com/cosmos/ethermint)). This satisfies the [EIP84](https://github.com/ethereum/EIPs/issues/84) for full [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) paths. The root HD path for BitBadges Ethereum-based accounts is `m/44'/60'/0'/0`. BitBadges uses the Coin type `60` to support Ethereum type accounts, unlike other Cosmos chains that use Coin type `118.`

**Signing Method:** All transactions should be signed with EIP712. EIP712 transactions can be generated via the BitBadges SDK.

### **Solana**

BitBadges also extends the SDK's functionality to support Solana signatures signing with a ed25519 key. Addresses are expected to be in the native Base58 format.

**Signing Method:** Transactions will be signed in JSON stringified format with all keys alphabetically sorted. JSON messages can also be generated via the SDK.

### **Cosmos**

Normal Cosmos accounts are also supported with all the Cosmos SDK's native functionality. We refer you to their documentation for further information.

### Bitcoin

BitBadges supports Bitcoin P2WPKH addresses and BIP322 message verification.

**Signing Method:** Transactions will be signed in JSON stringified format with all keys alphabetically sorted. JSON messages can also be generated via the SDK.

### Addresses and Public Keys[​](https://docs.injective.network/learn/basic-concepts/accounts#addresses-and-public-keys) <a href="#addresses-and-public-keys" id="addresses-and-public-keys"></a>

#### **Address Conversion**

<pre class="language-typescript"><code class="lang-typescript"><strong>import { ethToBitBadges, bitbadgesToEth } from 'bitbadgesjs-sdk';
</strong>
<strong>const bitbadgesAddress = ethToBitBadges(address);
</strong>const ethAddress = bitbadgesToEth(bitbadgesAddress);
const bitbadgesAddressFromSolana = solanaToBitBadges(address);
//Note there is no bitbadgesToSolana or ethToSolana due to how the addresses work
</code></pre>

Behind the scenes, the blockchain always uses the mapped BitBadges address, never a Solana or Ethereum address. The Solana / Ethereum addresses are only for visually displaying to the user.

The Bech32 format is the default format for Cosmos-SDK queries and transactions through CLI and REST clients.

#### **Representation** <a href="#addresses-and-public-keys" id="addresses-and-public-keys"></a>

Ethereum Example:

* Address (Bech32): `bb14au322k9munkmx5wrchz9q30juf5wjgz2cfqku`
* Address ([EIP55](https://eips.ethereum.org/EIPS/eip-55) Ethereum Hex): `0xAF79152AC5dF276D9A8e1E2E22822f9713474902`

Solana Example:

* Address (Base58): 6H2af68Yyg6j7N4XeQKmkZFocYQgv6yYoU3Xk491efa5
* Address (Bech32): bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl

Bitcoin Example

* Address (Native - P2WPKH): bc1q9s7rynm5pwhluhecsmlku8rn5yej5wdgj0gv3e
* Address (Bech32): bb19s7rynm5pwhluhecsmlku8rn5yej5wdg8g75f9

#### **Public Key Types**

For standard Cosmos accounts, the public key will have the `"@type": "/cosmos.crypto.secp256k1.PubKey"`.

For Solana accounts, the public key will have the `"@type": "/cosmos.crypto.ed25519.PubKey"`.

For standard Ethereum accounts, the public key will have the `"@type": "/ethereum.PubKey"`.

`{"@type":"/ethereum.PubKey","key":"AsV5oddeB+hkByIJo/4lZiVUgXTzNfBPKC73cZ4K1YD2"}`

### Deriving BitBadges Ethereum Account from a private key/mnemonic[​](https://docs.injective.network/learn/basic-concepts/accounts#deriving-injective-account-from-a-private-keymnemonic) <a href="#deriving-injective-account-from-a-private-keymnemonic" id="deriving-injective-account-from-a-private-keymnemonic"></a>

Below you will see an example code snippet on how to derive a BitBadges Account from a private key and/or a mnemonic phase:

```typescript
import { Wallet } from 'ethers'
import { Address as EthereumUtilsAddress } from 'ethereumjs-util'

const mnemonic = "indoor dish desk flag debris potato excuse depart ticket judge file exit"
const privateKey = "afdfd9c3d2095ef696594f6cedcae59e72dcd697e2a7521b1578140422a4f890"
const defaultDerivationPath = "m/44'/60'/0'/0/0"
const defaultBech32Prefix = 'bb'
const isPrivateKey: boolean = true /* just for the example */

const wallet = isPrivateKey ? Wallet.fromMnemonic(mnemonic, defaultDerivationPath) : new Wallet(privateKey)
const ethereumAddress = wallet.address
const addressBuffer = EthereumUtilsAddress.fromString(ethereumAddress.toString()).toBuffer()
const bitbadgesAddress = bech32.encode(defaultBech32Prefix, bech32.toWords(addressBuffer))
```

Let's see an example code snipped on how to derive a public key from a private key:

```typescript
import secp256k1 from 'secp256k1'

const privateKey = "afdfd9c3d2095ef696594f6cedcae59e72dcd697e2a7521b1578140422a4f890"
const privateKeyHex = Buffer.from(privateKey.toString(), 'hex')
const publicKeyByte = secp256k1.publicKeyCreate(privateKeyHex)

const buf1 = Buffer.from([10])
const buf2 = Buffer.from([publicKeyByte.length])
const buf3 = Buffer.from(publicKeyByte)

const publicKey = Buffer.concat([buf1, buf2, buf3]).toString('base64')
const type = '/ethereum.PubKey'
```

#### Acknowledgements

Credit to [https://docs.injective.network/learn/basic-concepts/accounts](https://docs.injective.network/learn/basic-concepts/accounts) and [https://docs.evmos.org/protocol/concepts/accounts](https://docs.evmos.org/protocol/concepts/accounts).


## File: ./for-developers/concepts/accounts.md

# 👤 Accounts

This page will give you an overview of BitBadges accounts. It should be enough information for most, but for more low-level interaction, [the next page](accounts-technical.md) will give you more in-depth explanations.&#x20;

#### **How is BitBadges able to support addresses from different blockchains?**

To enable interoperability between different blockchains, each individual L1 blockchain will have its native addresses mapped to an equivalent Cosmos bech32 address and an account ID number. An account ID number will be assigned to the address when it interacts with the BitBadges blockchain or is sent $BADGE for the first time.&#x20;

As an example, the Ethereum null address 0x0000000000000000000000000000000000000000 maps to the BitBadges address bb1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs7gvmv and will be assigned an account ID number upon interaction with the BitBadges blockchain. It would also map to an equivalent Bitcoin address as well.

<figure><img src="../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

#### **Representation** <a href="#addresses-and-public-keys" id="addresses-and-public-keys"></a>

Ethereum Example:

* Address (Bech32): `bb14au322k9munkmx5wrchz9q30juf5wjgz2cfqku`
* Address (Native - [EIP55](https://eips.ethereum.org/EIPS/eip-55) Ethereum Hex): `0xAF79152AC5dF276D9A8e1E2E22822f9713474902`

Solana Example:

* Address (Native - Base58): 6H2af68Yyg6j7N4XeQKmkZFocYQgv6yYoU3Xk491efa5
* Address (Bech32): bb18el5ug46umcws58m445ql5scgg2n3tzagfecvl

Bitcoin Example&#x20;

* Address (Native - P2WPKH): bc1q9s7rynm5pwhluhecsmlku8rn5yej5wdgj0gv3e
* Address (Bech32): bb19s7rynm5pwhluhecsmlku8rn5yej5wdg8g75f9

#### Why can I convert Solana address to a  BitBadges / Eth / BTC address but not the other way around?

You may notice that you cannot go from a BitBadges / Eth address directly to a Solana address but you can the other way around. This is because conversion from a Solana address requires a hash, so if you just have the postimage of the hash (an Eth / BitBadges address), you cannot deduce the preimage without prior knowledge of it.

#### **Which address should I use (native or mapped one)? How to convert?**

For user experience, you should always display the user's native address on a frontend. However, the BitBadges blockchain **only** uses the mapped BitBadges addresses behind the scenes, never a native address. This can be converted behind the scenes using the converter functions from [BitBadges SDK](../bitbadges-sdk/) (address-converter). This can be done with any validly formatted address.

<pre class="language-typescript"><code class="lang-typescript"><strong>import { ethToBitBadges, bitbadgesToEth, convertToBitBadgesAddress } from 'bitbadgesjs-sdk';
</strong><strong>
</strong><strong>
</strong><strong>const bitbadgesAddress1 = convertToBitBadgesAddress(address);
</strong><strong>const bitbadgesAddress = ethToBitBadges(address);
</strong>const ethAddress = bitbadgesToEth(bitbadgesAddress);
const bitbadgesAddressFromSolana = solanaToBitBadges(address);
//Note there is no bitbadgesToSolana or ethToSolana due to how the addresses work
</code></pre>

#### **How do I query details for an address?**

1. You can use the [BitBadges API](../bitbadges-api/api.md) to get information about an address (recommended option). This is the recommended options because we have indexed all the data already for you.
2. You an also query a BitBadges blockchain node directly, either through the CLI or  [REST API ](https://docs.cosmos.network/v0.46/run-node/interact-node.html).&#x20;


## File: ./for-developers/concepts/address-mappings-lists.md

# 📧 Address Lists (Lists)

[AddressLists](https://bitbadges.github.io/bitbadgesjs/interfaces/iAddressList.html) are a powerful feature with range logic similar to UintRanges. They allow us to specify a list of addresses, identified by a listId.

```typescript
export interface AddressList {
    listId: string;

    addresses: string[];
    whitelist: boolean;

    uri: string;
    customData: string;
}
```

### Inverting (Whitelist vs Blacklist)

These are invertible meaning we can create a list that includes all addresses EXCEPT some specified addresses (whitelist = false). Or, we can create a list that includes ONLY some specified addresses (whitelist = true). More commonly, this is thought of as a blacklist or whitelist.

**IMPORTANT:** When you invert, the inversion by default includes the "Mint" address. This is important when handling the **fromList** of approvals. You do not want to accidentally approve users to transfer from the "Mint" address.

### **Storage**

**On-Chain:** AddressLists are **permanent and not updatable** once created, if stored on-chain. These can be created using [MsgCreateAddressLists](../create-and-broadcast-txs/cosmos-sdk-msgs/).

They can be used to define transferability on-chain. For example, list "xyz" can only transfer to list "abc" initiated by the reserved "Manager" list.

The same address list is not unique to a collection on-chain and can be used for defining transferability by any collection.

**Off-Chain:** Address lists can also be created off-chain through our indexer / API. These are updatable and deletable, along with additional options. However, this is a centralized solution and doesn't use the blockchain. Everything is simply stored on our centralized servers

### **Reserved Address List IDs**

There are a couple IDs for AddressLists that are reserved for efficient shorthand methods. To enable this, "\_" and ":" and "!" are not allowed anywhere in a standard ID.

-   If prefixed with "!", it denotes to invert the address list (e.g. "!id123" inverts the "id123" address list)
-   Any valid Cosmos (bech32) address is reserved as the list that ONLY includes that specific address.
-   "Mint" specifies the "Mint" address only.
-   "AllWithoutAddress1" denotes all valid user addresses excluding Address1 (e.g. "AllWithoutMint")
-   "AllWithoutAddress1:Address2:Address3" denotes all valid user addresses excluding Address 1,2,and3 (e.g. "AllWithoutMint:bb123...:bb456...")
-   "All" or "AllWithMint" denotes all valid user addresses as well as the "Mint" address

See below for the function for generating them.

### Custom IDs

Reserved address lists are provided for convenience, so you don't actually have to create an AddressList on-chain first. However, long list IDs are very inefficient, especially if used multiple times (e.g. "AllWithoutMint:bb123...:bb456...").&#x20;

For efficiency, consider creating a list with a unique short ID and reference the list that way. You can create a list which is all addresses except Mint, bb123..., bb456... and identified by the ID "abc". Instead of repeating the long "AllWithoutMint:bb123...:bb456..." wherever the ID is needed, you can simply repeat "abc" which saves a lot of resources.

### Examples

This is the list which includes all addresses except "bb123...." and "bb456...."

```typescript
{
  "listId": "abcdef",
  "addresses": ["bb123...", "bb456...."],
  "whitelist": false,
  ...
}
```

<pre class="language-typescript"><code class="lang-typescript"><a data-footnote-ref href="#user-content-fn-1">function</a> getReservedList(
  addressListId: string,
  allowAliases?: boolean,
): AddressList {
  let inverted = false
  let addressList: AddressList | undefined = undefined

  if (addressListId[0] === '!') {
    inverted = true
    addressListId = addressListId.slice(1)
  }

  if (addressListId === 'Mint') {
    addressList = {
      listId: 'Mint',
      addresses: ['Mint'],
      whitelist: true,
      uri: '',
      customData: '',
      createdBy: '',
    }
  } else if (addressListId.startsWith('AllWithout')) {
    addressList = {
      listId: addressListId,
      addresses: [],
      whitelist: false,
      uri: '',
      customData: '',
      createdBy: '',
    }

    const addresses = addressListId.slice(10).split(':')

    for (let address of addresses) {
      addressList.addresses.push(address)
    }
  } else if (addressListId === 'AllWithMint' || addressListId === 'All') {
    addressList = {
      listId: addressListId,
      addresses: [],
      whitelist: false,
      uri: '',
      customData: '',
      createdBy: '',
    }
  } else if (addressListId === 'None') {
    addressList = {
      listId: 'None',
      addresses: [],
      whitelist: true,
      uri: '',
      customData: '',
      createdBy: '',
    }
  } else {
    //split by :
    const addressesToCheck = addressListId.split(':')
    let allAreValid = true
    //For tracker IDs, we allow aliasses(aka non valid addresses)
    if (!allowAliases) {
      for (let address of addressesToCheck) {
        if (address != 'Mint' &#x26;&#x26; !convertToBitBadgesAddress(address)) {
          allAreValid = false
        }
      }
    }

    if (allAreValid) {
      addressList = {
        listId: addressListId,
        addresses: addressesToCheck,
        whitelist: true,
        uri: '',
        customData: '',
        createdBy: '',
      }
    }
  }

  if (inverted &#x26;&#x26; addressList) {
    addressList.whitelist = !addressList.whitelist
  }

  if (!addressList) {
    throw new Error(`Invalid address list ID: ${addressListId}`)
  }

  return addressList
}
</code></pre>

[^1]:


## File: ./for-developers/concepts/balances.md

# 📊 Balances

For an overview, first read [Balances / Transfers](../../overview/how-it-works/time-dependent-ownership.md).

```typescript
export interface Balance<T extends NumberType> {
  amount: T;
  badgeIds: UintRange<T>[]
  ownershipTimes: UintRange<T>[]
}
```

**Interpreting Balances**

When interpreting balances, there are certain rules to keep in mind. If we have multiple ranges of badge IDs and ownership times defined within a single Balance structure, it means that we own all possible combinations.&#x20;

```
for (balance of balances) {
    for (badgeIdRange of balance.badgeIds) {
        for (ownershipTimeRange of balanace.ownershipTimes) {
            //User owns x(balance.amount) of (badgeIdRange) for the times (ownershipTimeRange)
        }
    }
}
```

For example, lets say we have a balance of&#x20;

<pre class="language-json"><code class="lang-json"><strong>{ 
</strong>    amount: 1, 
    badgeIds: [{ start: 1, end: 10}, {start: 20, end: 30}], 
    ownershipTimes: [{start: 20, end: 50}, {start: 100, end: 200}] 
}
</code></pre>

This can be expanded and thought of as owning:

* x1 of IDs 1-10 from times 20-50&#x20;
* x1 of IDs 1-10 from times 100-200
* x1 of IDs 20-30 from times 20-50
* x1 of IDs 20-30 from times 100-200

If we wanted to subtract the first set of balances (x1 of IDs 1-10 from times 20-50), we would then need to represent it as two separate balances:&#x20;

```
{ 
    amount: 1, 
    badgeIds: [{ start: 1, end: 10}, {start: 20, end: 30}], 
    ownershipTimes: [{start: 100, end: 200}] 
}
```

```
{ 
    amount: 1, 
    badgeIds: [{start: 20, end: 30}], 
    ownershipTimes: [{start: 20, end: 50}}] 
}
```

**Duplicates**

If you specify duplicate badge IDs in balances such as:

```
{ 
    amount: 1, 
    badgeIds: [{ start: 1, end: 10}, {start: 1, end: 10}], 
    ownershipTimes: [{start: 100, end: 200}] 
}
```

This is equivalent and will be treated as:

```
{ 
    amount: 2, 
    badgeIds: [{ start: 1, end: 10}], 
    ownershipTimes: [{start: 100, end: 200}] 
}
```


## File: ./for-developers/concepts/chain-details.md

# ✏ Chain Details

Cosmos Chain ID (Mainnet) - bitbadges-1

Cosmos Chain ID (Testnet) - bitbadges-2

[Cosmos SDK Coin Denom](https://docs.cosmos.network/main/modules/bank) - "ubadge" (1 $BADGE = 1 \* 10^9 ubadge)


## File: ./for-developers/concepts/uint-ranges.md

# 🔢 Uint Ranges

<pre class="language-typescript"><code class="lang-typescript"><strong>export interface UintRange&#x3C;T extends NumberType> {
</strong>  start: T;
  end: T;
}
</code></pre>

A core type behind the scenes in BitBadges is the [UintRange](https://bitbadges.github.io/bitbadgesjs/interfaces/iUintRange.html) type, which simply defines a range of numbers from some start value to some end value, inclusive. This allows us to apply powerful range logic.

These are typically used for representing badge IDs and time ranges. For example, transferring badges will require an UintRange\<number>\[] of badgeIds to be specified. If you say to transfer \[{ start: 1, end: 10}, {start: 20, end: 50}], it will transfer the badge IDs 1-10 and 20-50.

**Restricted Values**

If used for badge IDs or times, we only allow the start and end to be within the range of 1 to Go's math.MaxUint64 or 18446744073709551615 (**so no zero value and no value greater than that**).

To represent a "full" or "complete" range, use \[{ start: 1, end: 18446744073709551615 }]. If we invert a range, we get all the values from 1 to 18446744073709551615 that are not in the current range.

```json
"transferTimes": [
  {
    "start": "1",
    "end": "18446744073709551615"
  }
]
```


## File: ./for-developers/core-concepts/README.md

# 🧠 Concepts



## File: ./for-developers/core-concepts/maps.md

# Maps / Protocols

Maps are similar to anchors, but they allow you to store data on-chain in a structured way. They are simply key-value maps, and the configuration can be set with customization options like "no duplicates", "expect integere values"", and so on. With maps, you can create universal, reusable, flexible protocols for your users.

```json
{
    "bb...1234": "English",
    "bb...5678": "Spanish"
}
```

```json
{
    "BitBadges Follow Protocol": 12, //collection ID 12 is used for my follows
    "Experiences Protocol": 13
}
```

This is all facilitated through the x/maps module and its correspondingMsgs. See the Msgs for more information.

```typescript
export interface iMap<T extends NumberType> {
    creator: string;
    mapId: string;
    inheritManagerTimelineFrom: T;
    managerTimeline: iManagerTimeline<T>[];
    updateCriteria: iMapUpdateCriteria<T>;
    valueOptions: iValueOptions;
    defaultValue: string;
    permissions: iMapPermissions<T>;
    metadataTimeline: iMapMetadataTimeline<T>[];
}
```

**Reserved Maps**

All maps are identified by a **mapId.** The following **mapId** values are reserved:

* Any valid Bech32 BitBadges address - These are reserved for maps that can only be created by that specific address. This can be a place to store important values custom to you (that address).
* Any numeric ID is reserved for the corresponding badge collection with a matching ID. This can only be created by the badge collection manager. This can be used to store core details that belong on-chain for the collection not handled by the core badge collection interface.

**Use Cases**

* Alternative permissions - Store other permissions related to a collection in these maps on-chain
* Router for important information - For example, lets say thte collection has credentials attached to it. This can point to where the credentials can be found or important info needed to verify them.
* Protocols - On the next page, we expand on the concept of protocols which allow users to specify what collection they want to use for a certain protocol (e.g. use my collection 10 for the Follow Protocol).

**Manager**

The manager is similar to the badges interface. They are granted admin privileges to update certain things about the map.This is handled by **managerTImeline** and the **canUpdateManager** permission.

Maps also have the option to **inheritManagerTimelineFrom** a specific collection. This emans that the manager of the badge collection specified will be used instead of the **managerTimeline** field.

**Genesis Conditions**

Protocols may have expected genesis conditions or additional checks to be correctly implemented. There are no checks on-chain for genesis conditions but these can be handled by you.

**Map Type**

There are really four different map types.

* Manager only means only the manager can update values
* Collection ID means map key smust be numeric and only owners of badge ID N from the collection ID specified can update key = N.
* Creator only means keys are address-based. You can only update the value for your address. This uses mapped BitBadges addresses.
* First come, first serve means that map slots are open but once claimed, they can not be overwritten unless unset by the user who claimed the slot.

```typescript
export interface iMapUpdateCriteria<T extends NumberType> {
    managerOnly: boolean;
    collectionId: T;
    creatorOnly: boolean;
    firstComeFirstServe: boolean;
}
```

**Permissions / Expected Values**

```typescript
export interface iValueOptions {
    noDuplicates: boolean;
    permanentOnceSet: boolean;
    expectUint: boolean;
    expectBoolean: boolean;
    expectAddress: boolean;
    expectUri: boolean;
}
```

```typescript
export interface iMapPermissions<T extends NumberType> {
    canUpdateMetadata: iTimedUpdatePermission<T>[];
    canUpdateManager: iTimedUpdatePermission<T>[];
    canDeleteMap: iActionPermission<T>[];
}
```

**Map Metadata**

Map metadata follows the same interfaces as badges and address lists.

```typescript
export interface iMapMetadataTimeline<T extends NumberType> {
    timelineTimes: iUintRange<T>[];
    metadata: iCollectionMetadata;
}
```


## File: ./for-developers/core-concepts/verifiable-attestations/README.md

# Attestations - Advanced



## File: ./for-developers/core-concepts/verifiable-attestations/creating-a-attestation.md

# Creating an Attestation

Pre-Readings: [Verifiable Attestations](./)

On the official site, we provide interfaces to create attestations (Create -> Attestations). You can also self-generate locally and upload via the BitBadges API as well. Below, we provide information on how it works behind the scenes.

<figure><img src="../../../.gitbook/assets/image (135).png" alt=""><figcaption></figcaption></figure>

**Programmatic Generation / Verification**

The creation interface is as follows. All attestations are a series of one or more **messages** which can be either in 'json' or 'plaintext' **messageFormat**. You can use the corresponding API endpoint to create programmatically.

```typescript
await BitBadgesApi.createAttestation(...)
await BitBadgesApi.updateAttestation(...)
```

```typescript
export interface CreateAttestationPayload {
    /**
     * Proof of issuance is used for BBS+ signatures (scheme = bbs) only.
     * BBS+ signatures are signed with a BBS+ key pair, but you would often want the issuer to be a native address.
     * The prooofOfIssuance establishes a link saying that "I am the issuer of this attestation signed with BBS+ key pair ___".
     *
     * Fields can be left blank for standard signatures.
     */
    proofOfIssuance: {
        message: string;
        signature: string;
        signer: string;
        publicKey?: string;
    };

    /** The message format of the messages. */
    messageFormat: 'plaintext' | 'json';

    /** Whether or not the attestation is displayable on the user's profile / queryable by ID.
      If true, the attestation can be queried by anyone with the ID. */
    publicVisibility?: boolean;

    /**
     * The scheme of the attestation. BBS+ signatures are supported and can be used where selective disclosure is a requirement.
     * Otherwise, you can simply use your native blockchain's signature scheme.
     */
    scheme: 'bbs' | 'standard' | 'custom' | string;

    /** The original provider of the attestation. Used for third-party attestation providers. */
    originalProvider?: string;

    /** The type of the attestation (e.g. credential). */
    type: string;
    /**
     * Thesse are the attestations that are signed.
     * For BBS+ signatures, there can be >1 messages, and the signer can selectively disclose the attestations.
     * For standard signatures, there is only 1 attestationMessage.
     */
    messages: string[];

    /**
     * This is the signature and accompanying details of the messages. The siganture maintains the integrity of the messages.
     *
     * This should match the expected scheme. For example, if the scheme is BBS+, the signature should be a BBS+ signature and signer should be a BBS+ public key.
     */
    dataIntegrityProof: {
        signature: string;
        signer: string;
        publicKey?: string;
        isDerived?: boolean; //Used for BBS signatures to differentiate original vs derived proofs
    };

    /** Metadata for the attestation for display purposes. Note this should not contain anything sensitive. It may be displayed to verifiers. */
    name: string;
    /** Metadata for the attestation for display purposes. Note this should not contain anything sensitive. It may be displayed to verifiers. */
    image: string;
    /** Metadata for the attestation for display purposes. Note this should not contain anything sensitive. It may be displayed to verifiers. */
    description: string;
}
```

### **Schemes / Expected Formats**

The **messageFormat** = 'json' or 'plaintext' will determine what format the messages should be in.

The **scheme** field will determine a lot about the attestation:

* 'bbs': The N **messages** must be signed using the BBS+ signature algorithm. A proof of issuance is also required. The schema of the message is left up to the issuer. See below.
* 'standard': Only 1 attestation message is expected. The message should be signed using a standard wallet signature. The schema of the message is left up to the issuer. See below.
* 'custom' or anything else: If you do not want to use a BitBadges native scheme, you can also simply add your own. Feel free to use existing models such as the [W3C Verifiable Credentials](https://www.w3.org/TR/vc-data-model-2.0/) model, create your own, or anything else.

More can be found in the individual scheme documentation later in this section.

### Creating / Verifying Signatures

Note: When received from the BitBadges API directly, you can assume that signatures are already correct for non-custom implementations (bb or standard). However, it is always best practice to verify them on your end as well.

Public keys are currently only needed to be provided for Cosmos signatures in order to verify. Otherwise, you can leave them blank.

#### Standard Signatures

For standard signatures (**scheme** = 'standard'), you can sign 1 message (so **messages**.length = 1), and the **dataIntegrityProof** will be the resulting signature of the only message from your main key pair supported natively by BitBadges. See the signing transaction flow for more information on manually implementing signatures. No **proofOfIssuance** is required (can be left blank).

```typescript
const sig = await chain.signChallenge(attestation.messages[0]);
const pubKey = await chain.getPublicKey(chain.address);

body = {
    ...attestation,
    dataIntegrityProof: {
        signer: chain.address,
        signature: sig.signature,
        publicKey: pubKey,
    },
    proofOfIssuance: {
        signature: '',
        signer: '',
        message: '',
    },
};
```

#### **BBS+ Signatures**

For BBS+ signatures (**scheme** = 'bbs'), you can sign N **messages** and the **dataIntegrityProof** will be the BBS signature of those N message. On the BitBadges site, all BBS+ key pairs are one-time use only. The key pair is generated, signs the transaction, and then is discarded because it is never needed again.

Note: blsSign creates the original and proofs can be derived from that (see later pages in this section).

<pre class="language-typescript"><code class="lang-typescript">import { BlsKeyPair, blsSign, generateBls12381G2KeyPair } from '@mattrglobal/bbs-signatures';

<strong>const signature = await blsSign({
</strong>  keyPair: keyPair!,
  messages: attestation.messages.map((message) => Uint8Array.from(Buffer.from(message, 'utf-8')))
});

setAttestation((prev) => ({
  ...prev,
  dataIntegrityProof: {
<strong>    signer: Buffer.from(keyPair?.publicKey ?? '').toString('hex'),
</strong>    signature: Buffer.from(signature).toString('hex'),
    isDerived: false
  }
}));
</code></pre>

Because BBS+ are not actually signed by your "main" address, we also require a **proofOfIssuance** to establish this link.

```typescript
const message = `I approve the issuance of credentials signed with BBS+ ${attestation.dataIntegrityProof.signer} as my own.\n\n`;
const sig = await chain.signChallenge(message);
const publicKey = await chain.getPublicKey(chain.bitbadgesAddress);
body = {
    ...attestation,
    proofOfIssuance: {
        message,
        signer: chain.address,
        signature: sig.signature,
        publicKey,
    },
};
```

### Alternative Schemes

Note that non-BitBadges native schemes / approaches may have different verification algorithms. Please make sure your approach follows the verification approach.


## File: ./for-developers/core-concepts/verifiable-attestations/creating-and-verifying-a-proof.md

# Verification / Presentations

Pre-Readings: [Verifiable Attestations](./)

Putting it all together, you now need to present the attestation to a verifier when it is needed to be checked.

**Presentations**

Presentations are done with the proof interface which should give the verifier everything they need to check everything. We recommend leveraging our authentication flow (Sign In with BitBadges) and claims (BitBadges Claims) to be used in conjunction with proof verification / presentation.

* Sign In with BitBadges: Proofs / attestations that are stored in the user's BitBadges account can be revealed / passed along to the authentication provider (the verifier) within the sign-in flow.
* BitBadges Claims: Create a custom plugin or webhook that accepts and verifies attestation(s) from the claiming user when they attempt to claim.

These flows natively have protective measures against replay attacks, time windows for verification, and more.

{% content-ref url="broken-reference" %}
[Broken link](broken-reference)
{% endcontent-ref %}

{% content-ref url="../../../overview/claim-builder/" %}
[claim-builder](../../../overview/claim-builder/)
{% endcontent-ref %}

All attestations should be verified on your end as well. Treat BitBadges as an untrusted middleman. Don't trust, verify!

```typescript
import { BitBadgesApi, verifyAttestation } from 'bitbadgesjs-sdk';

//To outsource to server
await BitBadgesApi.verifyAttestation({ attestation });

//To do it locally
await verifyAttestation(attestation);
```

For any non-BitBadges schemes, we do not maintain any message schemas, verifying integrity, etc. This should all be handled on your end.

**Verification**

Once received, the verifier can then check whatever is needed according to the agreed approach:

* Verifying signatures
* Verifying on-chain anchors / timestamps
* Content is well-formed

Additionally, you should consider:

* If a malicious party gets a cryptographic signature, the signature will still be the same and valid. Thus, it is important to protect against replay attacks, man in the middle attacks, and verify any address ownership as needed. Thus, verification is typically a two-step approach, 1) verify the credential and 2) verify the address of the recipient.
* While the attestation / proof itself can prove the issuer signed the data, it has nothing natively about the holder or presenter. This also needs to be verified.
* The verifier also needs to check the content of the attestation messages and any other app-specific criteria. A valid signature means nothing if the mesage content is not as expected.


## File: ./for-developers/core-concepts/verifiable-attestations/custom-creation-links.md

# Custom Creation Links

To make it convenient for you to redirect users and auto-create attestations, you can create unique create / update links with the details auto-filled out. There are two query parameters that can be passed.

**attestationId:** ID of the existing attestation. Only needed for updates. For create links, leave blank.

**toSet:** A JSON-stringified `CreateAttestationPayload`object that we will set. Not all properties are required. We will only overwrite the ones provided. We refer you to the previous page for configuration.

```
https://bitbadges.io/attestations/create?toSet={}&attestationId=...
```

For example

<pre class="language-typescript"><code class="lang-typescript"><strong>const content: Partial&#x3C;CreateAttestationPayload> = {
</strong>  "messageFormat": "plaintext",
  "type": "credential",
  "scheme": "standard",
  "name": "Custom Name",
  "image": "ipfs://QmNytJNN44stkMndshtdfcCW2mzaCm6A23maiKaQvUqoj8",
  "description": "",
  "messages": [
    "super secret message"
  ]
}

const url = 'https://bitbadges.io/attestations/create?toSet=' + JSON.stringify(content)
</code></pre>

```
https://bitbadges.io/attestations/create?toSet={ "messageFormat": "plaintext", "type": "credential", "scheme": "standard", "name": "Custom Name", "image": "ipfs://QmNytJNN44stkMndshtdfcCW2mzaCm6A23maiKaQvUqoj8", "description": "gfdsgxdfgsdf", "messages": [ "super secret message" ] }
```


## File: ./for-developers/core-concepts/verifiable-attestations/custom-schemes/README.md

# Custom Schemes



## File: ./for-developers/core-concepts/verifiable-attestations/custom-schemes/witness-proofs.md

# WITNESS Proofs

Create WITNESS proofs and custom upload them to BitBadges via our attestation interface.

**Overview**

Anyone can use Witness to create verifiable [provenance](https://docs.witness.co/concepts/provenance) and issue [digital ownership](https://docs.witness.co/concepts/provenance) for any data without the upfront friction or cost of blockchains. This allows developers to build traditionally scalable applications that benefit from Web3 incentives such as:

-   Tokenization: NFTs, tokens, points
-   Universal Verifiability: attestations, logs, timestamps
-   Financialization: mint fees, referral fees, smart contracts composability

We refer you to [their docs](https://docs.witness.co/) for further implementation details.&#x20;

**Scheme Name**

The **scheme** property should be:

```typescriptreact
scheme: "witness-proof"
```

You can also set the originalProvider:

```
"originalProvider": "Witness"
```

**Message Interface**

```
"messageFormat": "json"
```

We expect the following interface for message content (stringified JSON) to be compatible with our UI.&#x20;

```typescript
interface WitnessProof {
    proof: {
        leafHash: string;
        leafIndex: bigint;
        leftHashes?: string[];
        rightHashes?: string[];
        targetRootHash: string;
    };
    chainId?: string;
    preimage?: string;
    timestamp?: number;
    txHash?: string;
}
```

```json
{
  "preimage": "Testing witness proofs",
  "proof": {
    "leafIndex": "30800033",
    "leafHash": "0x570751d4efee586ef4baa79c336778de08b019b69f182e68561ba2b44bce2d7c",
    "leftHashes": [
      "0xfd663a79b001aa5bcd55ce32aae934fc69281bc19b83f287236b572acaf57962",
      ...
    ],
    "rightHashes": [
      "0x3c6710710882171f7a3b07172d7637cfbf385e46fcfe8560eb2822410c4eca8d",
       ...
    ],
    "targetRootHash": "0xf34cf9b13d69ee9af5110841baf2a9b294ff13926d4f60e13222edaa7243de68"
  },
  "timestamp": 10000000, //Unix milli timestamp
  "chainId": "8453", //Defaults to this for "Base"
  "txHash": "0x842f3a5ac844ee222865cb03ea28c04f0eb65a4896b83d40c5cb4900cb7ffcc1"
}
```

Note: When stringified, it would be like this where we have an array of stringified JSON proofs with length 1.

```json
"messages": [
    "{\n  \"preimage\": \"Testing witness proofs\",\n  \"proof\": {\n    \"leafIndex\": \"30800033\",\n    \"leafHash\": \"0x570751d4efee586ef4baa79c336778de08b019b69f182e68561ba2b44bce2d7c\",\n    \"leftHashes\": [\n      \"0xfd663a79b001aa5bcd55ce32aae934fc69281bc19b83f287236b572acaf57962\",\n      \"0x44b18b19f7da0a75ea66af7fa9cdd3e5f376749ff3c201beaa867abfbd99270d\",\n      \"0xb52cfafbe335afc9eb38b74b1b9186c5426807985b99ecc568c338ed22f6d739\",\n      \"0x027cd88daedfbbf04cea7abd17b70504bdfb56d27541e654f5762d44f06e3cce\",\n      \"0xa0f9df4a46928425bb01b40bca6ead558358c62f4b692392cc4e8c76fe2c1fb1\",\n      \"0x53a276dac9002ecb766cb865198e912baf114fd3c95079f19ef2d9abe3a078f4\",\n      \"0xe1af8f9e39e7b57a7eee0d3f47cf111a3291c29ce757d6d542aca8d590bb1013\",\n      \"0xf1250deb418ab6f57d4482e1243cd8aadd021afd546a18a0a067757a0ad6198d\",\n      \"0x1351fef7c4972ebb9ac5b0691c411cf40e1773fbb8168e664bb0b13cffcfa07d\",\n      \"0x2d7002b8f80a5ff993c605298a6453293bc1bc827334fb9d46d6030e01992808\",\n      \"0x000f731409fed7667e5d01e2cf9d8d0da96556bbb2fb7e3b3b8e1028dab70d62\",\n      \"0x6b610a565e82e7eef56d58e66867b32cbd09865d09d991d0835e24786757214e\",\n      \"0xd73a3a8609a8b46cf508d84e040e785ad3cb7cdbc63e18fdf72b4d663f5e0a5f\",\n      \"0xedcbfd0e6a5172e1f0639e9f7e45cdd0bfdc7d05f27cb517deeb17c382b97f6d\"\n    ],\n    \"rightHashes\": [\n      \"0x3c6710710882171f7a3b07172d7637cfbf385e46fcfe8560eb2822410c4eca8d\",\n      \"0x4b3e0a2b6e91e1b788833344c3a1ce8380a5f444156cd314727348fc740ca427\",\n      \"0x8cb377e84af2f9415442daf363253aad4624b4df6bb3f2ce6c5c56d3bcfb2c49\",\n      \"0xdae86492eda6c7ea786ca598c978dade5d0939f28e0fc90f77a0289e1a8628c0\",\n      \"0xdd8c18abd775815100d4999419a2a3a718efcc35f1ffcd150f0068f829ad634a\",\n      \"0x94f2dd188c291f98615941697f93e7c17ca97083993d6bf14a4e5376a3d0c1b0\",\n      \"0x19ce36b7f94c5158073e825d622a58b455f65bc167cc35a2f758cc6d0e21fafb\",\n      \"0x1d8eb78409c5c2699dea20d3b4090afeedf8c3bfd911f2a7b695234d24946ec6\",\n      \"0x9667094385f73adf330afe89f20ee16a1d63f718c17b34eba93e45dfd003deb5\"\n    ],\n    \"targetRootHash\": \"0xf34cf9b13d69ee9af5110841baf2a9b294ff13926d4f60e13222edaa7243de68\"\n  },\n  \"timestamp\": 10000000,\n  \"chainId\": \"8453\",\n  \"txHash\": \"0x842f3a5ac844ee222865cb03ea28c04f0eb65a4896b83d40c5cb4900cb7ffcc1\"\n}"
]
```

\
**Other Fields**

There is no need for **proofOfIssuance** or **dataIntegrityProof** (can be left blank) since everything is included in the message content already.

Everything else is customizable as-is.

**Full Example Attestation**

```json
{
    "updateHistory": [
        {
            "txHash": "",
            "block": "188097",
            "blockTimestamp": "1730123159671",
            "timestamp": "1730123162836"
        }
    ],
    "_docId": "009a55376a52b5df74e15f47397052b3abbf74aee60d8f7399357d566c35e56a",
    "_id": "5d044ba2f73444dd747cd11a",
    "createdBy": "bb1dpxqmz2h835lq88qulvytnq6mpu4x5ylwhmhh9",
    "messageFormat": "json",
    "attestationId": "009a55376a52b5df74e15f47397052b3abbf74aee60d8f7399357d566c35e56a",
    "inviteCode": "b969dd52bf7a9e8ce0811eb214e8249a88cff064b1e61221a3f4c1fda446e423",
    "scheme": "witness-proof",
    "dataIntegrityProof": {
        "signer": "",
        "signature": "",
        "publicKey": ""
    },
    "holders": [],
    "name": "dfgsdfg",
    "image": "ipfs://QmNytJNN44stkMndshtdfcCW2mzaCm6A23maiKaQvUqoj8",
    "description": "gfdsgxdfgsdf",
    "proofOfIssuance": {
        "signature": "",
        "signer": "",
        "message": ""
    },
    "anchors": [],
    "messages": [
        "{\n  \"preimage\": \"Testing witness proofs\",\n  \"proof\": {\n    \"leafIndex\": \"30800033\",\n    \"leafHash\": \"0x570751d4efee586ef4baa79c336778de08b019b69f182e68561ba2b44bce2d7c\",\n    \"leftHashes\": [\n      \"0xfd663a79b001aa5bcd55ce32aae934fc69281bc19b83f287236b572acaf57962\",\n      \"0x44b18b19f7da0a75ea66af7fa9cdd3e5f376749ff3c201beaa867abfbd99270d\",\n      \"0xb52cfafbe335afc9eb38b74b1b9186c5426807985b99ecc568c338ed22f6d739\",\n      \"0x027cd88daedfbbf04cea7abd17b70504bdfb56d27541e654f5762d44f06e3cce\",\n      \"0xa0f9df4a46928425bb01b40bca6ead558358c62f4b692392cc4e8c76fe2c1fb1\",\n      \"0x53a276dac9002ecb766cb865198e912baf114fd3c95079f19ef2d9abe3a078f4\",\n      \"0xe1af8f9e39e7b57a7eee0d3f47cf111a3291c29ce757d6d542aca8d590bb1013\",\n      \"0xf1250deb418ab6f57d4482e1243cd8aadd021afd546a18a0a067757a0ad6198d\",\n      \"0x1351fef7c4972ebb9ac5b0691c411cf40e1773fbb8168e664bb0b13cffcfa07d\",\n      \"0x2d7002b8f80a5ff993c605298a6453293bc1bc827334fb9d46d6030e01992808\",\n      \"0x000f731409fed7667e5d01e2cf9d8d0da96556bbb2fb7e3b3b8e1028dab70d62\",\n      \"0x6b610a565e82e7eef56d58e66867b32cbd09865d09d991d0835e24786757214e\",\n      \"0xd73a3a8609a8b46cf508d84e040e785ad3cb7cdbc63e18fdf72b4d663f5e0a5f\",\n      \"0xedcbfd0e6a5172e1f0639e9f7e45cdd0bfdc7d05f27cb517deeb17c382b97f6d\"\n    ],\n    \"rightHashes\": [\n      \"0x3c6710710882171f7a3b07172d7637cfbf385e46fcfe8560eb2822410c4eca8d\",\n      \"0x4b3e0a2b6e91e1b788833344c3a1ce8380a5f444156cd314727348fc740ca427\",\n      \"0x8cb377e84af2f9415442daf363253aad4624b4df6bb3f2ce6c5c56d3bcfb2c49\",\n      \"0xdae86492eda6c7ea786ca598c978dade5d0939f28e0fc90f77a0289e1a8628c0\",\n      \"0xdd8c18abd775815100d4999419a2a3a718efcc35f1ffcd150f0068f829ad634a\",\n      \"0x94f2dd188c291f98615941697f93e7c17ca97083993d6bf14a4e5376a3d0c1b0\",\n      \"0x19ce36b7f94c5158073e825d622a58b455f65bc167cc35a2f758cc6d0e21fafb\",\n      \"0x1d8eb78409c5c2699dea20d3b4090afeedf8c3bfd911f2a7b695234d24946ec6\",\n      \"0x9667094385f73adf330afe89f20ee16a1d63f718c17b34eba93e45dfd003deb5\"\n    ],\n    \"targetRootHash\": \"0xf34cf9b13d69ee9af5110841baf2a9b294ff13926d4f60e13222edaa7243de68\"\n  },\n  \"timestamp\": 10000000,\n  \"chainId\": \"8453\",\n  \"txHash\": \"0x842f3a5ac844ee222865cb03ea28c04f0eb65a4896b83d40c5cb4900cb7ffcc1\"\n}"
    ],
    "createdAt": "1730123162836",
    "originalProvider": "Witness"
}
```


## File: ./for-developers/core-concepts/verifiable-attestations/deriving-a-proof.md

# Deriving a Proof

### **Standard Signatures**

For standard proofs (scheme = 'standard'), selective disclosure is not possible / supported. Simply copy and paste the **dataIntegrityProof** from the attestation exactly as is. No **proofOfIssuance** is needed.

### Alternative Non-Native Approaches

For custom approaches, this is really left open-ended. You may use the **proofOfIssuance** or **dataIntegrityProof** or any part of the interface however you would like.

In alternative approaches like these, BitBadges is just the middleman, so schemas, well-formedness, and other verification is outsourced to the issuer and / or verifier.

### **BBS+ Proofs - Verifying Proof of Issuance**

An important aspect of verifying BBS+ attestations is to verify the link between the "main" issuer and the BBS+ public key. This is done with the **proofOfIssuance** provided. You should verify that the main issuer has given valid approval to use such an approval as issued by themselves. For BitBadges, we use the scheme of the following.

```typescript
'I approve the issuance of attestations signed with BBS+ a5159099a24a8993b5eb8e62d04f6309bbcf360ae03135d42a89b3d94cbc2bc678f68926373b9ded9b8b9a27348bc755177209bf2074caea9a007a6c121655cd4dda5a6618bfc9cb38052d32807c6d5288189913aa76f6d49844c3648d4e6167 as my own.\n\n';
```

We then verify that the signer of the proof of issuance matches the issuer (createdBy) and he key they approved is the BBS key used for the proof.

```typescript
const bbsSigner = body.proofOfIssuance.message.split(' ')[9];
if (bbsSigner !== body.dataIntegrityProof.signer) {
    throw new Error('Proof signer does not match proof of issuance');
}
const address = body.proofOfIssuance.signer;
const chain = getChainForAddress(address);

if (
    convertToBitBadgesAddress(address) !==
    convertToBitBadgesAddress(body.createdBy)
) {
    throw new Error('Signer does not match creator');
}

await getChainDriver(chain).verifySignature(
    address,
    body.proofOfIssuance.message,
    body.proofOfIssuance.signature,
    body.proofOfIssuance.publicKey
);
```

### **BBS+ Proofs - Creation and Verification**

For verifying BBS+ signatures, it is important to note whether you are verifying a derived proof or the original signature. This is determined by **dataIntegrityProof.isDerived.** Typically, we expect the **dataIntegrityProof.signature** to always be a derived proof when using the **iAttestationsProof** interface.

Note: A proof can only be derived from the original. You cannot derive a proof from another proof.

To create the proof from the original attestation, the following code can be used. **revealed** is he zero-based indices of the messages that are revealed (i.e. messages elem 0 is revealed = \[0])

We use a generic "nonce" as the nonce because we expect proofs to be verified using an alternative sign-in flow that handles replay attacks there / verification.

<pre class="language-typescript"><code class="lang-typescript">import { createAttestationsProof } from "bitbadgesjs-sdk";

const derivedProof = await createAttestationsProof({
<strong>  signature: Uint8Array.from(Buffer.from(attestation.dataIntegrityProof.signature, 'hex')),
</strong>  publicKey: Uint8Array.from(Buffer.from(attestation.dataIntegrityProof.signer, 'hex')),
  messages: attestation.messages.map((message) => Uint8Array.from(Buffer.from(message, 'utf-8'))),
  nonce: Uint8Array.from(Buffer.from('nonce', 'utf8')),
  revealed: attestation.messages
    .map((_, idx) => (proof.messages.includes(attestation.messages[idx]) ? idx : -1))
    .filter((x) => x !== -1)
});

setProof(
  new AttestationsProof({
    ...proof,
    dataIntegrityProof: {
      signature: Buffer.from(derivedProof).toString('hex'),
      signer: attestation.dataIntegrityProof.signer,
      isDerived: true
    }
  })
);
</code></pre>

To verify the original, you need all N messages and will use blsVerify. To verify a derived proof, you only need to know the messages used to derive the proof.

```typescript
import { BitBadgesApi, verifyAttestation } from 'bitbadgesjs-sdk';

//To outsource to server
await BitBadgesApi.verifyAttestation({ attestation });

//To do it locally
await verifyAttestation(attestation);
```


## File: ./for-developers/core-concepts/verifiable-attestations/design-considerations.md

# Design Considerations

Attestations are super open-ended with many different approaches with varying tradeoffs. Below, we outline some additional design considerations or things you may want to think of.&#x20;

## **Badges with Attestations**

Leveraging on-chain badges or tokens could be useful to you if you need stateful data, a ledger of activity, transferability requirements, and more. For example,

-   To "have the credential", you must prove ownership of the badge and the credential. This can be used in cases where the credential itself can be public and is to be displayed in a portfolio (BitBadges) but has certain aspects that may need to maintain private (attestations). The design also may enable credentials to be transferable.
-   Badges can also be used for on-chain, tamper-proof, decentralized revocation or suspension statuses. In the credential somewhere, you say that this badge must not be burned or revoken on-chain for it to be valid.

### Malicious Issuers

All attestations / credentials inherently get their credibility from the issuer, so there is already a bit of trust there. However, additional measures can be taken to protect against a malicious issuer. Some examples include:

-   On-chain ID -> data integrity maps to prevent issuer from issuing duplicates (each credential ID can only correspond to one credential)
-   Anchors / Data Commitments - The issuer or holder can commit to proof of knowledge on-chain at some point which can be verified later. This gives a verifiable timestamp for when the data was known by. See below for more info.

### Custom Logic

It is important to note that proof verification is not limited to that is provided in the interface, you will typically also need to check the attestation messages are as expected against other private values (e.g. matching attestation data to a user). A valid proof is not sufficient if the data is not as expected. This is application-specific, but we expect you to handle everything for proper verification.

### Replay Attacks

Signatures are static, always verifiable, and not "revokable". If a signature gets in a malicious parties' hands, the signature will still be valid. There are many things that can be done to help mitigate this:

-   Revocation registries
-   Authenticating the holder at verification time
-   And many more approaches

### On-Chain Anchors + Update History

While a cryptographic signature proves data integrity / proof of knowledge, you may also need to verify knowledge or integrity with timestamps. For this, consider creating on-chain anchor transactions which can be used for such purposes. Anchors do not necessarily have to reveal private information. Posting a hash, encryption, etc is sufficient as long as it can prove what you need it to prove.

For BitBadges, anchors are facilitated through the x/anchor module (MsgAddCustomData). It is a very simple module that allows you to store arbitrary strings.

If an anchor is created through the BitBadges site, we use the following algorithm. If we have N attestation messages, we also have N entropies. We can then post the SHA256 hash of (message + entropy) on-chain. When revealed to a verifier in a proof, they can verify that data integrity has been maintained if they have the palintext message + entropy value. The random hash posted on-chain reveals nothing confidential but provides a verifiable timestamp for the data. This is facilitated through the x/anchor module's MsgAddCustomData.

```typescript
{
    type: 'MsgAddCustomData',
    msg: {
      data: JSON.stringify(
        attestation.messages.map((message, idx) => {
          return CryptoJS.SHA256(message + entropies[idx]).toString();
        })
      )
    }
}
```

Update history is also maintained by BItBadges in a centralized manner, but anchors could be useful to provide additional information to verifiers about when the data changed, verifiable timestamps, etc.

Other approaches like WITNESS proofs and many others are available. These just need to go on a trusted blockchain (not necessarily BitBadges blockchain).


## File: ./for-developers/core-concepts/verifiable-attestations/overview.md

# Overview

An attestation represents claims about a subject. They can come in many different forms (signatures, BBS, simple URLs) as long as they are verifiable. Each scheme can offer varying tradeoffs. We support a couple natively while also allowing you to custom upload your attestation.

Currently, our core suite supports two approaches. Both are cryptographically signed, and thus, data integrity is maintained. These are stored off-chain (centralized) but can be anchored or posted on-chain if desired.

* BBS+: Messages are signed with the BBS+ signature scheme and a proof of issuance is linked with another proof message signature. BBS+ signatures allow for zero-knowledge selective disclosure (reveal only M of N messages).&#x20;
  * The BBS+ signature algorithm allows an issuer to sign N messages to produce a signature. From that signature, a holder can derive a cryptographic proof that only reveals any subset of the N messages. This allows selectvie disclosure of the credential. For example, you may only want to reveal your GPA to an employer, but the diploma credential has other identifying fields like courses taken, student records, etc.
  * To create the link between a "main" crypto address and the BBS+ public key, we sign a message from the main address saying that attestations from BBS+ key can be treated as my own.
* Standard Signatures: Messages are signed via any supported wallet / ecosystem (Bitcoin, Ethereum, Solana, Cosmos). These do not support selective disclosure.

To get started, simply create an attestation in-site.

<figure><img src="../../../.gitbook/assets/image (134).png" alt="" width="375"><figcaption></figcaption></figure>


## File: ./for-developers/core-concepts/verifiable-attestations/proofs-vs-attestations.md

# Proofs vs Attestations

Attestations are the original document from which different proofs can be derived from, depending on the selected scheme. For example, for BBS signatures, you can selectively reveal M of N messages.

```
Proofs are a derivation from the core attestation with a few changes.
```

Proofs follow a very similar interface plus/minus a few fields, but proofs may change the following details, depending on the implementation:

* May have different metadata or visibility properties
* Can selectively disclose certain information but not others (for approaches that support selective disclosure).

There are user interfaces for handling this all on the frontend. However, below, we go into detail for how you can do it yourself. Check out [https://bitbadges.io/attestations/proofgen](https://bitbadges.io/attestations/proofgen) for a helper tool for generating BBS+ signatures.

Most notably, for BBS derived proofs, the dataIntegrityProof.isDerived will be true.

```typescript
export interface iAttestationsProof<T extends NumberType> {
    createdBy: string;
    scheme: 'bbs' | 'standard' | string;
    originalProvider: string;

    messages: string[];

    dataIntegrityProof: {
        signature: string;
        signer: string;
        publicKey?: string;
    };

    proofOfIssuance: {
        message: string;
        signer: string;
        signature: string;
        publicKey?: string;
    };

    name: string;
    image: string;
    description: string;

    entropies?: string[];
    updateHistory?: iUpdateHistory<T>[];
    anchors?: {
        txHash?: string;
        message?: string;
    }[];
}
```


## File: ./for-developers/create-and-broadcast-txs/cosmos-sdk-msgs/msgcreateaddressmappings.md

# MsgCreateAddressLists

To create an on-chain AddressList, you can use the MsgCreateAddressLists. See [here](../../core-concepts/address-lists-lists.md) to learn more about AddressLists.

Reminder: on-chain address lists are immutable, permanent. and non-deletable.

```typescript
export interface MsgCreateAddressLists {
  creator: string;
  addressLists: AddressList[];
}
```

```typescript
export interface AddressList {
  listId: string;

  addresses: string[];
  whitelist: boolean;

  uri: string; 
  customData: string;
}
```



**Combining with MsgCreateCollection or MsgUpdateCollection**

Oftentimes, you want to create a new AddressList, so it can be used in a MsgCreateCollection or MsgUpdateCollection (for example, defining transferability using a new, custom list ID).

Before an AddressList can be used, it needs to be defined on-chain. The two Msgs can be easily combined in the same transaction (as Cosmos transactions support multiple Msgs). See [here](../../bitbadges-sdk/common-snippets/creating-signing-and-broadcasting-txs.md) for an example of how to do it with the SDK. Just make sure MsgCreateAddressLists is executed first and precedes when it is actually used.

```typescript
const msgs: MessageGenerated[] = [];
msgs.push(...bootstrapLists().map(x => createProtoMsg(x))); //MsgCreateAddressLists
msgs.push(...bootstrapCollections().map(x => createProtoMsg(x))) //MsgCreateCollections

//Note how MsgCreateAddressLists is first in the array
const txn = createTransactionPayload(txContext, msgs);
```



## File: ./for-developers/getting-started.md

# 🔨 Getting Started

BitBadges is proud to offer no-code / low-code flows for all our major services. Simply navigate to the Create tab in-site, and get started creating badges, attestations, claims, address lists, explore listings, applications, and more!

<figure><img src="../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

> **Need help?** Join our Discord for support from the BitBadges team and community developers.
>
> **Need $BADGE credits?** Contact us on Discord - we offer subsidized credits for developers during beta!
>
> **No-Code / In-Site Solutions** Check out the [Create tab](https://bitbadges.io/create) or the [developer portal](https://bitbadges.io/developer) first to see what all is possible. Most of the time, you can just do everything with no code directly in-site! No need for any direct integration. Let us handle everything!
>
> Get creative. You can gate URLs, Discords, and integrate with many of your favorite tools without a single line of code!

## Explore First, Read Later

We strongly recommend, if you have not already, to explore the claim tester and other creation options in-site. Many of your questions should be answered by the interface and is much easier to understand than a bunch of long text here in this documentation. Just go explore and experiment first.

Most of your setup and management (and oftentimes all) will be done directly in-site via the developer portal or Create tab. Get started at [https://bitbadges.io/create](https://bitbadges.io/create).

## Gate Any Service In 2 Steps

Any service can be gated by ANY criteria simply in just 2 steps.

1. **Authenticate** - We recommend Sign In with BitBadges but it could be any approach
2. **Verify Claim Success** - Check the user satisfies a BitBadges claim (via post-success hooks, API, many ways!)

Claims are the universal connectors. Claim criteria can be anything from a payment to badge ownership to Discord servers. Implement it any way you want (including custom logic) at [https://bitbadges.io/create](https://bitbadges.io/create)!

## Quick Start - Badges

{% content-ref url="broken-reference" %}
[Broken link](broken-reference)
{% endcontent-ref %}

## Quick Start - Claims

This includes documentation everything from custom plugins to Zapier to dynamic stores and mroe

{% content-ref url="../overview/claim-builder/" %}
[claim-builder](../overview/claim-builder/)
{% endcontent-ref %}

## Quick Start - API

{% content-ref url="bitbadges-api/" %}
[bitbadges-api](bitbadges-api/)
{% endcontent-ref %}

{% content-ref url="bitbadges-sdk/" %}
[bitbadges-sdk](bitbadges-sdk/)
{% endcontent-ref %}

```bash
npm i bitbadgesjs-sdk
```

```ts
import { BitBadgesAPI } from 'bitbadgesjs-sdk';

const api = new BitBadgesAPI({
  ...YOUR_CONFIG_AND_API_KEY
});

await BitBadgesAPI.getCollection(...);
```

Try our interactive quickstart demo: [BitBadges Quickstart](https://bitbadges.io/quickstart). If that is what you need, clone it: [BitBadges Quickstart Repository](https://github.com/BitBadges/bitbadges-quickstart). Or, see out [Auth.js/Next.js Template](https://github.com/BitBadges/bitbadges-authjs-example).


## File: ./for-developers/sign-in-with-bitbadges/README.md

# 🖱️ Sign In with BitBadges



## File: ./for-developers/sign-in-with-bitbadges/already-have-web3-auth.md

# Already Have Web3 Auth?



## File: ./for-developers/sign-in-with-bitbadges/alternative-p2p-verification.md

# Alternative - P2P Verification



## File: ./for-developers/sign-in-with-bitbadges/approaches/README.md

# Approaches



## File: ./for-developers/sign-in-with-bitbadges/approaches/qr-codes.md

# QR Codes



## File: ./for-developers/sign-in-with-bitbadges/approaches/redirected-callback.md

# Redirect Callback

The standard OAuth callback approach is used for immediate authentication. To enable callbacks, the parameters must have a redirect URI set that matches your app's configured one. With the callback, the user will never even see the code. Everything is handled behind the scenes immediately.

**How do callbacks work?**

A high-level overview is:

1. Users navigate to the custom SIWBB URL for your authentication request.
2. The user will be walked through the authentication process. Upon completion, an authorization code is transmitted to the redirect URI via the query parameters `code` and `state`.
3. The redirect URI can then fetch the details from the API using the transmitted code with knowledge of the configured app's client secret.

**Generating the URL**

The important part here is to correctly specify a valid **redirectUri** letting us know that you expect to receive the details immeditately.

{% content-ref url="broken-reference" %}
[Broken link](broken-reference)
{% endcontent-ref %}

**Implementation - Backend**

```typescript
// GET /api/callback?code=...&state=...
const callbackHandler = async (req: NextApiRequest, res: NextApiResponse) => {
    //Parse the code and state from the query parameters
    const code = req.query.code;
    const state = req.query.state as string;

    //TODO: Fetch authentication details (see Verification page)
    //      const res = await BitBadgesApi.exchangeSIWBBAuthorizationCode({ code, ... });
    //TODO: Any application specific requirements

    //Learn more in the verification steps
};
```

At your redirect URI, you will need to set up a handler to handle the code / state that is passed. The code and state will be passed in via the HTTP query parameters. This follows typical OAuth2 flow. We refer you to OAuth tutorials for more details.

To ensure the security of the data exchange process, consider the following practices:

* Validate the `state` parameter according to your requirements (if applicable)
* Use HTTPS to protect the data in transit, ensuring that all communications between your server and the client are encrypted.


## File: ./for-developers/sign-in-with-bitbadges/authorization-url/README.md

# Authorization URL



## File: ./for-developers/sign-in-with-bitbadges/authorization-url/configuration.md

# Configuration



## File: ./for-developers/sign-in-with-bitbadges/authorization-url/generating-the-url.md

# Generating the URL



## File: ./for-developers/sign-in-with-bitbadges/connecting-a-claim.md

# Connecting a Claim



## File: ./for-developers/sign-in-with-bitbadges/overview.md

# Overview

Sign In with BitBadges (SIWBB) is a unified multi-chain authentication solution that works across all blockchain ecosystems. It replaces traditional "Sign In with X" buttons and can be configured to handle the following all in one flow:

* Multi-chain authentication
* Verification of attestation signatures
* Badge ownership verification
* Integration with 7000+ supported apps and plugins
* BitBadges API scope authorizations

Outsource the heavy lifting of authentication to us, allowing you to focus on your core utility. We aim to provide maximum flexibility in the design process.

```
NOTE: The QR codes flow has been deprecated.

You may still use Sign In with BitBadges and generate a QR for your user on your own.

We also have the peer-to-peer verification still enabled for on-the-fly QR verification.

Simply replace any QR code flow with your own and use claims, the standard SIWBB, and other tools.
```

#### OAuth Endpoints

* **Authorization:** `https://bitbadges.io/siwbb/authorize?your_params`
* **Token:** `https://api.bitbadges.io/api/v0/siwbb/token`
* **Revoke:** `https://api.bitbadges.io/api/v0/siwbb/token/revoke`&#x20;

[**Demo**](https://bitbadges.io/siwbb/authorize?expectAttestations=true\&client_id=example-client-id\&redirect_uri=https://example.com&)

<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (180).png" alt=""><figcaption></figcaption></figure>

## Implementation Flow

1. **Authentication- BitBadges Side**
   * User accesses BitBadges URL (direct or popup)
   * Proves address ownership and other criteria (badges, attestations, etc.)
   * Receives authorization code from BitBadges (QR or behind the scenes via redirect)
2. **Integration- Your App Side**
   * Receive authentication response
   * Check criteria on your end
   * Implements security measures (prevent replay attacks, etc.)
   * Focus on your core utility

## Getting Started

Check out our [BitBadges quickstart repo](https://github.com/BitBadges/bitbadges-quickstart) for a complete implementation example and reference code.

Note: SIWBB is fully OAuth 2.0 compatible and works with standard OAuth frameworks and tools.

**Hybrid No Wallet dApps**

Sign In with BitBadges is unique because it allows you to build hybrid dApps, as we term them. Hybrid dApps outsource ALL of the wallet connection, signing, authentication to us. You have no need to implement anything wallet-related on your app side if not needed.

However, if your app already uses wallets, you can still use SIWBB.  The flow is the exact same, and as the user navigates to the SIWBB page, the user's wallet should auto-connect, resulting in a seamless experience.


## File: ./for-developers/sign-in-with-bitbadges/setting-up-an-app.md

# Setting Up an App

### App Registration

* Register at [https://btibadges.io/developer](https://btibadges.io/developer) -> OAuth Apps
* Take note of your client ID / secret

### Key Components

#### 1. Client ID

* Unique identifier for your app
* Assigned upon registration

#### 2. Client Secret

* Cryptographic key for API authentication
* Keep confidential; never expose in client-side code. Treat like a password.
* Required to fetch user authentication details

#### 3. Redirect URIs

* Endpoints where users are redirected after authentication
* Must be pre-registered and use HTTPS
* Not needed for delayed/QR code authentication. Only for immediate digital redirects.

### Security Notes

* Treat client secret as securely as a password
* Ensure exact match between registered and used redirect URIs (if applicable)
* Use HTTPS for all redirects for security reasons


## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/README.md

# Templates and Frameworks



## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/auth0.md

# Auth0



## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/discourse.md

# Discourse



## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/expressjs.md

# ExpressJS



## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/others.md

# Others



## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/supabase.md

# Supabase



## File: ./for-developers/sign-in-with-bitbadges/templates-and-frameworks/wordpress.md

# WordPress



## File: ./for-developers/sign-in-with-bitbadges/verification/README.md

# Verification



## File: ./for-developers/sign-in-with-bitbadges/verification/access-tokens.md

# Access Tokens



## File: ./for-developers/sign-in-with-bitbadges/verification/offline-verification.md

# Offline Verification



## File: ./for-developers/sign-in-with-bitbadges/verification/security-considerations.md

# Security Considerations



## File: ./for-developers/sign-in-with-bitbadges/verification/verification-flow.md

# Verification Flow



## File: ./overview/claim-builder/README.md

# 🎁 BitBadges Claims



## File: ./overview/comparing-bitbadges-to-other-protocols.md

# ⚖️ BitBadges L1 vs Others

## Comparing BitBadges L1 to Other Protocols

BitBadges is a unique L1 (Layer 1) blockchain built using the Cosmos SDK that aims to simplify the multi-chain experience. The BitBadges token (badge) standard is not EVM-compatible, ERC-20 compatible, or Bitcoin Ordinals compatible. Instead, we offers our own flexible, ever-evolving token standard, making it easier to build multi-chain applications. This is because it is compatible with ANY wallet from ANY chain, all with ONE interface.

While BitBadges may lack some of the native smart contract support and interoperability features of other protocols, its self-contained design and API-like token standard can be a compelling solution for certain use cases.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Chain Architecture

BitBadges is its own L1 blockchain, not a layer-2 or sidechain solution. It is built using the Cosmos SDK, which gives it flexibility and scalability. It also connects to the IBC ecosystem and all other Cosmos features.

Protocols like Bitcoin Oracles, Ethereum NFTs, and Solana NFTs are all deployed on their respective chain and not compatible with each other. If you wanted to implement a token-gated application for all those chains, you would need to issue tokens on every chain. With BitBadges, it is one token in one place for all users from any chain.

### Security Model

Yes, BitBadges may not be as secure or decentralized (yet) as some other protocols. It is its own L1, and over time, we will only get more decentralized and secure. However, we actually envision BitBadges being a flexible part of any application stack and used where needed rather than an all encompassing solution.

For example, when building an application, you may use BitBadges for authentication / website gating but still accept payments in your native or preferred currency.

### Cross-Chain Interoperability

BitBadges is not interoperable in the traditional sense, as it is a self-contained L1 blockchain. BitBadges does not "pull" or "connect" data from other chains. All relevant data is stored on the BitBadges chain, simplifying application development.

However, it supports users and wallets from any chain, allowing for easy multi-chain token transfers and multi-chain application development (e.g. Ethereum users can transfer badges to Solana users to Bitcoin users). For example, Bitcoin users can sign BitBadges transactions with their Bitcoin wallets.

### Token Standard

BitBadges offers its own token standard built from the ground up that functions more like an API where everything is already implemented natively, and you just customize the requests (as Cosmos SDK Msgs) behind the scenes. This is how the BitBadges site is all no-code by default.

This approach vastly differs to existing ones requiring an individual smart contract for all tokens. Protocols like Ethereum rely on ERC-20 tokens, which require individual smart contract deployments and management. This approach gets complex, vulnerable to security flaws, and does not support the required structure.

### Smart Contract Support

While BitBadges does not natively support EVM or ERC-20 contracts, it does support CosmWASM contracts, allowing for the extension of functionality and the creation of dApps. However, our goal is to keep evolving our token standard so that no custom contracts are EVER needed.

Protocols like Ethereum and Solana have robust smart contract support, enabling a wide range of decentralized applications.


## File: ./overview/contributing.md

# 👨💻 Contributing

Everything is open-sourced and can be found at [https://github.com/bitbadges](https://github.com/bitbadges). Contributions to the core source code are greatly appreciated.&#x20;

Additionally, you can contribute by building on top of BitBadges. This can be anything from a dApp (decentralized application) to a developer tool to your own frontend for badges! If you do, reach out to us, so we can add it to [Ecosystem](ecosystem.md).

**Rewarding Developers**

In the future, we plan to host hackathons, bug bounties, and setup a developer funding pool where developers are rewarded for contributing and building with BitBadges.

**Improvement Proposals**

The official BitBadges improvement proposals repository can be found at [https://github.com/BitBadges/BBIPs](https://github.com/BitBadges/BBIPs).&#x20;

**Bug Bounties**

TBD

Let us know if you have another idea and how we can help.


## File: ./overview/ecosystem.md

# 🌴 Ecosystem



## File: ./overview/ecosystem/README.md

# 🌴 Ecosystem



## File: ./overview/ecosystem/blockin.md

# Blockin

{% content-ref url="https://app.gitbook.com/o/7VSYQvtb1QtdWFsEGoUn/s/AwjdYgEsUkK9cCca5DiU/" %}
[Blockin](https://app.gitbook.com/o/7VSYQvtb1QtdWFsEGoUn/s/AwjdYgEsUkK9cCca5DiU/)
{% endcontent-ref %}


## File: ./overview/ecosystem/chrome-extension.md

# Browser Extensions

The BitBadges browser extension provides a quick preview of a user's badges and portfolio directly via the extension popup, meaning you never have to leave the site you are currently on. You can add custom requirements as seen below which check for ownership of a custom set of requirements that you want to check.

Note: Chrome should have full settings functionality, but others may be limited.

**Chrome**

Install Link: [https://chromewebstore.google.com/detail/bitbadges-chrome-extensio/ocdlkggomnifibfadgaakkilojelgacj?authuser=0\&hl=en](https://chromewebstore.google.com/detail/bitbadges-chrome-extensio/ocdlkggomnifibfadgaakkilojelgacj?authuser=0\&hl=en)

Settings Page: [https://bitbadges.io/chrome-extension](https://bitbadges.io/chrome-extension)

**Edge**

Install Link: [https://microsoftedge.microsoft.com/addons/detail/bitbadges-extension/llcengdgmhalkamkhkoaeoaelghblfij](https://microsoftedge.microsoft.com/addons/detail/bitbadges-extension/llcengdgmhalkamkhkoaeoaelghblfij)

**Firefox**

Install Link: [https://addons.mozilla.org/en-US/firefox/addon/bitbadges-extension/](https://addons.mozilla.org/en-US/firefox/addon/bitbadges-extension/)

**Opera**

Coming Soon...



<figure><img src="../../.gitbook/assets/image (109).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/ecosystem/linkedin-certifications.md

# LinkedIn Certifications

Easily add badges, lists, or attestations to your LinkedIn certtfications with one click!

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/ecosystem/metamask-snap.md

# MetaMask Snap

BitBadges has created a MetaMask Snap extension to help guard your wallet and automatically check badge / asset ownership for addresses in your transactions and signatures.

**Installation:** [https://snaps.metamask.io/snap/npm/bitbadges-snap/](https://snaps.metamask.io/snap/npm/bitbadges-snap/)

**Configure Settings:** [https://bitbadges.io/snap](https://bitbadges.io/snap)

<figure><img src="../../.gitbook/assets/image (94).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/ecosystem/wordpress-plugin.md

# WordPress Plugin

{% content-ref url="broken-reference" %}
[Broken link](broken-reference)
{% endcontent-ref %}


## File: ./overview/faq.md

# ❓ FAQ

### **Badge vs $BADGE?**

Whenever we say **$BADGE**, we are referring to the BitBadges blockchain gas denomination used for paying transaction fees. All transactions on the BitBadges blockchain require $BADGE to be paid as a fee. This is not to be confused with badges / badge collections.

### **Are smart contracts needed?**

No! All badges are no-code with tons of functionality out of the box. If you need something custom, you can create a WASM or EVM (coming soon) contract to add custom functionality not already implemented.

### **Is BitBadges an L1 blockchain or an L2?**

BitBadges is its own Layer-1 blockchain built with Cosmos SDK. We also offer many off-chain services built on top of the blockchain as well.

### **Why the registry architecture over unique smart contracts for every collection?**

Typical NFTs and digital tokens (ERC721, ERC20) all require their own unique smart contracts to be implemented which follow their respective interface. However, BitBadges is not built like this. BitBadges uses a single registry and the same code is reused for all collections. This is a much more secure and scalable solution.

We do this for multiple reasons:

1. Security: The same code is being reused and over time, it will become more battle-tested and more secure. This is as opposed to unique smart contracts that can often have vulnerabilities, as seen with the large amount of hacks occurring in the Ethereum ecosystem.
2. Scalability: Since duplicate code doesn't need to be deployed, this solution is much more scalable.
3. Consistency: This provides a much cleaner and more consistent interface for querying, indexing, and maintenance.

Yes, this may sacrifice a little customizability, but we allow you to extend the interface and implement any custom logic required with smart contracts, if necessary. We believe the pros vastly (security, scalability, and ease of use) vastly outweigh the cons.

### **Are badges ERC-721 or ERC-20 compatible?**

While our token standard takes inspiration from existing standards like ERC-721, our token standard has its own properties and architecture.

### **What happens if there is convergence to a single blockchain ecosystem?**

BitBadges is uniuqely positioned at the center of any future trend. We can support any user from any chain. We can tap into any ecosystem through IBC x Cosmos. We have a CosmWASM layer. We have an EVM layer.

### **How does BitBadges compare to other interoperability protocols?**

BitBadges is a unique L1 blockchain that simplifies multi-chain experiences. Unlike other interoperability protocols, all tokens are stored on the BitBadges chain, simplifying development. And, we support any user from any chain. No need to worry about bridging tokens or managing multiple tokens.

### **How does cross-chain interoperability work?**

BitBadges doesn't "pull" data from other chains - all relevant data is stored on the BitBadges chain, simplifying development. However, it supports users and wallets from any chain, allowing multi-chain transfers (e.g., Bitcoin users can transfer badges to Solana users).

### **Does BitBadges support smart contracts?**

Yes, BitBadges supports CosmWASM contracts and EVM (coming soon) for extending functionality.


## File: ./overview/how-it-works/verifiable-secrets.md

# Verifiable Attestations

**Off-Chain Attestations and On-Chain Anchoring**

Besides traditional on-chain badges, BitBadges supports the storage of off-chain verifiable attestations. These can be any form of data that is secured by a signature, such as credentials or attestations. The flexibility to store data off-chain while still having the option to anchor it on-chain for verification purposes is often useful for use cases that have privacy and security requirements. Attestations are just signatures of one or more message using a crypto wallet.

BitBadges offers a centralized, easy to use solution for attestations with many neat features. The centralized part just comes from the fact that BitBadges stores the signatures for you. If you would like to self-host, you can for a decentralized experience.

Some of the neat features include:

-   **Integration into Authentication Flows:** Attestations can be used to prove certain criteria to authentication providers. If you can prove you meet the criteria via a attestation, you will be authenticated. This can be integrated into the Sign In with BitBadges flow, so for example, you can prove public ownership of a diploma badge whilst also verifying attestation data such as a users' GPA.
-   **Anchoring:** Anchoring credentials on-chain provides a transparent and verifiable record of issuance, enhancing the trustworthiness and integrity of the credential without compromising the holder's privacy. The blockchain can be used for proof of knowledge of a attestation at a certain time or to maintain data integrity.

**Issuance and Storage**

The credential issuance process begins when an issuer (for example, a university) signs a piece of private data (such as a student’s diploma) and transfers this signed data, along with the credential, to a recipient (the student). This action gives the holder concrete proof of their credential, which they can then present to any verifier. The system also ensures that verifiers receive cryptographic assurance of the data's authenticity.

A distinctive feature of BitBadges is the ability for issuers to **selectively disclose** information. This means they can prove claims (like a GPA above 3.0) without disclosing any additional personal information that's irrelevant to the verifier's needs.

For data integrity and verification purposes, credentials are signed and stored off-chain in the holder's BitBadges account. Issuers have the option to anchor these credentials on-chain to commit to the data publicly and verify its issuance time, although this step is optional and not always necessary.


## File: ./overview/learn/README.md

# 👨‍💻 Learn the Basics



## File: ./overview/learn/accounts.md

# Multi-Chain Accounts

### **How is BitBadges able to support addresses from different blockchains?**

To enable interoperability between different blockchains, BitBadges is signature compatible with all of its supported chains (Bitcoin, Ethereum, Solana, and Cosmos).

Signature compatibility means that users from any of the above blockchain ecosystems are able to sign BitBadges transactions, and we simply verify the signatures on our blockchain.

BitBadges is compatible with the wallets of each ecosystem. However, BitBadges is its own blockchain and does not pull any data from or is interoperable with any other blockchain. Everything is confined to the BitBadges blockchain.

<figure><img src="../../.gitbook/assets/image (34).png" alt=""><figcaption></figcaption></figure>

### **Why do I see multiple equivalent addresses?**

All addresses map to an equivalent one in a different ecosystem (see the image below). You may be used to seeing your address as an Ethereum address, but behind the scenes, your mapped BitBadges address may be used for record keeping.

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### **Which chains / wallets are supported?**

Currently, we support Ethereum, Cosmos, Solana, Bitcoin.

### Why is it per ecosystem and not per chain?

As you may have noticed, we do not differentiate between EVM chains, for example. All are treated the same with our architecture, so we just default to the emain chain of the ecosystem for display purposes (e.g. EVM for Ethereum).


## File: ./overview/learn/address-lists.md

# Address Lists

Address lists are a streamlined alternative to badges. Instead of dealing with the complexity of badges, you can create a simple list (public but off-chain). These can also be gated by claims, allowing you to gate spots on the list by any criteria imaginable.

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/learn/applications-points.md

# Applications (Points)

Applications allow you to create gamified points, quests, and tiers for your users. Behind the scenes, these just use claims with assigned weights for points, for example. Points can then be used as criteria for other gated utility, like a points-gated airdrop.

<figure><img src="../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/learn/attestations.md

# Attestations

Attestations are private by default credentials (e.g. signature of a specific claim like "Bob earned this diploma"). They enable individuals to prove claims about themselves (such as qualifications, achievements, or attributes) in a secure, tamper-evident, and privacy-preserving manner to any verifier.

These can be stored in your BItBadges account (or sent to the recipients) and selectively disclosed to whoever needs to verify them through claims or Sign In with BitBadges. Attestations are off-chain by default, but you can always anchor or prove existence of the attestation on-chain.

Attestations may come in different forms with varying properties, such as:

* Standard Signatures: Sign messages with your connected wallet address
* BBS+: Supports selectively disclosing only a subset of the N messages in the attestation. For example, disclose you are 21 without revealing your name.
* URLs: Attestations can even be a link to a URL as long as the verifier can verify it

<figure><img src="../../.gitbook/assets/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (7) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/learn/badge-concepts/README.md

# Badge Concepts



## File: ./overview/learn/badge-concepts/balances-types.md

# Balances Types

BitBadges offers different ways to store the badge balances and owners for your collection, each with their own pros and cons.

```
NOTE: Off-chain badge balances have now been deprecated on the frontend.

We made this decision because we felt they added too much complexity and could be implemented much simpler with address lists and claims.

If you are interested in us reenabling this, please let us know.
```

<figure><img src="../../../.gitbook/assets/image (40).png" alt=""><figcaption></figcaption></figure>

## Standard (On-Chain)

Standard balances are what you may be familiar with. All balances are stored on the blockchain, and users can transfer badges to each other by transacting with the blockchain. The total supply is controlled by on-chain transfers, approvals, and permissions.

This is the least scalable because it uses the most blockchain resources, but it is the most decentralized. Everything is facilitated on the blockchain and can access blockchain data with no trust involved (including $BADGE).

## Non-Public

We do give the option to make balances non-public. This can either mean you want to keep balances private through a self-implementation. Or, you may not need balances altogether. If either of these criteria match, you can select this balance type, and we will not display anything about balances on the user interface (everything is left up to you entirely).

## Off-Chain

Unlike conventional on-chain balances, off-chain balances leverage an alternative approach to balance storage. Core collection details are still stored on the blockchain, but balances are stored off-chain, on a typical server or through a file storage solution like IPFS. The current balance allocations are dynamically fetched from the URL designated for storage (URL is stored on-chain).

Transfers and approvals are not handled by the blockchain. Transfers may be implemented off-chain. This enables access to non blockchain native data, but it also means that blockchain data and logic can not be executed in a trustless manner (e.g. sending $BADGE along with an approval). Everything must occur off-chain.

#### Configurable URL and Permanent Storage

The URL fetching mechanism is customizable. URLs are stored on-chain and can be set to be updatable or non-updatable by the manager. The balances returned by the URL can also be configured be updatable or rely on permanent storage like IPFS, ensuring consistent and unchanging balance data. When URLs are non-updatable and use permanent storage, balances become immutable (aka soulbound or non-transferable), providing long-term stability.

#### Benefits

* **Significant Resource Reduction**: The architecture's off-chain nature results in a substantial reduction of resources used by your collection—potentially up to over 99%. This is primarily due to the absence of on-chain transfer transactions and balances. Only the collection needs to be created / updated on-chain, and future balance updates do not require blockchain transactions.
* **Non-Blockchain Data and Tools**: Balances can be customized using non-blockchain tools and data. While on-chain balances are restricted to on-chain data (smart contracts, etc.), off-chain balances can be customized with other data. For example, you can give badges to those who have paid subscriptions through a non-blockchain service (Google Pay, etc).
* **No-Cost Updates:** If the balances URL (stored on-chain) remains the same, balances can be updated by simply editing what is returned from the server. This means balances can be updated without interacting with the blockchain and paying transaction fees.
* **Enhanced User Experience**: Users are relieved from the need to interact directly with the blockchain and incur gas fees. This streamlined user experience enhances accessibility and usability. Badges are automatically populated into a user's portfolio without the user ever executing a blockchain transaction.
* **Discardability:** Because balances are indexed off-chain, past transfer activity that is no longer relevant and needed can be permanently discarded rather than permanently stored on the blockchain and bloating it.

#### Drawbacks

* **Scalability vs. Functionality Trade-off**: While off-chain balances offer scalability and user-centric benefits, they entail trade-offs in terms of functionality and decentralization. Mainly,\
  since there are no on-chain transfers, certain on-chain functionality (such as approvals, customizable transferability, transfers w/ $BADGE) is not supported. Everything is implemented off-chain in a custom manner.
* **Centralized Trust Factor**: The URL-driven approach introduces a centralized trust element, as the blockchain has no control over the data returned by the URL or the assignment of the balances. This can be mitigated if certain criteria is met (immutable and using permanent storage like IPFS).
* **Off-Chain Balance Indexing:** Because balance updates are facilitated and indexed off-chain, there is no on-chain verifiable ledger of transfer transactions. Off-chain indexing does not sacrifice any functionality, but the accuracy and availability may not be on par with on-chain indexing.
  * Timestamping: There is no decentralized, verifiable log of EXACTLY when each balance update occurs because they occur on a hosted server. Indexers will attempt to fetch and catch each update as fast as possible, if applicable, but there is bound to be delay.
  * Loss of Historical Data: Logs of past balances may be lost forever if all parties discard / lose the data and can not be reproduced. However, this could also be a good thing as seen in the benefits.

### Indexed vs Non-Indexed

Off-chain balances can either be indexed or non-indexed. Note we use on-demand and non-indexed interchangeably. The differences are as follows:

* Indexed balances have a total verifiable supply. Non-indexed does not.
* At any time, for indexed balances, all owners and their balances are known. With non-indexed, this is not tracked, and we fetch on-demand from the source every time.
* For indexed balances, a ledger of activity is tracked. For non-indexed, there is no ledger kept. You can only view the current balances at any given time.
* Indexed balances have a limit of unique owners (set by the indexer) for scalability reasons, whereas non-indexed has no such limit.

### Suitability of Off-Chain Balances

Consider adopting off-chain balances if your collection aligns with the following criteria:

1. **Non-Transferable / Soulbound**: If your collection's badges are intrinsically tied to specific users and are not intended for transfer, off-chain balances could be advantageous, especially if you make the balances frozen and immutable.
2. **Centralized Allocation Control**: In cases where a single entity should maintain complete control over badge allocation (concert tickets, diplomas, etc), the off-chain approach can be particularly beneficial.

This is because there is little added benefit to using a blockchain if such criteria is met. Sure, the blockchain might have better availability and verifiability than an off-chain solution (although, we have been using off-chain solutions for 20+ years successfully). However, other than that, the blockchain really provides little benefit, and fees can be expensive.

### Customizability and Advantages Over Standard Solutions

#### Custom Logic Implementation

Balances' updatable nature allows for the implementation of custom logic for what is returned by the URL. This empowers you to define and program your balance-fetching process to align with your collection's unique requirements. It also allows you to access and integrated with non-blockchain data and tools to customize your balances further.

For example, you can dynamically revoke and assign based on if users pay their subscription fees for a month all without ever interacting with the blockchain (since the URL won't change).

See [here](../../how-it-works/broken-reference/). Or, find a tool or tutorial for your use case on the [Ecosystem ](../../ecosystem/)page!

#### Advantages Over Standard Solutions

Compared to traditional client-server solutions, off-chain balances offer numerous advantages, including:

* **Simplified Badge Management**: Outsourcing badge creation, maintenance, and verification reduces your workload.
* **Seamless Integration**: Integration with the complete suite of BitBadges tools.
* **Enhanced Security and Availability**: While balances are off-chain, the collection's core creation and foundation remain on the blockchain where it benefits from security, immutability, and availability.
* **Unified Digital Identity Building**: Users can consolidate their digital identity to their single address, eliminating fragmentation across various websites.

In conclusion, off-chain balances present an intriguing avenue to enhance scalability, user experience, and badge management. While there are considerations and trade-offs, the decision to adopt this approach hinges on your collection's specific goals and priorities. For additional resources and guidance, consult the Ecosystem page to identify suitable tools and tutorials for your use case.


## File: ./overview/learn/badge-concepts/manager.md

# Manager

Each badge collection has a manager, which can execute admin permissions such as updating metadata, transferability, etc.

<figure><img src="../../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

**Manager Permissions**

The manager role can be granted various permissions, allowing for flexible administration of the collection. These permissions include, but are not limited to:

1. **Collection Deletion:** The ability to permanently remove the collection from the system.
2. **Collection Archiving:** Managers can archive a collection, making it read-only and rejecting all transactions until an unarchive action is performed.
3. **Core Collection Updates:** This includes modifying essential details such as metadata URLs, contract addresses, and the collection's standard.
4. **Off-chain Balance Management:** For collections using off-chain balance storage, managers can update these balances.
5. **Manager Role Transfer:** The ability to pass the manager role to another address.
6. **Badge Creation:** Managers can be given permission to mint additional badges within the collection.
7. **Transferability Updates:** This involves modifying the collection's approval settings, which determine how badges can be transferred. (For more details, see [transferability](transferability.md))
8. **Custom Permissions:** Depending on the collection's setup, there may be additional, collection-specific permissions available to the manager.

It's worth noting that the manager role can extend beyond on-chain functionalities. Various tools and platforms can offer custom off-chain utilities exclusive to the manager, further expanding the role's capabilities and responsibilities.

## Fine-Grained Customizability

One of the key features of the manager role in BitBadges is the ability to customize permissions at a granular level. This allows for precise control over the collection's management.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption><p>Fine-Grained Permission Settings</p></figcaption></figure>

Permissions can be customized based on various factors, including:

* **Badge Specificity:** Which particular badges within the collection can be affected?
* **Time Constraints:** When can certain actions be performed?
* **Value Limitations:** What specific values or ranges are allowed for updates?
* **Conditional Triggers:** Under what circumstances can certain permissions be exercised?

This level of customization allows collection creators to implement complex management strategies tailored to their specific needs.

## Permission States

Each permission can exist in one of three states:

1. **Forbidden + Permanently Frozen:**
   * The permission is permanently disallowed.
   * This state cannot be changed, ensuring certain actions remain off-limits indefinitely.
2. **Permitted + Not Frozen:**
   * The permission is currently allowed.
   * This state can be changed to either of the other two states, offering flexibility in management.
3. **Permitted + Permanently Frozen:**
   * The permission is permanently allowed.
   * Like the first state, this cannot be changed, ensuring certain capabilities always remain available.

It's important to note that there is no "Forbidden + Not Frozen" state. This is because such a state could theoretically be updated to "Permitted" at any time and then immediately executed, effectively making it a "Permitted" state.

This system of states allows for both flexibility and security in managing collection permissions, enabling creators to set up governance structures that can evolve over time or remain fixed, depending on their needs.


## File: ./overview/learn/badge-concepts/protocol-fee.md

# Protocol Fee

For any badge transfer on-chain, BitBadges takes a protocol fee of Max(0.5% of transfer or 0.1 $BADGE).

<figure><img src="../../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

**Frontend Affiliates**

If you are building a custom frontend or tool on top of BitBadges that triggers badge transfer transactions, you can use the affiliate address option in the transfer transaction to claim the protocol fee for yourself!


## File: ./overview/learn/badge-concepts/standards.md

# Standards

Collections can optionally implement a specific type of collection or standard. Standards define the expected format of the collection and help others to know how to interpret the details of the collection.

Standards can define the expected values and format of everything about a collection, such as its expected metadata format or the expected genesis conditions. If you implement a standard, it is your responsibility to follow the rules defined by the standard.

Choose the most appropriate standard(s) for your desired use case. You may choose to mix and match more than one as long as they are compatible.

**Example**

```
standards: ["non-fungible", "attendance-event", "No User Ownership"]
```

## List of Standards

1. "No User Ownership" standard - If the standards contains the standard "No User Ownership", then, user ownership is deemed unimportant and all user balances are to not be displayed. This means nothing about transferability, approvals, activity, and so on is displayed. This standard is used by collections where only the badge metadata / permissions matter, such as an attestation to something. All badges are expected to not have any recipient.



## File: ./overview/learn/badge-concepts/time-dependent-ownership.md

# Time-Dependent Ownership

Typically, you may think of a balance in two parts: what you own and the amount you own (x10 of Badge IDs 1-199). BitBadges introduces a third part: ownership times.

For example, Bob owns x10 of Badge IDs 1-100 from January to March but x5 from March-December.

### Balance Components

1. **Badge IDs**: This refers to which badges in your possession.
2. **Badge Quantity / Amount**: This refers to how much of each badge you own.
3. **Ownership Times**: A time-based framework that governs the periods during which you possess specific badge quantities.

<figure><img src="../../../.gitbook/assets/image (5) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Example of Ownership Structure

Consider Bob's ownership structure as an illustrative example:

Bob initially owns x10 of Badge IDs 1-100 from January to March. Subsequently, his ownership transitions to x5 of Badge IDs 1-100 from March to December.

### Advantages of the Ownership System

This ownership system brings forth several compelling benefits:

#### Subscription Tokens

By leveraging this system, the transfer of tokens designated for subscriptions becomes seamless. Auto-expiring tokens can be transferred without necessitating the revocation of permissions or initiating blockchain transactions.

#### Token Unlocks

Numerous projects feature stock or token unlock schedules that primarily rely on trust, rather than code-enforced mechanisms. This ownership framework empowers users to define and implement token unlock schedules natively, enhancing security and accountability.

#### Lending Mechanism

The ownership times concept facilitates badge lending for specified durations without the need for escrow services. Users can temporarily transfer their badges while retaining the ability to reclaim them after the designated timeframe.

### Usage Examples

To elucidate the functioning of this ownership system, let's delve into practical scenarios.

**Starting Balance**: Bob owns x10 of Badge IDs 1-100 from January to March.

**Example 1**: Bob's Transfer to Alice

* Bob transfers x10 of Badge IDs 1-100 from January to February to Alice.
* Result: Bob's ownership persists as x10 of Badge IDs 1-100 from February to March, while Alice becomes the owner of x10 of Badge IDs 1-100 from January to February.

**Example 2**: Bob's Partial Transfer to Alice

* Bob transfers x5 of Badge IDs 1-100 from January to March to Alice.
* Result: Both Bob and Alice now possess x5 of Badge IDs 1-100 during the January to March period.

**Example 3**: Complex Transfer Scenario

* Bob transfers x10 of Badge IDs 1-50 from January to February to Alice.
* Result: Bob retains ownership of x10 of Badge IDs 1-50 from February to March, and additionally, x10 of Badge IDs 50-100 from January to March. Meanwhile, Alice owns x10 of Badge IDs 1-50 from January to February.

Incorporating time-based ownership into the conventional badge ownership paradigm introduces enhanced flexibility, security, and functionality, enabling various usage scenarios that would otherwise be challenging to achieve.


## File: ./overview/learn/badge-concepts/total-supplys.md

# Total Supplys

Each badge in a collection will have its own circulating supply. You can think of the "Mint" address having unlimited balances, and the circulating supply is determined by the approvals and permissions of transfers from minting set up by the collection manager.

Badges can be fungible, non-fungible, or anything in between. Each has its own supply. And with time-dependent balances, this supply may change over time automatically.

Badges cannot be "burned" once created. However, they can be transferred (if allowed) to addresses where no private key is known such as the Ethereum zero address.


## File: ./overview/learn/badge-concepts/transferability.md

# Transferability

The transferability defines the rules for transferring badges within the collection. Note this does not apply to address lists or any off-chain balances type ([see here](balances-types.md)), only standard on-chain balances.

### **Transferable vs Non-Transferable**

At its simplest, a collection can be thought of as transferable (badges can be transferred freely from one owner to another) or non-transferable (once a badge is owned, it is tied to that owner and never transferable).

### Problem

However, only specifying simply "transferable" vs "non-transferable" is very naive and not suitable for many use cases.&#x20;

For example, what if you need to be able to revoke? Freeze one's ability to transfer? Restrict who can transfer to who? Restrict when users can transfer? Restrict how many times a transfer can occur? Restrict the total amount of badges transferred? Or a combination of all of these?

We abstract everything to a clearly defined interface that accounts for all these factors on three different levels.

<figure><img src="../../../.gitbook/assets/image (157).png" alt=""><figcaption></figcaption></figure>

## Approval Levels

We define three levels of approved transfers: collection-wide, incoming, and outgoing.&#x20;

<figure><img src="../../../.gitbook/assets/image (32).png" alt=""><figcaption></figcaption></figure>

### **Collection Approvals**

The collection-wide approved transfers defines all possible combinations of transfers that are allowed to take place. **All transfers must be explicitly approved on the collection level.**  This is established upon creation and updated by the manager (according to the permissions set). This also is the only way to approve "transfers" from the "Mint" address as the "Mint" address has no user level approvals.

For example, the manager could define all badges to be transferable, non-transferable, revokable by the manager. Or, they can specify claims that must be passed in order to transfer (e.g. you must own this badge to interact with this collection or you must not own a scammer badge to interact with this collection). See all possibilities below.

The collection-wide approved transfers are unique because there is a forceful option which allows you to override and ignore the other two levels of approvals (incoming and outgoing). This is used for forcefully revoking badges or forcefully freezing badges. **If it does not override the incoming and outgoing levels of approvals, the transfer must also be approved on those levels as well.** This is what is used in the case of approving mints.

### **Outgoing Approvals**

The outgoing approvals are the approved transfers of the sender. By default, all transfers where the sender equals the transaction initiator are allowed, and all others are disallowed. The sender can optionally approve other addresses to transfer on their behalf. If you are familiar with other blockchain NFTs and tokens, this is similar.

The collection can define a default outgoing approved transfers for each user. This can then be updated by the user as they desire.

### **Incoming Approvals**

The incoming approvals are the approved transfers of the recipient. By default, all transfers where the recipient equals the transaction initiator are allowed, and all others are disallowed. The recipient can choose whether to block or allow incoming transfers via their incoming approved transfers. This is a new concept introduced by BitBadges.

The collection can define a default incoming approved transfers for each user. They can then be updated by the user as they desire. They can then be updated by the user as they desire.

Typically, this is left open-ended to allow all incoming transfers, but this can be customized for more advanced use cases.

### Transfer Validation Scenario

Let's delve into a transfer scenario to understand the process of approval validation:

#### Scenario: Bob transfers x5 of Badge IDs 1-10 to Alice for the times January to March&#x20;

1. **Collection-Level Approval Check**:
   * The initial step involves verifying if the transfer adheres to collection-level rules. For instance, if Badge ID 1 is found to be non-transferable overall via the collection, the transfer attempt would be deemed unsuccessful.
2. **Incoming Approval Check**:
   * If the transfer passes the collection-level check, the subsequent step involves assessing Alice's incoming approvals. This evaluation considers whether Alice has blocked Bob from sending her badges and whether she has opted in to the specific badge collection in question.
3. **Outgoing Approval Check**:
   * Upon Alice's incoming approval, the process moves on to Bob's approvals. It's necessary to ascertain whether Bob has provided his consent for the transfer to proceed. This step is particularly significant if the transfer was initiated by a party other than Bob himself.

This layered approach to approval ensures a thorough examination of the transfer's legitimacy and compliance with various levels of permissions. The hierarchical structure prevents unauthorized transfers and enhances transparency in the transfer process.

### Customization Options

At each level, we offer the following functionality for defining approved transfers. Mix and match any combinations:

* Who can transfer to who? And who can initiate the transaction?
* When can the transfer take place?
* Which badges can be sent? For how long ([see ownership times](time-dependent-ownership.md))? What amount?
* Max number of overall transfers? Max per sender? Max per recipient? Max per initiator?
* Max amount transferred? Max per sender? Max per recipient? Max per initiator?
* Predetermined transfers?
  * Transfer A must take place before Transfer B before Transfer C
* Incremented transfers?&#x20;
  * Start with specific badges and ownership times and increment them every transaction.
  * Ex: Transfer x1 of Badge ID 1, then x1 of Badge ID 2, and so on...
* Must own (or not own) specific badges to be approved
  * Ex: Must own a membership to transfer or must now own a scammer badge to transfer
* Require sender to be the initiator? Require sender to not be the initiator?
* Require recipient to be the initiator? Require recipient to not be the initiator?
* And more!

The best way to see all that is possible is to view the badge creation process.

### **Updatability**

We also support fine-grained updatability for all combinations of the above functionality through the manager permissions.

For example, the manager can permanently lock all combinations on a collection-level to make the transferability non-updatable. Or, they can lock it for a certain amount of time. Or, they can keep it updatable. One can even combine combinations, such as locking an approval for a specific badge for a specific time for specific users.


## File: ./overview/learn/badges.md

# Badges

Badges are on-chain, public tokens ownable and transferable by users from different addresses. These are handled on our own L1 blockchain and show up in your portfolio.

Badges offer many never-seen-before-features and ways of implementation like time-dependent balances, off-chain hybrid balances, and much more. Badge distribution can be gated by claims, allowing you to offer minting / approvals gated by any criteria imaginable. On the flip side, use ownership as criteria to gate any service imaginable.

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/learn/distribution.md

# BitBadges Claims

Claims are the backbone (or connectors) of pretty much all aspects of BitBadges. Create criteria checks from 7000+ applications, plugins, and services to gate anything from content to websites to badge distribution and more. Claims offer flexible implementation methods from no-code, in-site plugins to custom webhooks to a no-code Zapier integration connecting you to 7000+ apps and more.

1. Meet criteria - Owns badge? Is in Discord server? Provided secret attendance code?
2. Receive reward - Access to services? Receive badges?

What the criteria and / or rewards are all up to you!

Let BitBadges do the heavy lifting, enabling you to focus on offering your core utility. We offer tools to help on either end (badges, address lists, etc), but ultimately, you can check any criteria and deliver any reward you want!

Claims can be simply thought of as:

Claims have super flexible implementation as well. For example:

* Check criteria on-demand vs have users claim in-site vs auto-complete on behalf of users?
* Add any plugin you want from 7000+ no-code integrations
* Custom webhooks to connect to any service on either end
* No-code Zapier / Pipedream automation workflows on either criteria or rewards side

The best way we recommend to deep dive into what all is possible is just to experiment with the claim tester in the developer portal: [https://bitbadges.io/developer](https://bitbadges.io/developer). Or, explore the site.

For additional documentation, see here:

{% content-ref url="../claim-builder/" %}
[claim-builder](../claim-builder/)
{% endcontent-ref %}

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>


## File: ./overview/learn/subscriptions.md

# Subscriptions

Subscriptions are an abstraction over the badge / NFT interface using the time-dependent balances feature. Each subscription is a time-dependent NFT owned by the user for a specific period of time. We enable recurring support through a tip system for bots to fulfill each charge period's requests. For example, if a subscription is 10 $BADGE credits / month, the user may pay 11, and the bot profits the 1 for fulfillment.&#x20;

Subscriptions follow specific rules and are a subset of the overall badge standard. Please only update subscriptions through compatible interfaces.

<figure><img src="../../.gitbook/assets/image (1) (1) (1).png" alt=""><figcaption></figcaption></figure>



## File: ./overview/learn/verification-tools.md

# Sign In with BitBadges

Gate any service (digital or in-person) with Sign In with BitBadges. All chains, one interface.

Gate your digital services with an industry standard OAuth 2..0 multi-chain authentication. This approach is a multi-chain replacement to "Sign In with Google". Or, leverage the QR code feature to create QR codes for gating in-person events. QR codes are exportable to any preferred format (email, Apple Wallet), so you do not need wallets at authentication time.

Additionally, use along with checking a claim to allow you to gate based on any criteria you want:

* Payment-gated website
* Badge-gated event
* Attestation-gated digital services
* Any combination of gated access!

We also are compatible with many frameworks and tools like Discourse, WordPress, Auth0, and more!

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

For developers interested in implementing these features, please refer to our detailed guide:

{% content-ref url="broken-reference" %}
[Broken link](broken-reference)
{% endcontent-ref %}


## File: ./overview/learn/wallets-and-sign-ins/README.md

# Wallets and Sign Ins



## File: ./overview/learn/wallets-and-sign-ins/approved-transactors.md

# Approved Transactors

**Approved Transactors**

In your account settings, BitBadges provides the option to approve other wallets to transact on-chain your behalf. Note this is different from the alternate sign ins on the prior page which approve other ways to access your BitBadges account (off-chain). This feature can be used to configure hot wallets, for example, that are easier to access and can sign on your behalf on the go.

Note: This feature is opt-in and not enabled by default.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**BitBadges Embedded Wallet**

While we allow approving any wallet / address, we offer a managed embedded wallet maintained by BitBadges. We will sign transactions / messages when requested, but the requester has to be signed in with the Embedded Wallet (embeddedWallet) scope enabled. This can be approved with an alternate sign-in method saved for your account, or check out the Sign In with BitBadges documentaion if you want to do this programmatically.

Note: The embedded wallet is its own address and needs to be treated as such. It needs to be registered, be funded, etc.

To sign transactions:

1. You must be signed in with permission to use the embedded wallet (the Embedded Wallet scope). You can configure alternate sign in methods (socials or other addresses) via the Sign In Methods tab. Ensure the Embedded Wallet scope is enabled.
2. The desired transaction message types must be approved in the account settings before transacting.
3. The wallet must have sufficient $BADGE credits.

Note this is opt-in and can be revoked at any time. This is provided as a way to trade off centralization / trust for enhanced user experience but is completely optional. Also note that the BitBadges embedded wallet is not the only option. We provide the functionality for you to approve any wallet.


## File: ./overview/learn/wallets-and-sign-ins/mobile-support.md

# Alternate Sign Ins / Mobile

If you want access to your BitBadges account on the go, consider adding approved sign-in methods in your account settings.&#x20; This allows you to access certain aspects of your account via Signing In with Discord, Google, etc, or an alternate approved method. Use at your own risk though as approving socials means account compromise on your socials -> account compromise on BitBadges. Only assign the scopes that you need. This can approve any off-chain action. 

For approving on-chain transactors, see the approved transactors page.

<figure><img src="../../../.gitbook/assets/image (158).png" alt=""><figcaption></figcaption></figure>

**Mobile Wallets**

Any mobile wallet is also supported. If you are using a mobile crypto wallet, please use best practices for that wallet. Some may require you to use their in-app browser, for example.

**Mobile App (PWA)**

While we do not have an official app on any app store, our web app is mobile friendly. It is also built as a PWA (progressive web app) which allows you to add it to your homescreen.&#x20;


## File: ./overview/learn/wallets-and-sign-ins/supported-wallets.md

# Supported Wallets

BitBadges is compatible with wallets from any of the supported chain's ecosystems.

**Ethereum** - 500+ via WalletConnect and compatible with any injected wallet

**Cosmos** - Keplr, Leap, Cosmostation

**Bitcoin** - Leather, Phantom

**Solana** - Phantom

**Privy** - We also support Privy wallets which help you map standard socials sign ins to an Ethereum wallet!

**Guest Accounts -** We also support browser-based, rotatable, temporary guest accounts.

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Note: Because we verify signatures on our own chain and do not pull data from any other chain, contract wallets like Coinbase Smart Wallet are not supported.


## File: ./overview/link-sharing.md

# 🤝 Brand Guidelines

Feel free to use BitBadges name and logo in your site as you see fit. If you have any questions or concerns about usage, please let us know. We are also happy to provide any other logos, images, or information you may need.

**Text Logo**

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Square Logo**

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>



## File: ./overview/official-links.md

# 🔗 Official Links and Resources

Below is a list of official links for socials and other platforms. Our preferred contact is Discord. This is not an exhaustive list. See the rest of the documentation for more information on specific subjects.

* [BitBadges App](https://bitbadges.io)
* [Explorer](https://explorer.bitbadges.io)

### Documentation

* [LLM .txt](../for-llms.txt) - Entire documentation dumped into one file

### Socials

* [Discord](https://discord.com/invite/TJMaEd9bar)
* [LinkedIn](https://linkedin.com/company/bitbadges)
* [Twitter](https://twitter.com/bitbadges_io)
* [Facebook](https://facebook.com/profile.php?id=100092259215026)
* [Instagram](https://instagram.com/bitbadges_official/)
* [Slack](https://bitbadges.slack.com/join/shared_invite/zt-1tws89arl-TMSK_4bdTLOLdyp177811Q#/shared-invite/email)
* [Reddit](https://www.reddit.com/r/BitBadges/)
* [Telegram](https://t.me/BitBadges)
* [GitHub](https://github.com/bitbadges)

### Integrations

* [Zapier](https://zapier.com/apps/bitbadges/integrations)
* [Chrome Extension](https://chromewebstore.google.com/detail/bitbadges-chrome-extensio/ocdlkggomnifibfadgaakkilojelgacj?authuser=0\&hl=en)
* [MetaMask Snap Download](https://snaps.metamask.io/snap/npm/bitbadges-snap/)&#x20;

### API & SDK

* [NPM API / SDK Package](https://www.npmjs.com/package/bitbadgesjs-sdk) ([Docs](../for-developers/bitbadges-sdk/))
* [API Documentation](https://bitbadges.stoplight.io/docs/bitbadges) ([Docs](../for-developers/bitbadges-api/))
* [Quickstarter Demo](https://bitbadges.io/quickstart)
* [Python API / SDK Package](https://pypi.org/project/bitbadgespy-sdk/)

```bash
# Using npm
npm install bitbadgesjs-sdk

# Using pnpm
pnpm add bitbadgesjs-sdk

# Using bun
bun add bitbadgesjs-sdk

# Using pip
pip install bitbadgespy-sdk
```

### Running a Node

* [Run a Node](https://docs.bitbadges.io/for-developers/bitbadges-blockchain/run-a-node)

Learn more about the team at [https://bitbadges.io/about](https://bitbadges.io/about).


## File: ./overview/staking-usdbadge.md

# Staking / Validators

The BitBadges blockchain is a [delegated proof-of-stake blockchain](https://101blockchains.com/proof-of-stake-vs-delegated-proof-of-stake/). Delegated Proof of Stake (DPoS) is a blockchain consensus mechanism where token holders elect a small group of trusted members (validators) to validate transactions and maintain the network. These validators stake their own stake and earn additional stake from maintaining the network.&#x20;

The delegated part is because token holders can delegate their stake to validators and split the earned, according to their delegation and commission charged by the validator. This enables token holders to contribute to the security of the network without running their own validator.

Reach out to us in Discord if you plan to run a validating node and need funds. To run a validator node, see [here](../for-developers/bitbadges-blockchain/run-a-node/).&#x20;

BitBadges is also a delegated PoS chain, so you can delegate to an existing validator. This validator will split the amount earned from securing the network with you (they may charge a commission). Visit [https://bitbadges.io/stake](https://bitbadges.io/stake).&#x20;

Behind the scenes, this uses the [Cosmos SDK staking](https://docs.cosmos.network/main/modules/staking) module.&#x20;

## **Governance**

Initially, we do not plan to use a governance structure to allow us to ship fast and build a great prduct. Over time as we shift to becoming more decentralized, we will allow stakeholders to propose and vote on governance proposals, weighted via their amount. This will be via the [Cosmos SDK governance module](https://docs.cosmos.network/main/modules/gov). These governance proposals will allow holders to decide on the future of BitBadges.


## File: ./overview/testnet-mode.md

# 🧪 Testnet Mode

Testnet mode provides a separate environment for testing purposes. Simply turn on the switch (or go to [testnet.bitbadges.io](https://testnet.bitbadges.io)). It is isolated from the production environment of BitBadges and uses its own resources, such as a testnet blockchain, database, API, and more.

<pre><code><strong>Note: Third-party integrations (e.g. claim plugins) are the exact same.
</strong></code></pre>

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Important Notes

You should treat testnet as an entirely SEPARATE service. NOTHING will carry over from normal mode (not even profiles, badges, settings, anything). Consider this before determining whether testnet mode is the correct option for you.

### Differences

-   Some features available in production may not be accessible in testnet:
    -   Off-chain balances managed by BitBadges are not hosted externally (via CDN)
    -   Buying $BADGE credits
    -   Push notifications
    -   And more
-   Some restrictions may be more relaxed
    -   No API keys required
    -   Faucet may be more lenient
-   Performance also may differ from the production environment

### Links

Frontend: [https://testnet.bitbadges.io](https://testnet.bitbadges.io)

Backend: [https://api.bitbadges.io/testnet](https://api.bitbadges.io/testnet) (append the normal routes to this base URL)

Testnet Node:

-   RPC: [https://testnet.node.bitbadges.io/rpc](https://testnet.node.bitbadges.io/rpc)
-   REST: [https://testnet.bitbadges.io/api](https://testnet.bitbadges.io/api)
-   Direct Node Access: `http://138.197.10.8:YOUR_PORT`

### Feedback

If there is anything we can do to make development easier, let us know.


## File: ./overview/use-cases.md

# 🎨 Use Cases

Because you can check criteria for anything, there are infinitely many possible use cases for BitBadges! Below are some of our favorites. You can also browse featured items at [https://bitbadges.io/browse](https://bitbadges.io/browse).

## Core Tokenization Use Cases

-   **Subscriptions** - Create time-based subscription tokens with built-in expiration dates for services like streaming platforms, gym memberships, or software licenses. Easily verify subscription status through our public API.
-   **Quests & Gamification** - Design quest systems and achievement badges for gaming, education, or community engagement. Track progress and reward completion with verifiable digital badges.
-   **Tradable NFTs** - Create unique, tradable digital assets with advanced features like time-dependent ownership and cross-chain compatibility that go beyond traditional NFT standards.
-   **Tradable Tokens** - Issue fungible or semi-fungible tokens that can be traded across multiple blockchain ecosystems with built-in transferability controls.
-   **Profile Pictures & Digital Identity** - Create verifiable profile pictures and digital identity tokens that prove authenticity and ownership across platforms.
-   **Products & Merchandise** - Tokenize physical or digital products, enabling verification of authenticity, ownership tracking, and exclusive access to limited editions.

## Additional Use Cases

-   **Access Control & Gated Content** - Control access to premium content, private Discord servers, exclusive websites, or any digital service. Gate content behind badge ownership for tiered access systems.
-   **Memberships** - Create membership badges with expiration dates for gyms, clubs, organizations, or subscription services. Easily verify membership status through our public API.
-   **Achievements & Credentials** - Issue verifiable credentials like university diplomas, professional certifications, job qualifications, awards, and athletic accomplishments that can be verified anywhere.
-   **Collectibles** - Create unique digital collectibles with advanced features like time-dependent ownership, fine-grained transferability rules, and multi-chain compatibility.
-   **Proof of Anything** - Use badges as the source of truth for any claim - proof of attendance, voting records, completion of tasks, authenticity verification, or protection against deep fakes and scams.
-   **Decentralized Verification** - Multiple verification services can give out verification badges, and you can choose which person/entity to get your verification ticks from. Or, verification can be more fine-grained and each entity / company can assign badges to their own registered employees / community.
-   **Security and Safety -** Maybe a badge is assigned to every address who's private keys are compromised. Apps can then refuse service to such addresses.
-   **Cross-Chain Protocols -** Implement a cross-chain follow, messaging, social media, etc protocols where every post, message, item is a badge being transferred / minted.&#x20;
-   **Visual Block Explorers:** Query on-chain activity in a visual way with badges. For example, to see when a user's first blockchain transaction was, see which badge they own (OG 2015 User vs OG 2023 User, etc.)
-   **Recognition of Achievement or Completion** - Job certifications, awards, athletic accomplishments, etc.
-   **E-Learning** - Gamify the learning experience through learning badges
-   **University Diplomas** - Universities can offer verifiable diplomas to students as a badge.
-   **Publications** - Verify you are the author of a publication
-   **Real Estate** - Custom encrypted title ownership, HOAs, and even MLS documents registered through the blockchain
-   **Praise / Vouch Badges** - Praise, recommend, or vouch for something or someone/
-   Literally anything!


## File: ./x-badges/README.md

# Overview

This directory contains comprehensive developer documentation for the BitBadges blockchain's `x/badges` module.

This section is a knowledge dump for how badges operate behind the scenes. For most use cases, you will not care about any of this as it will be handled for you via the site. And if you are self-implementing a badge-gated service, you can just fetch badge balances and metadata from the API without worrying about the underlying details.

```typescript
const res = await BitBadgesApi.getBadgeBalanceByAddress(collectionId, address, {
    ...options,
});
console.log(res);

const res = await BitBadgesApi.getBadgeMetadata(1, 5);
```

## Table of Contents

1. [Introduction](./introduction.md) - Overview and key concepts
2. [Concepts](./02-concepts.md) - Core data structures and business logic
3. [State](./state.md) - State management and storage patterns
4. [Messages](./messages/) - Transaction messages and handlers
5. [Queries](./queries/) - Query types and endpoints
6. [Events](./events.md) - Event emissions and tracking
7. [Examples](./examples/) - Common usage patterns and building blocks

## Message Reference

### Collection Management

-   [MsgCreateCollection](./messages/msg-create-collection.md) - Create new badge collection
-   [MsgUpdateCollection](./messages/msg-update-collection.md) - Update existing collection
-   [MsgDeleteCollection](./messages/msg-delete-collection.md) - Delete collection

### Badge Transfers

-   [MsgTransferBadges](./messages/msg-transfer-badges.md) - Transfer badges between addresses

### User Approvals

-   [MsgUpdateUserApprovals](./messages/msg-update-user-approvals.md) - Update transfer approvals

### Address Lists & Dynamic Stores

-   [MsgCreateAddressLists](./messages/msg-create-address-lists.md) - Create reusable address lists
-   [MsgCreateDynamicStore](./messages/msg-create-dynamic-store.md) - Create key-value store
-   [MsgUpdateDynamicStore](./messages/msg-update-dynamic-store.md) - Update dynamic store properties
-   [MsgDeleteDynamicStore](./messages/msg-delete-dynamic-store.md) - Delete dynamic store
-   [MsgSetDynamicStoreValue](./messages/msg-set-dynamic-store-value.md) - Set address-specific store values
-   [More messages...](./messages/) - See full message reference

## Query Reference

### Core Queries

-   [GetCollection](./queries/get-collection.md) - Retrieve collection data
-   [GetBalance](./queries/get-balance.md) - Get user badge balances
-   [GetApprovalTracker](./queries/get-approval-tracker.md) - Get approval usage data
-   [GetAddressList](./queries/get-address-list.md) - Retrieve address list
-   [More queries...](./queries/) - See full query reference

## Quick Links

-   [BitBadges Chain Repository](https://github.com/bitbadges/bitbadgeschain)
-   [BitBadges Documentation](https://docs.bitbadges.io)
-   [Proto Definitions](https://github.com/bitbadges/bitbadgeschain/tree/master/proto/badges)

## Documentation Style

This documentation follows the [Cosmos SDK module documentation standards](https://docs.cosmos.network/main/building-modules/README) and is designed for developers building on or integrating with the BitBadges blockchain.


## File: ./x-badges/concepts/README.md

# Concepts

This directory contains detailed explanations of the core concepts and data structures that form the foundation of the BitBadges module.

## Overview

Each concept is documented in its own file for better organization and easier navigation:

-   **[UintRange](uintrange.md)** - Representing ranges of unsigned integers
-   **[Timeline System](timeline-system.md)** - How properties change over time with immutable historical records
-   **[Badge Collections](badge-collections.md)** - The primary entity that defines groups of related badges
-   **[Balance System](balance-system.md)** - How badge ownership is tracked with precise control over quantities and time
-   **[Balances Type](balances-type.md)** - How badge ownership and transfers are managed within collections
-   **[Default Balances](default-balances.md)** - Predefined balance stores assigned to new users upon genesis creation
-   **[Valid Badge IDs](valid-badge-ids.md)** - Defining the range of badge identifiers that can exist within a collection
-   **[Total Supply](total-supply.md)** - Maximum number of badges that can exist for each badge ID
-   **[Mint Escrow Address](mint-escrow-address.md)** - Reserved address for holding native funds on behalf of the Mint address
-   **[Archived Collections](archived-collections.md)** - Temporarily or permanently disabling collection transactions
-   **[Metadata](metadata.md)** - Rich, dynamic content for collections and badges with timeline support
-   **[Manager](manager.md)** - Central authority for collection administration with timeline-based control
-   **[Transferability & Approvals](transferability-approvals.md)** - Overview of the three-tier approval system for badge transfers
-   **[Approval Criteria](approval-criteria/)** - Detailed approval criteria and conditions for badge transfers
-   **[Address Lists](address-lists.md)** - Reusable collections of addresses for approval configurations
-   **[Permissions](permissions/README.md)** - Granular control over collection management operations
-   **[Standards](standards.md)** - Generic framework for defining collection behavior and interpretation guidelines
-   **[Time Fields](time-fields.md)** - Understanding the different time-related fields used throughout BitBadges
-   **[Custom Data](custom-data.md)** - Generic string fields for storing arbitrary application-specific data
-   **[Cosmos Wrapper Paths](cosmos-wrapper-paths.md)** - 1:1 wrapping between badges and native Cosmos SDK coins for IBC compatibility
-   **[Protocols](protocols/)** - Standardized implementation patterns for badge collections


## File: ./x-badges/concepts/address-lists.md

# Address Lists

Address lists define collections of addresses for use in approval configurations. They support both static lists stored on-chain and dynamic reserved patterns for common access control scenarios.

## Usage in Approval Configurations

Address lists are referenced by ID in three approval contexts. IDs can either be reserved, shorthand IDs or user-created lists via `MsgCreateAddressLists`.

### Collection Approvals

```protobuf
message CollectionApproval {
  string fromListId = 1;        // Who can send badges
  string toListId = 2;          // Who can receive badges
  string initiatedByListId = 3; // Who can initiate transfers
  // ... other fields
}
```

### User Outgoing Approvals

```protobuf
message UserOutgoingApproval {
  string toListId = 1;          // Who user can send to
  string initiatedByListId = 2; // Who can initiate on user's behalf
  // ... other fields
}
```

### User Incoming Approvals

```protobuf
message UserIncomingApproval {
  string fromListId = 1;        // Who can send to user
  string initiatedByListId = 2; // Who can initiate transfers to user
  // ... other fields
}
```

### Usage Examples

#### Universal Access

```json
{
    "fromListId": "AllWithoutMint", // Everyone except Mint
    "toListId": "All", // Everyone including Mint
    "initiatedByListId": "All" // Anyone can initiate
}
```

#### Restricted Access

```json
{
    "fromListId": "vipMembers", // Only VIP members can send
    "toListId": "!banned", // Everyone except banned users
    "initiatedByListId": "AllWithoutMint"
}
```

#### Quick Address Lists

```json
{
    "fromListId": "bb1alice...:bb1bob...:bb1charlie...", // Direct addresses
    "toListId": "AllWithoutMint:bb1blocked...", // Everyone except these
    "initiatedByListId": "All"
}
```

## Proto Definition

```protobuf
message AddressList {
  string listId = 1;           // Unique identifier
  repeated string addresses = 2; // List of addresses
  bool whitelist = 3;          // true = whitelist, false = blacklist
  string uri = 4;              // Metadata URI
  string customData = 5;       // Custom data
  string createdBy = 6;        // Creator address
}
```

## Reserved Address List IDs

BitBadges provides built-in reserved list IDs that are dynamically generated without storage overhead:

### Core Reserved Lists

#### "Mint"

-   **Purpose**: Contains only the "Mint" address
-   **Logic**: Whitelist (addresses: ["Mint"], whitelist: true)
-   **Use case**: Minting operations and initial badge distribution

#### "All" and "AllWithMint"

-   **Purpose**: Represents all addresses including Mint
-   **Logic**: Blacklist with empty addresses list (addresses: [], whitelist: false)
-   **Use case**: Universal access, public collections

#### "None"

-   **Purpose**: Represents no addresses
-   **Logic**: Whitelist with empty addresses list (addresses: [], whitelist: true)
-   **Use case**: Blocking all access, disabled transfers

### Dynamic Patterns

#### AllWithout Pattern

-   **Format**: `"AllWithout<addresses>"` where addresses are colon-separated
-   **Example**: `"AllWithoutMint"`, `"AllWithoutMint:bb1user123"`
-   **Logic**: Blacklist containing the specified addresses (addresses: ["Mint", "bb1user123"], whitelist: false)
-   **Use case**: Allow everyone except specific addresses

#### Colon-Separated Addresses

-   **Format**: `"address1:address2:address3"`
-   **Logic**: Whitelist containing the specified addresses (addresses: ["bb1user123", "bb1user234", "bb1user345"], whitelist: true)
-   **Use case**: Quick address lists without creating stored lists

#### Inversion Patterns

-   **Format**: `"!listId"` or `"!(listId)"`
-   **Effect**: Inverts the whitelist/blacklist behavior of the referenced list
-   **Example**: `"!5"` inverts list ID 5's behavior

## Whitelist vs Blacklist Logic

Address lists use a boolean `whitelist` field to determine inclusion/exclusion behavior:

### Whitelist Logic (`whitelist: true`)

```javascript
function isAddressIncluded(address, addressList) {
    const found = addressList.addresses.includes(address);
    return addressList.whitelist ? found : !found;
}
```

-   **Listed addresses**: Explicitly included
-   **Unlisted addresses**: Explicitly excluded
-   **Use case**: "Only these addresses are allowed"

### Blacklist Logic (`whitelist: false`)

-   **Listed addresses**: Explicitly excluded
-   **Unlisted addresses**: Explicitly included
-   **Use case**: "All addresses except these are allowed"

### Inversion Effect

When a list ID has the `"!"` prefix, the final whitelist boolean is inverted:

-   Whitelist becomes blacklist behavior
-   Blacklist becomes whitelist behavior

## Usage in Approval Configurations

Address lists are referenced by ID in three approval contexts:

### Collection Approvals

```protobuf
message CollectionApproval {
  string fromListId = 1;        // Who can send badges
  string toListId = 2;          // Who can receive badges
  string initiatedByListId = 3; // Who can initiate transfers
  // ... other fields
}
```

### User Outgoing Approvals

```protobuf
message UserOutgoingApproval {
  string toListId = 1;          // Who user can send to
  string initiatedByListId = 2; // Who can initiate on user's behalf
  // ... other fields
}
```

### User Incoming Approvals

```protobuf
message UserIncomingApproval {
  string fromListId = 1;        // Who can send to user
  string initiatedByListId = 2; // Who can initiate transfers to user
  // ... other fields
}
```

## Address List Creation

### User-Created Lists

Created through `MsgCreateAddressLists` with the requirements below. Once created, this list is immutable and cannot be modified.

#### ID Validation Rules

-   Must be alphanumeric characters only
-   Cannot be empty or reserved keywords
-   Cannot contain `:` or `!` characters
-   Cannot be valid addresses themselves
-   Cannot conflict with reserved IDs

#### Address Validation

-   All addresses must be valid Bech32 format
-   No duplicate addresses allowed
-   Special addresses like "Mint" are permitted

### Example User-Created List

```json
{
    "listId": "vipMembers",
    "addresses": ["bb1alice...", "bb1bob...", "bb1charlie..."],
    "whitelist": true,
    "uri": "https://api.example.com/vip-list",
    "customData": "VIP members with exclusive access",
    "createdBy": "bb1manager..."
}
```

## Performance Characteristics

Tip: Use reserved IDs for common patterns. Use user-created lists for large lists used multiple times.

### Reserved Lists

-   **Storage**: Zero on-chain storage
-   **ID Length**: Dependent on the pattern used
-   **Resolution**: Dynamic generation at runtime
-   **Gas efficiency**: Minimal overhead for common patterns

### User-Created Lists

-   **Storage**: On-chain storage per list
-   **ID Length**: Reusable short ID that can be used to reference complex lists
-   **Resolution**: Direct store lookup
-   **Gas cost**: Proportional to validation complexity

## Address Lists vs Dynamic Stores

Both address lists and dynamic stores can control who is approved for transfers, but they serve different purposes:

### Address Lists

-   **Purpose**: Immutable shorthand references for collections of addresses
-   **Mutability**: Cannot be modified after creation - addresses are fixed
-   **Storage**: Direct list of addresses stored on-chain
-   **Use case**: Static whitelists/blacklists that don't change over time

### Dynamic Stores

-   **Purpose**: Mutable on-chain approval management with CRUD operations
-   **Mutability**: Can be updated dynamically using CRUD messages (Create, Update, Delete, Set)
-   **Storage**: Boolean values per address (true/false approval status)
-   **Use case**: Dynamic approval systems that need real-time updates (typically contract logic)


## File: ./x-badges/concepts/approval-criteria/README.md

# Approval Criteria



## File: ./x-badges/concepts/approval-criteria/approval-system.md

# Overview

In the transferability page, we mainly talked about how we match and check an approval. Here, we will talk about the **approvalCriteria.**

These are the additional options or restrictions you can set which decide whether a transfer is approved or not (e.g. how much can be transferred? how many times? etc). To be approved, it must satisfy all the options / restrictions set (everything talked about in the last page AND the **approvalCriteria**).

```typescript
export interface iApprovalCriteria<T extends NumberType> {
    /** The $BADGE transfers to be executed upon every approval. */
    coinTransfers?: iCoinTransfer<T>[];
    /** The list of merkle challenges that need valid proofs to be approved. */
    merkleChallenges?: iMerkleChallenge<T>[];
    /** The predetermined balances for each transfer. */
    predeterminedBalances?: iPredeterminedBalances<T>;
    /** The maximum approved amounts for this approval. */
    approvalAmounts?: iApprovalAmounts<T>;
    /** The max num transfers for this approval. */
    maxNumTransfers?: iMaxNumTransfers<T>;
    /** Whether the to address must equal the initiatedBy address. */
    requireToEqualsInitiatedBy?: boolean;
    /** Whether the from address must equal the initiatedBy address. */
    requireFromEqualsInitiatedBy?: boolean;
    /** Whether the to address must not equal the initiatedBy address. */
    requireToDoesNotEqualInitiatedBy?: boolean;
    /** Whether the from address must not equal the initiatedBy address. */
    requireFromDoesNotEqualInitiatedBy?: boolean;
    /** Whether this approval overrides the from address's approved outgoing transfers. */
    overridesFromOutgoingApprovals?: boolean;
    /** Whether this approval overrides the to address's approved incoming transfers. */
    overridesToIncomingApprovals?: boolean;
}
```

**Extending Functionality**

These are just the native options provided in the interface for convenience and consistency, but you can always implement your own approvals via custom logic with a CosmWASM smart contract.

Or, you can leverage the native features for custom implementations:

-   Use Merkle challenges as a commit-reveal claim code mechanism. This is what we do for BitBadges claims. Then, you can assign claim codes how you wish.&#x20;
-   Create custom, general-purpose zero-knowledge circuits that need to be satisfied. Implement your custom logic within in the circuit (if it lends itself to this approach).

#### Tracker IDs

The approval interface utilizes trackers behind the scenes for certain fields which are identified by IDs (**amountTrackerId, challengeTrackerId)**. Trackers are increment only and immutable in storage and referenced by an ID consisting of **approvalId-trackerId** plus other identifying details. Because the **approvalId** is in there, this enforces that all trackers are scoped to a specific approvalId. However, since they are ID based and increment only, it is important to be careful to not use previous IDs that have state. See best practices below.

**Best Practices - Creating / Updating / Deleting**

A really important part in creating / editing / deleting approvals is to keep track of the trackers' state. You do not want to use a tracker with prior history when creating an approval which should start from scratch. This messes up the expected behavior of the approval. You can't just simply delete the tracker because it is increment only and immutable.

To combat this, we recommend the following best practices:

-   When creating an approval for the first time (which is expected to start completely from scratch), always use unique, unused IDs for **approvalId**, **amountTrackerId** and **challengeTrackerId**. If these are unique, the tracker IDs will also be unique which means they will have no prior history.
-   When you want entirely new state (whole approval), change the **approvalId** to something unique. This makes all tracker IDs different. This is the recommended option (if applicable) because you know for certain that all trackers have been reset.
-   When you want just an individual tracker's state to be reset, you need to change the individual tracker ID to a aunique unused vaue.

#### Scoped vs Cross-Approval Logic

All approvals' state is expected to be scoped, but sometimes, you may want to implement cross-approval logic (e.g. do not allow double dipping between two approvals). This, unfortunately, is out of scope for the native interface at the moment. Consider workarounds and careful design decisions.&#x20;

However, if you do need more advanced functionality, you may have to go up a level and use CosmWASM or alternative solutions. If you run into this problem, let us know, and we can recommend what to do.&#x20;


## File: ./x-badges/concepts/approval-criteria/approval-trackers.md

# Approval Trackers

```typescript
export interface iApprovalAmounts<T extends NumberType> {
  ...
  
  /** The ID of the approval tracker. This is the key used to track tallies. */
  amountTrackerId: string;
}
```

```typescript
export interface iMaxNumTransfers<T extends NumberType> {
  ...
  
  /** The ID of the approval tracker. This is the key used to track tallies. */
  amountTrackerId: string;
}
```

## Approval Trackers

Approval or amount trackers track how many badges have been transferred and how many transfers have occurred. This is done via an incrementing tally system with a threshold.&#x20;

Take the following approval tracker

1. You are approved for x10 of badge IDs 1-10. For simplicity, lets say the tracker ID is "xyz".
2. You transfer x5 of badge IDs 1-10 -> "xyz" tally goes from x0/10 -> x5/10
3. You transfer another x5 -> "xyz" tally goes to x10/10
4. You transfer another x1 -> exceed threshold so transfer fails and will also fail for all subsequent approvals that match to "xyz".
5. However, if subsequent transfers match to tracker "abc", the tally starts from zero again because it is a different tracker w/o any history.

### **How are approval trackers identified?**

Above, we used "xyz" for simplicity, but the identifier of each approval tracker actually consists of **amountTrackerId** along with other identifying details.

Note that if multiple approvals specify the same **amountTrackerId,** the SAME tracker will be incremented when DIFFERENT approvals are used. This is because the tracker identifier will be the same and thus increment the same tracker. However, all tracker IDs specify the **approvalId** which must be unique. Thus, all trackers are only ever scoped to a single aproval.

```
ID: collectionId-approvalLevel-approverAddress-approvalId-amountTrackerId-trackerType-approvedAddress
```

```typescript
export interface ApprovalTrackerIdDetails<T extends NumberType> {
  collectionId: T
  approvalLevel: "collection" | "incoming" | "outgoing" | ""
  approvalId: string
  approverAddress: string
  amountTrackerId: string
  trackerType: "overall" | "to" | "from" | "initiatedBy" | ""
  approvedAddress: string
}
```

The **trackerType** corresponds to what type of tracker it is. For example, should we increment every time this approval is used? per unique recipient? sender? initiator?

If "overall", this is applicable to any transfer and will increment everytime the approval is used. This creates a single universal tally. **approvedAddress** will be empty.&#x20;

If "to", "from", or "initiatedBy", the **approvedAddress** is the sender, recipient, or initiator of the transfer, respectively. Note since **approvedAddress** and **trackerType** are part of the approval tracker's identifier, this creates unique individual tallies (trackers) per address.

For example, these correspond to different trackers because the **approvedAddress** is different. Thus, Alice's transfers will be tracked separately from Bob's.

`1-collection- -approvalId-uniqueID-initiatedBy-alice`

`1-collection- -approvalId-uniqueID-initiatedBy-bob`

**Handling Multiple Trackers**

Trackers are ID-based, and thus, multiple trackers can be created. Take note of what makes up the ID. The collection ID, approval level, approver address, and more are all considered. If one changes or is different, the whole ID is different and will correspond to a new tracker.

**Increment Only**

Trackers are increment only and immutable in storage. To start an approval tally from scratch, you will need to map the approval to a new unused ID. This can be done simply by editing **amountTrackerId** (because this changes the whole ID) or restructuring to change one of the other fields that make up the overall ID.

IMPORTANT: Because of the immutable nature, be careful to not revert to a previously used ID unintentionally because the starting point will be the previous tally (not starting from scratch).

### **What is tracked?**

```typescript
export interface ApprovalTrackerInfoBase<T extends NumberType> extends ApprovalTrackerIdDetails<T> {
  numTransfers: T;
  amounts: Balance<T>[];
  lastUpdatedAt: UnixMilliTimestamp<T>;
}
```

Each transfer that maps to the tracker increments **numTransfers** by 1, and each badge transferred increments the **amounts** in the interface (if tracked).

Example:

`ID: 1-collection- -uniqueID-initiatedBy-alice`

```json
{
    "numTransfers": 10,
    "amounts": [{ 
        "amount": 10n, 
        "badgeIds": [{ start: 1n, end: 1n }], 
        "ownershipTimes":  [{ start: 1n, end: 100000000000n }], 
    }]
}
```

**As-Needed Basis**

We increment on an as-needed basis. Meaning, if there is no need to increment the tally (unlimited limit and/or not restrictions), we **do not increment** for efficiency purposes. For example, if we only have requirements for **numTransfers** but do not need the **amounts**, we do not increment the amounts.

**Different Tracker IDs - Amounts vs Transfers**

It is possible to have different tracker IDs for the number of transfers and amounts (as seen at the top of the page). However, typically, these will be the same for simplicity.

### **Resets**

For both tracker types, we also allow occasional resets to zero. If it is the first update of the interval, we will reset all tracker progress. This is useful for recurring subscriptions (one transfer per month), for example.

If they are left as 0, there is no reset.&#x20;

Whether an update is needed or not is calculated using the lastUpdatedAt field.

```typescript
/**
 * @category Interfaces
 */
export interface iResetTimeIntervals<T extends NumberType> {
  /** The start time of the first interval. */
  startTime: T;
  /** The length of the interval. */
  intervalLength: T;
}

```


## File: ./x-badges/concepts/approval-criteria/badge-ownership.md

# Badge Ownership

Must own badges are another unique feature that is very powerful. This allows you to specify certain badges and amounts of badges of a collection (typically a different collection) that must be owned in order to be approved. This is checked on-chain.

For example, you may implement a badge collection where only holders of a verified badge are approved to send and receive badges. Or, you may implement what you must NOT own (own x0) a scammer badge in order to interact.

Note that alternatively, you may choose to check / enforce this off-chain as well via BitBadges claims.

```typescript
export interface MustOwnBadges<T extends NumberType> {
  collectionId: T;

  amountRange: UintRange<T>; //min/max amount expected to be owned
  ownershipTimes: UintRange<T>[];
  badgeIds: UintRange<T>[];
  
  //override ownershipTimes with the exact block millisecond at execution
  //Ex: [{start: 12345, end: 12345}]
  overrideWithCurrentTime: boolean;
  
  //if true, must meet ownership requirements for ALL badges
  //if false, must meet ownership requirements for ONE badge
  mustSatisfyForAllAssets: boolean; 
}
```


## File: ./x-badges/concepts/approval-criteria/dynamic-store-challenges.md

# Dynamic Store Challenges

Dynamic Store Challenges are approval criteria that require the transfer initiator to pass boolean checks against one or more dynamic stores. The concept is simple: if a user can return `true` for all dynamic store fetches by their address (the initiator), they pass all challenges.

This is a powerful feature that can be used to implement complex approval logic. This is intended to be used in conjunctions with smart contracts allowing for more complex logic to be implemented.

Note: For fully off-chain alternatives, you may want to consider the merkleChallenges field to save on gas costs and avoid the need for transactions.

## Proto Definition

```protobuf
// DynamicStoreChallenge defines a challenge that requires the initiator to pass a dynamic store check.
message DynamicStoreChallenge {
  // The ID of the dynamic store to check.
  string storeId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

## How It Works

### Challenge Logic

1. **Initiator Check**: The system checks the transfer initiator's address against the specified dynamic store
2. **Boolean Evaluation**: The dynamic store returns a boolean value for the initiator's address
3. **Pass Requirement**: The initiator must have a `true` value in the dynamic store to pass the challenge
4. **Multiple Challenges**: If multiple challenges exist, the initiator must pass ALL of them

### Challenge Evaluation

```javascript
function passesAllChallenges(initiatorAddress, challenges) {
    for (const challenge of challenges) {
        const storeValue = getDynamicStoreValue(
            challenge.storeId,
            initiatorAddress
        );
        if (!storeValue) {
            return false; // Failed challenge
        }
    }
    return true; // Passed all challenges
}
```

## Usage in Approval Criteria

Dynamic store challenges can be used in all three approval levels:

### Collection Approval Criteria

```json
{
    "dynamicStoreChallenges": [
        {
            "storeId": "1"
        },
        {
            "storeId": "5"
        }
    ]
}
```

### Outgoing Approval Criteria

```json
{
    "dynamicStoreChallenges": [
        {
            "storeId": "3"
        }
    ]
}
```

### Incoming Approval Criteria

```json
{
    "dynamicStoreChallenges": [
        {
            "storeId": "2"
        }
    ]
}
```

## Use Cases

### Membership Verification

-   **VIP Access**: Store `true` for VIP members in a dynamic store
-   **Active Users**: Track active users with periodic updates
-   **Subscription Status**: Verify current subscription status

### Governance and Voting

-   **Voting Rights**: Store voting eligibility in dynamic stores
-   **Proposal Participation**: Track participation in governance proposals
-   **Staking Requirements**: Verify staking status for transfer privileges

### Game Mechanics

-   **Achievement Unlocks**: Require specific achievements for certain transfers
-   **Level Requirements**: Check player levels or progression
-   **Quest Completion**: Verify quest completion status

### Compliance and KYC

-   **Identity Verification**: Store KYC completion status
-   **Compliance Checks**: Verify regulatory compliance
-   **Whitelist Management**: Maintain dynamic whitelists

## Example Implementation

### Setup Dynamic Store Challenge

```json
{
    "collectionApprovals": [
        {
            "approvalId": "member-only-transfers",
            "fromListId": "All",
            "toListId": "All",
            "transferTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "badgeIds": [{ "start": "1", "end": "100" }],
            "dynamicStoreChallenges": [
                {
                    "storeId": "1" // Member status store
                },
                {
                    "storeId": "2" // Active subscription store
                }
            ]
        }
    ]
}
```

### Managing Store Values

Users and managers can update dynamic store values using the appropriate messages and queries.

## Related Operations

For more information on managing dynamic stores, see:

-   **[Create Dynamic Store](../../messages/msg-create-dynamic-store.md)** - Creating new dynamic stores
-   **[Update Dynamic Store](../../messages/msg-update-dynamic-store.md)** - Updating store properties
-   **[Delete Dynamic Store](../../messages/msg-delete-dynamic-store.md)** - Removing dynamic stores
-   **[Set Dynamic Store Value](../../messages/msg-set-dynamic-store-value.md)** - Setting address-specific values
-   **[Get Dynamic Store Value](../../queries/query-get-dynamic-store-value.md)** - Querying store values

## Important Notes

### Default Values

-   Dynamic stores have default values for uninitialized addresses
-   If an address has no explicit value, the default is used
-   Default values are set when creating the dynamic store

### Performance Considerations

-   Dynamic store lookups are efficient on-chain operations
-   Multiple challenges are evaluated sequentially
-   Consider the gas cost of multiple store lookups

### Security Implications

-   Store creators control who can update values
-   Values can be changed, affecting future challenge results
-   Design challenges with appropriate access controls

Dynamic Store Challenges provide a flexible and powerful way to implement complex approval logic while maintaining simplicity in the core protocol design.


## File: ./x-badges/concepts/approval-criteria/linking-trackers-advanced.md

# Extending the Approval (Advanced)

We try to offer as much as we can in the native interface; however, in edge cases, you may run into scenarios where you need more advanced functionality, for example, cross-approval functionality or access to other blockchain data / modules.

Before trying to extend the approval, please consider workarounds and design considerations. Many approvals that you think may need extension can be altered to fit into the native interfaces by thinking out of the box.

If you truly do need a more custom implementation, you will have to build your own smart contract with CosmWASM or an alternative self-implementation and call into the x/badges module. We refer you to the Tutorials section for how to do so.&#x20;

Please also let us know if whatever you are missing can be added natively. Our end goal is to have no one ever write a smart contract.



## File: ./x-badges/concepts/approval-criteria/max-number-of-transfers.md

# Max Number of Transfers

Pre-Readings (IMPORTANT): [Approval Trackers](approval-trackers.md)

```typescript
export interface ApprovalCriteria<T extends NumberType> {
  ...
  maxNumTransfers?: MaxNumTransfers<T>;
  ...
}
```

Similar to approval amounts, you can also specify the maximum number of transfers that can occur on an overall or per sender/recipient/initiatedBy basis. If tracked, the corresponding approval tracker will be incremented by 1 each transfer.&#x20;

"0" means unlimited allowed and not tracked. "N" means max N transfers allowed.

**Example**

Let's say we have the ID `1-collection- -approvalId-uniqueID-initiatedBy-alice` and the defined values below:

<pre class="language-json"><code class="lang-json">"maxNumTransfers": {
<strong>    "overallMaxNumTransfers": "0",
</strong>    "perFromAddressMaxNumTransfers": "0",
    "perToAddressMaxNumTransfers": "0",
    "perInitiatedByAddressMaxNumTransfers": "1",
    "amountTrackerId": "uniqueID",
    "resetTimeIntervals": {
      "startTime": "0",
      "intervalLength": "0"
    }
}
</code></pre>

The first transfer initiated by Alice would increment the approval tracker ID`1-collection- -approvalId-uniqueID-initiatedBy-alice` to 1/1 transfers used. Alice can no longer initiate another transfer.

However, Bob can still transfer because his ID is `1-collection- -approvalId-uniqueID-initiatedBy-bob` which is a different tracker.

**As-Needed Basis**

We track on an as-needed basis, meaning if we do not have requirements that use the number of transfers, we will not increment / track.

Edge Case: In [Predetermined Balances](max-number-of-transfers.md#predetermined-balances), you may need the number of transfers for determining the balances to assign to each transfer (e.g. transfer #10 -> badge ID 10). In this case, we do need to track the number of transfers. This is all facilitated via the same tracker, so even if you have "0" or unlimited set for the corresponding value in **maxNumTransfers**, the tracker may be incremented behind the scenes. Consider this when editing / creating approvals. You do not want to use a tracker that has prior history when you expect it to start from scratch.


## File: ./x-badges/concepts/approval-criteria/merkle-challenges.md

# Merkle Challenges

```typescript
export interface MerkleChallenge<T extends NumberType> {
    root: string;
    expectedProofLength: T;
    useCreatorAddressAsLeaf: boolean;
    maxUsesPerLeaf: T;
    uri: string;
    customData: string;
    challengeTrackerId: string;
    leafSigner: string;
}
```

<pre class="language-json"><code class="lang-json"><strong>"merkleChallenge": {
</strong>   "root": "758691e922381c4327646a86e44dddf8a2e060f9f5559022638cc7fa94c55b77",
   "expectedProofLength": "1",
   "useCreatorAddressAsLeaf": true,
   "maxOneUsePerLeaf": true,
   "uri": "ipfs://Qmbbe75FaJyTHn7W5q8EaePEZ9M3J5Rj3KGNfApSfJtYyD",
   "customData": "",
   "challengeTrackerId": "uniqueId",
   "leafSigner": "0x"
}
</code></pre>

Merkle challenges allow you to define a SHA256 Merkle tree, and to be approved for each transfer, the initiator of the transfer must provide a valid Merkle path for the tree when they transfer (via **merkleProofs** in [MsgTransferBadges](../../../bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgtransferbadges.md)).

For example, you can create a Merkle tree of claim codes. Then to be able to claim badges, each claimee must provide a valid unused Merkle path from the claim code to the **root**. You distribute the secret leaves / paths in any method you prefer.

Or, you can create an whitelist tree where the user's addresses are the leaves, and they must specify the valid Merkle path from their address to claim. This can be used to distribute gas costs among N users rather than the collection creator defining an address list with N users on-chain and paying all gas fees.

#### Expected Proof Length

The **expectedProofLength** defines the expected length for the Merkle proofs to be provided. This avoids preimage and second preimage attacks. **All proofs must be of the same length, which means you must design your trees accordingly. THIS IS CRITICAL.**

**Whitelist Trees**

Whitelist trees can be used to distribute gas costs among N users rather than the collection creator defining an expensive address list with N users on-chain and paying all gas fees. For small N, we recommend not using whitelist trees for user experience.

If defining a whitelist tree, note that the initiator must also be within the **initiatedByList** of the approval for it to make sense. Typically, **initiatedByList** will be set to "All" and then the whitelist tree restricts who can initiate.

To create a whitelist tree, you need to set **useCreatorAddressAsLeaf** to true. If **useCreatorAddressAsLeaf** is set to true, we will override the provided leaf of each Merkle proof with the BitBadges address of the initiator of the transfer transaction.

**Max Uses per Leaf**

For whitelist trees (**useCreatorAddressAsLeaf** is true), **maxUsesPerLeaf** can be set to any number. "0" or null means unlimited uses. "1" means max one use per leaf and so on. When **useCreatorAddressAsLeaf** is false, this must be set to "1" to avoid replay attacks. For example, ensure that a code / proof can only be used once because once used once, the blockchain is public and anyone then knows the secret code.

We track this in a challenge tracker, similar to the approvals trackers previously explained. We simply track if a leaf index (leftmost leaf of expected proof length layer (aka leaf layer) = index 0, ...) has been used and only allow it to be used **maxUsesPerLeaf** many times, if constrained.

The identifier for each challenge tracker consists of **challengeTrackerId** along with other identifying details seen below. The full ID contains the **approvalId,** so you know state will always be scoped to an approval and the tracker cannot be used by any other approval.

Like approval trackers, this is increment only and non-deletable. Thus, it is critical to not use a tracker with prior history if you intend for it to start tracking from scratch. This can be achieved by using an unused **challengeTrackerId**. If updating an approval with a challenge, please consider how the challenge tracker is working behind the scenes.

```typescript
{
  collectionId: T;
  approvalId: string;
  approvalLevel: "collection" | "incoming" | "outgoing";
  approverAddress?: string;
  challengeTrackerId: string;
  leafIndex: T;
}
```

**approvalLevel** corresponds to whether it is a collection-level approval, user incoming approval, or user outgoing approval. If it is user level, the **approverAddress** is the user setting the approval. **approverAddress** is blank for collection level.

Example:

`1-collection- -approvalId-uniqueID-0` -> USED 1 TIME

`1-collection- -approvalId-uniqueID-1` -> UNUSED

**Reserving Specific Leafs**

See Predetermined Balances below for reserving specific leaf indices for specific badges / ownership times.

**Leaf Signatures**

Leaf signatures are a protection against man-in-the-middle attacks. For code-based merkle challenges, there is always a risk that the code is intercepted while the transaction is in the mempool, and the malicious actor can try to claim the badge with the intercepted code before the user can.

If **leafSigner** is set, the leaf must be signed by the leaf signer. We currently only support leafSigner being an Ethereum address and signatures being ECDSA signatures.

The scheme we currently use is as follows:\
signature = ETHSign(leaf + "-" + bitbadgesAddressOfInitiator)

Then the user must provide the **leafSignature** in the **merkleProofs** field of the transfer transaction.

Note: The bitbadgesAddressOfInitiator is the converted BitBadges address (bb1...) of the initiator of the transfer transaction. This also helps to tie a specific code to a specific BitBadges address to prevent other users from using and intercepting the same code.

This is optional but strongly recommended for code-based merkle challenges.

#### **Creating a Merkle Tree**

We provide the **treeOptions** field in the SDK to let you define your own build options for the tree (see [Compatibility](../../../bitbadges-api/concepts/designing-for-compatibility.md) with the BitBadges API / Indexer). You may experiment with this, but please test all Merkle paths and claims work as intended first. The only tested build options so far are what you see below with the fillDefaultHash.

The important part is making sure all leaves are on the same layer and have the same proof length, or else, they will fail on-chain.

```typescript
import { SHA256 } from 'crypto-js';
import MerkleTree from 'merkletreejs';

const codes = [...]
const hashedCodes = codes.map(x => SHA256(x).toString());
const treeOptions = { fillDefaultHash: '0000000000000000000000000000000000000000000000000000000000000000' }
const codesTree = new MerkleTree(hashedCodes, SHA256, treeOptions);
const codesRoot = codesTree.getRoot().toString('hex');
const expectedMerkleProofLength = codesTree.getLayerCount() - 1;
```

For whitelists, replace with this code.

```typescript
addresses.push(...toAddresses.map((x) => convertToBitBadgesAddress(x)));

const addressesTree = new MerkleTree(
    addresses.map((x) => SHA256(x)),
    SHA256,
    treeOptions
);
const addressesRoot = addressesTree.getRoot().toString('hex');
```

A valid proof can then be created via where codeToSubmit is the code submitted by the user.

```typescript
const passwordCodeToSubmit = '....'
const leaf = isWhitelist ? SHA256(chain.bitbadgesAddress).toString() : SHA256(passwordCodeToSubmit).toString();
const proofObj = tree?.getProof(leaf, whitelistIndex !== undefined && whitelistIndex >= 0 ? whitelistIndex : undefined);
const isValidProof = proofObj && tree && proofObj.length === tree.getLayerCount() - 1;

const leafSignature = '...';


const codeProof = {
  aunts: proofObj ? proofObj.map((proof) => {
    return {
      aunt: proof.data.toString('hex'),
      onRight: proof.position === 'right'
    }
  }) : [],
  leaf: isWhitelist ? '' : passwordCodeToSubmit,
  leafSignature //if applicable
}

const txCosmosMsg: MsgTransferBadges<bigint> = {
  creator: chain.bitbadgesAddress,
  collectionId: collectionId,
  transfers: [{
    ...
    merkleProofs: requiresProof ? [codeProof] : [],
    ...
  }],
};
```


## File: ./x-badges/concepts/approval-criteria/overrides.md

# Override User Level Approvals

As mentioned in the transferability page, the collection-wide approvals can override the user-level approvals. This is done via **overridesFromOutgoingApprovals** or **overridesToIncomingApprovals**.

If set to true, we will not check the user's incoming / outgoing approvals for the approved balances respectively. Essentially, it is **forcefully** transferred without needing user approvals. This can be leveraged to implement forcefully revoking a badge, freezing a badge, etc.

IMPORTANT: The Mint address has its own approvals store, but since it is not a real address, they are always empty. **Thus, it is important that when you define approvals from the Mint address, you always override the outgoing approvals of the Mint address.** Or else, the approval will not work.

* <pre class="language-json"><code class="lang-json"><strong>"fromListId": "Mint", //represents the list with the "Mint" addres
  </strong>...
  "approvalCriteria": {
    "overridesFromOutgoingApprovals": true
    ...
  }
  </code></pre>

<figure><img src="../../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1)  (18).png" alt=""><figcaption></figcaption></figure>


## File: ./x-badges/concepts/approval-criteria/predetermined-balances.md

# Predetermined Balances

Predetermined balances are a new way of having fine-grained control over the amounts that are approved with each transfer. In a typical tally-based system where you approve X amount to be transferred, you have no control over the combination of amounts that will add up to X. For example, if you approve x100, you can't control whether the transfers are \[x1, x1, x98] or \[x100] or another combination.

Predetermined balances let you explicitly define the amounts that must be transferred and the order of the transfers. For example, you can enforce x1 of badge ID 1 has to be transferred before x1 of badge ID 2, and so on.

Although this can be used in tandem with approval amounts, either one or the other is usually used because they both specify amount restrictions.

**TLDR; The transfer will fail if the balances are not EXACTLY as defined in the predetermined balances.**

```typescript
export interface PredeterminedBalances<T extends NumberType> {
    manualBalances: ManualBalances<T>[];
    incrementedBalances: IncrementedBalances<T>;
    orderCalculationMethod: PredeterminedOrderCalculationMethod;
}
```

## **Defining Balances**

There are two ways to define the balances. Both can not be used together.

-   **Manual Balances:** Simply define an array of balances manually. Each element corresponds to a different set of balances for a unique transfer.
-   ```json
    "manualBalances": [
      {
        "amount": "1",
        "badgeIds": [
          {
            "start": "1",
            "end": "1"
          }
        ],
        "ownershipTimes": [
          {
            "start": "1691978400000",
            "end": "1723514400000"
          }
        ]
      },
      {...},
      {...},
    ]
    ```
-   **Incremented Balances:** Define starting balances and then define how much to increment or calculate the IDs and times by after each transfer. There are different approaches here (incompatible with each other).
    -   Increments: You can enforce x1 of badge ID 1 has to be transferred before x1 of badge ID 2, and so on. This is typically used for minting badges. You can also customize the ownership times to increment by a certain amount. Or, have them dynamically overriden to be the current time + a interval length (now + 1 month, now + 1 year, etc).
    -   Duration From Timestamp: If enabled, this will dynamically calculate the ownership times from a timestamp (default: transfer time) + a set duration of time. All ownership times will be overwritten. If the override timestamp is allowed, users can specify a custom timestamp to start from in MsgTransferBadges precalculationOptions.
    -   Recurring Ownership Times: Recurring ownership times are similar to the above, but they define set intervals + charge periods that are approved. For example, you could approve the ownership times for the 1st to the 30th of the month which repeats indefinitely. The charge period is how long before the next interval starts, the approval can be used. For example, allow this approval to be charged up to 7 days in advance of the next interval.
    -   Allowing Badge Override: If enabled, users can specify a custom badge ID in MsgTransferBadges precalculationOptions. This will override all the badge IDs in the starting balances to this specified badge ID. This is useful for collection offers. The specified badge IDs must only be a single badge ID and must be a valid badge ID in the collection.
-   ```json
    "incrementedBalances": {
      "startBalances": [
        {
          "amount": "1",
          "badgeIds": [
            {
              "start": "1",
              "end": "1"
            }
          ],
          "ownershipTimes": [
            {
              "start": "1691978400000",
              "end": "1723514400000"
            }
          ]
        }
      ],
      "incrementBadgeIdsBy": "1",
      "incrementOwnershipTimesBy": "0",
      "durationFromTimestamp": "0", // UNIX milliseconds
      "allowOverrideTimestamp": false,
      "allowOverrideWithAnyValidBadge": false,
      "recurringOwnershipTimes": {
        "startTime": "0",
        "intervalLength": "0",
        "chargePeriodLength": "0"
      }
    }
    ```

## **Precalculating Balances**

Predetermined balances can quickly change, such as in between the time a transaction is broadcasted and confirmed. For example, other users' mints get processed, and thus, the badge IDs one should receive changes. This creates a problem because you can't manually specify balances because that results in race conditions and failed transfers / claims.

To combat this, when initiating a transfer, we allow you to specify **precalculateBalancesFromApproval** (in [MsgTransferBadges](../../../bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgtransferbadges.md)). Here, you define which **approvalId** you want to precalculate from, and at execution time, we calculate what the predetermined balances are and override the requested balances to transfer with them. Note this is the unique **approvalId** of the approval, not the tracker ID. Additional override options can be specified in the **precalculationOptions** field as well.

<pre class="language-typescript"><code class="lang-typescript"><strong>precalculateBalancesFromApproval: {
</strong>    approvalId: string;
    approvalLevel: string; //"collection" | "incoming" | "outgoing"
    approverAddress: string; //"" if collection-level
    version: string; //"1"
}
</code></pre>

## **Defining Order of Transfers**

Which balances to assign for a transfer is calculated by a specified order calculation method.

For manual balances, we want to determine which element index of the array is transferred (e.g. order number = 0 means the balances of manualBalances\[0] will be transferred). For incremented balances, this corresponds to how many times we should increment (e.g. order number = 5 means apply the increments to the starting balances five times).

There are five calculation methods to determine the order method.

### Defining Order by Number of Transfers

We either use a running tally of the number of transfers to calculate the order number (no previous transfers = order number 0, one previous transfer = order number 1, and so on). This can be done on an overall or per to/from/initiatedBy address basis and is incremented using an approval tracker as explained in [Max Number of Transfers](predetermined-balances.md#max-number-of-transfers).

IMPORTANT: Note the number of transfers is tracked using the same tracker as used within **maxNumTransfers**. Trackers are increment only, immutable, and incremented on an as-needed basis. Be mindful of this. If the tracker has prior history (potentially because **maxNumTransfers** was set), the order numbers will be calculated according to the prior history of this tracker. The opposite is also true. If you are tracking transfers here for predetermined balances, the **maxNumTransfers** restrictions will be calculated according to the tracker's history. Consider this when editing / creating approvals. You do not want to use a tracker that has prior history when you expect it to start from scratch.

### Reserved Order

We also support using the leaf index for the defined Merkle challenge proof (see [Merkle Challenges](predetermined-balances.md#merkle-challenges)) to calculate the order number (e.g. leftmost leaf on expected leaf layer will correspond to order number 0, next leaf will be order number 1, and so on). The leftmost leaf means the leftmost leaf of the **expectedProofLength** layer. The challenge we will use is the one with the corresponding **challengeTrackerId**.

This is used to reserve specific badges for specific users / claim codes. For example, reserve the badges corresponding to order number 10 (leaf number 10) for address xyz.eth.

```typescript
export interface PredeterminedOrderCalculationMethod {
    useOverallNumTransfers: boolean;
    usePerToAddressNumTransfers: boolean;
    usePerFromAddressNumTransfers: boolean;
    usePerInitiatedByAddressNumTransfers: boolean;
    useMerkleChallengeLeafIndex: boolean;
    challengeTrackerId: string;
}
```

**Overlap / Out of Bounds**

In the base approval interface, we specify the bounds for the approval ("Alice" can transfer the IDs 1-10 for Mon-Fri to "Bob" initiated by "Alice"). Typically, the precalculated balances should be completely within these bounds. However, the order number may eventually correspond to balances that have no overlap with these bounds or partially overlap. For example, if you approve x1 of ID 1, then x1 of ID 2 and so on up to x1 of ID 10000, eventually, the order number will be 10001 which corresponds to balances that are out of bounds.

If it is completely out of bounds (e.g. order number = 101 but approved badgeIds 1-100 with increments of 1), this is practically ignored. This is because if you try and transfer badge ID 101, it will never match to the current approval.

You should try and design your approvals for no partial overlaps. But, in rare cases, this may occur (some in bounds and some out of bounds). In this case, the overall transfer balances still must be **exactly** as defined (in bounds + out of bounds); however, we only approve the in bounds ones for the current approval. The out of bounds ones must be approved by a separate approval.


## File: ./x-badges/concepts/approval-criteria/requires.md

# Requires

You also have the following options to further restrict who can transfer to who.

**requireToEqualsInitiatedBy, requireToDoesNotEqualsInitiatedBy**

**requireFromEqualsInitiatedBy, requireFromDoesNotEqualsInitiatedBy**

These are pretty self-explanatory. You can enforce that we additionally check if the to or from address equals or does not equal the initiator of the transfer.&#x20;

Note that this is bounded to the addresses in the respective lists for to, from, and initiatedBy (i.e. **toList, fromList, initiatedByList**).


## File: ./x-badges/concepts/approval-criteria/tallied-approval-amounts.md

# Tallied Approval Amounts

Pre-Readings (IMPORTANT): [Approval Trackers](approval-trackers.md)

```typescript
export interface ApprovalCriteria<T extends NumberType> {
  ...
  approvalAmounts?: ApprovalAmounts<T>;
  ...
}
```

**Approval Amounts**

Approval amounts (**approvalAmounts**) allow you to specify the threshold amount that can be transferred for this approval. This is similar to other interfaces (such as approvals for ERC721), except we use an increment + threshold system as opposed to a decrement + greater than 0 system. This is facilitated via the concept of [Approval Trackers](approval-trackers.md).

The amounts approved are scoped to the **badgeIds** and **ownershipTimes** defined by the base approval (see transferability page). Also, note that the to addresses are bounded to the addresses in the **toList,** from addresses from the **fromList**, and initiated by addresses from the **initiatedByList**.

We define four levels (**trackerType** = "overall", "to", "from", "initiatedBy") that you can specify for approval amounts as seen below. You can define multiple if desired, and to be approved, the transfer must satisfy all.

* **Overall**: Overall will increment a universal, cumulative approval tracker for all transfers that match this approval, regardless of who sends, receives, or initiates them.
* **Per To Address**: If you specify an approval amount per to address, we will create unique cumulative trackers for every unique "to" address.
* **Per From Address**: Creates unique cumulative tallies for every unique "from" address.
* **Per Initiated By Address**: Creates unique cumulative tallies for every unique "initiatedBy" address.

If the amount set is nil value or "0", this means there is no limit (no amount restrictions).

**Example**

```json
"collectionApprovals": [
    {
      "fromListId": "Bob",
      "toListId": "AllWithMint",
      "initiatedByListId": "AllWithMint",
      "transferTimes": [
        {
          "start": "1691931600000",
          "end": "1723554000000"
        }
      ],
      "ownershipTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "badgeIds": [
        {
          "start": "1",
          "end": "100"
        }
      ],
      "approvalId": "uniqueID",
      "version": "1",
      
      "approvalCriteria": {
        "approvalAmounts": {
           "overallApprovalAmount": "1000", //overall limit of x1000
           "perFromAddressApprovalAmount": "0", //no limit
           "perToAddressApprovalAmount": "0",
           "perInitiatedByAddressApprovalAmount": "10", //limit of x10 per initiator
           "amountTrackerId": "uniqueID",
           "resetTimeIntervals": {
              "startTime": "0",
              "intervalLength": "0"
            }
        },
        ...
      }
      ...
    }
  
```

Let's say we have the **approvalAmounts** defined above and Alice initiates a transfer of x10 from Bob. There are two separate trackers that get incremented here.

\#1) Tracker with the following ID `1-collection- -approvalId-uniqueID-overall-` gets incremented to x10 out of 1000. Any subsequent transfers (say from Charlie) will also increment this overall universal tracker as well.

\#2) Tracker with ID `1-collection- -approvalId-uniqueID-initiatedBy-alice`gets incremented to x10 out of 10 used. Alice has now fully used up her threshold for this tracker. This tracker is only incremented when Alice initiates the transfer. If Charlie initiates a transfer, his unique initiatedBy tracker will get incremented which is separate from Alice's.

Since there was an unlimited amount approved for the "to" and "from" trackers, we do not increment anything for those trackers (as-needed basis).

**Resets + ID Changes**

Let's say we update the **amountTrackerId** to "uniqueID2" from "uniqueID". This makes all tracker IDs different, and thus, all tallies will start from scratch.

`1-collection- -approvalId-uniqueID-initiatedBy-alice` ->

`1-collection- -approvalId-uniqueID2-initiatedBy-alice`

If in the future, you change back to "uniqueID", the starting point will be the previous tally. Using the examples above, x10/10 used for Alice's initiated by tracker.


## File: ./x-badges/concepts/approval-criteria/usdbadge-transfers.md

# $BADGE Transfers

**coinTransfers** are the $BADGE credits to be sent **every** use of the approval. There can be multiple transfers here to implement complex royalty systems, for example. Or, you can leave it blank for no $BADGE transfers. The only allowed denom is "ubadge" which has 9 decimals. 1e9 ubadge = 1 $BADGE.

Note: $BADGE refers to the native gas credits token of the blockchain, not a specific badge.

This will be executed every time the approval is used.

For collection approvals that **overrideFromWithApproverAddress**, the approver address will be overridden with a special mint escrow address. This address can be used to transfer / send $BADGE via collection approvals for the Mint address. For example, quest payouts are implemented by using this address to send $BADGE from the Mint address to the initiator.

```typescript
// To generate the mint escrow address for a collection ID
const mintEscrowAddress = generateAlias(
    'badges',
    getAliasDerivationKeysForCollection(doc.collectionId)
);
```

The Mint escrow address is slightly longer than a normal address and cannot be controlled by any end-user because it has no private key. It is technically an address, so it can receive badges, $BADGE, etc. However, the only way to trigger a $BADGE transfer from the mint escrow address is via collection approvals.

```typescript
export interface iCoinTransfer<T extends NumberType> {
    /**
     * The recipient of the coin transfer. This should be a Bech32 BitBadges address.
     */
    to: string;
    /**
     * The coins
     */
    coins: iCosmosCoin<T>[];
    /**
     * Whether or not to override the from address with the approver address.
     */
    overrideFromWithApproverAddress: boolean;
    /**
     * Whether or not to override the to address with the initiator of the transaction.
     */
    overrideToWithInitiator: boolean;
}
```

```typescript
export interface iCosmosCoin<T extends NumberType> {
    /** The amount of the coin. */
    amount: T;
    /** The denomination of the coin. */
    denom: string;
}
```


## File: ./x-badges/concepts/archived-collections.md

# Archived Collections

Collections can be archived to temporarily or permanently disable all transactions while keeping the collection data verifiable and public on-chain.

## Key Concepts

### Archive State

-   Controlled by the `isArchivedTimeline` field
-   When archived, all transactions fail until unarchived
-   Collection remains readable and verifiable on-chain
-   Does not delete the collection, only makes it read-only

### Timeline-Based Archiving

Collections can be archived for specific time periods:

-   **Temporary archiving** - Archive for maintenance or security
-   **Permanent archiving** - Sunset collections while preserving data
-   **Scheduled archiving** - Pre-planned archive periods

## Implementation

### isArchivedTimeline Structure

```json
"isArchivedTimeline": [
  {
    "timelineTimes": [{"start": "1672531200000", "end": "18446744073709551615"}],
    "isArchived": true
  }
]
```

### Permission Control

Archiving is controlled by the `canArchiveCollection` permission:

```json
"canArchiveCollection": [
  {
    "permanentlyPermittedTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyForbiddenTimes": []
  }
]
```

Note that the `canArchiveCollection` permission is for the updatability of the `isArchivedTimeline` field. It has no bearing on the current value of the `isArchived` field.

For example, when you permanently forbid updating the archive status forever, it could be locked as `true` forever or `false` forever.

## Transaction Behavior

### When Archived

-   **All transactions fail** - No updates, transfers, or changes allowed
-   **Read operations continue** - Queries and data access remain available
-   **Unarchiving exception** - Only unarchiving transactions can succeed

### When Unarchived

-   **Normal operations resume** - All transaction types are allowed
-   **No data loss** - All collection data remains intact
-   **Permissions apply** - Standard permission checks resume

## Archiving a Collection

### During Collection Creation

```json
{
    "creator": "bb1...",
    "isArchivedTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "isArchived": false
        }
    ],
    "collectionPermissions": {
        "canArchiveCollection": [
            {
                "permanentlyPermittedTimes": [
                    { "start": "1", "end": "18446744073709551615" }
                ],
                "permanentlyForbiddenTimes": []
            }
        ]
    }
}
```

### During Collection Updates

Use [MsgUpdateCollection](../../messages/msg-update-collection.md) to update the archive status:

```json
{
    "creator": "bb1...",
    "collectionId": "1",
    "updateIsArchivedTimeline": true,
    "isArchivedTimeline": [
        {
            "timelineTimes": [
                { "start": "1672531200000", "end": "18446744073709551615" }
            ],
            "isArchived": true
        }
    ]
}
```


## File: ./x-badges/concepts/badge-collections.md

# Badge Collections

A badge collection is the primary entity that defines a group of related badges with shared properties and rules. We refer you to other pages for more details on the different concepts that make up a collection.

## Proto Definition

```protobuf
message BadgeCollection {
  // The unique identifier for this collection. This is assigned by the blockchain. First collection has ID 1.
  string collectionId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];

  // The metadata for the collection itself, which can vary over time.
  repeated CollectionMetadataTimeline collectionMetadataTimeline = 2;

  // The metadata for each badge in the collection, also subject to changes over time.
  repeated BadgeMetadataTimeline badgeMetadataTimeline = 3;

  // The type of balances this collection uses ("Standard", "Off-Chain - Indexed", "Off-Chain - Non-Indexed", or "Non-Public").
  string balancesType = 4;

  // Metadata for fetching balances for collections with off-chain balances, subject to changes over time.
  repeated OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 5;

  // An arbitrary field that can store any data, subject to changes over time.
  repeated CustomDataTimeline customDataTimeline = 7;

  // The address of the manager of this collection, subject to changes over time.
  repeated ManagerTimeline managerTimeline = 8;

  // Permissions that define what the manager of the collection can do or not do.
  CollectionPermissions collectionPermissions = 9;

  // Transferability of the collection for collections with standard balances, subject to changes over time.
  // Overrides user approvals for a transfer if specified.
  // Transfer must satisfy both user and collection-level approvals.
  // Only applicable to on-chain balances.
  repeated CollectionApproval collectionApprovals = 10;

  // Standards that define how to interpret the fields of the collection, subject to changes over time.
  repeated StandardsTimeline standardsTimeline = 11;

  // Whether the collection is archived or not, subject to changes over time.
  // When archived, it becomes read-only, and no transactions can be processed until it is unarchived.
  repeated IsArchivedTimeline isArchivedTimeline = 12;

  // The default store of a balance for a user, upon genesis.
  UserBalanceStore defaultBalances = 13;

  // The user or entity who created the badge collection.
  string createdBy = 14;

  // The valid badge IDs for this collection.
  repeated UintRange validBadgeIds = 15;

  // The generated address of the badge collection. Also used to escrow Mint balances.
  string mintEscrowAddress = 16;

  // The IBC wrapper (sdk.coin) paths for the collection.
  repeated CosmosCoinWrapperPath cosmosCoinWrapperPaths = 17;
}
```


## File: ./x-badges/concepts/balance-system.md

# Balance System

The Balance system in BitBadges is designed to represent ownership of badges across different IDs and time ranges. Ownership times are a new concept to BitBadges allowing you to set that someone owns a badge during a specific time but not other times.

## Balance Interface

```typescript
export interface Balance<T extends NumberType> {
  amount: T;
  badgeIds: UintRange<T>[];
  ownershipTimes: UintRange<T>[];
}
```

- `amount`: The quantity of badges owned
- `badgeIds`: An array of ID ranges representing the badges owned
- `ownershipTimes`: An array of time ranges during which the badges are owned

## Interpreting Balances

When interpreting balances, it's crucial to understand that multiple ranges of badge IDs and ownership times within a single Balance structure represent all possible combinations.

### Interpretation Algorithm

```javascript
for (balance of balances) {
  for (badgeIdRange of balance.badgeIds) {
    for (ownershipTimeRange of balance.ownershipTimes) {
      // User owns x(balance.amount) of (badgeIdRange) for the times (ownershipTimeRange)
    }
  }
}
```

### Example

Consider the following balance:

```json
{
  "amount": 1,
  "badgeIds": [{ "start": 1, "end": 10 }, { "start": 20, "end": 30 }],
  "ownershipTimes": [{ "start": 20, "end": 50 }, { "start": 100, "end": 200 }]
}
```

This balance expands to:

1. 1x of IDs 1-10 from times 20-50
2. 1x of IDs 1-10 from times 100-200
3. 1x of IDs 20-30 from times 20-50
4. 1x of IDs 20-30 from times 100-200

## Balance Subtraction

When subtracting balances, you may need to represent the result as multiple Balance objects. For example, if we subtract the first set of balances from the example above (1x of IDs 1-10 from times 20-50), the result would be:

```json
[
  {
    "amount": 1,
    "badgeIds": [{ "start": 1, "end": 10 }, { "start": 20, "end": 30 }],
    "ownershipTimes": [{ "start": 100, "end": 200 }]
  },
  {
    "amount": 1,
    "badgeIds": [{ "start": 20, "end": 30 }],
    "ownershipTimes": [{ "start": 20, "end": 50 }]
  }
]
```

## Handling Duplicates

When duplicate badge IDs are specified in balances, they are combined and their amounts are added. For example:

```json
{
  "amount": 1,
  "badgeIds": [{ "start": 1, "end": 10 }, { "start": 1, "end": 10 }],
  "ownershipTimes": [{ "start": 100, "end": 200 }]
}
```

This is equivalent to and will be treated as:

```json
{
  "amount": 2,
  "badgeIds": [{ "start": 1, "end": 10 }],
  "ownershipTimes": [{ "start": 100, "end": 200 }]
}
```

## Best Practices

1. **Efficient Representation**: Try to represent balances in the most compact form possible by combining overlapping ranges
2. **Careful Subtraction**: When subtracting balances, ensure that you correctly split the remaining balances to accurately represent the result
3. **Avoid Duplicates**: While the system handles duplicates by combining them, it's more efficient to represent balances without duplicates in the first place
4. **Time-Aware Operations**: Always consider the time dimension when performing operations on balances, as ownership can vary over time
5. **Range Calculations**: Familiarize yourself with range operations, as they are crucial for correctly manipulating and interpreting balances

By understanding these concepts and following these practices, you can effectively work with the BitBadges balance system, enabling complex ownership structures and time-based badge management.

## File: ./x-badges/concepts/balances-type.md

# Balances Type

The balances type determines how badge ownership and transfers are managed within a collection. This is permanent upon genesis and cannot be changed.

> **Important**: Always use `"Standard"` for new collections. Other balance types are supported behind the scenes for legacy purposes only, but "Standard" should always be used for on-chain balances.

## Standard Balances Type

```json
"balancesType": "Standard"
```

With standard balances, everything is facilitated on-chain in a decentralized manner. All balances are stored on the blockchain, and everything is facilitated through on-chain transfers and approvals.

## Key Features

### On-Chain Storage

-   All balances are stored directly on the blockchain
-   Provides complete transparency and decentralization
-   No reliance on external systems for balance verification

### Transfer Requirements

All transfers require:

-   **Sufficient balances** in the sender's account
-   **Valid approvals** for the collection, sender, and recipient where necessary
-   **Three-tier approval system** verification (collection, sender, recipient)

### Approval Structure

All transfers must specify:

-   **Collection approvals** - Managed by the collection manager
-   **Sender's outgoing approvals** - User-controlled outgoing approval permissions (if not forcefully overridden by collection approvals)
-   **Recipient's incoming approvals** - User-controlled incoming approval permissions (if not forcefully overridden by collection approvals)

The collection approvals are managed by the manager and can optionally override the user-level approvals.

### Mint Address Behavior

The "Mint" address has special properties:

-   **Unlimited balances** - Can mint any amount of badges
-   **Send-only** - Can only send badges, not receive them
-   **Circulating supply control** - All circulating badges originate from Mint transfers. Thus, the circulating supply is controlled by the collection approvals from the Mint address.
-   **Non-Controllable** - The Mint address cannot set its own approvals, so all approvals must be set by the collection manager and forcefully override the Mint address's approvals.

### Circulating Supply Management

The circulating supply is controlled by:

-   **Transfers from Mint address** - Initial distribution mechanism
-   **Collection approvals** - Manager-controlled transfer rules
-   **User approvals** - Individual transfer permissions
-   **Collection permissions** - Controls approval updatability


## File: ./x-badges/concepts/cosmos-wrapper-paths.md

# Cosmos Wrapper Paths

Cosmos Wrapper Paths enable 1:1 wrapping between BitBadges badges and native Cosmos SDK coin asset types, making badges IBC-compatible. These paths automatically mint and burn badges when transferring to/from specific wrapper addresses. These transfers to/from are handled within the badges module, so you can set up customizable logic for how these transfers are handled.

## Key Concepts

### Automatic Conversion

-   **1:1 wrapping** - One native coin unit is wrapped and unwrapped for the set conversion rate
-   **Automatic minting/burning** - Transfers to/from wrapper addresses trigger automatic conversion
-   **IBC compatibility** - Wrapped assets become native SDK coins that work with IBC
-   **Bidirectional** - Can wrap badges to coins and unwrap coins back to badges based on the conversion rate

### Generated Wrapper Address

-   **Non-controllable** - Generated addresses have no known private keys
-   **Collection-specific** - Each wrapper path has its own unique address dependent on the denom
-   **Automatic processing** - Transfers to this address trigger wrapping/unwrapping

> **Important**: Since wrapper addresses are uncontrollable (no private keys), approval design requires careful consideration. You must override the wrapper address's user-level approvals where necessary using collection approvals to ensure wrapping/unwrapping functions properly.

### Auto-Generating Wrapper Addresses

You can programmatically generate wrapper addresses using the `bitbadgesjs-sdk` npm package:

```typescript
import { generateAliasAddressForDenom } from 'bitbadgesjs-sdk';

const denom = 'utoken1';
const wrapperAddress = generateAliasAddressForDenom(denom);
console.log('Wrapper Address:', wrapperAddress);
```

## Proto Definition

```protobuf
message CosmosCoinWrapperPathAddObject {
  string denom = 1;
  repeated Balance balances = 2;
  string symbol = 3;
  repeated DenomUnit denomUnits = 4;
}

message DenomUnit {
  string decimals = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string symbol = 2;
  bool isDefaultDisplay = 3;
}
```

## Configuration Fields

### Denom

-   **Base denomination** - The fundamental unit name for the wrapped coin. For the full Cosmos denomination, it will be "badges:collectionId:denom"

### Symbol

-   **Display symbol** - Human-readable symbol for the wrapped asset

### Balances

-   **Custom conversion rates** - Defines which badges and ownership times participate in wrapping and how many badges are wrapped for each native coin unit

### Denomination Units

Multiple denomination units allow for different display formats:

#### Decimals

-   **Precision level** - Number of decimal places for this unit
-   **Conversion factor** - How this unit relates to the base denomination

#### Symbol

-   **Unit symbol** - Symbol for this specific denomination unit
-   **Different from base** - Can differ from the main symbol
-   **Context-specific** - Used in appropriate contexts (micro, milli, etc.)

#### Default Display

-   **Primary unit** - Which unit is shown by default in interfaces
-   **Only one default** - Only one unit can be marked as default display. If none are marked as default, the base level with 0 decimals is shown by default.
-   **User experience** - Determines what users see first

## Usage Examples

### Basic Wrapper Path

```json
{
    "denom": "utoken1",
    "symbol": "TOKEN1",
    "balances": [
        {
            "amount": "1",
            "badgeIds": [{ "start": "1", "end": "1" }],
            "ownershipTimes": [{ "start": "1", "end": "18446744073709551615" }]
        }
    ],
    "denomUnits": [
        {
            "decimals": "6",
            "symbol": "TOKEN1",
            "isDefaultDisplay": true
        }
    ]
}
```

### Multi-Unit Display System

```json
{
    "denom": "utoken",
    "symbol": "TOKEN",
    "balances": [
        {
            "amount": "1",
            "badgeIds": [{ "start": "1", "end": "100" }],
            "ownershipTimes": [{ "start": "1", "end": "18446744073709551615" }]
        }
    ],
    "denomUnits": [
        {
            "decimals": "3",
            "symbol": "mtoken",
            "isDefaultDisplay": false
        },
        {
            "decimals": "6",
            "symbol": "TOKEN",
            "isDefaultDisplay": true
        }
    ]
}
```

This creates a system where:

-   `utoken` is the base unit (smallest denomination)
-   `mtoken` = 1,000 `utoken` (milli-token)
-   `TOKEN` = 1,000,000 `utoken` (full token, default display)

## Use Cases

### IBC Transfers

-   **Cross-chain transfers** - Send wrapped badges to other Cosmos chains
-   **DeFi integration** - Use wrapped badges in Cosmos DeFi protocols
-   **Liquidity provision** - Add wrapped badges to AMM pools

### Multi-Chain Ecosystems

-   **Ecosystem bridges** - Connect BitBadges to broader Cosmos ecosystem
-   **Shared liquidity** - Participate in cross-chain liquidity pools
-   **Governance tokens** - Use wrapped badges in governance across chains

### Trading and Exchange

-   **DEX compatibility** - Trade on Cosmos-native decentralized exchanges
-   **Price discovery** - Enable market-driven price discovery
-   **Arbitrage opportunities** - Cross-chain arbitrage possibilities

### Featured Use Case: List on Osmosis

With BitBadges' existing relayer infrastructure and IBC-compatible wrapped denominations, listing wrapped badges on Osmosis is streamlined:

-   **IBC Relayer Ready** - BitBadges already has relayer infrastructure set up for seamless cross-chain transfers
-   **Native IBC Compatibility** - Wrapped badges become native SDK coins that work seamlessly with IBC protocols
-   **Automatic Liquidity** - Create liquidity pools on Osmosis DEX with wrapped badge assets
-   **Streamlined Process** - The technical infrastructure eliminates common barriers to cross-chain trading
-   **Enhanced Discoverability** - Badges gain exposure to the broader Cosmos DeFi ecosystem

## Conversion Process

### Badge to Coin (Wrapping)

1. User transfers badges to the wrapper address
2. System burns the badges from user's balance
3. System mints equivalent native coins
4. Coins are credited to the user's account

### Coin to Badge (Unwrapping)

1. User transfers coins to the wrapper address
2. System burns the native coins
3. System mints equivalent badges
4. Badges are credited to the user's balance

Cosmos Wrapper Paths provide seamless interoperability between BitBadges and the broader Cosmos ecosystem while maintaining the unique properties of both badge and coin systems.


## File: ./x-badges/concepts/custom-data.md

# Custom Data

Custom data fields are generic string fields that allow you to store any arbitrary value within BitBadges structures. These fields provide flexibility for storing application-specific information. They are not used for any specific purpose via the BitBadges site and are more for future customization and extensibility.

## Overview

Custom data fields appear throughout BitBadges as generic string storage:

-   **`customData`** - Simple string field in various structures
-   **`customDataTimeline`** - Timeline-based custom data that can change over time
-   **Custom fields in messages** - Additional data in transaction messages

## Usage

### Simple Custom Data

```json
{
    "customData": "Any string value you want to store"
}
```

### Timeline-Based Custom Data

```json
"customDataTimeline": [
  {
    "timelineTimes": [{"start": "1", "end": "18446744073709551615"}],
    "customData": "Application-specific data that changes over time"
  }
]
```

## Where You'll Find Custom Data

Custom data fields appear in:

-   **Collections** - `customDataTimeline` for collection-level data
-   **Address Lists** - `customData` for list-specific information
-   **Badge Metadata** - `customData` within badge metadata structures
-   **Messages** - Various transaction messages include custom data fields


## File: ./x-badges/concepts/default-balances.md

# Default Balances

Default balances are predefined balance stores that are automatically assigned to new users (uninitialized balance stores) when they first interact with a collection. These defaults are set during collection creation and cannot be updated after genesis.

## Key Concepts

### Genesis-Only Configuration

-   **Set at creation** - Default balances are defined only during collection creation
-   **Immutable after genesis** - Cannot be updated, modified, or removed after collection is created
-   **One-time setup** - This is your only opportunity to configure default user behavior

### Automatic Assignment

-   **New user initialization** - Users who have never interacted with a collection receive default balances
-   **Seamless onboarding** - No additional setup required for new users
-   **Consistent behavior** - All new users start with the same baseline configuration

### Inheritance Behavior

```javascript
function getUserBalanceStore(collectionId, userAddress) {
    const userStore = getUserExplicitBalanceStore(collectionId, userAddress);
    if (userStore.exists) {
        return userStore; // User has explicit balances
    }
    return getDefaultBalances(collectionId); // User inherits defaults
}
```

## Structure

Default balances follow the same `UserBalanceStore` structure:

```json
{
    "defaultBalances": {
        "balances": [],
        "outgoingApprovals": [],
        "incomingApprovals": [],
        "autoApproveSelfInitiatedOutgoingTransfers": false,
        "autoApproveSelfInitiatedIncomingTransfers": true,
        "userPermissions": {
            // User permission configuration
        }
    }
}
```

## Important Limitations

### No Complex Approval Criteria

Default balances **cannot** include:

-   **Approval criteria** with complex conditions (merkle challenges, dynamic store challenges, etc.)
-   **Coin transfers** or native token requirements
-   **Badge ownership** requirements or other side effects
-   **Advanced conditional logic**

Default balances are limited to basic approval structures without complex criteria.

## Related Concepts

-   **[Balance System](balance-system.md)** - How user balances work and inherit from defaults
-   **[Transferability & Approvals](transferability-approvals.md)** - User-level approval system
-   **[Permissions](permissions/)** - User permissions for updating their own approvals
-   **[Manager](manager.md)** - Collection-level controls that can override user defaults

Default balances provide a powerful way to establish baseline behavior for all users while maintaining the flexibility for users to customize their own approval settings after initialization.


## File: ./x-badges/concepts/manager.md

# Manager

The manager is the central authority for a collection, controlling all administrative operations and having exclusive rights to perform updates, deletions, and other management tasks.

## Key Concepts

### Manager Authority

-   **Exclusive control** - Only the current manager can perform administrative operations
-   **Timeline-based** - Manager can change over time using `managerTimeline`
-   **Administrative operations** - Updates, deletions, approval management, permission changes
-   **Permission-controlled** - Manager changes are governed by `canUpdateManager` permission

See [Permissions](permissions/) for more details on how permissions work.

### Current Manager Determination

The current manager is determined by finding the manager entry in `managerTimeline` that includes the current time:

```javascript
function getCurrentManager(managerTimeline, currentTime) {
    for (const entry of managerTimeline) {
        if (timeInRange(currentTime, entry.timelineTimes)) {
            return entry.manager;
        }
    }
    return null; // No manager defined for current time
}
```

## Manager Timeline

### Structure

```json
"managerTimeline": [
  {
    "timelineTimes": [{"start": "1", "end": "18446744073709551615"}],
    "manager": "bb1alice..."
  }
]
```

### Time-Based Manager Changes

Managers can be scheduled to change automatically:

```json
"managerTimeline": [
  {
    "timelineTimes": [{"start": "1", "end": "1672531199000"}],
    "manager": "bb1alice..."
  },
  {
    "timelineTimes": [{"start": "1672531200000", "end": "18446744073709551615"}],
    "manager": "bb1bob..."
  }
]
```

This transfers management from Alice to Bob on January 1, 2023.

## Manager Permissions

The manager role can be granted various permissions, allowing for flexible administration of the collection. These permissions include:

### Core Administrative Permissions

1. **Collection Deletion** - The ability to permanently remove the collection from the system
2. **Collection Archiving** - Archive a collection, making it read-only and rejecting all transactions until unarchived
3. **Core Collection Updates** - Modifying essential details such as metadata URLs and collection standards
4. **Manager Role Transfer** - The ability to pass the manager role to another address
5. **Badge Creation** - Permission to mint additional badges within the collection
6. **Custom Permissions** - Collection-specific permissions depending on setup

### Metadata Management

-   **Collection Metadata Updates** - Modify collection-level metadata and URIs
-   **Badge Metadata Updates** - Update individual badge metadata (with badge-specific permissions)
-   **Timeline Management** - Schedule metadata changes over time

### Transferability Control

-   **Approval Settings** - Modify the collection's approval settings that determine how badges can be transferred
-   **Transfer Rules** - Update transferability conditions and restrictions
-   **Permission Updates** - Configure transferability permissions

### Off-Chain Management

-   **Off-chain Balance Management** - For collections using off-chain balance storage, managers can update these balances
-   **External Integrations** - Manager role can extend to off-chain functionalities and custom utilities

### User-Level Operation Limits

The manager cannot directly:

-   Modify user balances (must follow approval system)
-   Access user private keys or personal data

## Fine-Grained Permission Customizability

One of the key features of the manager role in BitBadges is the ability to customize permissions at a granular level. This allows for precise control over the collection's management.

Permissions can be customized based on various factors:

### Permission Dimensions

-   **Badge Specificity** - Which particular badges within the collection can be affected
-   **Time Constraints** - When can certain actions be performed
-   **Value Limitations** - What specific values or ranges are allowed for updates
-   **Conditional Triggers** - Under what circumstances can certain permissions be exercised

### Permission States

Each permission can exist in one of three states:

1. **Forbidden + Permanently Frozen**

    - The permission is permanently disallowed
    - This state cannot be changed, ensuring certain actions remain off-limits indefinitely

2. **Permitted + Not Frozen**

    - The permission is currently allowed
    - This state can be changed to either of the other two states, offering flexibility in management

3. **Permitted + Permanently Frozen**
    - The permission is permanently allowed
    - Like the first state, this cannot be changed, ensuring certain capabilities always remain available

**Note**: There is no "Forbidden + Not Frozen" state because such a state could theoretically be updated to "Permitted" at any time and then immediately executed, effectively making it a "Permitted" state.

## Permission Control Examples

### Manager Updates

Manager updates are controlled by the `canUpdateManager` permission:

```json
"canUpdateManager": [
  {
    "timelineTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyPermittedTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyForbiddenTimes": []
  }
]
```

## Usage Examples

### Setting Initial Manager

During collection creation:

```json
{
    "creator": "bb1alice...",
    "managerTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "manager": "bb1alice..."
        }
    ],
    "collectionPermissions": {
        "canUpdateManager": [
            {
                "permanentlyPermittedTimes": [
                    { "start": "1", "end": "18446744073709551615" }
                ],
                "permanentlyForbiddenTimes": []
            }
        ]
    }
}
```

### Scheduled Management Transfer

```json
{
    "updateManagerTimeline": true,
    "managerTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "1672531199000" }],
            "manager": "bb1alice..."
        },
        {
            "timelineTimes": [
                { "start": "1672531200000", "end": "1704067199000" }
            ],
            "manager": "bb1bob..."
        },
        {
            "timelineTimes": [
                { "start": "1704067200000", "end": "18446744073709551615" }
            ],
            "manager": "bb1charlie..."
        }
    ]
}
```

This creates a management succession plan: Alice → Bob → Charlie.

### Decentralized Management Transition

```json
{
    "managerTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "1672531199000" }],
            "manager": "bb1alice..."
        },
        {
            "timelineTimes": [
                { "start": "1672531200000", "end": "18446744073709551615" }
            ],
            "manager": "bb1qqqq...."
        }
    ],
    "collectionPermissions": {
        "canUpdateManager": [
            {
                "permanentlyPermittedTimes": [],
                "permanentlyForbiddenTimes": [
                    { "start": "1672531200000", "end": "18446744073709551615" }
                ]
            }
        ]
    }
}
```

This transitions to a burn address manager and locks management permanently, creating a decentralized collection.


## File: ./x-badges/concepts/metadata.md

# Metadata

BitBadges allows defining metadata for both collections and individual badges using timeline-based metadata fields. This enables rich, dynamic content that can change over time while maintaining on-chain verifiability.

## Metadata Timelines

### Collection Metadata Timeline

The `collectionMetadataTimeline` defines metadata for the entire collection over time.

```json
"collectionMetadataTimeline": [
  {
    "timelineTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "collectionMetadata": {
      "uri": "ipfs://Qmf8xxN2fwXGgouue3qsJtN8ZRSsnoHxM9mGcynTPhh6Ub",
      "customData": ""
    }
  }
]
```

### Badge Metadata Timeline

The `badgeMetadataTimeline` defines metadata for individual badges over time. The order of `badgeMetadata` entries matters, as it uses a **first-match approach** via linear scan for specific badge IDs. BitBadges uses the `{id}` placeholder in the badge metadata URI to replace with the actual badge ID.

```json
"badgeMetadataTimeline": [
  {
    "timelineTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "badgeMetadata": [
      {
        "uri": "ipfs://Qmf8xxN2fwXGgouue3qsJtN8ZRSsnoHxM9mGcynTPhh6Ub/{id}",
        "badgeIds": [
          {
            "start": "1",
            "end": "10000000000000"
          }
        ],
        "customData": ""
      }
    ]
  }
]
```

## Metadata Interface

The BitBadges API, Indexer, and Site expect metadata to follow this format by default:

```typescript
export interface Metadata<T extends NumberType> {
    name: string;
    description: string;
    image: string;
    video?: string;
    category?: string;
    externalUrl?: string;
    tags?: string[];
    socials?: {
        [key: string]: string;
    };
}
```

## Key Features

### Dynamic Badge ID Replacement

-   If the badge metadata URI includes `"{id}"`, it's replaced with the actual badge ID
-   Example: `"...abc.com/metadata/{id}"` becomes `"...abc.com/metadata/1"` for badge ID 1
-   Enables efficient metadata generation for large collections

### First-Match Badge Metadata

-   Badge metadata entries are evaluated in order
-   First matching entry for a badge ID is used
-   Allows specific overrides before general rules

## Permission Control

Metadata updates are controlled by collection permissions:

### Collection Metadata Permission

```json
"canUpdateCollectionMetadata": [
  {
    "timelineTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyPermittedTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyForbiddenTimes": []
  }
]
```

### Badge Metadata Permission

```json
"canUpdateBadgeMetadata": [
  {
    "badgeIds": [{"start": "1", "end": "100"}],
    "timelineTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyPermittedTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyForbiddenTimes": []
  }
]
```

### Timeline Times vs Permission Times Within Permissions

As explained in [Permissions](permissions/), the `timelineTimes` field is used to define the timeline times that can be updated or not. The `permanentlyPermittedTimes` and `permanentlyForbiddenTimes` fields are used to define the times when the permission is enabled or disabled.

## Usage Examples

### Static Collection Metadata

```json
{
    "collectionMetadataTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "collectionMetadata": {
                "uri": "https://example.com/collection-metadata.json",
                "customData": ""
            }
        }
    ]
}
```

### Dynamic Badge Metadata with ID Replacement

```json
{
    "badgeMetadataTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "badgeMetadata": [
                {
                    "uri": "https://api.example.com/badges/{id}",
                    "badgeIds": [{ "start": "1", "end": "1000" }],
                    "customData": ""
                }
            ]
        }
    ]
}
```


## File: ./x-badges/concepts/mint-escrow-address.md

# Mint Escrow Address

The Mint Escrow Address (_mintEscrowAddress_) is a special reserved address generated from the collection ID that holds Cosmos native funds on behalf of the "Mint" address for a specific collection. This address has no known private key and is not controlled by anyone. The only way to get funds out is via collection approvals from the Mint address.

## Key Concepts

### Address Generation

-   **Collection-specific** - Uniquely generated from each collection ID
-   **No private key** - Not controlled by any individual or entity
-   **Reserved address** - Cannot be used as a regular user address
-   **Longer format** - May be longer than normal BitBadges addresses

### Relationship to Mint Address

-   **Mint representation** - The "Mint" address is typically represented as `"Mint"` but when Cosmos-native funds are involved, we use the mintEscrowAddress instead

## Functionality

### Cosmos Native Fund Storage

The Mint Escrow Address can hold Cosmos native tokens (like "ubadge" tokens) that are associated with the Mint address for a specific collection.

See the coinTransfers section for more details. This is the only way to get funds out of the Mint Escrow Address.

## Auto-Escrow During Collection Creation

The `MsgCreateCollection` interface includes a `mintEscrowCoinsToTransfer` field of type `repeated cosmos.base.v1beta1.Coin` that allows you to automatically escrow native coins to the Mint Escrow Address during collection creation.

### Pre-Creation Escrow

-   **Unknown collection ID** - Escrow coins before knowing the final collection ID
-   **Automatic transfer** - Coins are automatically transferred to the generated Mint Escrow Address
-   **Collection initialization** - Funds are available immediately when the collection is created
-   **Single transaction** - Combine collection creation and coin escrow in one operation

### Usage

```json
{
    "creator": "cosmos1...",
    "collectionId": "0",
    "mintEscrowCoinsToTransfer": [
        {
            "denom": "ubadge",
            "amount": "1000000"
        }
    ]
    // ... other collection fields
}
```

This field is particularly useful when you need to fund the Mint Escrow Address but don't know the collection ID beforehand, since the escrow address is derived from the collection ID itself. Thus, it can be done all in one transaction.


## File: ./x-badges/concepts/permissions/README.md

# Permissions



## File: ./x-badges/concepts/permissions/action-permission.md

# Action Permission

ActionPermissions are the simplest (no criteria). Just denotes what times the action is executable or not.

<pre class="language-json"><code class="lang-json"><strong>"collectionPermissions": {
</strong>    "canDeleteCollection": [...],
    ...
}
</code></pre>

```json
"userPermissions": {
    ...
    "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [...],
    "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [...],
    "canUpdateAutoApproveAllIncomingTransfers": [...],
}
```

```typescript
export interface ActionPermission<T extends NumberType> {
  permanentlyPermittedTimes: UintRange<T>[];
  permanentlyForbiddenTimes: UintRange<T>[];
}
```

**Examples**

Below, this forbids the action from ever being executed.

```json
"canDeleteCollection": [
  {
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
  }
]
```


## File: ./x-badges/concepts/permissions/balances-action-permission.md

# Badge IDs Action Permission

The BadgeIdsAction permission denotes for what (badge ID, ownership times), can an action be executed? For example, can I create more of badge ID 1-10?

This permission refers to the UPDATABILITY of the balances and has no bearing on what the circulating supplys are currently set to.

```json
"collectionPermissions": {
    "canUpdateValidBadgeIds": [...],
    ...
}
```

```typescript
export interface BadgeIdsActionPermission<T extends NumberType> {
  badgeIds: UintRange<T>[];
  
  permanentlyPermittedTimes: UintRange<T>[];
  permanentlyForbiddenTimes: UintRange<T>[];
}
```

{% content-ref url="../balances-transfers/creating-badges.md" %}
[creating-badges.md](../balances-transfers/creating-badges.md)
{% endcontent-ref %}

```json
"canUpdateValidBadgeIds": [
  {
    "badgeIds": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ]
  }
]
```


## File: ./x-badges/concepts/permissions/permission-system.md

# Overview

First, read [Permissions](broken-reference) for an overview.

Note: The [Approved Transfers](../balances-transfers/transferability-approvals.md) and [Permissions ](broken-reference)are the most powerful features of the interface, but they can also be the most confusing. Please ask for help if needed.

```json
"collectionPermissions": {
    ...
}
```

```json
"userPermissions": {
    ...
}
```

### Collection Permissions

#### Manager

The collectionPermissions only apply to the current manager of the collection. In other words, the manager is the only one who is able to execute permissions. If there is no manager for a collection, no permissions can be executed.

The current manager is determined by the **managerTimeline.** Transferring the manager is facilitated via the **canUpdateManager** permission.

```json
"managerTimeline": [
  {
    "manager": "bb1kfr2xajdvs46h0ttqadu50nhu8x4v0tc2wajnh",
    "timelineTimes": [
      {
        "start": 1,
        "end": "18446744073709551615"
      }
    ]
  }
]
```

### **User Permissions**

Besides the collection permissions, there are also userPermissions that can be set. Typically, these will remain empty / unset, so that the user can always have full control over their approvals. If empty, they are permitted by default (but not frozen).

However, setting user permissions can be leveraged in some cases for specific purposes.

* Locking that a specific badge can never be transferred out of the account
* Locking that a specific approval is always set and uneditable so that two mutually distrusting parties can use the address as an escrow

**Defaults**

We also give the option for the collection to define default user permissions. These will be used as the starting values when the balance is initially created in storage. This can be used in tandem with the other defaults. The default permissions are also not typically used, but again can be used in certain situations. For example, by default, approve all incoming transfers and lock the permission so all transfers always have incoming approvals and can never be disapproved.

### **Permitted and Forbidden Times**

Permissions allow you to define permitted or forbidden times to be able to execute a permission.

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**States**

There are three states that a permission can be in at any one time:

1. **Forbidden + Permanently Frozen (permanentlyForbiddenTimes):** This permission is forbidden and will always remain forbidden.
   1. If a permission is explicitly allowed via the **permanentlyPermittedTimes, it will ALWAYS be allowed** during those permanentlyPermittedTimes (can't change it).
2. **Permitted + Not Frozen (Unhandled):** This permission is currently permitted but can be changed to one of the other two states.
   1. If not explicitly permitted or forbidden - NEUTRAL (not defined or unhandled), **permissions are ALLOWED by default** but can later be set to be permanently allowed or disallowed. There is no "forbidden currently but updatable" state.
3. **Permitted + Permanently Frozen (permanentlyPermittedTimes):** This permission is forbidden and will always remain permitted
   1. If a permission is explicitly forbidden via the **permanentlyForbiddenTimes, it will ALWAYS be disallowed** during those permanentlyForbiddenTimes.

There is no forbidden + not frozen state because theoretically, it could be updated to permitted at any time and executed (thus making it permitted).

**Examples**

This means the permission is permanently forbidden and frozen.

```typescriptreact
permanentlyPermittedTimes: []
permanentlyForbiddenTimes: [{ start: 1, end: GO_MAX_UINT_64 }]
```

This means it is permanently allowed and frozen.

```typescriptreact
permanentlyForbiddenTimes: []
permanentlyPermittedTimes: [{ start: 1, end: GO_MAX_UINT_64 }]
```

This means it is allowed currently but neutral and can be changed to be always permitted or always forbidden in the future.

```
permanentlyForbiddenTimes: []
permanentlyPermittedTimes: []
```

### First Match Policy

All permissions are a linear array where each element may have some criteria as well as **permanentlyForbiddenTimes** or **permanentlyPermittedTimes.** It can be interpreted as if the criteria matches, the permission is permitted or forbidden according to the defined times, respectively.

We do not allow times to be in both the permanentlyPermittedTimes and permanentlyForbiddenTimes array simultaneously.

**Unlike approvals, we only allow taking the first match in the case criteria satisfies multiple elements in the permissions array.** All subsequent matches are ignored. This makes it so that for any time and for each criteria combination, there is a deterministic permission state (permitted, forbidden, or neutral). This means you have to carefully design your permissions because order and overlaps matter.

Ex: If we have the following permission definitions in an array \[elem1, elem2]:

1. ```
   timelineTimes: [{ start: 1, end: 10 }]

   permanentlyPermittedTimes: []
   permanentlyForbiddenTimes: [{ start: 1, end: 10 }]
   ```
2. ```
   timelineTimes: [{ start: 1, end: 100 }]

   permanentlyForbiddenTimes: []
   permanentlyPermittedTimes: [{ start: 1, end: GO_MAX_UINT_64 }]
   ```

In this case, the timeline times 1-10 will be forbidden ONLY from times 1-10 because we take the first element that matches for that specific criteria (which is permanentlyPermittedTimes: \[], permanentlyForbiddenTimes: \[1 to 10]).

Times 11-100 would be permanently permitted since the first match for those times is the second element.

Similar to approved transfers, even though we allow range logic to be specified, we first expand everything maintaining order to their singular values (one value, no ranges) before checking for our first match.

### Satisfying Criteria

For permissions, all criteria must be satisfied for it to be a match. If you satisfy N-1 criteria, it is not a match.

For example, lets say you had a permission with badge IDs and ownership times:

```
badgeIds: [{ start: 1, end: 10 }]
ownershipTimes: [{ start 1, end: 10 }]

permanentlyForbiddenTimes: []
permanentlyPermittedTimes: [{ start: 1, end: GO_MAX_UINT_64 }]
```

This would result in the manager being able to create more of badges IDs 1-10 which can be owned from times 1-10.

However, this permission **does not** specify whether they can create more of badge ID 1 at time 11 or badge ID 11 at time 1. These combinations are considered unhandled or not defined by the permission definition above.

**Common Misunderstanding**

A common misunderstanding is that if the permission below is appended after the above one, this would forbid badges 11+ from ever being created. However, creating badge IDs 11+ at times 11+ would still be unhandled and **allowed by default**.

```
badgeIds: [{ start: 11, end: Max }]
ownershipTimes: [{ start 1, end: 10 }]

permanentlyForbiddenTimes: [{ start: 1, end: GO_MAX_UINT_64 }]
permanentlyPermittedTimes: []
```

To permanently forbid all badgeIds, you must brute force ALL other combinations such as

```
badgeIds: [{ start: 11, end: Max }]
ownershipTimes: [{ start: 1, end: Max }] // 1-10 never gets matched to bc of first match
//can also do start: 11

permanentlyForbiddenTimes: [{ start: 1, end: GO_MAX_UINT_64 }]
permanentlyPermittedTimes: []
```

**Brute-Forcing**

A common pattern you will see is to brute force all possible combinations. For example, in the above example we brute forced all possible combinations for badge IDs 11+. No subsequent element specifying a badge ID 11+ will ever get matched to.

To brute force a specific criteria (such as IDs 11+), you specify it, then for all other N - 1 criteria, you set them equal to ALL values. All values in the case of UintRanges is 1 - max Uint64. For address lists / IDs, this is all possible addresses / IDs.

The following brute forces badge IDs 1-10.

<pre class="language-json"><code class="lang-json"><strong>{
</strong>  "fromListId": "All",
  "toListId": "All",
  "initiatedByListId": "All",
  "badgeIds":  [{ "start": "1", "end": "10" }],
  "transferTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "ownershipTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "approvalId": "All", //forbids approval "xyz" from being updated

  "permanentlyPermittedTimes": [],
  "permanentlyForbiddenTimes": [{ "start": "1", "end": "18446744073709551615" }]
}
</code></pre>

### **Permission Categories**

There are five categories of permissions, each with different criteria that must be matched with. If you get confused with the different time types, refer to [Different Time Types](../different-time-fields.md) for examples and explanations.

{% content-ref url="action-permission.md" %}
[action-permission.md](action-permission.md)
{% endcontent-ref %}

{% content-ref url="timed-update-permission.md" %}
[timed-update-permission.md](timed-update-permission.md)
{% endcontent-ref %}

{% content-ref url="timed-update-with-badge-ids-permission.md" %}
[timed-update-with-badge-ids-permission.md](timed-update-with-badge-ids-permission.md)
{% endcontent-ref %}

{% content-ref url="balances-action-permission.md" %}
[balances-action-permission.md](balances-action-permission.md)
{% endcontent-ref %}

{% content-ref url="update-approval-permission.md" %}
[update-approval-permission.md](update-approval-permission.md)
{% endcontent-ref %}

### **Examples**

See [Example Msgs](../../core-concepts/broken-reference/) for further examples. Or, see the page for each permission category.

```json
"collectionPermissions": {
    "canArchiveCollection": [],
    "canCreateMoreBadges": [
      {
        "badgeIds": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ],
        "ownershipTimes": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ],
        "permanentlyPermittedTimes": [],
        "permanentlyForbiddenTimes": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ],
      }
    ],
    "canDeleteCollection": [],
    "canUpdateBadgeMetadata": [],
    "canUpdateCollectionApprovals": [
      {
        "fromListId": "AllWithMint",
        "toListId": "AllWithMint",
        "initiatedByListId": "AllWithMint",
        "timelineTimes": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ],
        "transferTimes": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ],
        "badgeIds": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ],
        "ownershipTimes": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ],
        "approvalId": "All",
        "permanentlyPermittedTimes": [],
        "permanentlyForbiddenTimes": [
          {
            "start": "1",
            "end": "18446744073709551615"
          }
        ]
      }
    ],
    "canUpdateCollectionMetadata": [],
    "canUpdateContractAddress": [],
    "canUpdateCustomData": [],
    "canUpdateManager": [],
    "canUpdateOffChainBalancesMetadata": [],
    "canUpdateStandards": []
  }
```


## File: ./x-badges/concepts/permissions/timed-update-permission.md

# Timed Update Permission

```json
"collectionPermissions": {
    "canArchiveCollection": [...],
    "canUpdateOffChainBalancesMetadata": [...],
    "canUpdateStandards": [...],
    "canUpdateCustomData": [...],
    "canUpdateManager": [...],
    "canUpdateCollectionMetadata": [...],
    ...
}
```

```typescript
export interface TimedUpdatePermission<T extends NumberType> {
  timelineTimes: UintRange<T>[];
  
  permanentlyPermittedTimes: UintRange<T>[];
  permanentlyForbiddenTimes: UintRange<T>[];
}
```

**TimedUpdatePermission**s simply denote for what **timelineTimes**, can the manager update the scheduled value? These are only applicable to normal [timeline-based fields](../timelines.md) such as the collection metadata timeline. This permission refers to the UPDATABILITY of the timeline and has no bearing on what the timeline is currently set to.

The **timelineTimes** are which timeline time values can be updated. The permitted / forbidden times are when the permission can be executed (the update can take place). Note these may not be aligned. Maybe, you want to forbid updating the timeline from Jan 2024 - Dec 2024 during 2023.

**Examples**

Below, this forbids updating the entire timeline because all timelineTimes are specified.

```json
"canUpdateCollectionMetadata": [
  {
    "timelineTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
  }
]
```

Below, this forbids ever updating the times 1000-2000 only. All other times can still be updated.

```json
"canUpdateCollectionMetadata": [
  {
    "timelineTimes": [
      {
        "start": "1000",
        "end": "2000"
      }
    ],
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
  }
]
```


## File: ./x-badges/concepts/permissions/timed-update-with-badge-ids-permission.md

# Timed Update With Badge Ids Permission

```json
"collectionPermissions": {
    "canUpdateBadgeMetadata": [...],
    ...
}
```

```typescript
export interface TimedUpdateWithBadgeIdsPermission<T extends NumberType> {
  timelineTimes: UintRange<T>[];
  badgeIds: UintRange<T>[];
  
  permanentlyPermittedTimes: UintRange<T>[];
  permanentlyForbiddenTimes: UintRange<T>[];
}
```

**TimedUpdatePermissionWithBadgeId**s simply denote for what **timelineTimes** and **badgeIds** combinations, can the manager update the scheduled value? These are only applicable to badge ID [timeline-based fields](../timelines.md) such as the badge metadata timeline. This permission refers to the UPDATABILITY of the timeline and has no bearing on what the timeline is currently set to.

The **timelineTimes** are which timeline time values can be updated. The **badgeIds** are which badge IDs can be updated. For a pair such as (Mon-Fri, IDs 1-10), this means the values corresponding to the badge IDs at the timeline times can be updated or not. Both have to match. IDs 11+ are not handled at all in this case. Sunday is not handled. Updating IDs 1-10 on Sunday is not handled.

**Examples**

Below, this forbids updating the entire timeline because all timelineTimes and badgeIds are specified.

```json
"canUpdateBadgeMetadata": [
  {
    "timelineTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "badgeIds": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
  }
]
```

A commonly set value for this permission may look like the following. Let's say you have a collection with 100 badges but in the future, you can create new badges 101+. This permission allows you to freeze the metadata of the current badges but allow you to set the metadata for any new badges in the future.

```json
"canUpdateBadgeMetadata": [
  {
    "timelineTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "badgeIds": [
      {
        "start": "1",
        "end": "100"
      }
    ],
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
  }
]
```


## File: ./x-badges/concepts/permissions/update-approval-permission.md

# Update Approval Permission

Pre-Readings: [Transferability](../balances-transfers/transferability-approvals.md) and [Approval Criteria](../balances-transfers/approval-criteria/)

The ApprovalPermissions refer to the UPDATABILITY of the currently set approvals / transferability. These can be leveraged to freeze specific transferability / approvals in order to give users more confidence that they cannot be changed in the future. Note this refers to the updatability of them and has no bearing on what they are currently set to.

For what transfer combinations (see [Representing Transfers](../balances-transfers/transferability-approvals.md)), can I create / delete / update approvals?&#x20;

```json
"userPermissions": {
    "canUpdateIncomingApprovals": [...],
    "canUpdateOutgoingApprovals": [...],
    ...
}
```

```json
"collectionPermissions": {
    "canUpdateCollectionApprovals": [...]
    ...
}
```

The **canUpdateIncomingApprovals** and **canUpdateOutgoingApprovals** follow the same interface as **canUpdateCollectionApprovals** minus automatically populating the user's address for to / from for incoming / outgoing, respectively. We only explain the collection approval permission to avoid repetition.

```typescript
export interface CollectionApprovalPermission<T extends NumberType> {
  fromListId: string;
  toListId: string;
  initiatedByListId: string;
  transferTimes: UintRange<T>[];
  badgeIds: UintRange<T>[];
  ownershipTimes: UintRange<T>[];
  approvalId: string
  
  permanentlyPermittedTimes: UintRange<T>[];
  permanentlyForbiddenTimes: UintRange<T>[];
}
```

Ex: I can/cannot update the approvals for the transfer combinations ("All", "All", "All", 1-100, 1-10, 1-10, "All",  "All",  "All") tuple.

## ID Shorthands

IDs are used for locking specific approvals. This is because sometimes it may not be sufficient to just lock a specific (from, to, initiator, time, badge IDs, ownershipTimes) combination because multiple approvals could match to it.

To specify IDs, you can use the "All" reserved ID to represent all IDs, or you can use other shorthand methods such as "!xyz" to denote all IDs but xyz. These shorthands are the same as reserved lists, so we refer you[ there for more info](../../core-concepts/address-lists-lists.md). Just replace the addresses with the IDs.

## Break Down Logic

Because of the way breakdown logic is performed, the following is allowed.

Permission: Badge IDs 2-10 are locked as forbidden

Before: 1-10 -> Criteria ABC

After: 1 -> Criteria XYZ, 2-10 -> Criteria ABC

## Expected Behavior vs Non-Updatability

Approval permission updates are slightly tricky because even though an approval may be non-updatable according to the permissions set, its expected behavior may change due to how approvals are designed (i.e. using trackers).

* For example, lets say we want to freeze IDs 501-1000 and have an incrementing mint of x1 of ID 1, x1 of ID 2, up to ID 1000. If we simply freeze the IDs 501-1000, the approval could still be deleted for IDs 1-500, and the increment number (tracker) will then never reach 501 because it will be out of bounds every time. Thus, expected behavior for 501-1000 changes even though it is frozen.

### Definitions

To explain things easier, let's start with some definitions:

#### **Approval Tuple**

We define an approval tuple as a set of values (**from, to, initiated by, badgeIds, transferTimes, ownershipTimes, approvalId**). The tuple for a specific approval that is currently set will consist of all values for that approval.

Note that to match, all N criteria must match. If one doesn't, it isn't a match. For example, in the example below, badge ID 1 will never match to the tuple.

<pre class="language-json"><code class="lang-json"><strong>{
</strong>  "fromListId": "AllWithMint",
  "toListId": "AllWithMint",
  "initiatedByListId": "AllWithMint",
  "badgeIds":  [{ "start": "2", "end": "10" }],
  "transferTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "ownershipTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "approvalId": "All"
}
</code></pre>

#### **Non-Updatable**

For a given approval tuple, it is considered non-updatable according to the permissions if all possible combinations of the entire tuple are **permanently forbidden** from being updated in the permissions.&#x20;

<pre class="language-json"><code class="lang-json"><strong>{
</strong>  "fromListId": "AllWithMint",
  "toListId": "AllWithMint",
  "initiatedByListId": "AllWithMint",
  "badgeIds":  [{ "start": "2", "end": "10" }],
  "transferTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "ownershipTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "approvalId": "All", //forbids approval "xyz" from being updated
  
  "permanentlyPermittedTimes": [],
  "permanentlyForbiddenTimes": [{ "start": "1", "end": "18446744073709551615" }]
}
</code></pre>

Note that non-updatability is scoped to the tuple itself.

**Brute Forced**

Commonly, you will make some values non-updatable by specifying some criteria (e.g. IDs 2-10) and setting everything else to all possible values. For example, the permission above does this for badge IDs 2-10. We refer to this as brute forcing (i.e. above badge IDs 2-10 are brute forced but badge IDs 2-11 are not). In other words, for some criteria, all possible combinations of that criteria are COMPLETELY forbidden and non-updatable.

#### **Expected Behavior**

As explained above, expected behavior not only encompasses non-updatability, but it also makes sure that nothing any other approval or update can do can affect the expected behavior of this approval. This designation is especially important.

### Freezing Specific Approval Tuples

With the way trackers work, it is important to handle approval permissions correctly to protect against break-down attacks to ensure expected behavior.

Below, we will walk through the process of making a specific approval tuple non-updatable AND keeping its expected behavior.&#x20;

**Specific Approval ID**

If you want to do this for a specific approval that is set, the approval tuple should consist of the specific values for that specific approval. Because the **approvalId** is unique and included in the tuple, you know there are no other approvals that overlap.

Thus, you can simply brute force this tuple in the permissions and call it a day.

**Tuples with Overlaps**

For tuples which may span multiple approvals, the algorithm is essentially the following:

1. Forbid updates for the exact tuple values you want to freeze in permissions
2. To keep expected behavior, you need to forbid updates for all specific approvals that are currently set and overlap (even partially) with the values you are trying to freeze.
   * Ex: If you are trying to freeze badge IDs 1-10, you should also entirely freeze the approval abc123 which is for badge IDs 1-100.
   * Technically, this only needs to be done for approvals that are set and can affect the behavior of the tuple values, but to be safe, we recommend freezing all overlapping approvals or restructuring so they do not overlap. It is difficult to manage when part of an approval is frozen.

**Example**

Let's say you want to forbid ever updating the transferability for badges 1-10, and you have the following approvals currently set (for badges 1-100).

```json
"collectionApprovals": [
    {
      "fromListId": "Mint",
      "toListId": "All",
      "initiatedByListId": "All",
      "transferTimes": [
        {
          "start": "1691978400000",
          "end": "1723514400000"
        }
      ],
      "ownershipTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "badgeIds": [
        {
          "start": "1",
          "end": "100"
        }
      ],
      "approvalId": "abc",
      "approvalCriteria": {
        .... //uses trackers
      }
    }
  ]
```

Step 1: Brute force IDs 1-10 in the permissions to be forbidden.

<pre class="language-json"><code class="lang-json"><strong>{
</strong>  "fromListId": "All",
  "toListId": "All",
  "initiatedByListId": "All",
  "badgeIds":  [{ "start": "1", "end": "10" }],
  "transferTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "ownershipTimes":  [{ "start": "1", "end": "18446744073709551615" }],
  "approvalId": "All",
  "permanentlyPermittedTimes": [],
  "permanentlyForbiddenTimes": [{ "start": "1", "end": "18446744073709551615" }]
}
</code></pre>

Step 2: Find all matching approvals. In this case, we only have one and it matches because it uses overlaps since it uses IDs 1-100.

```json
{
    "fromListId": "Mint",
    "toListId": "All",
    "initiatedByListId": "All",
    "transferTimes": [
      {
        "start": "1691978400000",
        "end": "1723514400000"
      }
    ],
    "ownershipTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "badgeIds": [
      {
        "start": "1",
        "end": "100"
      }
    ],
    "approvalId": "abc",
    "approvalCriteria": {
      ....
    }
  }
```

In this particular case, the approval is updatable (IDs 11-100 are) and is not already frozen. Thus, expected behavior of badges 1-10 may not be guaranteed.

We need to handle this, which we can do by adding another permission brute forcing approval "abc".

```json
{
    "fromListId": "All",
    "toListId": "All",
    "initiatedByListId": "All",
    "transferTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "ownershipTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "badgeIds": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "approvalId": "abc",    
     
    "permanentlyPermittedTimes": [],
    "permanentlyForbiddenTimes": [{ "start": "1", "end": "18446744073709551615" }]
  }
```


## File: ./x-badges/concepts/protocols/README.md

# Protocols

This directory contains documentation for standardized protocols that can be implemented using BitBadges collections. These protocols define specific patterns and requirements for creating interoperable badge collections with well-defined behaviors.

## Available Protocols

-   **[Subscriptions Protocol](./subscriptions-protocol.md)** - Implementation pattern for subscription-based badge collections with recurring payments and time-based ownership

## Protocol Overview

Protocols in BitBadges are standardized implementations that:

-   Define specific collection configuration patterns
-   Establish validation rules for protocol compliance
-   Enable interoperability between different applications
-   Provide predictable behavior for users and developers


## File: ./x-badges/concepts/protocols/subscriptions-protocol.md

# Subscriptions Protocol

The Subscriptions Protocol enables collections to implement subscription-based badge ownership with recurring payments, time-limited access, and a tipping system for automatic renewal. This protocol standardizes how subscription badges are created, distributed, and renewed.

## Protocol Overview

Subscription collections allow users to pay a recurring fee + tip to maintain ownership of badges for specific time periods. The protocol ensures predictable behavior for subscription management across different applications.

## Protocol Requirements

### Standards Declaration

Collections must include "Subscriptions" in their standards timeline:

```json
{
    "standardsTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "standards": ["Subscriptions"]
        }
    ]
}
```

### Badge ID Configuration

-   **Single Badge ID**: Only one badge ID range (1-1) is permitted
-   **Valid Badge IDs**: Must match exactly with subscription approval badge IDs

### Collection Approvals

Must contain at least one subscription faucet approval with the following characteristics:

#### From Address

-   **fromListId**: Must be "Mint" (minting operation)

#### Approval Criteria Requirements

##### Coin Transfers

-   **Required**: At least one coin transfer specification
-   **Single Denom**: All coin transfers must use the same denomination
-   **No Address Override**: `overrideFromWithApproverAddress` and `overrideToWithInitiator` must be false

##### Predetermined Balances

Must use `incrementedBalances` with specific configuration:

```json
{
    "predeterminedBalances": {
        "incrementedBalances": {
            "startBalances": [
                {
                    "amount": "1",
                    "badgeIds": [{ "start": "1", "end": "1" }],
                    "ownershipTimes": [{ "start": "0", "end": "0" }]
                }
            ],
            "incrementBadgeIdsBy": "0",
            "incrementOwnershipTimesBy": "0",
            "durationFromTimestamp": "2592000000", // 30 days in milliseconds
            "allowOverrideTimestamp": true,
            "recurringOwnershipTimes": {
                "startTime": "0",
                "intervalLength": "0",
                "chargePeriodLength": "0"
            }
        }
    }
}
```

**Key Requirements:**

-   **Amount**: Must be exactly 1
-   **Badge IDs**: Single badge ID (1-1)
-   **Duration**: Must be greater than 0 (subscription period length)
-   **Override Timestamp**: Must be true for faucet functionality
-   **No Increments**: Badge ID and ownership time increments must be 0
-   **No Recurring**: Recurring ownership times must be all 0

##### Restrictions

-   **No Merkle Challenges**: Cannot include merkle challenges
-   **No Badge Requirements**: Cannot include mustOwnBadges requirements
-   **No Address Restrictions**: Cannot require from/to equals initiated by
-   **No Override Approvals**: Cannot override incoming approvals

## User Subscription Management

Users manage their subscriptions through incoming approvals that complement the collection's faucet approval:

### User Incoming Approval Requirements

#### Basic Configuration

-   **fromListId**: Must be "Mint"
-   **Badge IDs**: Must match subscription approval badge IDs exactly
-   **Single Badge**: Only one badge ID range permitted

#### Coin Transfer Configuration

```json
{
    "coinTransfers": [
        {
            "coins": [
                {
                    "denom": "ubadge", // Must match subscription denom
                    "amount": "100000" // Must be >= subscription amount
                }
            ],
            "overrideFromWithApproverAddress": true,
            "overrideToWithInitiator": true
        }
    ]
}
```

#### Predetermined Balances for Renewals

```json
{
    "predeterminedBalances": {
        "incrementedBalances": {
            "startBalances": [
                {
                    "amount": "1",
                    "badgeIds": [{ "start": "1", "end": "1" }]
                }
            ],
            "incrementBadgeIdsBy": "0",
            "incrementOwnershipTimesBy": "0",
            "durationFromTimestamp": "0",
            "allowOverrideTimestamp": false,
            "recurringOwnershipTimes": {
                "startTime": "1672531200000", // Current subscription start
                "intervalLength": "2592000000", // 30 days
                "chargePeriodLength": "604800000" // 7 days max charge period
            }
        }
    }
}
```

#### Transfer Limits

```json
{
    "maxNumTransfers": {
        "overallMaxNumTransfers": "1",
        "resetTimeIntervals": {
            "startTime": "1672531200000",
            "intervalLength": "2592000000" // Same as subscription interval
        }
    }
}
```

## Protocol Validation Logic

### Collection Validation

```typescript
function doesCollectionFollowSubscriptionProtocol(collection) {
    // Check for "Subscriptions" standard
    const hasSubscriptionStandard = collection.standardsTimeline.some(
        (standard) =>
            standard.standards.includes('Subscriptions') &&
            isCurrentTime(standard.timelineTimes)
    );

    if (!hasSubscriptionStandard) return false;

    // Find subscription faucet approvals
    const subscriptionApprovals = collection.collectionApprovals.filter(
        (approval) => isSubscriptionFaucetApproval(approval)
    );

    if (subscriptionApprovals.length < 1) return false;

    // Validate single badge ID requirement
    if (collection.validBadgeIds.length !== 1) return false;

    // Ensure approval badge IDs match collection badge IDs
    const allApprovalBadgeIds = subscriptionApprovals
        .map((approval) => approval.badgeIds)
        .flat();

    return badgeIdsMatch(collection.validBadgeIds, allApprovalBadgeIds);
}
```

### Faucet Approval Validation

```typescript
function isSubscriptionFaucetApproval(approval) {
    // Must be from Mint
    if (approval.fromListId !== 'Mint') return false;

    // Must have coin transfers
    if (!approval.approvalCriteria?.coinTransfers?.length) return false;

    // Single denomination requirement
    const allDenoms = approval.approvalCriteria.coinTransfers.flatMap((ct) =>
        ct.coins.map((c) => c.denom)
    );
    if (new Set(allDenoms).size > 1) return false;

    // No address overrides in coin transfers
    for (const coinTransfer of approval.approvalCriteria.coinTransfers) {
        if (
            coinTransfer.overrideFromWithApproverAddress ||
            coinTransfer.overrideToWithInitiator
        ) {
            return false;
        }
    }

    // Validate incremented balances configuration
    const incrementedBalances =
        approval.approvalCriteria.predeterminedBalances?.incrementedBalances;
    if (!incrementedBalances) return false;

    return validateIncrementedBalances(incrementedBalances, approval.badgeIds);
}
```

### User Approval Validation

```typescript
function isUserRecurringApproval(userApproval, subscriptionApproval) {
    // Must be from Mint
    if (userApproval.fromListId !== 'Mint') return false;

    // Badge IDs must match subscription
    if (!badgeIdsMatch(userApproval.badgeIds, subscriptionApproval.badgeIds)) {
        return false;
    }

    // Payment amount must be >= subscription amount
    const userAmount =
        userApproval.approvalCriteria?.coinTransfers?.[0]?.coins?.[0]?.amount;
    const subscriptionAmount =
        subscriptionApproval.approvalCriteria?.coinTransfers?.[0]?.coins?.[0]
            ?.amount;
    if (userAmount < subscriptionAmount) return false;

    // Validate coin transfer overrides
    const coinTransfer = userApproval.approvalCriteria.coinTransfers[0];
    if (
        !coinTransfer.overrideFromWithApproverAddress ||
        !coinTransfer.overrideToWithInitiator
    ) {
        return false;
    }

    // Validate recurring configuration
    return validateRecurringConfiguration(userApproval, subscriptionApproval);
}
```

## Usage Examples

### Basic Subscription Collection

```json
{
    "validBadgeIds": [{ "start": "1", "end": "1" }],
    "standardsTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "standards": ["Subscriptions"]
        }
    ],
    "collectionApprovals": [
        {
            "fromListId": "Mint",
            "toListId": "All",
            "initiatedByListId": "All",
            "transferTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "badgeIds": [{ "start": "1", "end": "1" }],
            "approvalCriteria": {
                "coinTransfers": [
                    {
                        "coins": [{ "denom": "ubadge", "amount": "100000" }],
                        "overrideFromWithApproverAddress": false,
                        "overrideToWithInitiator": false
                    }
                ],
                "predeterminedBalances": {
                    "incrementedBalances": {
                        "startBalances": [
                            {
                                "amount": "1",
                                "badgeIds": [{ "start": "1", "end": "1" }]
                            }
                        ],
                        "durationFromTimestamp": "2592000000",
                        "allowOverrideTimestamp": true
                    }
                }
            }
        }
    ]
}
```

### User Subscription Setup

```json
{
    "fromListId": "Mint",
    "badgeIds": [{ "start": "1", "end": "1" }],
    "approvalCriteria": {
        "coinTransfers": [
            {
                "coins": [{ "denom": "ubadge", "amount": "100000" }],
                "overrideFromWithApproverAddress": true,
                "overrideToWithInitiator": true
            }
        ],
        "predeterminedBalances": {
            "incrementedBalances": {
                "recurringOwnershipTimes": {
                    "intervalLength": "2592000000",
                    "chargePeriodLength": "604800000"
                }
            }
        },
        "maxNumTransfers": {
            "overallMaxNumTransfers": "1",
            "resetTimeIntervals": {
                "intervalLength": "2592000000"
            }
        }
    }
}
```

## Implementation Benefits

1. **Standardization**: Predictable subscription behavior across applications
2. **Interoperability**: Common interface for subscription management
3. **Automation**: Recurring payment and renewal mechanisms
4. **Flexibility**: Configurable subscription periods and pricing
5. **Validation**: Built-in compliance checking for protocol adherence

The Subscriptions Protocol provides a robust foundation for implementing subscription-based badge systems while maintaining the flexibility and security of the BitBadges approval system.


## File: ./x-badges/concepts/standards.md

# Standards

Standards are informational tags that provide guidance on how to interpret and implement collection features. The collection interface is very feature-rich, and oftentimes you may need certain features to be implemented in a certain way, avoid certain features, etc. That is what standards are for.

## Purpose

All collections implement the same interface on the blockchain, but standards define:

-   How specific fields should be interpreted
-   Which features should be used or avoided
-   Expected metadata formats
-   Implementation guidelines for applications

## Timeline Implementation

```json
"standardsTimeline": [
  {
    "timelineTimes": [{"start": "1", "end": "18446744073709551615"}],
    "standards": ["transferable", "text-only-metadata", "non-fungible", "attendance-format"]
  }
]
```

## Important Notes

-   **No blockchain validation** - Standards are purely informational
-   **Multiple standards allowed** - As long as they are compatible
-   **Application responsibility** - Queriers must verify compliance

## Example Usage

```json
{
    "standardsTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "standards": ["soulbound", "event-attendance", "minimal-metadata"]
        }
    ]
}
```

## BitBadges Site Standards

The BitBadges site recognizes three specific standards that collections can implement to ensure compatibility with various features and integrations:

### 1. Tradable Standard

Collections marked with the **Tradable** standard are marked as tradable on the BitBadges site. We will track orderbook, volume, price, and other metrics for these collections. Also, the interface will be optimized for trading.

-   **Requirements**:
    -   Ensure the collection lends itself to user-to-user trading
    -   Must be able to support bids / offers / listings / collection offers. These are standardized approvals that follow specific rules.

### 2. NFT Standard

Collections marked with the **NFT** standard are expected to be non-fungible tokens with supply = 1 for every badge ID.

-   **Requirements**:
    -   Each badge ID must have supply = 1 and full ownership times
    -   No fungible badge IDs allowed
    -   Maintains uniqueness across all badge IDs in the collection

### 3. Cosmos Wrappable Standard

Collections marked with the **Cosmos Wrappable** standard can be wrapped into Cosmos SDK coin denominations.

-   **Requirements**:
    -   Must have at least one wrapper path defined
    -   Should support bidirectional wrapping/unwrapping
    -   Refer to the [Cosmos Wrapper documentation](../cosmos-wrapper-paths.md) for detailed implementation guidelines

### 4. Subscriptions Standard

Collections marked with the **Subscriptions** standard are designed for recurring content delivery and subscription-based systems.

-   **Requirements**:
    -   Must support time-based ownership periods for subscription-like behavior
    -   Must be able to handle recurring badge issuance and expiration
    -   Should support dynamic content updates based on subscription status
-   **Implementation**: See [Subscriptions Protocol](protocols/subscriptions-protocol.md) for detailed implementation requirements and validation logic

### 5. Quests Standard

Collections marked with the **Quests** standard are designed for achievement-based systems and quest completion tracking.

-   **Requirements**:
    -   Should implement quest completion tracking and reward distribution
    -   Must support achievement-based badge issuance
    -   Should handle quest progression and milestone tracking

### Using BitBadges Standards

To implement these standards on your collection, add them to your `standardsTimeline`:

```json
{
    "standardsTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "18446744073709551615" }],
            "standards": [
                "Tradable",
                "NFT",
                "Cosmos Wrappable",
                "Subscriptions",
                "Quests"
            ]
        }
    ]
}
```

**Note**: These standards are informational and do not enforce blockchain-level validation. Applications and platforms are responsible for verifying compliance with the specified standards.


## File: ./x-badges/concepts/time-fields.md

# Different Time Fields

BitBadges uses various time-related fields to manage permissions, timelines, transfers, and ownership. Understanding these fields is crucial for effectively managing collections and badges.

## Time Representation

All times in BitBadges are represented as UNIX time, which is the number of milliseconds elapsed since the epoch (midnight at the beginning of January 1, 1970, UTC).

Time fields use UintRange format with valid values from 1 to 18446744073709551615 (Go MaxUint64). For complete details on range formatting and restrictions, see the [UintRange concept](uintrange.md).

## Time Field Types

### 1. permanentlyPermittedTimes
- **Purpose**: Defines the times when a permission will always be executable (permanent)
- **Usage**: Setting allowed periods for specific actions

### 2. permanentlyForbiddenTimes
- **Purpose**: Defines the times when a permission will always be forbidden (permanent)
- **Usage**: Setting restricted periods for specific actions

### 3. timelineTimes
- **Purpose**: Specifies when a field is scheduled to have a specific value in a timeline-based field
- **Usage**: Scheduling changes to collection or badge properties over time

### 4. transferTimes
- **Purpose**: Defines when a transfer transaction can occur (i.e. when an approval is valid)
- **Usage**: Setting periods when badges can be transferred between addresses

### 5. ownershipTimes
- **Purpose**: Specifies the times that a user owns a badge
- **Usage**: Defining the duration of badge ownership for users

## Important Note

The `timelineTimes` in permissions correspond to the updatability of the timeline, while `timelineTimes` in the actual timeline represent the actual times for the values.

## Examples

### Example 1: Presidential Election Badges

Scenario: Users participate in a US presidential election by casting votes through badge transfers.

- T1: Conclusion of voting
- T2: Start of presidential term  
- T3: End of presidential term

Setup:
- `transferTimes`: [{ start: T1, end: T2 }] (President badge can be transferred after voting concludes)
- `ownershipTimes`: [{ start: T2, end: T3 }] (Defines the presidential term)

### Example 2: Managing Collection Archival

Scenario: A collection can be optionally archived by the manager from T1 to T2, but is non-archivable at all other times.

Before archiving:
```
Permission:
permanentlyPermittedTimes: [{ start: T1, end: T2 }]
permanentlyForbiddenTimes: [everything but T1 to T2]
timelineTimes: [{ start: 1, end: MAX_TIME }]

Archived Timeline:
isArchived: false for [{ start: 1, end: MAX_TIME }]
```

After archiving for all times:
```
Permission: (unchanged)
permanentlyPermittedTimes: [{ start: T1, end: T2 }]
permanentlyForbiddenTimes: [everything but T1 to T2]
timelineTimes: [{ start: 1, end: MAX_TIME }]

Archived Timeline:
isArchived: true for [{ start: 1, end: MAX_TIME }]
```

### Example 3: Permanently Locking Permissions

Scenario: Continuing from Example 2, the manager wants to permanently lock the permission.

Final state:
```
Permission:
permanentlyPermittedTimes: []
permanentlyForbiddenTimes: [{ start: 1, end: MAX_TIME }]
timelineTimes: [{ start: 1, end: MAX_TIME }]

Archived Timeline:
isArchived: true for [{ start: 1, end: MAX_TIME }]
```

## Best Practices

1. **Clear Timelines**: Always define clear and non-overlapping time ranges for each field to avoid confusion and conflicts
2. **Permission Management**: Carefully consider the implications of setting `permanentlyPermittedTimes` and `permanentlyForbiddenTimes`, as these can significantly impact the flexibility of your collection
3. **Timeline Planning**: When using `timelineTimes`, plan your collection's lifecycle in advance to minimize the need for frequent updates
4. **Transfer Windows**: Use `transferTimes` to create specific windows for badge transfers, which can be useful for time-limited events or phased distributions
5. **Ownership Tracking**: Leverage `ownershipTimes` to create badges with time-bound ownership, useful for temporary privileges or rotating responsibilities
6. **Permission Locking**: Be cautious when permanently locking permissions (as in Example 3), as this action is irreversible and may limit future flexibility
7. **Time Synchronization**: Ensure all systems interacting with your BitBadges collection are properly time-synchronized to avoid discrepancies in time-based operations

By understanding and effectively using these time fields, you can create sophisticated and dynamic badge systems in BitBadges, enabling complex scenarios from voting systems to time-bound privileges and beyond.

## File: ./x-badges/concepts/timeline-system.md

# Timeline System

BitBadges uses timeline-based fields to allow dynamic, time-dependent values for various attributes. This feature enables automatic updates to field values based on the current time, without requiring additional blockchain transactions.

## Key Concepts

### Time Representation

-   Times are represented as UNIX time (milliseconds since the epoch)
-   Epoch: Midnight at the beginning of January 1, 1970, UTC
-   Time fields use UintRange format with valid values from 1 to 18446744073709551615 (Go MaxUint64)

### Value Assignment

-   Values are assigned to specific time ranges
-   No overlapping time ranges are allowed for a single field
-   Current value determined by finding the timeline entry that includes current time

### Default Behavior

-   If no value is set for the current time, the field assumes an empty/null/default value

## Structure

Timeline-based fields extend the `TimelineItem` interface:

```typescript
export interface TimelineItem<T extends NumberType> {
    timelineTimes: UintRange<T>[];
}
```

## Proto Definition Examples

```protobuf
message ManagerTimeline {
  repeated UintRange timelineTimes = 1;
  string manager = 2;
}

message CollectionMetadataTimeline {
  repeated UintRange timelineTimes = 1;
  CollectionMetadata collectionMetadata = 2;
}

message BadgeMetadataTimeline {
  repeated UintRange timelineTimes = 1;
  repeated UintRange badgeIds = 2;
  BadgeMetadata badgeMetadata = 3;
}
```

## Timeline Fields in Collections

The collection interface includes the following timeline-based fields:

-   `managerTimeline: ManagerTimeline<T>[]`
-   `collectionMetadataTimeline: CollectionMetadataTimeline<T>[]`
-   `badgeMetadataTimeline: BadgeMetadataTimeline<T>[]`
-   `offChainBalancesMetadataTimeline: OffChainBalancesMetadataTimeline<T>[]`
-   `customDataTimeline: CustomDataTimeline<T>[]`
-   `standardsTimeline: StandardsTimeline<T>[]`
-   `isArchivedTimeline: IsArchivedTimeline<T>[]`

## Usage Example

### Collection Metadata Timeline

```json
{
    "collectionMetadataTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "1680307199000" }],
            "collectionMetadata": {
                "uri": "ipfs://abc123",
                "customData": ""
            }
        },
        {
            "timelineTimes": [
                { "start": "1680307200000", "end": "18446744073709551615" }
            ],
            "collectionMetadata": {
                "uri": "ipfs://xyz456",
                "customData": ""
            }
        }
    ]
}
```

In this example:

-   From time 1 to March 31, 2023, the collection metadata URI is 'ipfs://abc123'
-   From April 1, 2023 onwards, the collection metadata URI is 'ipfs://xyz456'
-   The change happens automatically without additional transactions

### Manager Timeline

```json
{
    "managerTimeline": [
        {
            "timelineTimes": [{ "start": "1", "end": "1672531199000" }],
            "manager": "bb1alice..."
        },
        {
            "timelineTimes": [
                { "start": "1672531200000", "end": "18446744073709551615" }
            ],
            "manager": "bb1bob..."
        }
    ]
}
```

This setup transfers management from Alice to Bob on January 1, 2023.

## Key Principles

1. **Automatic Updates**: Values change automatically based on current time
2. **No Overlaps**: Timeline times within the same array should not overlap
3. **Future Scheduling**: Can schedule changes for future times
4. **Gas Efficiency**: No additional transactions needed for scheduled changes

## Practical Applications

Timeline-based fields enable:

-   **Scheduled ownership transfers** without manual intervention
-   **Automatic metadata updates** for evolving collections
-   **Time-based permission changes** for governance
-   **Seasonal content updates** for dynamic collections
-   **Archive scheduling** for temporary collections


## File: ./x-badges/concepts/total-supply.md

# Total Supply

The total circulating supply is not a fixed value but rather dynamically determined through the collection approvals and permissions. The total supply is the sum of all the badges that have been transferred from the Mint address (which has unlimited balances). Setting the Mint approvals and using them determines the total supply. Permissions are used to control the ability to set, update, or delete the Mint approvals.

## Related Concepts

-   **[Valid Badge IDs](valid-badge-ids.md)** - Defines which badge IDs can exist for informational purposes
-   **[Manager](manager.md)** - Controls the collection approvals and permissions
-   **[Transferability & Approvals](transferability-approvals.md)** - Governs transfers from Mint address
-   **[Permissions](permissions/)** - Controls what managers can do and when they can do it


## File: ./x-badges/concepts/transferability-approvals.md

# Transferability / Approvals

First, read [Transferability ](broken-reference/)for an overview of approved transfers.

Note: The [Approved Transfers](transferability-approvals.md) and [Permissions ](broken-reference/)are the most powerful features of the interface, but they can also be the most confusing. Please ask for help if needed.

Collections with "Off-Chain" balances and address lists do not utilize on-chain transferability, so this page is not applicable to them.

## Approvals Overview

### Approval Levels - Collection, Incoming, Outgoing

Approved transfers encompass three hierarchical levels: collection, incoming, and outgoing, as previously elaborated. The interfaces for these three levels share common elements, with slight variations in functionality:

-   Incoming approvals exclude the "to" fields as they are automatically populated with the recipient's address.
-   Outgoing approvals omit the "from" fields, as they are automatically filled with the sender's address.
-   The collection level holds the capacity to override user-level (incoming / outgoing) approvals, but not vice versa.

**For a transfer to be approved, it has to satisfy the collection-level approvals, and if not overriden forcefully by the collection-level approvals, the user incoming / outgoing also have to be satisfied.**

<figure><img src="../../../.gitbook/assets/image (33).png" alt=""><figcaption></figcaption></figure>

### Approvals != Escrows

When it comes to approved transfers, it's important to note that they are just approvals and may not necessarily correspond directly to underlying balances. Approvers must ensure that sufficient balances are available to uphold the approvals' integrity, accounting for potential revokes or freezes. This responsibility extends to the collection-level transferability as well.

On a similar note, if approvals become no longer valid (such as approving a badge but it was revoked via a different approval), the former approval doesn't automatically get cancelled. It is the approver's responsibility to handle them accordingly.

### Mint - Unlimited Balances

For on-chain balances, the Mint address has unlimited balances. So, it is extra critical to set these approvals correctly.

The Mint address does not have incoming / outgoing approvals that can be controlled. For all Mint approvals, they must forcefully override the user-level outgoing approval because it cannot be managed.

### Representation

In the collection interface, they are represented as the following:

```json
{
    ...
    "collectionApprovals": [{ ... }, ...]
    ...
}
```

```typescript
export interface CollectionApproval<T extends NumberType> {
    toListId: string;
    fromListId: string;
    initiatedByListId: string;
    transferTimes: UintRange<T>[];
    badgeIds: UintRange<T>[];
    ownershipTimes: UintRange<T>[];
    approvalId: string;

    uri?: string;
    customData?: string;

    approvalCriteria?: ApprovalCriteria<T>;

    version: T;
}
```

Note; User incoming / outgoing approvals follow the same interface except **toList** is auto-populated with the user's address for incoming approvals and similarly the **fromList** for outgoingApprovals.

**Approved vs Unapproved**

Approvals are simply a set of criteria, so it is entirely possible the same transfer could satisfy multiple approvals on the same level. We handle approvals per level in the following manner:

1. If the transfer is unhandled (doesn't match to any approval), it is DISAPPROVED by default.
2. We allow users to specify **prioritizedApprovals** and **onlyCheckPrioritizedApprovals** (in [MsgTransferBadges](../../bitbadges-blockchain/cosmos-sdk-msgs/x-badges/msgtransferbadges.md)) when transferring, so they can only use up their desired approvals.
    1. Any approval with side effects (coin transfers, criteria, trackers, etc) MUST be specified explicity in prioritized approvals.
    2. Any approval without side effects (e.g. generic unlimited transferability collection approval) does not have to be specified.
    3. When scanning approvals, we check prioritized approvals first. Then, we attempt to scan any approvals without side effects.

We strongly recommend designing approvals in a way where no transfer can map to multiple. This improves the simplicity and readability of your collection.

**Who? When? What? - Main Fields**

To represent transfers, six main fields are used: **`toList`**, **`fromList`**, **`initiatedByList`**, **`transferTimes`**, **`badgeIds`**, and **`ownershipTimes`**. These fields collectively define the transfer details, such as the addresses involved, timing, and badge details. This representation leverages range logic, breaking down into individual tuples for enhanced comprehension.

-   **toList, fromList, initiatedByList**: [AddressLists](../../core-concepts/address-lists-lists.md) specifying which addresses can send, receive, and initiate the transfer. If we use **toListId, fromListId, initiatedByListId**, these refer to the lists IDs of the respective lists. IDs can either be reserved IDs (see [AddressLists](../../core-concepts/address-lists-lists.md)) or IDs of lists created on-chain through [MsgCreateAddressLists](../../bitbadges-blockchain/cosmos-sdk-msgs/). Note that on-chain approvals cannot access off-chain lists.
-   **transferTimes**: When can the transfer takes place? A [UintRange](../../core-concepts/uint-ranges.md)\[] of times (UNIX milliseconds).
-   **badgeIds**: What badge IDs can be transferred? A [UintRange](../../core-concepts/uint-ranges.md)\[] of badge IDs.
-   **ownershipTimes**: What ownership times for the badges are being transferred? (UNIX milliseconds)

For example, we might have something like the following:

-   ```json
    "fromListId": "Mint", //reserved list ID for the "Mint" addres
    "toListId": "All", //reserved list ID for all addresses (excluding "Mint")
    "initiatedByListId": "All",
    "transferTimes": [
      {
        "start": "1691931600000",
        "end": "1723554000000"
      }
    ],
    "ownershipTimes": [
      {
        "start": "1",
        "end": "18446744073709551615" //Max possible value
      }
    ],
    "badgeIds": [
      {
        "start": "1",
        "end": "100"
      }
    ],
    ```

Let's break down the definition above.

-   The "Mint" list ID is the reserved list corresponding to the Mint address. This approval only allows transfers from the "Mint" address. The transfer can be initiated by any user (because the AddressList "All" includes all addresses) and can have any address as the recipient.
-   The ownership rights for any time of badge IDs 1-100 can be transferred from UNIX time 1691931600000 (Aug 13, 2023) to time 1723554000000 (Aug 13, 2024).

Note the approval only applies to the details defined and must match ALL details. For example, badge ID #101 is not defined by this approval even if all other criteria matches.

**Transferring From Mint Address**

As mentioned before, we check the collection level approvals first, and if not overriden, we check the user-level incoming/outgoing approvals.

The Mint address is a special case. It technically has its own approvals, but since it is not a real address, the user approvals are always empty and never usable. Thus, it is important that when you attempt transfers from the Mint address, you **override the outgoing approvals** of the Mint address (see [Overrides](approval-criteria/#overrides) on the next page for how).

It is also recommended that when dealing with approvals from the "Mint" address, the approval's **fromList** is only the "Mint" address and no other address. This helps readability and simplicity and avoiding unintentionally approving users to mint, which could be very bad. See Example 2 below.

Again, remember the Mint address has unlimited balances.

#### Approval IDs

All approvals must have a unique **approvalId** for identification per level. This is simply used for identification.

```json
{
    ...
    "approvalId": "abc123",
}
```

**Metadata**

We provide an optional **uri** and **customData** to allow you to add a link to something about your approval. See [Compatibility](../../bitbadges-api/concepts/designing-for-compatibility.md) for the expected format for the BitBadges API / Indexer.

This can typically be used for providing names, descriptions about your approvals. Or, we also use it to host N - 1 layers of a Merkle tree for a Merkle challenge of codes (N - 1 to be able to construct the path but not give away the value of leaves which are to be secret). Or, for whitelist trees where no leaves are secret, we can host the full tree. Learn more in the approval criteria merkle challenges section.

#### Approval Criteria

The **`approvalCriteria`** section corresponds to additional restrictions or challenges necessary to be satisfied for approval. It defines aspects like the quantity approved, maximum transfers, and more. There is a lot here, so we have dedicated a page to just explaining the [approval details here](approval-criteria/).

For the rest of this page, you can simply think of it as the challenges or restrictions that need to be obeyed to be approved.

**Breaking Down Range Logic**

Even though our interface uses range logic (UintRanges, AddressLists), you can think of it as we break everything down into single-value tuples (e.g., `(bob, alice, bob, 1, 1, 1000)`) and check each singular value tuple separately. This simplifies the matching process and enhances clarity.

#### Matching Transfers to Approvals

The process of matching transfers to approvals involves several steps. This is done on a per-level basis.

1. We start with the collection-level approvals.
2. Expand all approval tuples with range logic (AllWithMint, ...., \[IDs 1-100]) to singular tuple values (e.g. (bob, alice, bob, badge ID #1, ....)
3. Expand the current transfer tuple to singular tuple values.
4. Find all matches (for approvals, linear first match by default but can be customized with **prioritizedApprovals** and **onlyCheckPrioritizedApprovals**).
    1. If anything is unhandled on any approval level (accounting for overrides), the overall transfer is disapproved.
    2. In the case of overflowing approvals (e.g. we are transferring x10 but have two approvals for x3 and x12), we deduct as much as possible from each one as we iterate. So using the previous example, we would end up with x3/3 of the first approval used and x7/12 of the second used.
    3. We check the **`approvalCriteria`** for each match and ensure everything is satisfied. If not, it is not a match.
5. For any amounts / balances that were approved but do not override incoming / outgoing approvals respectively, we go back to step 2 and check the recipient's incoming approvals and the senders' outgoing approvals for those balances.

### Defaults and Auto Approvals

**Auto Approvals**

If **autoApproveSelfInitiatedOutgoingTransfers** is set to true, we automatically apply an unlimited approval (with no amount restrictions) to the user's outgoing approvals when the sender is the same as the initiator.

If **autoApproveSelfInitiatedIncomingTransfers** is set to true, we automatically apply an unlimited approval (with no amount restrictions) to the user's incoming approvals when the recipient is the same as the initiator.

if **autoApproveAllIncomingTransfers** is set to true, we automatically apply an unlimited approval (with no amount restrictions) to the user's incoming approvals when the recipient is the same as the initiator.

In 99% of cases, the auto approvals should be true because the expected functionality is that if the user is initiating the transaction, they also approve it. However, this can be turned off and leveraged for specific use cases such as using an account for an escrow.

**Defaults**

We allow the collection to define default values for each user, and when the user first interacts with the collection, they will start with these values. The defaults include **balances**, **outgoingApprovals**, **incomingApprovals**, **autoApproveSelfInitiatedOutgoingTransfers,** **autoApproveAllIncomingTransfers**, and **autoApproveSelfInitiatedIncomingTransfers.**

For default balances, we refer you to the balance types and creating badges sections (i.e. these are the starting balances).

Note: Default approvals can NOT contain custom criteria checks. In other words, default approvals can not have side effects. They can only be a simple approval without any custom restrictions.

**Default Outgoing Approvals**

For outgoing approvals, the expected functionality is that everything is disapproved by default unless self initiated. Thus, the following is the typical default values.

```
"defaultOutgoingApprovals": [],
"autoApproveSelfInitiatedOutgoingTransfers": true
```

**Default Incoming Approvals - Forceful Transfers vs Opt-In Only**

However, with incoming approvals, the expected functionality is slightly different. There are a couple options. Do you want users to be able to transfer "forcefully" to an address without prior approval by default? Or, do you want users to have to self-initiate / opt-in first to receive badges?

In order to allow forceful transfers to an address without prior approval, the **incomingApprovals** must be set to something like below. Otherwise, if empty or \[], then all transfers must be initiated by or manually approved by the recipient by default (opt-in only).

```json
//"forceful" is allowed
"defaultIncomingApprovals": [
    {
      "fromListId": "AllWithMint",
      "initiatedByListId": "AllWithMint",
      "transferTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "badgeIds": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "ownershipTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "approvalId": "forceful-transfers-allowed"
    }
  ]
```

### **Approval Value vs Permission**

While the value may seem similar to the approval update permissions, the permission corresponds to the **updatability** of the approvals (i.e. **canUpdateCollectionApprovals**). The approvals themselves correspond to if a transfer is currently approved or not.

**Example**

Current Value - IDs 1-10 are approved

Permission - IDs 1-5 cannot be updated, 6-10 can

### **Example 1 - Putting It Together**

Bob is transferring x10 of **ownershipTimes** 1-Max of **badgeIds** 1-2 at time T to Alice.

#### Transfer Request:

Transfer: `(Bob, Alice, Bob, T, [1-2], [1-Max])`

#### Collection Approved Transfers:

1. `(Bob, Alice, Bob, T, [1-2], [1000-2000]) -> APPROVED`
2. `(Bob, Alice, All, T, [1-2], [1-2000]) -> APPROVED`
3. `(Bob, Alice, All, T, [1-2], [2001-Max]) -> APPROVED`

Let's say each approval has no amount restriction but does not override the user level incoming / outgoing approvals.

In this scenario, let's say the default "first match" approach is used:

1. The first approved transfer `(Bob, Alice, Bob, T, [1-2], [1000-2000])` matches the transfer request partially, but it only covers **ownershipTimes** from 1000 to 2000. We deduct this overlap but still have a lot remaining to be approved for (\[1-999], \[2001-Max]).
2. The second approved transfer `(Bob, Alice, All, T, [1-2], [1-2000]),` again partially matches, and we deduct. This partial match only handles 1-999 because we handled 1000-2000 already. Note that this approval says it can be initiated by "All" instead of Bob, but Bob's address is within the "All" list.
3. The third approved transfer `(Bob, Alice, All, T, [1-2], [1001-Max])` covers the rest. This transfer is approved on the collection level because the entire transfer was handled.

If Bob was requesting badge ID 3 to be transferred as well, it would fail because badge ID 3 is unhandled by all defined approvals (and disallowed by default if unhandled).

**Outgoing Approvals**

Because we did not override the user level approvals, we need to check that Bob approved this transfer in his approvals.

The process above would then be repeated for Bob's outgoing approvals. In this case, Bob is the initiator, so we automatically add an unlimited approval by default (see below).

**Incoming Approvals**

Likewise, we also need to check Alice's incoming approvals using the same process.

**Satisfied?**

If all levels are satisfied, the transfer is approved, and we deduct/increment the used approvals where necessary.

**Extending the Example: Prioritized Approvals**

Let's say that Bob only wants to use the second and third approvals from the collection level but not the first. By default, a first-match policy is applied, so it would by default use the first one as shown above.

When initiating the transfer (MsgTransferBadges), Bob can set **prioritizedApprovals** to be the second and third collection approvals. These would then be checked first, followed by the first approval.

If Bob additionally sets **onlyCheckPrioritizedApprovals** = true, we only check the ones specified in **prioritizedApprovals**.

### Example 2 - Collection

This would define a collection where badges 1-100 can be transferred from the Mint address (according to the first approval). Once transferred out of the Mint address, they can be transferred freely, thus making the collection transferable.

Note how the **fromList** of each approval are non-overlapping, so any transfer will only match to one of the two approvals (if either). The first approval is restricted to transfers from the Mint address whereas the second is all EXCEPT the Mint address.

```json
 "collectionApprovals": [
    {
      "fromListId": "Mint",
      "toListId": "AllWithMint",
      "initiatedByListId": "AllWithMint",
      "transferTimes": [
        {
          "start": "1691931600000",
          "end": "1723554000000"
        }
      ],
      "ownershipTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "badgeIds": [
        {
          "start": "1",
          "end": "100"
        }
      ],
      "approvalId": "claim-from-mint-address",
      ... //other criteria (including the IMPORTANT overrideFromOutgoingApprovals = true since we are dealing with transfers from the Mint address)
    },
    {
      "fromListId": "AllWithoutMint",
      "toListId": "AllWithoutMint",
      "initiatedByListId": "AllWithoutMint",
      "badgeIds": [
        {
          "start": "1",
          "end": "100"
        }
      ],
      "ownershipTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "transferTimes": [
        {
          "start": "1",
          "end": "18446744073709551615"
        }
      ],
      "approvalId": "transferable"
    }
  ],
```

### Example 3 - Outgoing Approvals

This would set approve Charlie to send badges to Bob on this user's behalf.

```json
"outgoingApprovals": [
  {
    "toListId": "Bob",
    "initiatedByListId": "Charlie",
    "transferTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "badgeIds": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "ownershipTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "approvalId": "test",
    //see next page
    "approvalCriteria": //define approval criteria (how much? challenges? etc here)
  }
]
```

### Example 4 - Incoming Approvals

This would set approve this user to receive any transfer from Bob.

```json
"incomingApprovals": [
  {
    "fromListId": "Bob",
    "initiatedByListId": "AllWithMint",
    "transferTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "badgeIds": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "ownershipTimes": [
      {
        "start": "1",
        "end": "18446744073709551615"
      }
    ],
    "approvalId": "test",
  }
]
```


## File: ./x-badges/concepts/uintrange.md

# UintRanges

The `UintRange` is the fundamental data structure used throughout the badges module to represent inclusive ranges of unsigned integers efficiently. This type enables powerful range-based operations and is primarily used for badge IDs, time ranges, and amounts.

## Proto Definition

```protobuf
message UintRange {
  string start = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  string end = 2 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
}
```

## Overview

The `UintRange` represents an **inclusive** range of numbers from a start value to an end value. Both the start and end values are included in the range.

## Usage Patterns

UintRanges are used to represent:

-   **Badge ID ranges**: `[1-100]` represents badge IDs 1 through 100 (inclusive)
-   **Time ranges**: `[1640995200000-1672531200000]` represents a year in UNIX milliseconds
-   **Amount ranges**: `[1-5]` represents quantities from 1 to 5
-   **Ownership time ranges**: When badges are valid for ownership

## Restrictions & Valid Values

Unless otherwise specified, we only allow numbers in the ranges to be from **1 to Go Max UInt64**:

-   **Valid range**: 1 to 18446744073709551615 (Go's `math.MaxUint64`)
-   **Zero and negative values**: Not allowed
-   **Values greater than maximum**: Not allowed

## Validation Rules

-   `start` must be ≤ `end`
-   Ranges in the same array cannot overlap
-   Zero amounts are not allowed in balance ranges
-   All values must be within the valid range (1 to MaxUint64)

## Special Cases

### Full Range

To represent a complete range covering all possible values:

```protobuf
// Full range from 1 to maximum
{
  start: "1",
  end: "18446744073709551615"
}
```

### Single Value

To represent a single value, use the same value for start and end:

```protobuf
// Single badge ID 5
{
  start: "5",
  end: "5"
}
```

### Range Inversion

Inverting a range results in all values from 1 to 18446744073709551615 that are **not** in the current range. This is useful for exclusion logic.

## Examples

### Badge ID Examples

```typescript
// Badge IDs 1-10 (inclusive)
const badgeRange: UintRange[] = [{ start: '1', end: '10' }];

// Multiple non-overlapping ranges
const multipleBadges: UintRange[] = [
    { start: '1', end: '10' },
    { start: '20', end: '50' },
];
```

### Time Range Examples

```typescript
// Transfer time range (UNIX milliseconds)
const transferTimes: UintRange[] = [
    { start: '1630000000000', end: '1640000000000' },
    // This represents 2021-08-26 to 2021-12-20
];

// Permanent validity
const permanent: UintRange[] = [{ start: '1', end: '18446744073709551615' }];
```

### Go Code Examples

```go
// Badge IDs 1-10
badgeIdRange := UintRange{Start: NewUint(1), End: NewUint(10)}

// Unlimited amount
unlimitedAmount := UintRange{Start: NewUint(1), End: MaxUint}

// Single badge ID
singleBadge := UintRange{Start: NewUint(5), End: NewUint(5)}
```

## Efficiency Benefits

-   **Compact representation**: Ranges avoid storing individual values
-   **Range operations**: Efficient intersection, union, and containment checks
-   **Gas optimization**: Reduces transaction size and computational costs
-   **Scalability**: Handles large ranges without performance degradation


## File: ./x-badges/concepts/valid-badge-ids.md

# Valid Badge IDs

Valid Badge IDs define the range of badge IDs that exist within a collection. This is mainly informational but also may be used to enforce certain rules within the collection.

## Key Concepts

### Badge ID Range Definition

-   The range of valid badge IDs (e.g., 1-100) must be defined on-chain in the core collection details
-   IDs must start at 1 and have no gaps
-   This range is separate from circulating supply

### Separation from Circulating Supply

-   Valid badge IDs define what _can_ exist
-   Circulating supply defines what _actually_ exists
-   Circulating supply is managed through transfers/approvals and balance allocations
-   Circulating supply should obey the valid badge IDs defined on-chain

## Creating Badge IDs

### During Collection Creation

Use the `validBadgeIds` field in [MsgCreateCollection](../../messages/msg-create-collection.md):

```json
{
    "creator": "bb1...",
    "validBadgeIds": [
        {
            "start": "1",
            "end": "100"
        }
    ],
    "collectionPermissions": {
        "canUpdateValidBadgeIds": [
            // { ... }
        ]
    }
}
```

### During Collection Updates

Use the `validBadgeIds` field in [MsgUpdateCollection](../../messages/msg-update-collection.md):

```json
{
    "creator": "bb1...",
    "collectionId": "1",
    "validBadgeIds": [
        {
            "start": "101",
            "end": "200"
        }
    ]
}
```

## Permission Control

Updates to valid badge IDs must obey the `canUpdateValidBadgeIds` permission:

### Permission Structure

```json
"canUpdateValidBadgeIds": [
  {
    "badgeIds": [{"start": "1", "end": "1000"}],
    "permanentlyPermittedTimes": [{"start": "1", "end": "18446744073709551615"}],
    "permanentlyForbiddenTimes": []
  }
]
```

### Permission Behaviors

Note that the `canUpdateValidBadgeIds` permission applies to the updatability of the `validBadgeIds` field.

We find the first-match for (current time, badge ID) for each badge ID that is changed, and check the permission for that time. If no time matches, the permission is default enabled. See [Permissions](permissions/) for more details.

### Permission Best-Practices

Typically, the desired functionality falls into one of the following categories:

-   **Set and Lock All**: Set the valid badge IDs upon genesis and lock everything from further updates
-   **Set and Lock All Current, Allow Expansion**: Set the valid badge IDs upon genesis and lock the current ones from being updated, but allow expansion in the future.

## Examples

### Basic Badge Creation

```json
// Create badges 1-50
{
    "validBadgeIds": [
        {
            "start": "1",
            "end": "50"
        }
    ]
}
```

### Expanding Badge Range

```json
// Later add badges 51-100 (must be sequential)
{
    "validBadgeIds": [
        {
            "start": "1",
            "end": "100"
        }
    ]
}
```

## Best Practices

1. **Plan ahead**: Consider future expansion when setting initial badge ID ranges
2. **Sequential additions**: Always add badge IDs sequentially to maintain the no-gaps requirement
3. **Permission management**: Carefully configure `canUpdateValidBadgeIds` permissions based on collection lifecycle
4. **Documentation**: Clearly document the intended use of different badge ID ranges


## File: ./x-badges/events.md

# Events

The badges module emits events for all message operations to enable blockchain monitoring and external application integration.

## Event Categories

### Standard Message Events

All message handlers emit `sdk.EventTypeMessage` events with message-specific attributes.

### Indexer Events

Duplicate events with type "indexer" for external application consumption.

### Transfer Events

Detailed events for transfer operations including approval usage and challenge tracking.

### IBC Events

Events for cross-chain operations with acknowledgment handling.

## Standard Message Events

### Collection Management

#### CreateCollection

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (creator address)
  - action: "create_collection"
  - msg: string (JSON-encoded message)
```

#### UpdateCollection

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (creator address)
  - action: "update_collection"
  - msg: string (JSON-encoded message)
```

#### UniversalUpdateCollection

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (creator address)
  - action: "universal_update_collection"
  - msg: string (JSON-encoded message)
```

#### DeleteCollection

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (creator address)
  - action: "delete_collection"
  - msg: string (JSON-encoded message)
```

### Badge Transfers

#### TransferBadges

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (initiator address)
  - action: "transfer_badges"
  - msg: string (JSON-encoded message)
  - transfer: string (JSON transfer details)
  - from: string (sender address)
  - to: string (recipient address)
  - initiatedBy: string (initiator address)
  - coinTransfers: string (JSON coin transfer details)
  - approvalsUsed: string (JSON approval usage details)
  - balances: string (JSON balance details)
```

### User Approvals

#### UpdateUserApprovals

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (user address)
  - action: "update_user_approvals"
  - msg: string (JSON-encoded message)
```

### Address Lists

#### CreateAddressLists

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (creator address)
  - action: "create_address_lists"
  - msg: string (JSON-encoded message)
```

### Dynamic Stores

#### CreateDynamicStore

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (creator address)
  - action: "create_dynamic_store"
  - store_id: string
  - msg: string (JSON-encoded message)
```

#### UpdateDynamicStore

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (updater address)
  - action: "update_dynamic_store"
  - store_id: string
  - msg: string (JSON-encoded message)
```

#### DeleteDynamicStore

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (deleter address)
  - action: "delete_dynamic_store"
  - store_id: string
  - msg: string (JSON-encoded message)
```

#### SetDynamicStoreValue

```
Type: "message"
Attributes:
  - module: "badges"
  - sender: string (setter address)
  - action: "set_dynamic_store_value"
  - store_id: string
  - address: string (target address)
  - value: string ("true"/"false")
  - msg: string (JSON-encoded message)
```

## Transfer Events

### Approval Usage

```
Type: "usedApprovalDetails"
Attributes:
  - collectionId: string
  - approverAddress: string
  - approvalId: string
  - amountTrackerId: string
  - approvalLevel: string
  - trackerType: string
  - address: string
  - amounts: string (JSON array)
  - numTransfers: string
  - lastUpdatedAt: string
```

### Challenge Events

```
Type: "challenge{approvalId}{challengeId}{leafIndex}{approverAddress}{approvalLevel}{newNumUsed}"
Attributes:
  - challengeTrackerId: string
  - approvalId: string
  - leafIndex: string
  - approverAddress: string
  - approvalLevel: string
  - numUsed: string
```

### Dynamic Approval Events

```
Type: "approval{collectionId}{approverAddress}{approvalId}{amountsTrackerId}{approvalLevel}{trackerType}{address}"
Attributes:
  - amountTrackerId: string
  - approvalId: string
  - approverAddress: string
  - approvalLevel: string
  - trackerType: string
  - approvedAddress: string
  - amounts: string (JSON array)
  - numTransfers: string
  - lastUpdatedAt: string
```

## IBC Events

### Packet Events

```
Type: "timeout" (for timeouts)
Attributes:
  - acknowledgement: string
  - success: string ("true"/"false")
  - error: string (if applicable)
```


## File: ./x-badges/examples/README.md

# Badge Standard Examples

This directory contains practical examples and building blocks for x/badges.

## Contents

- `base-collection-details.md` - Standard base collection configuration template
- `building-collection-approvals.md` - Guide to building collection-level approvals
- `building-collection-permissions.md` - Guide to configuring collection permissions
- `cosmos-coin-wrapper-example.md` - Example of wrapping badges as Cosmos coins
- `mint-all-to-self-tutorial.md` - Tutorial for creating collection and minting badges to yourself
- `approvals/` - Common approval patterns and examples
  - `transferable-approval.md` - Basic transferable approval configuration
  - `burnable-approval.md` - Approval allowing badges to be burned
  - `cosmos-wrapper-approval.md` - Approval for wrapping badges as Cosmos coins
  - `cosmos-unwrapper-approval.md` - Approval for unwrapping Cosmos coins back to badges
  - `admin-override-approval.md` - Admin approval that overrides user-level restrictions
- `permissions/` - Common permission patterns and examples


## File: ./x-badges/examples/approvals/admin-override-approval.md

# Admin Override Approval

This example demonstrates how to create an approval that allows a specific address to forcefully transfer badges, overriding all user-level approvals. This provides complete administrative control for emergency situations or management purposes.

## Overview

An admin override approval grants a specific address the power to:

-   Transfer badges from any address to any address
-   Override user-level incoming and outgoing approvals
-   Bypass normal approval restrictions
-   Maintain complete administrative control

⚠️ **Warning**: This approval type grants significant power and should be used carefully with trusted addresses only.

## Code Example

```typescript
const approveSelfForcefully = (address: string) => {
    const id = 'complete-admin-control';

    return {
        fromListId: 'Mint',
        toListId: 'All',
        initiatedByListId: address,
        transferTimes: UintRangeArray.FullRanges(),
        badgeIds: UintRangeArray.FullRanges(),
        ownershipTimes: UintRangeArray.FullRanges(),
        approvalId: id,
        version: 0n,
        approvalCriteria: {
            ...defaultNoRestrictionsApprovalCriteria,
            overridesFromOutgoingApprovals: true,
            overridesToIncomingApprovals: true,
        },
    };
};
```

## Usage Example

```typescript
// Create admin override for collection manager
const adminOverrideApproval = approveSelfForcefully(
    'bb1admin1234567890abcdef...'
);

// Use in collection
const otherApprovals = [
    // ... other approvals
];

const collection = {
    ...BaseCollectionDetails,
    collectionApprovalTimeline: [
        {
            timelineTimes: FullTimeRanges,
            collectionApprovals: [...otherApprovals, adminOverrideApproval],
        },
    ],
};
```

## Related Concepts

-   [Transferability / Approvals](../../concepts/transferability-approvals.md)
-   [Address Lists](../../concepts/address-lists.md)
-   [Approval Criteria](../../concepts/approval-criteria/)


## File: ./x-badges/examples/approvals/burnable-approval.md

# Burnable Approval

This example demonstrates how to create a burnable approval that allows badges to be sent to the burn address (0x0000000000000000000000000000000000000000), effectively removing them from circulation.

## Overview

A burnable approval enables badges to be permanently destroyed by sending them to the zero address.

## Code Example

```typescript
const burnableApproval = new CollectionApproval({
    fromListId: '!Mint', // Excludes the Mint address
    toListId: convertToBitBadgesAddress(
        '0x0000000000000000000000000000000000000000' //bb1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqs7gvmv
    ),
    initiatedByListId: 'All',
    transferTimes: UintRangeArray.FullRanges(),
    ownershipTimes: UintRangeArray.FullRanges(),
    badgeIds: UintRangeArray.FullRanges(),
    approvalId: 'burnable-approval',
    version: 0n,
    approvalCriteria: undefined, // No additional restrictions
});
```

## Usage in Collection

To use this approval in a collection, add it to the collection's approval timeline:

```typescript
const otherApprovals = [
    // ... other approvals
];

const collection = {
    ...BaseCollectionDetails,
    collectionApprovalTimeline: [
        {
            timelineTimes: FullTimeRanges,
            collectionApprovals: [...otherApprovals, burnableApproval],
        },
    ],
};
```

## Related Concepts

-   [Transferability / Approvals](../../concepts/transferability-approvals.md)
-   [Address Lists](../../concepts/address-lists.md)
-   [Timeline System](../../concepts/timeline-system.md)


## File: ./x-badges/examples/approvals/cosmos-unwrapper-approval.md

# Cosmos Unwrapper Approval

This example demonstrates how to create an approval that allows the Cosmos coin wrapper address to send badges back to users, enabling conversion from Cosmos coins back to badges (unwrapping).

Full example: [Cosmos Coin Wrapper Example](../cosmos-coin-wrapper-example.md)

## Code Example

```typescript
export const unwrapperApproval = ({
    specialAddress,
    badgeIds,
    ownershipTimes,
    approvalId,
}: {
    specialAddress: string;
    badgeIds: iUintRange<bigint>[];
    ownershipTimes: iUintRange<bigint>[];
    approvalId: string;
}): RequiredApprovalProps => {
    const id = approvalId;
    const toSet: RequiredApprovalProps = {
        version: 0n,
        fromListId: specialAddress,
        fromList: AddressList.getReservedAddressList(specialAddress),
        toListId: 'All',
        toList: AddressList.AllAddresses(),
        initiatedByListId: 'All',
        initiatedByList: AddressList.AllAddresses(),
        transferTimes: UintRangeArray.FullRanges(),
        badgeIds: badgeIds,
        ownershipTimes: ownershipTimes,
        approvalId: id,
        approvalCriteria: {
            autoDeletionOptions: {
                afterOneUse: false,
                afterOverallMaxNumTransfers: false,
            },
            requireToDoesNotEqualInitiatedBy: false,
            requireFromDoesNotEqualInitiatedBy: false,
            coinTransfers: [],
            predeterminedBalances: {
                manualBalances: [],
                orderCalculationMethod: {
                    useOverallNumTransfers: false,
                    usePerToAddressNumTransfers: false,
                    usePerFromAddressNumTransfers: false,
                    usePerInitiatedByAddressNumTransfers: false,
                    useMerkleChallengeLeafIndex: false,
                    challengeTrackerId: '',
                },
                incrementedBalances: {
                    startBalances: [],
                    incrementBadgeIdsBy: 0n,
                    incrementOwnershipTimesBy: 0n,
                    //monthly in milliseconds
                    durationFromTimestamp: 0n,
                    allowOverrideTimestamp: false,
                    allowOverrideWithAnyValidBadge: false,
                    recurringOwnershipTimes: {
                        startTime: 0n,
                        intervalLength: 0n,
                        chargePeriodLength: 0n,
                    },
                },
            },
            maxNumTransfers: {
                overallMaxNumTransfers: 0n,
                perToAddressMaxNumTransfers: 0n,
                perFromAddressMaxNumTransfers: 0n,
                perInitiatedByAddressMaxNumTransfers: 0n,
                amountTrackerId: id,
                resetTimeIntervals: {
                    startTime: 0n,
                    intervalLength: 0n,
                },
            },
            approvalAmounts: {
                overallApprovalAmount: 0n,
                perFromAddressApprovalAmount: 0n,
                perToAddressApprovalAmount: 0n,
                perInitiatedByAddressApprovalAmount: 0n,
                amountTrackerId: id,
                resetTimeIntervals: {
                    startTime: 0n,
                    intervalLength: 0n,
                },
            },
            merkleChallenges: [],
            mustOwnBadges: [],
            dynamicStoreChallenges: [],
            requireToEqualsInitiatedBy: false,
            requireFromEqualsInitiatedBy: false,
            overridesFromOutgoingApprovals: true,
            overridesToIncomingApprovals: false,
            userRoyalties: {
                percentage: 0n,
                payoutAddress: '',
            },
        },
    };

    return toSet;
};
```

## Related Concepts

-   [Cosmos Wrapper Approval](./cosmos-wrapper-approval.md)
-   [Cosmos Wrapper Paths](../../concepts/cosmos-wrapper-paths.md)
-   [Transferability / Approvals](../../concepts/transferability-approvals.md)
-   [Address Lists](../../concepts/address-lists.md)


## File: ./x-badges/examples/approvals/cosmos-wrapper-approval.md

# Cosmos Wrapper Approval

This example demonstrates how to create an approval that allows badges to be sent to a Cosmos coin wrapper address, enabling conversion to native Cosmos SDK coins.

Full example: [Cosmos Coin Wrapper Example](../cosmos-coin-wrapper-example.md)

## Code Example

```typescript
export const wrapperApproval = ({
    specialAddress,
    badgeIds,
    ownershipTimes,
    approvalId,
}: {
    specialAddress: string;
    badgeIds: iUintRange<bigint>[];
    ownershipTimes: iUintRange<bigint>[];
    approvalId: string;
}): RequiredApprovalProps => {
    const id = approvalId;
    const toSet: RequiredApprovalProps = {
        version: 0n,
        toListId: specialAddress,
        toList: AddressList.getReservedAddressList(specialAddress),
        fromListId: 'AllWithoutMint',
        fromList: AddressList.getReservedAddressList('AllWithoutMint'),
        initiatedByListId: 'All',
        initiatedByList: AddressList.AllAddresses(),
        transferTimes: UintRangeArray.FullRanges(),
        badgeIds: badgeIds,
        ownershipTimes: ownershipTimes,
        approvalId: id,
        approvalCriteria: {
            autoDeletionOptions: {
                afterOneUse: false,
                afterOverallMaxNumTransfers: false,
            },
            requireToDoesNotEqualInitiatedBy: false,
            requireFromDoesNotEqualInitiatedBy: false,
            coinTransfers: [],
            predeterminedBalances: {
                manualBalances: [],
                orderCalculationMethod: {
                    useOverallNumTransfers: false,
                    usePerToAddressNumTransfers: false,
                    usePerFromAddressNumTransfers: false,
                    usePerInitiatedByAddressNumTransfers: false,
                    useMerkleChallengeLeafIndex: false,
                    challengeTrackerId: '',
                },
                incrementedBalances: {
                    startBalances: [],
                    incrementBadgeIdsBy: 0n,
                    incrementOwnershipTimesBy: 0n,
                    durationFromTimestamp: 0n,
                    allowOverrideTimestamp: false,
                    allowOverrideWithAnyValidBadge: false,
                    recurringOwnershipTimes: {
                        startTime: 0n,
                        intervalLength: 0n,
                        chargePeriodLength: 0n,
                    },
                },
            },
            maxNumTransfers: {
                overallMaxNumTransfers: 0n,
                perToAddressMaxNumTransfers: 0n,
                perFromAddressMaxNumTransfers: 0n,
                perInitiatedByAddressMaxNumTransfers: 0n,
                amountTrackerId: id,
                resetTimeIntervals: {
                    startTime: 0n,
                    intervalLength: 0n,
                },
            },
            approvalAmounts: {
                overallApprovalAmount: 0n,
                perFromAddressApprovalAmount: 0n,
                perToAddressApprovalAmount: 0n,
                perInitiatedByAddressApprovalAmount: 0n,
                amountTrackerId: id,
                resetTimeIntervals: {
                    startTime: 0n,
                    intervalLength: 0n,
                },
            },
            merkleChallenges: [],
            mustOwnBadges: [],
            dynamicStoreChallenges: [],
            requireToEqualsInitiatedBy: false,
            requireFromEqualsInitiatedBy: false,
            overridesFromOutgoingApprovals: false,
            overridesToIncomingApprovals: true,
            userRoyalties: {
                percentage: 0n,
                payoutAddress: '',
            },
        },
    };

    return toSet;
};
```

## Related Concepts

-   [Cosmos Wrapper Paths](../../concepts/cosmos-wrapper-paths.md)
-   [Transferability / Approvals](../../concepts/transferability-approvals.md)
-   [Address Lists](../../concepts/address-lists.md)


## File: ./x-badges/examples/approvals/transferable-approval.md

# Transferable Approval

This example demonstrates how to create a basic transferable approval that allows badges to be freely transferred between any users after minting.

## Overview

A transferable approval enables badges to be moved between addresses without restrictions.

## Code Example

```typescript
const transferableApproval = new CollectionApproval({
    fromListId: '!Mint', // Excludes the Mint address
    toListId: 'All',
    initiatedByListId: 'All',
    transferTimes: UintRangeArray.FullRanges(),
    ownershipTimes: UintRangeArray.FullRanges(),
    badgeIds: UintRangeArray.FullRanges(),
    approvalId: 'transferable-approval',
    version: 0n,
    approvalCriteria: undefined, // No additional restrictions
});
```

## Usage in Collection

To use this approval in a collection, add it to the collection's approval timeline:

```typescript
const otherApprovals = [
    // ... other approvals
];

const collection = {
    ...BaseCollectionDetails,
    collectionApprovalTimeline: [
        {
            timelineTimes: FullTimeRanges,
            collectionApprovals: [...otherApprovals, transferableApproval],
        },
    ],
};
```

## Related Concepts

-   [Transferability / Approvals](../../concepts/transferability-approvals.md)
-   [Address Lists](../../concepts/address-lists.md)
-   [Timeline System](../../concepts/timeline-system.md)


## File: ./x-badges/examples/base-collection-details.md

# Base Collection Details

BitBadges collections are very expressive but also can lead to verbose configurations. We will provide additional examples in this section but also refer you to the corresponding concepts section for more details on any specific field.

### Reference Links

For detailed information about each field, see the corresponding concepts documentation:

| Field                         | Concepts Link                                               |
| ----------------------------- | ----------------------------------------------------------- |
| `validBadgeIds`               | [Valid Badge IDs](../concepts/valid-badge-ids.md)           |
| `balancesType`                | [Balances Type](../concepts/balances-type.md)               |
| `managerTimeline`             | [Manager](../concepts/manager.md)                           |
| `collectionMetadataTimeline`  | [Metadata](../concepts/metadata.md)                         |
| `badgeMetadataTimeline`       | [Metadata](../concepts/metadata.md)                         |
| `customDataTimeline`          | [Custom Data](../concepts/custom-data.md)                   |
| `standardsTimeline`           | [Standards](../concepts/standards.md)                       |
| `isArchivedTimeline`          | [Archived Collections](../concepts/archived-collections.md) |
| `defaultBalances`             | [Default Balances](../concepts/default-balances.md)         |
| `mintEscrowCoinsToTransfer`   | [Mint Escrow Address](../concepts/mint-escrow-address.md)   |
| `cosmosCoinWrapperPathsToAdd` | [Cosmos Wrapper Paths](../concepts/cosmos-wrapper-paths.md) |

| Timeline System (all fields) | [Timeline System](../concepts/timeline-system.md) |

## Base Collection Details

For most collections, your base configuration for these fields will be very similar to this.

```typescript
// Our standard time range represeting "forever"
const FullTimeRanges = [
    {
        start: '1',
        end: '18446744073709551615',
    },
];

const BaseCollectionDetails = {
    validBadgeIds: [
        {
            start: '1',
            end: '100', // Set to your max ID
        },
    ],
    // Off-chain are a legacy feature. You should use the following fields for standard on-chain collections.
    balancesType: 'Standard',
    offChainBalancesMetadataTimeline: [],

    managerTimeline: [
        {
            manager: 'bb1kj9kt5y64n5a8677fhjqnmcc24ht2vy9atmdls', // Set to your address
            timelineTimes: FullTimeRanges,
        },
    ],
    collectionMetadataTimeline: [
        {
            timelineTimes: FullTimeRanges,
            collectionMetadata: {
                uri: 'ipfs://QmSTZZPgYF58gS9bM7q3nWVegUJH51WBdT91fz7q94qDwS', // Points to a valid .json metadata file
                customData: '',
            },
        },
    ],
    badgeMetadataTimeline: [
        {
            timelineTimes: FullTimeRanges,
            badgeMetadata: [
                {
                    uri: 'ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/{id}', // Points to a valid .json metadata file (replacing {id} with the badge ID)
                    badgeIds: [
                        {
                            start: '1',
                            end: '100',
                        },
                    ],
                    customData: '',
                },
                // You can have multiple entries. This is useful for placeholder metadata.
                {
                    uri: 'ipfs://QmSTZZPgYF58gS9bM7q3nWVegUJH51WBdT91fz7q94qDwS', // Placeholder metadata
                    badgeIds: [
                        {
                            start: '101',
                            end: '100000000',
                        },
                    ],
                    customData: '',
                },
            ],
        },
    ],
    customDataTimeline: [
        {
            timelineTimes: FullTimeRanges,
            customData: '',
        },
    ],
    standardsTimeline: [
        {
            timelineTimes: FullTimeRanges,
            standards: ['Subscriptions'],
        },
    ],
    isArchivedTimeline: [
        {
            timelineTimes: FullTimeRanges,
            isArchived: false,
        },
    ],

    // Coins to send to the mint escrow address. You can also fund after the fact. This is just useful for genesis since the address is dependent on the collectionId which you don't know until after the collection is created.
    mintEscrowCoinsToTransfer: [
        {
            denom: 'ubadge',
            amount: '1',
        },
    ],

    // If you want to add paths to wrap badges as Cosmos coins, you can do so here.
    cosmosCoinWrapperPathsToAdd: [],

    defaultBalances: {
        // Everyone starts with empty balances and no approvals
        balances: [],
        incomingApprovals: [],
        outgoingApprovals: [],
        // Empty = Soft Enabled (i.e. enabled but can be disabled at any time by each user)
        userPermissions: {
            canUpdateOutgoingApprovals: [],
            canUpdateIncomingApprovals: [],
            canUpdateAutoApproveSelfInitiatedOutgoingTransfers: [],
            canUpdateAutoApproveSelfInitiatedIncomingTransfers: [],
            canUpdateAutoApproveAllIncomingTransfers: [],
        },

        // Typically, these flags are all you need to set.
        autoApproveSelfInitiatedIncomingTransfers: true,
        autoApproveSelfInitiatedOutgoingTransfers: true,
        autoApproveAllIncomingTransfers: true,
    },
};
```

For information on building collection approvals, see [Building Collection Approvals](./building-collection-approvals.md).


## File: ./x-badges/examples/building-collection-approvals.md

# Building Your Collection Approvals

The collection-level transferability is determined by the collection-level approvals. The important thing to consider here is that any approval that allows transfers from the "Mint" address will mint balances out of thin air.

## Approval Categories

It is typically recommended to split into two categories:

-   **Mint Approvals** (`fromListId: 'Mint'`)
-   **Post-Mint Approvals** (`fromListId: '!Mint'`)

## Important Notes

1. The reserved "All" list ID includes Mint. Do not use "All" for the fromListId for post-mint approvals.
2. To function, the "Mint" approval must forcefully override the user-level outgoing approval because it cannot be managed.

## Code Example

Mix and match the approvals as you see fit. See the examples in the [approvals](./approvals/) section for a bunch of examples.

```typescript
const mintApprovals = [
    // Mint approvals
];

const postMintApprovals = [transferableApproval, burnableApproval];

const collectionApprovals = [...mintApprovals, ...postMintApprovals];

const collectionApprovalTimeline = [
    {
        timelineTimes: FullTimeRanges,
        collectionApprovals,
    },
];
```

## Related Concepts

-   [Transferability / Approvals](../concepts/transferability-approvals.md)
-   [Address Lists](../concepts/address-lists.md)
-   [Timeline System](../concepts/timeline-system.md)
-   [Approval Examples](./approvals/)


## File: ./x-badges/examples/building-collection-permissions.md

# Building Your Collection Permissions

Collection permissions are executable by the manager. They are used to control who can perform various management actions on your badge collection and when those actions are allowed.

```typescript
const managerTimeline = [
    {
        manager: 'bb1youraddress...', // Your address
        timelineTimes: FullTimeRanges,
    },
];
```

## Setting Your Permissions

You have a few options for setting your permissions.

1. No Manager

If you simply don't want a manager, you can set the manager to an empty string. Then, the permission values never matter.

```typescript
const managerTimeline = [
    {
        manager: '',
        timelineTimes: FullTimeRanges,
    },
];
```

2. Complete Control - Soft Enabled

Each permission is enabled by default, unless you permanently disabled it. Thus, an empty array means that the permission is enabled for all times. However, it is soft enabled, meaning that the manager can disable it at any time. This configuration offers full control with ability to disable in the future.

```typescript
const collectionPermissions = {
    canDeleteCollection: [],
    canArchiveCollection: [],
    canUpdateOffChainBalancesMetadata: [],
    canUpdateStandards: [],
    canUpdateCustomData: [],
    canUpdateManager: [],
    canUpdateCollectionMetadata: [],
    canCreateMoreBadges: [],
    canUpdateBadgeMetadata: [],
    canUpdateCollectionApprovals: [],
    canUpdateValidBadgeIds: [],
};
```

3. Custom Permissions

Oftentimes, you want a little more control over your permissions though.

Each permission follows the same pattern:

1. For the times `permanentlyPermittedTimes`, the permission is always permitted for the given values.
2. For the times `permanentlyForbiddenTimes`, the permission is always forbidden for the given values.
3. If the item is not explicity in either, then the permission is enabled for the given values, but the status can change.

```typescript



```

---

Each permission type follows the same pattern of two categories:

```typescript
// Part 1. Enabled vs Disabled Times For The Execution Of The Permission
const permanentlyPermittedTimes = [];
const permanentlyForbiddenTimes = FullTimeRanges;

// Part 2. For what values (if any) does this apply? This is dependent on the permission type.
const {
    timelineTimes,
    badgeIds,
    fromListId,
    toListId,
    initiatedByListId,
    transferTimes,
    ownershipTimes,
    approvalId,
} = permission;
```

## Common Things To Consider

1.

## Examples

We refer you to the [examples](./permissions/) for more detailed examples.

## Related Concepts

-   [Permission System](../concepts/permissions/permission-system.md)
-   [Manager](../concepts/manager.md)
-   [Timeline System](../concepts/timeline-system.md)
-   [Timed Update Permission](../concepts/permissions/timed-update-permission.md)

```

```


## File: ./x-badges/examples/cosmos-coin-wrapper-example.md

# Cosmos Coin Wrapper Tutorial

This tutorial walks you through setting up cosmos coin wrappers to bridge BitBadges with the broader Cosmos ecosystem. Cosmos coin wrappers automatically convert badges to fungible Cosmos coins and vice versa.

## Prerequisites

-   Understanding of [Cosmos Wrapper Paths](../concepts/cosmos-wrapper-paths.md)
-   Basic knowledge of BitBadges collections and approvals

## Step 1: Set Up Your Cosmos Denominations

First, define your cosmos coin wrapper paths. For detailed information about available options, see [Cosmos Wrapper Paths](../concepts/cosmos-wrapper-paths.md).

```typescript
const cosmosCoinWrapperPaths = [ ... ];
```

## Step 2: Generate Your Special Address

When you create a collection with cosmos coin wrapper paths, the system automatically generates a special address for each wrapper. This address acts as the bridge between badges and cosmos coins. This will also be available on the BitBadges site if you want to go that route.

```typescript
import { generateAliasAddressForDenom } from 'bitbadgesjs-sdk';

const denom = 'utoken1';
const wrapperAddress = generateAliasAddressForDenom(denom);
console.log('Wrapper Address:', wrapperAddress);
```

## Step 3: Set Up Approvals for Wrapping/Unwrapping

The transfers still operate under the approval / transferability system. We will use the following examples from our examples section, but you can customize as you see fit. Note the need to override the wrapper address's approvals where necessary because the wrapper address is uncontrollable.

-   [Cosmos Wrapper Approval](./approvals/cosmos-wrapper-approval.md)
-   [Cosmos Unwrapper Approval](./approvals/cosmos-unwrapper-approval.md)

```typescript
const collection = {
    ...BaseCollectionDetails,
    collectionApprovalTimeline: [
        {
            timelineTimes: FullTimeRanges,
            collectionApprovals: [
                ...otherApprovals,
                wrapperApproval,
                unwrapperApproval,
            ],
        },
    ],
};
```

## Related Concepts

-   [Cosmos Wrapper Paths](../concepts/cosmos-wrapper-paths.md)
-   [Approval System](../concepts/approval-criteria/approval-system.md)
-   [Badge Collections](../concepts/badge-collections.md)


## File: ./x-badges/examples/mint-all-to-self-tutorial.md

# Mint All Badges to Self - Tutorial

This tutorial walks through the process of creating a collection and minting all badges to yourself in a single transaction. This is useful for creating collections where you want to control the initial distribution.

## Overview

This is a two-step process that can be executed as a single multi-message transaction:

1. **Create Collection** with a mint approval that allows you to mint badges
2. **Execute Transfer** using that approval to mint badges to yourself

## Step 1: Create Mint Approval

First, create an approval that allows you to mint badges from the "Mint" address:

```typescript
// Step 1: Set up your mint approval
const mintApproval = {
    fromListId: 'Mint', // From the mint address
    toListId: 'All', // To any address
    initiatedByListId: myAddress, // Only you can initiate
    transferTimes: UintRangeArray.FullRanges(),
    badgeIds: UintRangeArray.FullRanges(), // All badge IDs
    ownershipTimes: UintRangeArray.FullRanges(),
    approvalId: 'mint-approval',
    version: 0n,
    approvalCriteria: {
        // No restrictions - you can mint unlimited amounts
        ...defaultNoRestrictionsApprovalCriteria,
        overridesFromOutgoingApprovals: true, // Required for mint address
    },
};

// Step 1: Create your collection with the mint approval
const collection = {
    ...BaseCollectionDetails,
    collectionApprovalTimeline: [
        {
            timelineTimes: FullTimeRanges,
            collectionApprovals: [mintApproval, ...otherApprovals],
        },
    ],
};

// Create the collection
```

## Step 2: Execute Mint Transfer

After creating the collection, use the mint approval to transfer badges to yourself:

```typescript
// Step 2: Mint badges to yourself using the approval
const transfers = [
    {
        from: 'Mint', // From mint address
        toAddresses: [myAddress], // To your address
        balances: [
            {
                badgeIds: [{ start: 1n, end: 100n }],
                ownershipTimes: UintRangeArray.FullRanges(),
                amount: 100n,
            },
        ],
        // ... other transfer details
    },
];
```

## Related Concepts

-   [Building Collection Approvals](./building-collection-approvals.md)
-   [Admin Override Approval](./approvals/admin-override-approval.md)
-   [Mint Escrow Address](../concepts/mint-escrow-address.md)
-   [MsgTransferBadges](../messages/msg-transfer-badges.md)


## File: ./x-badges/examples/permissions/README.md

# Permission Examples

This directory contains practical examples of different permission configurations for badge collections. Each example demonstrates specific patterns and use cases for controlling collection management.

## Contents

- `locked-collection.md` - Collection with permanently locked permissions
- `temporary-permissions.md` - Time-limited management permissions
- `badge-specific-permissions.md` - Permissions that apply to specific badge IDs
- `community-controlled.md` - Permissions for community-managed collections

## Permission System Overview

BitBadges permissions follow a timeline-based system where:

1. **Permanently Permitted Times** - Permission is always allowed
2. **Permanently Forbidden Times** - Permission is always denied  
3. **Default (Empty)** - Permission is soft-enabled (manager can change)

## Common Patterns

- **No Manager** - Set manager to empty string to disable all management
- **Complete Control** - Empty permission arrays for full soft-enabled control
- **Locked Forever** - Use `permanentlyForbiddenTimes: FullTimeRanges`
- **Time-Limited** - Use specific time ranges for temporary control

## Related Concepts

- [Permission System](../../concepts/permissions/permission-system.md)
- [Manager](../../concepts/manager.md)
- [Timeline System](../../concepts/timeline-system.md)

## File: ./x-badges/messages/README.md

# Messages

This directory contains detailed documentation for all message types supported by the badges module.

## Message Categories

### Collection Management

-   [MsgCreateCollection](./msg-create-collection.md) - Create new badge collection
-   [MsgUpdateCollection](./msg-update-collection.md) - Update existing collection properties
-   [MsgDeleteCollection](./msg-delete-collection.md) - Archive/delete collection

### Badge Transfers

-   [MsgTransferBadges](./msg-transfer-badges.md) - Transfer badges between addresses with approval validation

### User Approval Management

-   [MsgUpdateUserApprovals](./msg-update-user-approvals.md) - Update user transfer approval settings

### Address List Management

-   [MsgCreateAddressLists](./msg-create-address-lists.md) - Create reusable address lists for access control

### Dynamic Store Management

-   [MsgCreateDynamicStore](./msg-create-dynamic-store.md) - Create boolean flag stores for approval criteria
-   [MsgUpdateDynamicStore](./msg-update-dynamic-store.md) - Update dynamic store configuration
-   [MsgDeleteDynamicStore](./msg-delete-dynamic-store.md) - Delete dynamic store
-   [MsgSetDynamicStoreValue](./msg-set-dynamic-store-value.md) - Set individual address values in dynamic store

### System Administration

-   [MsgUpdateParams](./msg-update-params.md) - Update module parameters via governance

## Additional Message Types

The following message types exist in the protocol but may be documented separately:

-   **MsgUniversalUpdateCollection** - Legacy unified create/update interface


## File: ./x-badges/messages/msg-create-address-lists.md

# MsgCreateAddressLists

Creates reusable address lists by ID for gas optimizations.

## Important Notes

1. **Create Only**: There are no update, edit, or delete functions for address lists. Once created, they are immutable.

2. **Optional Efficiency Tool**: This is completely optional and serves as a reusable shorthand ID to avoid repetition of long reserved address list IDs. The primary purpose is gas efficiency.

3. **Minimal Metadata**: Typically, `uri` and `customData` are left blank as these fields are not supported on the BitBadges site and are different from off-chain lists you may see elsewhere.

## Proto Definition

```protobuf
message MsgCreateAddressLists {
  string creator = 1; // Address creating the address lists
  repeated AddressList addressLists = 2; // Lists to create in single transaction
}

message MsgCreateAddressListsResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges create-address-lists '[tx-json]' --from creator-key
```

### JSON Example

```json
{
    "creator": "bb1...",
    "addressLists": [
        {
            "listId": "",
            "addresses": ["bb1...", "bb1..."],
            "whitelist": true,
            "createdBy": "", // Leave blank - auto-generated
            "aliasAddress": "", // Leave blank - auto-generated
            "uri": "",
            "customData": ""
        }
    ]
}
```


## File: ./x-badges/messages/msg-create-collection.md

# MsgCreateCollection

Creates a new badge collection.

The collectionId will be assigned at execution time and is obtainable in the transaction response. Subsequent updates to the collection will be through MsgUpdateCollection.

## Creation Only Properties

The creation or genesis transaction for a collection is unique in a couple ways.

There are no permissions previously set, so there are no restrictions for what can be set vs not. Subsequent updates to the collection must follow any previously set permissions.

This is the only time that you can specify `balancesType` and the `defaultBalances` information.

## Proto Definition

```protobuf
message MsgCreateCollection {
  string creator = 1; // Address creating the collection
  string balancesType = 2; // "Standard", "Off-Chain - Indexed", etc.
  UserBalanceStore defaultBalances = 4;
  repeated UintRange validBadgeIds = 5; // Badge ID ranges to include
  CollectionPermissions collectionPermissions = 6;
  repeated ManagerTimeline managerTimeline = 7;
  repeated CollectionMetadataTimeline collectionMetadataTimeline = 8;
  repeated BadgeMetadataTimeline badgeMetadataTimeline = 9;
  repeated OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 10;
  repeated CustomDataTimeline customDataTimeline = 11;
  repeated CollectionApproval collectionApprovals = 12;
  repeated StandardsTimeline standardsTimeline = 13;
  repeated IsArchivedTimeline isArchivedTimeline = 14;
  repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 16;
  repeated CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 17;
}

message MsgCreateCollectionResponse {
  string collectionId = 1; // ID of the created collection
}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges create-collection '[tx-json]' --from creator-key
```

### JSON Example
```json
{
  "creator": "bb1abc123...",
  "balancesType": "Standard",
  "defaultBalances": {
    "balances": [],
    "outgoingApprovals": [],
    "incomingApprovals": [],
    "autoApproveSelfInitiatedOutgoingTransfers": false,
    "autoApproveSelfInitiatedIncomingTransfers": true,
    "autoApproveAllIncomingTransfers": false,
    "userPermissions": {
      "canUpdateOutgoingApprovals": [],
      "canUpdateIncomingApprovals": [],
      "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [],
      "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [],
      "canUpdateAutoApproveAllIncomingTransfers": []
    }
  },
  "validBadgeIds": [{"start": "1", "end": "100"}],
  "collectionPermissions": {
    "canDeleteCollection": [],
    "canArchiveCollection": [],
    "canUpdateOffChainBalancesMetadata": [],
    "canUpdateStandards": [],
    "canUpdateCustomData": [],
    "canUpdateManager": [],
    "canUpdateCollectionMetadata": [],
    "canUpdateValidBadgeIds": [],
    "canUpdateBadgeMetadata": [],
    "canUpdateCollectionApprovals": []
  },
  "managerTimeline": [],
  "collectionMetadataTimeline": [],
  "badgeMetadataTimeline": [],
  "offChainBalancesMetadataTimeline": [],
  "customDataTimeline": [],
  "collectionApprovals": [],
  "standardsTimeline": [],
  "isArchivedTimeline": [],
  "mintEscrowCoinsToTransfer": [],
  "cosmosCoinWrapperPathsToAdd": []
}
```

## File: ./x-badges/messages/msg-create-dynamic-store.md

# MsgCreateDynamicStore

Creates a new dynamic store for boolean key-value storage.

## Proto Definition

```protobuf
message MsgCreateDynamicStore {
  string creator = 1; // Address creating the dynamic store
  bool defaultValue = 2; // Default value for uninitialized addresses
}

message MsgCreateDynamicStoreResponse {
  string storeId = 1; // ID of the created dynamic store
}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges create-dynamic-store [default-value] --from creator-key
```

### JSON Example
```json
{
  "creator": "bb1...",
  "defaultValue": false
}
```

## File: ./x-badges/messages/msg-delete-collection.md

# MsgDeleteCollection

Deletes a badge collection.

## Authorization

Collection deletion can only be performed by the **current manager** of the collection and requires the `canDeleteCollection` permission to be enabled at the current time in the collection's permissions.

## Proto Definition

```protobuf
message MsgDeleteCollection {
  string creator = 1; // Address requesting deletion (must be manager)
  string collectionId = 2; // ID of collection to delete
}

message MsgDeleteCollectionResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges delete-collection [collection-id] --from manager-key
```

### JSON Example

```json
{
    "creator": "bb1...",
    "collectionId": "1"
}
```


## File: ./x-badges/messages/msg-delete-dynamic-store.md

# MsgDeleteDynamicStore

Deletes a dynamic store.

## Proto Definition

```protobuf
message MsgDeleteDynamicStore {
  string creator = 1; // Address deleting the store (must be creator)
  string storeId = 2; // ID of dynamic store to delete
}

message MsgDeleteDynamicStoreResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges delete-dynamic-store [store-id] --from creator-key
```

### JSON Example

```json
{
    "creator": "bb1...",
    "storeId": "1"
}
```


## File: ./x-badges/messages/msg-set-dynamic-store-value.md

# MsgSetDynamicStoreValue

Sets a boolean value for a specific address in a dynamic store.

## Proto Definition

```protobuf
message MsgSetDynamicStoreValue {
  string creator = 1; // Address setting the value (must be store creator)
  string storeId = 2; // ID of the dynamic store
  string address = 3; // Address to set the value for
  bool value = 4; // Boolean value to set (true/false)
}

message MsgSetDynamicStoreValueResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges set-dynamic-store-value [store-id] [address] [value] --from creator-key
```

### JSON Example
```json
{
  "creator": "bb1...",
  "storeId": "1",
  "address": "bb1...",
  "value": true
}
```

## File: ./x-badges/messages/msg-transfer-badges.md

# MsgTransferBadges

Executes badge transfers between addresses.

## Collection ID Auto-Lookup

If you specify `collectionId` as `"0"`, it will automatically lookup the latest collection ID created. This can be used if you are creating a collection and do not know the official collection ID yet but want to perform a multi-message transaction.

## Proto Definition

```protobuf
message MsgTransferBadges {
  string creator = 1; // Address initiating the transfer
  string collectionId = 2; // Collection containing badges to transfer
  repeated Transfer transfers = 3; // Transfer operations (must pass approvals)
}

message MsgTransferBadgesResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges transfer-badges '[tx-json]' --from sender-key
```

### JSON Example
```json
{
  "creator": "bb1initiator123...",
  "collectionId": "1",
  "transfers": [
    {
      "from": "bb1sender123...",
      "toAddresses": ["bb1recipient123..."],
      "balances": [
        {
          "amount": "10",
          "ownershipTimes": [{"start": "1", "end": "18446744073709551615"}],
          "badgeIds": [{"start": "1", "end": "5"}]
        }
      ],
      "precalculateBalancesFromApproval": {
        "approvalId": "",
        "approvalLevel": "",
        "approverAddress": "",
        "version": "0"
      },
      "merkleProofs": [],
      "memo": "",
      "prioritizedApprovals": [],
      "onlyCheckPrioritizedCollectionApprovals": false,
      "onlyCheckPrioritizedIncomingApprovals": false,
      "onlyCheckPrioritizedOutgoingApprovals": false,
      "precalculationOptions": {
        "overrideTimestamp": "0",
        "badgeIdsOverride": []
      },
      "affiliateAddress": "",
      "numAttempts": "1"
    }
  ]
}
```

## File: ./x-badges/messages/msg-update-collection.md

# MsgUpdateCollection

Updates an existing badge collection's properties.

## Update Flag Pattern

This message uses an update flag + value pattern for selective updates. Each updatable field has a corresponding boolean flag (e.g., `updateValidBadgeIds`, `updateCollectionPermissions`). 

- **If update flag is `true`**: The corresponding value field is processed and the collection is updated with the new value
- **If update flag is `false`**: The corresponding value field is completely ignored, regardless of what data is provided

This allows you to update only specific fields without affecting others, and you can safely leave unused value fields empty or with placeholder data.

## Authorization & Permissions

Updates can only be performed by the **current manager** of the collection. All updates must obey the previously set permissions - meaning the permission settings that were in effect *before* this message was started.

**Important**: If you update the permissions in the current message, those new permissions are applied last and will not be applicable until the following transaction. This prevents circumventing permission restrictions within the same transaction.

## Proto Definition

```protobuf
message MsgUpdateCollection {
  string creator = 1; // Address updating collection (must be manager)
  string collectionId = 2; // ID of collection to update
  bool updateValidBadgeIds = 3;
  repeated UintRange validBadgeIds = 4;
  bool updateCollectionPermissions = 7;
  CollectionPermissions collectionPermissions = 8;
  bool updateManagerTimeline = 9;
  repeated ManagerTimeline managerTimeline = 10;
  bool updateCollectionMetadataTimeline = 11;
  repeated CollectionMetadataTimeline collectionMetadataTimeline = 12;
  bool updateBadgeMetadataTimeline = 13;
  repeated BadgeMetadataTimeline badgeMetadataTimeline = 14;
  bool updateOffChainBalancesMetadataTimeline = 15;
  repeated OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 16;
  bool updateCustomDataTimeline = 17;
  repeated CustomDataTimeline customDataTimeline = 18;
  bool updateCollectionApprovals = 21;
  repeated CollectionApproval collectionApprovals = 22;
  bool updateStandardsTimeline = 23;
  repeated StandardsTimeline standardsTimeline = 24;
  bool updateIsArchivedTimeline = 27;
  repeated IsArchivedTimeline isArchivedTimeline = 28;
  repeated cosmos.base.v1beta1.Coin mintEscrowCoinsToTransfer = 29;
  repeated CosmosCoinWrapperPathAddObject cosmosCoinWrapperPathsToAdd = 30;
}

message MsgUpdateCollectionResponse {
  string collectionId = 1; // ID of updated collection
}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges update-collection '[tx-json]' --from manager-key
```

### JSON Example
```json
{
  "creator": "bb1abc123...",
  "collectionId": "1",
  "updateValidBadgeIds": true,
  "validBadgeIds": [{"start": "1", "end": "200"}],
  "updateCollectionPermissions": false,
  "collectionPermissions": {
    "canDeleteCollection": [],
    "canArchiveCollection": [],
    "canUpdateOffChainBalancesMetadata": [],
    "canUpdateStandards": [],
    "canUpdateCustomData": [],
    "canUpdateManager": [],
    "canUpdateCollectionMetadata": [],
    "canUpdateValidBadgeIds": [],
    "canUpdateBadgeMetadata": [],
    "canUpdateCollectionApprovals": []
  },
  "updateManagerTimeline": false,
  "managerTimeline": [],
  "updateCollectionMetadataTimeline": false,
  "collectionMetadataTimeline": [],
  "updateBadgeMetadataTimeline": false,
  "badgeMetadataTimeline": [],
  "updateOffChainBalancesMetadataTimeline": false,
  "offChainBalancesMetadataTimeline": [],
  "updateCustomDataTimeline": false,
  "customDataTimeline": [],
  "updateCollectionApprovals": false,
  "collectionApprovals": [],
  "updateStandardsTimeline": false,
  "standardsTimeline": [],
  "updateIsArchivedTimeline": false,
  "isArchivedTimeline": [],
  "mintEscrowCoinsToTransfer": [],
  "cosmosCoinWrapperPathsToAdd": []
}
```

## File: ./x-badges/messages/msg-update-dynamic-store.md

# MsgUpdateDynamicStore

Updates an existing dynamic store's default value.

## Proto Definition

```protobuf
message MsgUpdateDynamicStore {
  string creator = 1; // Address updating the store (must be creator)
  string storeId = 2; // ID of dynamic store to update
  bool defaultValue = 3; // New default value for uninitialized addresses
}

message MsgUpdateDynamicStoreResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges update-dynamic-store [store-id] [default-value] --from creator-key
```

### JSON Example

```json
{
    "creator": "bb1...",
    "storeId": "1",
    "defaultValue": true
}
```


## File: ./x-badges/messages/msg-update-user-approvals.md

# MsgUpdateUserApprovals

Updates a user's approval settings for badge transfers.

## Collection ID Auto-Lookup

If you specify `collectionId` as `"0"`, it will automatically lookup the latest collection ID created. This can be used if you are creating a collection and do not know the official collection ID yet but want to perform a multi-message transaction.

## Update Flag Pattern

This message uses an update flag + value pattern for selective updates. Each updatable field has a corresponding boolean flag (e.g., `updateOutgoingApprovals`, `updateIncomingApprovals`, `updateAutoApproveSelfInitiatedOutgoingTransfers`).

- **If update flag is `true`**: The corresponding value field is processed and the user's settings are updated with the new value
- **If update flag is `false`**: The corresponding value field is completely ignored, regardless of what data is provided

This allows you to update only specific approval settings without affecting others, and you can safely leave unused value fields empty or with placeholder data.

## Authorization & Permissions

Users can only update their own approvals. Updates must be performed according to the permissions set (i.e. the `userPermissions` previously set for that user).

**Note**: Typically, user permissions are almost always permanently allowed/set to enabled. These permissions only need to be customized in advanced cases where fine-grained control over user approval updates is required.

## Proto Definition

```protobuf
message MsgUpdateUserApprovals {
  string creator = 1; // User updating their approval settings
  string collectionId = 2; // Target collection for approval updates
  bool updateOutgoingApprovals = 3;
  repeated UserOutgoingApproval outgoingApprovals = 4;
  bool updateIncomingApprovals = 5;
  repeated UserIncomingApproval incomingApprovals = 6;
  bool updateAutoApproveSelfInitiatedOutgoingTransfers = 7;
  bool autoApproveSelfInitiatedOutgoingTransfers = 8;
  bool updateAutoApproveSelfInitiatedIncomingTransfers = 9;
  bool autoApproveSelfInitiatedIncomingTransfers = 10;
  bool updateAutoApproveAllIncomingTransfers = 11;
  bool autoApproveAllIncomingTransfers = 12;
  bool updateUserPermissions = 13;
  UserPermissions userPermissions = 14;
}

message MsgUpdateUserApprovalsResponse {}
```

## Usage Example

```bash
# CLI command
bitbadgeschaind tx badges update-user-approved-transfers '[tx-json]' --from user-key
```

### JSON Example
```json
{
  "creator": "bb1user123...",
  "collectionId": "1",
  "updateOutgoingApprovals": false,
  "outgoingApprovals": [],
  "updateIncomingApprovals": false,
  "incomingApprovals": [],
  "updateAutoApproveSelfInitiatedOutgoingTransfers": true,
  "autoApproveSelfInitiatedOutgoingTransfers": true,
  "updateAutoApproveSelfInitiatedIncomingTransfers": false,
  "autoApproveSelfInitiatedIncomingTransfers": true,
  "updateAutoApproveAllIncomingTransfers": false,
  "autoApproveAllIncomingTransfers": false,
  "updateUserPermissions": false,
  "userPermissions": {
    "canUpdateOutgoingApprovals": [],
    "canUpdateIncomingApprovals": [],
    "canUpdateAutoApproveSelfInitiatedOutgoingTransfers": [],
    "canUpdateAutoApproveSelfInitiatedIncomingTransfers": [],
    "canUpdateAutoApproveAllIncomingTransfers": []
  }
}
```

## File: ./x-badges/queries/README.md

# Queries

This directory contains detailed documentation for all query types supported by the badges module.

## Query Categories

### Collection Queries

-   [GetCollection](./get-collection.md) - Retrieve collection data and properties

### Balance Queries

-   [GetBalance](./get-balance.md) - Get user badge balances for a collection

### Address List Queries

-   [GetAddressList](./get-address-list.md) - Retrieve address list information

### Approval Tracking Queries

-   [GetApprovalTracker](./get-approval-tracker.md) - Get approval usage tracking data and limits
-   [GetChallengeTracker](./get-challenge-tracker.md) - Get challenge completion tracking status

### Dynamic Store Queries

-   [GetDynamicStore](./get-dynamic-store.md) - Get dynamic store configuration and metadata
-   [GetDynamicStoreValue](./get-dynamic-store-value.md) - Get boolean value for specific address in store

### System Queries

-   [Params](./params.md) - Get current module parameters and configuration


## File: ./x-badges/queries/get-address-list.md

# GetAddressList

Retrieves information about a specific address list.

## Proto Definition

```protobuf
message QueryGetAddressListRequest {
  string listId = 1; // ID of address list to retrieve
}

message QueryGetAddressListResponse {
  AddressList list = 1;
}

message AddressList {
  string listId = 1; // Unique identifier for the address list
  repeated string addresses = 2; // List of addresses included in the list
  bool whitelist = 3; // Whether list includes (true) or excludes (false) specified addresses
  string uri = 4; // URI providing metadata, if applicable
  string customData = 5; // Custom arbitrary data or additional information
  string createdBy = 6; // The user or entity who created the address list
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-address-list [id]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_address_list/1"
```

### Response Example

```json
{
    "list": {
        "listId": "1",
        "addresses": ["bb1...", "bb1..."],
        "whitelist": true,
        "uri": "",
        "customData": "",
        "createdBy": "bb1..."
    }
}
```


## File: ./x-badges/queries/get-approval-tracker.md

# GetApprovalTracker

Retrieves tracking information for approval usage.

## Proto Definition

```protobuf
message QueryGetApprovalTrackerRequest {
  string amountTrackerId = 1; 
  string approvalLevel = 2; // "collection", "incoming", or "outgoing"
  string approverAddress = 3; // Leave blank if approvalLevel is "collection"
  string trackerType = 4; // "overall", "to", "from", "initiatedBy"
  string collectionId = 5;
  string approvedAddress = 6; // Leave blank if trackerType is "overall"
  string approvalId = 7;
}

message QueryGetApprovalTrackerResponse {
  ApprovalTracker tracker = 1;
}

message ApprovalTracker {
  string numTransfers = 1; // Number of transfers that have been processed
  repeated Balance amounts = 2; // Cumulative balances associated with processed transfers
  string lastUpdatedAt = 3; // Last updated at time (UNIX millisecond timestamp)
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-approval-tracker [collectionId] [approvalLevel] [approverAddress] [approvalId] [amountTrackerId] [trackerType] [approvedAddress]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_approvals_tracker/1/outgoing/bb1.../approval-1/tracker-1/overall/"
```

### Response Example
```json
{
  "tracker": {
    "numTransfers": "5",
    "amounts": [
      {
        "amount": "100",
        "badgeIds": [{"start": "1", "end": "10"}],
        "ownershipTimes": [{"start": "1672531200000", "end": "18446744073709551615"}]
      }
    ],
    "lastUpdatedAt": "1672531200000"
  }
}
```

## File: ./x-badges/queries/get-balance.md

# GetBalance

Retrieves badge balances for a specific address in a collection.

## Proto Definition

```protobuf
message QueryGetBalanceRequest {
  string collectionId = 1; // Collection ID to query
  string address = 2; // Address to get balances for
}

message QueryGetBalanceResponse {
  UserBalanceStore balance = 1;
}

message UserBalanceStore {
  repeated Balance balances = 1; // List of balances associated with this user
  repeated UserOutgoingApproval outgoingApprovals = 2; // Approved outgoing transfers
  repeated UserIncomingApproval incomingApprovals = 3; // Approved incoming transfers
  bool autoApproveSelfInitiatedOutgoingTransfers = 4; // Auto-approve self-initiated outgoing transfers
  bool autoApproveSelfInitiatedIncomingTransfers = 5; // Auto-approve self-initiated incoming transfers
  bool autoApproveAllIncomingTransfers = 6; // Auto-approve all incoming transfers
  UserPermissions userPermissions = 7; // Permissions for this user's actions
}

// See all the proto definitions [here](https://github.com/BitBadges/bitbadgeschain/tree/master/proto/badges)
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-balance [collection-id] [address]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_balance/1/bb1..."
```

### Response Example

```json
{
    "balance": {
        "balances": [
            {
                "amount": "1",
                "badgeIds": [{ "start": "1", "end": "1" }],
                "ownershipTimes": [
                    { "start": "1672531200000", "end": "18446744073709551615" }
                ]
            }
        ],
        "outgoingApprovals": [
            // ...
        ],
        "incomingApprovals": [
            // ...
        ],
        "autoApproveSelfInitiatedOutgoingTransfers": true,
        "autoApproveSelfInitiatedIncomingTransfers": true,
        "autoApproveAllIncomingTransfers": true,
        "userPermissions": {
            // ...
        }
    }
}
```


## File: ./x-badges/queries/get-challenge-tracker.md

# GetChallengeTracker

Retrieves the number of times a given leaf has been used for a specific challenge tracker.

## Proto Definition

```protobuf
message QueryGetChallengeTrackerRequest {
  string collectionId = 1;
  string approvalLevel = 2; // "collection", "incoming", or "outgoing"
  string approverAddress = 3; // Leave blank if approvalLevel is "collection"
  string challengeTrackerId = 4;
  string leafIndex = 5;
  string approvalId = 6;
}

message QueryGetChallengeTrackerResponse {
  string numUsed = 1; // Number of times this leaf has been used
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-challenge-tracker [collectionId] [approvalLevel] [approverAddress] [approvalId] [challengeTrackerId] [leafIndex]

# REST API
# Note for blank values, use "" so you may have // in the query
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_challenge_tracker/1/collection//approval-123/challenge-1/42"
```

### Response Example

```json
{
    "numUsed": "1"
}
```


## File: ./x-badges/queries/get-collection.md

# GetCollection

Retrieves complete information about a badge collection.

## Proto Definition

```protobuf
message QueryGetCollectionRequest {
  string collectionId = 1; // ID of collection to retrieve
}

message QueryGetCollectionResponse {
  BadgeCollection collection = 1;
}

message BadgeCollection {
  string collectionId = 1; // Unique identifier for this collection
  repeated CollectionMetadataTimeline collectionMetadataTimeline = 2; // Collection metadata over time
  repeated BadgeMetadataTimeline badgeMetadataTimeline = 3; // Badge metadata over time
  string balancesType = 4; // Type of balances ("Standard", "Off-Chain - Indexed", etc.)
  repeated OffChainBalancesMetadataTimeline offChainBalancesMetadataTimeline = 5; // Off-chain balance metadata
  repeated CustomDataTimeline customDataTimeline = 7; // Arbitrary custom data over time
  repeated ManagerTimeline managerTimeline = 8; // Manager address over time
  CollectionPermissions collectionPermissions = 9; // Collection permissions
  repeated CollectionApproval collectionApprovals = 10; // Collection-level approvals
  repeated StandardsTimeline standardsTimeline = 11; // Standards over time
  repeated IsArchivedTimeline isArchivedTimeline = 12; // Archive status over time
  UserBalanceStore defaultBalances = 13; // Default balance store for users
  string createdBy = 14; // Creator of the collection
  repeated UintRange validBadgeIds = 15; // Valid badge ID ranges
  string mintEscrowAddress = 16; // Generated escrow address for the collection
}

// See all the proto definitions [here](https://github.com/bitbadges/bitbadgeschain/tree/master/proto/badges)
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-collection [id]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_collection/1"
```

### Response Example

```json
{
    "collection": {
        "collectionId": "1"
        // ...
    }
}
```


## File: ./x-badges/queries/get-dynamic-store-value.md

# GetDynamicStoreValue

Retrieves the boolean value for a specific address in a dynamic store.

## Proto Definition

```protobuf
message QueryGetDynamicStoreValueRequest {
  string storeId = 1; // ID of dynamic store to query
  string address = 2; // Address to get value for
}

message QueryGetDynamicStoreValueResponse {
  DynamicStoreValue value = 1;
}

message DynamicStoreValue {
  string storeId = 1; // The dynamic store ID
  string address = 2; // The address this value applies to
  bool value = 3; // The boolean value (true/false)
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-dynamic-store-value [store-id] [address]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_dynamic_store_value/1/bb1..."
```

### Response Example

```json
{
    "value": {
        "storeId": "1",
        "address": "bb1...",
        "value": true
    }
}
```


## File: ./x-badges/queries/get-dynamic-store.md

# GetDynamicStore

Retrieves information about a dynamic store.

## Proto Definition

```protobuf
message QueryGetDynamicStoreRequest {
  string storeId = 1;
}

message QueryGetDynamicStoreResponse {
  DynamicStore store = 1;
}

message DynamicStore {
  // The unique identifier for this dynamic store. This is assigned by the blockchain.
  string storeId = 1 [(gogoproto.customtype) = "Uint", (gogoproto.nullable) = false];
  // The address of the creator of this dynamic store.
  string createdBy = 2;
  // The default value for uninitialized addresses.
  bool defaultValue = 3;
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges get-dynamic-store [store-id]

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/get_dynamic_store/1"
```

### Response Example

```json
{
    "store": {
        "storeId": "1",
        "createdBy": "bb1...",
        "defaultValue": false
    }
}
```


## File: ./x-badges/queries/params.md

# Params

Retrieves the current module parameters.

## Proto Definition

```protobuf
message QueryParamsRequest {}

message QueryParamsResponse {
  Params params = 1;
}

message Params {
  // Array of allowed denominations for fee payments and escrow operations
  repeated string allowed_denoms = 1;
}
```

## Usage Example

```bash
# CLI query
bitbadgeschaind query badges params

# REST API
curl "https://lcd.bitbadges.io/bitbadges/bitbadgeschain/badges/params"
```

### Response Example
```json
{
  "params": {
    "allowedDenoms": ["ubadge", "ibc/1234567890"]
  }
}
```


## File: ./x-badges/state.md

# State

This document describes how the badges module manages state storage, including key structures and data organization.

## Table of Contents

-   [State Store Overview](#state-store-overview)
-   [Key Generation](#key-generation)
-   [Data Structures](#data-structures)

## State Store Overview

The badges module uses the Cosmos SDK's KVStore with a prefix-based key structure to organize different types of data efficiently. All data is stored in a single store with logical separation through key prefixes.

### Store Architecture

```
KVStore (badges)
├── Collections [0x01]
├── User Balances [0x02]
├── Next Collection ID [0x03]
├── Challenge Trackers [0x04]
├── Address Lists [0x06]
├── Approval Trackers [0x07]
├── Next Address List ID [0x0A]
├── Dynamic Stores [0x0D]
├── Next Dynamic Store ID [0x0E]
└── Dynamic Store Values [0x0F]
```

## Key Generation

The badges module uses deterministic key generation with prefixes and delimiters to ensure unique storage keys.

### Key Prefixes

```go
var (
    CollectionKey           = []byte{0x01}
    UserBalanceKey          = []byte{0x02}
    NextCollectionIdKey     = []byte{0x03}
    UsedClaimChallengeKey   = []byte{0x04}
    AddressListKey          = []byte{0x06}
    ApprovalTrackerKey      = []byte{0x07}
    NextAddressListIdKey    = []byte{0x0A}
    DynamicStoreKey         = []byte{0x0D}
    NextDynamicStoreIdKey   = []byte{0x0E}
    DynamicStoreValueKey    = []byte{0x0F}

    BalanceKeyDelimiter = "-"
)
```

## Data Structures

### Collections

-   **Key**: `0x01 + collectionId`
-   **Value**: `BadgeCollection` protobuf message
-   **Description**: Complete collection metadata, permissions, and configuration

### User Balances

-   **Key**: `0x02 + collectionId + "-" + address`
-   **Value**: `UserBalanceStore` protobuf message
-   **Description**: User's badge balances and approval settings for a collection

### Address Lists

-   **Key**: `0x06 + listId`
-   **Value**: `AddressList` protobuf message
-   **Description**: Reusable address lists for access control and approvals

### Approval Trackers

-   **Key**: `0x07 + collectionId + "-" + addressForApproval + "-" + approvalId + "-" + amountTrackerId + "-" + level + "-" + trackerType + "-" + address`
-   **Value**: `ApprovalTracker` protobuf message
-   **Description**: Tracks usage of approvals for transfer limits and restrictions

### Challenge Trackers

-   **Key**: `0x04 + collectionId + "-" + addressForChallenge + "-" + approvalLevel + "-" + approvalId + "-" + challengeId + "-" + leafIndex`
-   **Value**: Usage count (uint64)
-   **Description**: Tracks merkle proof leaf usage to prevent replay attacks

### Dynamic Stores

-   **Key**: `0x0D + storeId`
-   **Value**: `DynamicStore` protobuf message
-   **Description**: Dynamic store configuration and metadata

### Dynamic Store Values

-   **Key**: `0x0F + storeId + address`
-   **Value**: Boolean value
-   **Description**: Address-specific boolean values within dynamic stores

### Counter Keys

-   **Next Collection ID**: `0x03` → Current collection counter
-   **Next Address List ID**: `0x0A` → Current address list counter
-   **Next Dynamic Store ID**: `0x0E` → Current dynamic store counter


## File: ./.github/workflows/for--llms.yml

```
name: Generate LLM Training Text

on:
    push:
        branches: [main, master]
    workflow_dispatch: # Allows manual triggering

jobs:
    generate-llm-text:
        runs-on: ubuntu-latest
        permissions:
            contents: write
        steps:
            - name: Checkout repository
              uses: actions/checkout@v3

            - name: Set up Python
              uses: actions/setup-python@v4
              with:
                  python-version: '3.10'

            - name: Install dependencies
              run: |
                  python -m pip install --upgrade pip

            - name: Create for-llms.txt file
              run: |
                  echo "# Gitbook Documentation Compilation" > for-llms.txt
                  echo "Generated on $(date)" >> for-llms.txt
                  echo "" >> for-llms.txt

                  # Find all markdown files
                  find . -type f -name "*.md" | sort | while read -r file; do
                    # Skip hidden directories and node_modules
                    if [[ "$file" != *"/.git/"* && "$file" != */node_modules/* && "$file" != */build/* && "$file" != */dist/* ]]; then
                      echo "Processing $file"
                      
                      # Add file path as header
                      echo -e "\n\n## File: $file\n" >> for-llms.txt
                      
                      # Add file content
                      cat "$file" >> for-llms.txt
                    fi
                  done

                  # Also find and process any other text-based documentation files
                  find . -type f -name "*.txt" -o -name "*.yaml" -o -name "*.yml" -o -name "*.json" | sort | while read -r file; do
                    if [[ "$file" != *"/.git/"* && "$file" != */node_modules/* && "$file" != */build/* && "$file" != */dist/* && "$file" != *"for-llms.txt"* ]]; then
                      echo "Processing $file"
                      
                      # Add file path as header
                      echo -e "\n\n## File: $file\n" >> for-llms.txt
                      echo '```' >> for-llms.txt
                      
                      # Add file content
                      cat "$file" >> for-llms.txt
                      
                      echo '```' >> for-llms.txt
                    fi
                  done

            - name: Upload for-llms.txt as artifact
              uses: actions/upload-artifact@v4
              with:
                  name: llm-training-data
                  path: for-llms.txt

            - name: Commit and push for-llms.txt
              run: |
                  git config --local user.email "action@github.com"
                  git config --local user.name "GitHub Action"
                  git add for-llms.txt
                  git commit -m "Update for-llms.txt via GitHub Action" || echo "No changes to commit"
                  git push
```


## File: ./.vscode/settings.json

```
{
  "workbench.colorCustomizations": {
    "activityBar.background": "#2E2461",
    "titleBar.activeBackground": "#403287",
    "titleBar.activeForeground": "#FBFBFE"
  }
}```

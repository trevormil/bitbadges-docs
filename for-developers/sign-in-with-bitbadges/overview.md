# Overview

Authentication is a great use case for BitBadges. With BitBadges, you can seamlessly authenticate your users from any chain all with one interface and all with the same set of badges. There is no longer a need to fragment and support many different interfaces for many different blockchain ecosystems.

This documentation will walk you through the process of using our authentication tools.

Example Use Cases:

* In-Person QR Codes: Sometimes, you may want to verify users own a badge with a QR code, rather than having them sign a message with a crypto wallet. For example, for in person events, it may be unrealistic to expect all users to have their crypto wallets handy to sign an authentication message. Instead, you can have users sign their authentication messages prior to authentication time, generate a QR code (or NFC or other method) via BitBadges, and present that at authentication time instead.
* Sign In with BitBadges Popup Window: Similar to how websites outsource auth to popup implementation, the same thing can be done for Blockin / BitBadges (Sign In with BitBadges).

<figure><img src="../../.gitbook/assets/image (77).png" alt=""><figcaption></figcaption></figure>

## Quickstart

As you read along, you can refer to the [BitBadges quickstart repo](https://github.com/BitBadges/bitbadges-quickstart) to get started and as an implementation reference.

<figure><img src="../../.gitbook/assets/image (80).png" alt="" width="563"><figcaption></figcaption></figure>

## **Overview**&#x20;

BitBadges authentication can be split up into three main parts: verifying address ownership, verifying asset ownership, and verifying secrets / off-chain signatures.&#x20;

You may only need one or two out of the three parts, and you can customize your implementation accordingly. We hope to design this process to allow you as much flexibility as possible. Our main implementation (Sign In with BitBadges and Blockin) has support for all of the parts in one interface, but you can plug and remove and customize as you wish.&#x20;

**Execution Flow**

1. Users navigate to a custom BitBadges URL (either directly or via a popup window). This URL will have them sign your authentication message and generate a secret authentication code (i.e. their signature).&#x20;
2. Obtain the authentication details via a popup window callback, or they can be stored in the user's BitBadges account (under Authentication Codes tab) and fetched via the code ID.
3. At verification time (can be immediate or delayed), verify address ownership, asset ownership, and other secrets via the BitBadges API and SDK.
4. Perform your application-specific requirements, such as session handling, preventing replay attacks, other custom logic, etc.

<figure><img src="../../.gitbook/assets/image (78).png" alt=""><figcaption></figcaption></figure>

**Verifying Address Ownership**&#x20;

Verifying address ownership is done through having the user sign a unique challenge message. The challenge can be generated by the user or resource provider. Typically, it is generated by the resource provider, and the user can possibly edit certain fields before sending it back. The provider is expected to verify that the returned challenge was not edited in any undesired way by the user. We use Blockin for our challenge messages.&#x20;

The challenge message can be anything as long as replay attacks can be prevented (see security section below). We use and recommend Blockin (our multi-chain sign-in standard library that extends[`EIP-4361 Sign-In With Ethereum`](https://eips.ethereum.org/EIPS/eip-4361) interface (see [https://login.xyz/](https://login.xyz/)) to support a) specifying assets (such as NFTs or badges) and b) each chain's native signature algorithm. Blockin messages outline the authentication request information in a human-readable manner.

By verifying this signature, you can verify that the user actually owns the address they say they own. &#x20;

* Note that this is just a signature, so it doesn't cost anything and doesn't add anything (such as a transaction) on the blockchain.
* It is also offline, meaning signing and verifying challenges can also be done in an offline setting.

{% content-ref url="https://app.gitbook.com/o/7VSYQvtb1QtdWFsEGoUn/s/AwjdYgEsUkK9cCca5DiU/" %}
[Blockin](https://app.gitbook.com/o/7VSYQvtb1QtdWFsEGoUn/s/AwjdYgEsUkK9cCca5DiU/)
{% endcontent-ref %}

<pre><code><strong>https://bitbadges.io wants you to sign in with your Ethereum account:
</strong>0xb48B65D09aaCe9d3EBDE4De409Ef18556eb53085

Sign this message only if prompted by a trusted party. The signature of this message can be used to authenticate you on BitBadges. By signing, you agree to the BitBadges privacy policy and terms of service.

URI: https://bitbadges.io
Version: 1
Chain ID: 1
Nonce: cPW1vKj0xfTFlrUab
Issued At: 2024-01-21T18:35:21.141Z
Expiration Time: 2024-02-04T16:11:29.880Z
Resources:
Asset Ownership Requirements:
- Requirement A1-1 (satisfied if one of B1 is satisfied):
  - Requirement B1-1:
      Chain: BitBadges
      Collection ID: 1
      Asset IDs: 8 to 8
      Ownership Time: Authentication Time
      Ownership Amount: x1

  - Requirement B1-2:
      Chain: BitBadges
      Collection ID: 1
      Asset IDs: 9 to 9
      Ownership Time: Authentication Time
      Ownership Amount: x1
</code></pre>

**Querying Asset Ownership**

The next part of authentication is to query asset ownership. Balances can be verified by querying them somehow, which can be via the BitBadges website, BitBadges API, directly from source for off-chain balances, or directly from a blockchain node. You can run your own API / node or self-host balances for further decentralization and other benefits like low latency, availability, etc. Keep in mind the technical knowledge required, potential delay / lag, availability, and pros and cons for all the options.

The BitBadges API currently supports the following assets:

* BitBadges Badges
* BitBadges Address Lists
* Ethereum / Polygon NFTs

**Verifying Secrets / Signatures**

Lastly, you may also have additional secret signatures / proofs that you want to check. For example, maybe you want to verify ownership of a diploma badge but also verify a secret attestation to one's GPA signed by the university.

## **Security Considerations**

### **Replay Attacks** <a href="#security-replay-attacks" id="security-replay-attacks"></a>

**What are replay attacks?**

Preventing replay attacks is crucial in any authentication or authorization system. A replay attack occurs when an attacker intercepts and maliciously reuses a valid communication or transaction between two parties. In the context of Blockin, this could involve intercepting and reusing a valid authentication request (signature / code), compromising the security of the authentication process.

Lets say Bob authenticates at Event A, but his signature / code is maliciously intercepted. The adversary could now theoretically authenticate as Bob at Event A. Thus, the adversary could not **replay** the signature to be authenticated. It will be caught as already used.

Also, note that the same message signed by the same address will ALWAYS produce the same signature. Thus, it is important for your authentication message to have some sort of randomness to produce unique signatures.

Lets say Event B uses the same authentication message at Event A. Bob authenticates at Event A as intended. However, the authentication provider of Event A now has Bob's signature and could theoretically use it to authenticate at Event B as Bob. Even if the authentication is one-time use only at both Event A and Event B, it could be replayed across events.

**How can you protect?**

Please make sure you protect accordingly. **As mentioned above, you should assume the message may have been manipulated by the user before being returned to you.** This means that a replay attack mechanism must consider this as well.

Below are some ways to protect:

* Restrict and check one use per session per address
* If using assets, restrict and check one use per session per asset
* Unique nonce generation: Including a unique and random nonce (number used once) in each challenge to ensure that each request is unique, one time use only, and cannot be replayed. Nonces should be marked as used / not used by you. The generation scheme is left up to you.
* Time-dependent windows: Consider implementing a small time window where the sign in can be "redeemed". This is different from the authenticated times. For example, you have 1 minute to "redeem" your sign in after it is signed. After that, it is invalid, thus preventing future replay attacks. **However, replay attacks during the time window are still possible. This may not be applicable for some applications.**
  * These can be implemented with **issuedAt** timestamps, system times, using recent block hashes, or any time-dependent property.
  * This is typically fine for digital applications with secure, encrypted network communication

### **Flash Ownership Attacks** <a href="#security-flash-ownership-attacks" id="security-flash-ownership-attacks"></a>

If you are authenticating with assets (e.g. verify Bob owns this asset at sign-in time), you need to have protection against what we call flash ownership attacks. This attack is where, for example, Bob signs in with Asset A and immediately transfers Asset A to Alice who then also signs in successfully with Asset A. Two sign ins were approved for Asset A when only one should have been.

Solutions can vary dependent on the application, but here are some ideas:

* Assert that the asset cannot be transferred on-chain. This can be by making it completely non-transferable or only transferable in desired ways (such as by a trusted entity).
* If assets are non-fungible, consider preventing two sign ins with the same badge

Note that for chains that support ownership times (such as BitBadges), this is not adequate since ownership times can be transferred. For example Bob signs in with Asset A (Monday - Wednesday) but then transfers the badge + rights from Monday - Wednesday to Alice.

## **Immediate or Delayed Authentication?**

Authentication can be facilitated in many settings (in-person, digitally, etc). This is an important question to ask before starting your implementation.

**Immediate**

You can authenticate users and verify badge ownership, such as badge-gating a website. This process is immediate, meaning as soon as a user is prompted, you can proceed to the verification step. Nothing needs to be cached or stored because the details are immediately used.

<figure><img src="../../.gitbook/assets/image (76).png" alt=""><figcaption></figcaption></figure>

**Delayed Authentication**

Or, you can pre-generate with authentication codes. For example, you may not expect users to have wallets handy at authentication time, so you have them pre-generate their authentication details to present to you at authentication time. An example use case might be presenting a QR code at a ticket gate in real life.&#x20;

<figure><img src="../../.gitbook/assets/image (75).png" alt=""><figcaption></figcaption></figure>
